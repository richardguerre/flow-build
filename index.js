// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// ../../node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js
var require_shouldSkipPonyfill = __commonJS((exports, module) => {
  var isNextJs = function() {
    return Object.keys(globalThis).some((key) => key.startsWith("__NEXT"));
  };
  module.exports = function shouldSkipPonyfill() {
    if (globalThis.Deno) {
      return true;
    }
    if (process.versions.bun) {
      return true;
    }
    if (isNextJs()) {
      return true;
    }
    return false;
  };
});

// ../../node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS((exports, module) => {
  var we = function(e, t) {
    return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
  };
  var D = function(e, t = false) {
    let r = [], n = 0;
    for (;n < e.length; ) {
      let a = e[n], c = function(l) {
        if (!t)
          throw new TypeError(l);
        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
      };
      if (a === "*") {
        r.push({ type: "ASTERISK", index: n, value: e[n++] });
        continue;
      }
      if (a === "+" || a === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
        continue;
      }
      if (a === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
        continue;
      }
      if (a === "{") {
        r.push({ type: "OPEN", index: n, value: e[n++] });
        continue;
      }
      if (a === "}") {
        r.push({ type: "CLOSE", index: n, value: e[n++] });
        continue;
      }
      if (a === ":") {
        let l = "", s = n + 1;
        for (;s < e.length; ) {
          let i = e.substr(s, 1);
          if (s === n + 1 && Ae.test(i) || s !== n + 1 && ye.test(i)) {
            l += e[s++];
            continue;
          }
          break;
        }
        if (!l) {
          c(`Missing parameter name at ${n}`);
          continue;
        }
        r.push({ type: "NAME", index: n, value: l }), n = s;
        continue;
      }
      if (a === "(") {
        let l = 1, s = "", i = n + 1, o = false;
        if (e[i] === "?") {
          c(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e.length; ) {
          if (!we(e[i], false)) {
            c(`Invalid character '${e[i]}' at ${i}.`), o = true;
            break;
          }
          if (e[i] === "\\") {
            s += e[i++] + e[i++];
            continue;
          }
          if (e[i] === ")") {
            if (l--, l === 0) {
              i++;
              break;
            }
          } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
            c(`Capturing groups are not allowed at ${i}`), o = true;
            break;
          }
          s += e[i++];
        }
        if (o)
          continue;
        if (l) {
          c(`Unbalanced pattern at ${n}`);
          continue;
        }
        if (!s) {
          c(`Missing pattern at ${n}`);
          continue;
        }
        r.push({ type: "REGEX", index: n, value: s }), n = i;
        continue;
      }
      r.push({ type: "CHAR", index: n, value: e[n++] });
    }
    return r.push({ type: "END", index: n, value: "" }), r;
  };
  var F = function(e, t = {}) {
    let r = D(e);
    t.delimiter ??= "/#?", t.prefixes ??= "./";
    let n = `[^${S(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = new Set, o = (h) => {
      if (l < r.length && r[l].type === h)
        return r[l++].value;
    }, f = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), d = (h) => {
      let u = o(h);
      if (u !== undefined)
        return u;
      let { type: p, index: A } = r[l];
      throw new TypeError(`Unexpected ${p} at ${A}, expected ${h}`);
    }, T = () => {
      let h = "", u;
      for (;u = o("CHAR") ?? o("ESCAPED_CHAR"); )
        h += u;
      return h;
    }, xe = (h) => h, L = t.encodePart || xe, I = "", U = (h) => {
      I += h;
    }, $ = () => {
      I.length && (a.push(new R(3, "", "", L(I), "", 3)), I = "");
    }, X = (h, u, p, A, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u && !p && g === 3) {
        U(h);
        return;
      }
      if ($(), !u && !p) {
        if (!h)
          return;
        a.push(new R(3, "", "", L(h), "", g));
        return;
      }
      let m;
      p ? p === "*" ? m = v : m = p : m = n;
      let O = 2;
      m === n ? (O = 1, m = "") : m === v && (O = 0, m = "");
      let P;
      if (u ? P = u : p && (P = c++), i.has(P))
        throw new TypeError(`Duplicate name '${P}'.`);
      i.add(P), a.push(new R(O, P, L(h), m, L(A), g));
    };
    for (;l < r.length; ) {
      let h = o("CHAR"), u = o("NAME"), p = o("REGEX");
      if (!u && !p && (p = o("ASTERISK")), u || p) {
        let g = h ?? "";
        t.prefixes.indexOf(g) === -1 && (U(g), g = ""), $();
        let m = f();
        X(g, u, p, "", m);
        continue;
      }
      let A = h ?? o("ESCAPED_CHAR");
      if (A) {
        U(A);
        continue;
      }
      if (o("OPEN")) {
        let g = T(), m = o("NAME"), O = o("REGEX");
        !m && !O && (O = o("ASTERISK"));
        let P = T();
        d("CLOSE");
        let be = f();
        X(g, m, O, P, be);
        continue;
      }
      $(), d("END");
    }
    return a;
  };
  var S = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e) {
    return e && e.ignoreCase ? "ui" : "u";
  };
  var q = function(e, t, r) {
    return W(F(e, r), t, r);
  };
  var k = function(e) {
    switch (e) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e, t, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n = r.start ? "^" : "";
    for (let s of e) {
      if (s.type === 3) {
        s.modifier === 3 ? n += S(s.value) : n += `(?:${S(s.value)})${k(s.modifier)}`;
        continue;
      }
      t && t.push(s.name);
      let i = `[^${S(r.delimiter)}]+?`, o = s.value;
      if (s.type === 1 ? o = i : s.type === 0 && (o = v), !s.prefix.length && !s.suffix.length) {
        s.modifier === 3 || s.modifier === 1 ? n += `(${o})${k(s.modifier)}` : n += `((?:${o})${k(s.modifier)})`;
        continue;
      }
      if (s.modifier === 3 || s.modifier === 1) {
        n += `(?:${S(s.prefix)}(${o})${S(s.suffix)})`, n += k(s.modifier);
        continue;
      }
      n += `(?:${S(s.prefix)}`, n += `((?:${o})(?:`, n += S(s.suffix), n += S(s.prefix), n += `(?:${o}))*)${S(s.suffix)})`, s.modifier === 0 && (n += "?");
    }
    let a = `[${S(r.endsWith)}]|\$`, c = `[${S(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
    r.strict || (n += `(?:${c}(?=${a}))?`);
    let l = false;
    if (e.length) {
      let s = e[e.length - 1];
      s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
    }
    return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
  };
  var ee = function(e, t) {
    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
  };
  var te = function(e, t) {
    return e.startsWith(t) ? e.substring(t.length, e.length) : e;
  };
  var Ce = function(e, t) {
    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
  };
  var _ = function(e) {
    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
  };
  var N = function(e) {
    if (!e)
      return true;
    for (let t of re)
      if (e.test(t))
        return true;
    return false;
  };
  var ne = function(e, t) {
    if (e = te(e, "#"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e, t) {
    if (e = te(e, "?"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e, t) {
    return t || e === "" ? e : _(e) ? K(e) : j(e);
  };
  var ae = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.password = e, r.password;
  };
  var oe = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.username = e, r.username;
  };
  var ce = function(e, t, r) {
    if (r || e === "")
      return e;
    if (t && !re.includes(t))
      return new URL(`${t}:${e}`).pathname;
    let n = e[0] == "/";
    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
  };
  var le = function(e, t, r) {
    return z(t) === e && (e = ""), r || e === "" ? e : G(e);
  };
  var fe = function(e, t) {
    return e = Ce(e, ":"), t || e === "" ? e : y(e);
  };
  var z = function(e) {
    switch (e) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var y = function(e) {
    if (e === "")
      return e;
    if (/^[-+.A-Za-z0-9]*$/.test(e))
      return e.toLowerCase();
    throw new TypeError(`Invalid protocol '${e}'.`);
  };
  var he = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.username = e, t.username;
  };
  var ue = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.password = e, t.password;
  };
  var j = function(e) {
    if (e === "")
      return e;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
      throw new TypeError(`Invalid hostname '${e}'`);
    let t = new URL("https://example.com");
    return t.hostname = e, t.hostname;
  };
  var K = function(e) {
    if (e === "")
      return e;
    if (/[^0-9a-fA-F[\]:]/g.test(e))
      throw new TypeError(`Invalid IPv6 hostname '${e}'`);
    return e.toLowerCase();
  };
  var G = function(e) {
    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
      return e;
    throw new TypeError(`Invalid port '${e}'.`);
  };
  var de = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
  };
  var pe = function(e) {
    return e === "" ? e : new URL(`data:${e}`).pathname;
  };
  var ge = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.search = e, t.search.substring(1, t.search.length);
  };
  var me = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.hash = e, t.hash.substring(1, t.hash.length);
  };
  var Se = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e, t);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var b = function(e, t) {
    return t ? C(e) : e;
  };
  var w = function(e, t, r) {
    let n;
    if (typeof t.baseURL == "string")
      try {
        n = new URL(t.baseURL), t.protocol === undefined && (e.protocol = b(n.protocol.substring(0, n.protocol.length - 1), r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && (e.username = b(n.username, r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && t.password === undefined && (e.password = b(n.password, r)), t.protocol === undefined && t.hostname === undefined && (e.hostname = b(n.hostname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && (e.port = b(n.port, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && (e.pathname = b(n.pathname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && (e.search = b(n.search.substring(1, n.search.length), r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && t.hash === undefined && (e.hash = b(n.hash.substring(1, n.hash.length), r));
      } catch {
        throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
      }
    if (typeof t.protocol == "string" && (e.protocol = fe(t.protocol, r)), typeof t.username == "string" && (e.username = oe(t.username, r)), typeof t.password == "string" && (e.password = ae(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
      if (e.pathname = t.pathname, n && !ee(e.pathname, r)) {
        let a = n.pathname.lastIndexOf("/");
        a >= 0 && (e.pathname = b(n.pathname.substring(0, a + 1), r) + e.pathname);
      }
      e.pathname = ce(e.pathname, e.protocol, r);
    }
    return typeof t.search == "string" && (e.search = se(t.search, r)), typeof t.hash == "string" && (e.hash = ne(t.hash, r)), e;
  };
  var C = function(e) {
    return e.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e, t) {
    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
    let r = ".*", n = `[^${Le(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
    for (let l = 0;l < e.length; ++l) {
      let s = e[l];
      if (s.type === 3) {
        if (s.modifier === 3) {
          c += C(s.value);
          continue;
        }
        c += `{${C(s.value)}}${k(s.modifier)}`;
        continue;
      }
      let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), f = l > 0 ? e[l - 1] : null, d = l < e.length - 1 ? e[l + 1] : null;
      if (!o && i && s.type === 1 && s.modifier === 3 && d && !d.prefix.length && !d.suffix.length)
        if (d.type === 3) {
          let T = d.value.length > 0 ? d.value[0] : "";
          o = a.test(T);
        } else
          o = !d.hasCustomName();
      if (!o && !s.prefix.length && f && f.type === 3) {
        let T = f.value[f.value.length - 1];
        o = t.prefixes.includes(T);
      }
      o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!f || f.type === 3 || f.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += k(s.modifier));
    }
    return c;
  };
  var M = Object.defineProperty;
  var Pe = Object.getOwnPropertyDescriptor;
  var Re = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Oe = (e, t) => {
    for (var r in t)
      M(e, r, { get: t[r], enumerable: true });
  };
  var ke = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let a of Re(t))
        !Ee.call(e, a) && a !== r && M(e, a, { get: () => t[a], enumerable: !(n = Pe(t, a)) || n.enumerable });
    return e;
  };
  var Te = (e) => ke(M({}, "__esModule", { value: true }), e);
  var Ne = {};
  Oe(Ne, { URLPattern: () => Y });
  module.exports = Te(Ne);
  var R = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t, r, n, a, c, l) {
      this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Ae = /[$_\p{ID_Start}]/u;
  var ye = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var x = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var H = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #l = 0;
    #o = 0;
    #d = 0;
    #p = 0;
    #g = false;
    constructor(t) {
      this.#i = t;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#o === 0) {
            this.#b(), this.#f() ? this.#r(9, 1) : this.#h() ? this.#r(8, 1) : this.#r(7, 0);
            continue;
          } else if (this.#o === 2) {
            this.#u(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#d > 0)
          if (this.#A())
            this.#d -= 1;
          else
            continue;
        if (this.#T()) {
          this.#d += 1;
          continue;
        }
        switch (this.#o) {
          case 0:
            this.#P() && this.#u(1);
            break;
          case 1:
            if (this.#P()) {
              this.#C();
              let t = 7, r = 1;
              this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
            }
            break;
          case 2:
            this.#S() ? this.#u(3) : (this.#x() || this.#h() || this.#f()) && this.#u(5);
            break;
          case 3:
            this.#O() ? this.#r(4, 1) : this.#S() && this.#r(5, 1);
            break;
          case 4:
            this.#S() && this.#r(5, 1);
            break;
          case 5:
            this.#y() ? this.#p += 1 : this.#w() && (this.#p -= 1), this.#k() && !this.#p ? this.#r(6, 1) : this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 6:
            this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 8:
            this.#f() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
      this.#t.hostname !== undefined && this.#t.port === undefined && (this.#t.port = "");
    }
    #r(t, r) {
      switch (this.#o) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#c();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#c();
          break;
        case 4:
          this.#t.password = this.#c();
          break;
        case 5:
          this.#t.hostname = this.#c();
          break;
        case 6:
          this.#t.port = this.#c();
          break;
        case 7:
          this.#t.pathname = this.#c();
          break;
        case 8:
          this.#t.search = this.#c();
          break;
        case 9:
          this.#t.hash = this.#c();
          break;
        case 10:
          break;
      }
      this.#o !== 0 && t !== 10 && ([1, 2, 3, 4].includes(this.#o) && [6, 7, 8, 9].includes(t) && (this.#t.hostname ??= ""), [1, 2, 3, 4, 5, 6].includes(this.#o) && [8, 9].includes(t) && (this.#t.pathname ??= this.#g ? "/" : ""), [1, 2, 3, 4, 5, 6, 7].includes(this.#o) && t === 9 && (this.#t.search ??= "")), this.#R(t, r);
    }
    #R(t, r) {
      this.#o = t, this.#l = this.#e + r, this.#e += r, this.#s = 0;
    }
    #b() {
      this.#e = this.#l, this.#s = 0;
    }
    #u(t) {
      this.#b(), this.#o = t;
    }
    #m(t) {
      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
    }
    #a(t, r) {
      let n = this.#m(t);
      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
    }
    #P() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #S() {
      return this.#a(this.#e, "@");
    }
    #O() {
      return this.#a(this.#e, ":");
    }
    #k() {
      return this.#a(this.#e, ":");
    }
    #x() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t = this.#m(this.#e - 1);
      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
    }
    #f() {
      return this.#a(this.#e, "#");
    }
    #T() {
      return this.#n[this.#e].type == "OPEN";
    }
    #A() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #y() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #c() {
      let t = this.#n[this.#e], r = this.#m(this.#l).index;
      return this.#i.substring(r, t.index);
    }
    #C() {
      let t = {};
      Object.assign(t, x), t.encodePart = y;
      let r = q(this.#c(), undefined, t);
      this.#g = N(r);
    }
  };
  var V = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    #l = false;
    constructor(t = {}, r, n) {
      try {
        let a;
        if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
          let i = new H(t);
          if (i.parse(), t = i.result, a === undefined && typeof t.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t.baseURL = a;
        } else {
          if (!t || typeof t != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n > "u" && (n = { ignoreCase: false });
        let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s;
        for (s of V) {
          if (!(s in this.#i))
            continue;
          let i = {}, o = this.#i[s];
          switch (this.#t[s] = [], s) {
            case "protocol":
              Object.assign(i, x), i.encodePart = y;
              break;
            case "username":
              Object.assign(i, x), i.encodePart = he;
              break;
            case "password":
              Object.assign(i, x), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, x), i.encodePart = G;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c), i.encodePart = de) : (Object.assign(i, x, c), i.encodePart = pe);
              break;
            case "search":
              Object.assign(i, x, c), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, x, c), i.encodePart = me;
              break;
          }
          try {
            this.#s[s] = F(o, i), this.#n[s] = W(this.#s[s], this.#t[s], i), this.#e[s] = Ie(this.#s[s], i), this.#l = this.#l || this.#s[s].some((f) => f.type === 2);
          } catch {
            throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
          }
        }
      } catch (a) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
      }
    }
    test(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return false;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return false;
      }
      let a;
      for (a of V)
        if (!this.#n[a].exec(n[a]))
          return false;
      return true;
    }
    exec(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return null;
      }
      let a = {};
      r ? a.inputs = [t, r] : a.inputs = [t];
      let c;
      for (c of V) {
        let l = this.#n[c].exec(n[c]);
        if (!l)
          return null;
        let s = {};
        for (let [i, o] of this.#t[c].entries())
          if (typeof o == "string" || typeof o == "number") {
            let f = l[i + 1];
            s[o] = f;
          }
        a[c] = { input: n[c] ?? "", groups: s };
      }
      return a;
    }
    static compareComponent(t, r, n) {
      let a = (i, o) => {
        for (let f of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[f] < o[f])
            return -1;
          if (i[f] === o[f])
            continue;
          return 1;
        }
        return 0;
      }, c = new R(3, "", "", "", "", 3), l = new R(0, "", "", "", "", 3), s = (i, o) => {
        let f = 0;
        for (;f < Math.min(i.length, o.length); ++f) {
          let d = a(i[f], o[f]);
          if (d)
            return d;
        }
        return i.length === o.length ? 0 : a(i[f] ?? c, o[f] ?? c);
      };
      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
    get hasRegExpGroups() {
      return this.#l;
    }
  };
});

// ../../node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type = str.slice(0, i).toLowerCase();
    return { type, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode = 2;
                else if (encode === 0)
                  encode = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode)
      return decode(data, hint);
  };
  var basename = function(path) {
    if (typeof path !== "string")
      return "";
    for (let i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// ../../node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// ../../node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = import.meta.require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields2 = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields2 === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields2;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// ../../node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = import.meta.require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// ../../node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type of TYPES) {
      const matched = type.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils2 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value);
      }
      headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
  };
  var isPromise4 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value) {
    if (isPromise4(value)) {
      return value;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value);
          if (isPromise4(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise4(callbackResult)) {
            return callbackResult.then(() => value);
          }
          return fakePromise(value);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  var createDeferredPromise = function() {
    let resolveFn;
    let rejectFn;
    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
      resolveFn = resolve;
      rejectFn = reject;
    });
    return {
      promise,
      get resolve() {
        return resolveFn;
      },
      get reject() {
        return rejectFn;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
  exports.createDeferredPromise = createDeferredPromise;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  var isPonyfillWritableStream = function(obj) {
    return obj?.writable != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = import.meta.require("stream");
  var utils_js_1 = require_utils2();

  class PonyfillReadableStream {
    readable;
    constructor(underlyingSource) {
      if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        this.readable = stream_1.Readable.fromWeb(underlyingSource);
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          destroy(err, callback) {
            if (underlyingSource?.cancel) {
              try {
                const res$ = underlyingSource.cancel(err);
                if (res$?.then) {
                  return res$.then(() => {
                    callback(null);
                  }, (err2) => {
                    callback(err2);
                  });
                }
              } catch (err2) {
                callback(err2);
                return;
              }
            }
            callback(null);
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return new Promise((resolve) => this.readable.once("end", resolve));
    }
    locked = false;
    getReader(_options) {
      const iterator = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator.next();
        },
        releaseLock: () => {
          if (iterator.return) {
            const retResult$ = iterator.return();
            if (retResult$.then) {
              retResult$.then(() => {
                this.locked = false;
              });
              return;
            }
          }
          this.locked = false;
        },
        cancel: (reason) => {
          if (iterator.return) {
            const retResult$ = iterator.return(reason);
            if (retResult$.then) {
              return retResult$.then(() => {
                this.locked = false;
              });
            }
          }
          this.locked = false;
          return (0, utils_js_1.fakePromise)(undefined);
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    pipeTo(destination) {
      if (isPonyfillWritableStream(destination)) {
        return new Promise((resolve, reject) => {
          this.readable.pipe(destination.writable);
          destination.writable.once("finish", resolve);
          destination.writable.once("error", reject);
        });
      } else {
        const writer = destination.getWriter();
        return Promise.resolve().then(async () => {
          try {
            for await (const chunk of this) {
              await writer.write(chunk);
            }
            await writer.close();
          } catch (err) {
            await writer.abort(err);
          }
        });
      }
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var hasBufferMethod = function(obj) {
    return obj != null && obj.buffer != null && typeof obj.buffer === "function";
  };
  var hasArrayBufferMethod = function(obj) {
    return obj != null && obj.arrayBuffer != null && typeof obj.arrayBuffer === "function";
  };
  var hasBytesMethod = function(obj) {
    return obj != null && obj.bytes != null && typeof obj.bytes === "function";
  };
  var hasTextMethod = function(obj) {
    return obj != null && obj.text != null && typeof obj.text === "function";
  };
  var hasSizeProperty = function(obj) {
    return obj != null && typeof obj.size === "number";
  };
  var hasStreamMethod = function(obj) {
    return obj != null && obj.stream != null && typeof obj.stream === "function";
  };
  var hasBlobSignature = function(obj) {
    return obj != null && obj[Symbol.toStringTag] === "Blob";
  };
  var isArrayBuffer = function(obj) {
    return obj != null && obj.byteLength != null && obj.slice != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  exports.hasBufferMethod = hasBufferMethod;
  exports.hasArrayBufferMethod = hasArrayBufferMethod;
  exports.hasBytesMethod = hasBytesMethod;
  exports.hasTextMethod = hasTextMethod;
  exports.hasSizeProperty = hasSizeProperty;
  exports.hasStreamMethod = hasStreamMethod;
  exports.hasBlobSignature = hasBlobSignature;
  exports.isArrayBuffer = isArrayBuffer;
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();

  class PonyfillBlob {
    blobParts;
    type;
    encoding;
    _size = null;
    constructor(blobParts = [], options) {
      this.blobParts = blobParts;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && hasBlobSignature(blobParts[0])) {
        return blobParts[0];
      }
    }
    _buffer = null;
    buffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (hasBufferMethod(blobPart)) {
          return blobPart.buffer().then((buf) => {
            this._buffer = buf;
            return this._buffer;
          });
        }
        if (hasBytesMethod(blobPart)) {
          return blobPart.bytes().then((bytes) => {
            this._buffer = Buffer.from(bytes);
            return this._buffer;
          });
        }
        if (hasArrayBufferMethod(blobPart)) {
          return blobPart.arrayBuffer().then((arrayBuf) => {
            this._buffer = Buffer.from(arrayBuf, undefined, blobPart.size);
            return this._buffer;
          });
        }
        this._buffer = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (hasBufferMethod(blobPart)) {
          jobs.push(blobPart.buffer().then((buf) => {
            bufferChunks[i] = buf;
          }));
          return;
        } else if (hasArrayBufferMethod(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else if (hasBytesMethod(blobPart)) {
          jobs.push(blobPart.bytes().then((bytes) => {
            bufferChunks[i] = Buffer.from(bytes);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.blobParts.length === 1) {
        if (isArrayBuffer(this.blobParts[0])) {
          return (0, utils_js_1.fakePromise)(this.blobParts[0]);
        }
        if (hasArrayBufferMethod(this.blobParts[0])) {
          return this.blobParts[0].arrayBuffer();
        }
      }
      return this.buffer();
    }
    bytes() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.blobParts.length === 1) {
        if (Buffer.isBuffer(this.blobParts[0])) {
          this._buffer = this.blobParts[0];
          return (0, utils_js_1.fakePromise)(this.blobParts[0]);
        }
        if (this.blobParts[0] instanceof Uint8Array) {
          this._buffer = Buffer.from(this.blobParts[0]);
          return (0, utils_js_1.fakePromise)(this.blobParts[0]);
        }
        if (hasBytesMethod(this.blobParts[0])) {
          return this.blobParts[0].bytes();
        }
        if (hasBufferMethod(this.blobParts[0])) {
          return this.blobParts[0].buffer();
        }
      }
      return this.buffer();
    }
    _text = null;
    text() {
      if (this._text) {
        return (0, utils_js_1.fakePromise)(this._text);
      }
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          this._text = blobPart;
          return (0, utils_js_1.fakePromise)(this._text);
        }
        if (hasTextMethod(blobPart)) {
          return blobPart.text().then((text) => {
            this._text = text;
            return this._text;
          });
        }
        const buf = getBlobPartAsBuffer(blobPart);
        this._text = buf.toString(this.encoding);
        return (0, utils_js_1.fakePromise)(this._text);
      }
      return this.buffer().then((buf) => {
        this._text = buf.toString(this.encoding);
        return this._text;
      });
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (hasSizeProperty(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (hasStreamMethod(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      if (this._buffer != null) {
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(this._buffer);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (hasBufferMethod(blobPart)) {
              return blobPart.buffer().then((buf2) => {
                controller.enqueue(buf2);
              });
            }
            if (hasBytesMethod(blobPart)) {
              return blobPart.bytes().then((bytes) => {
                const buf2 = Buffer.from(bytes);
                controller.enqueue(buf2);
              });
            }
            if (hasArrayBufferMethod(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    name;
    lastModified;
    constructor(fileBits, name, options) {
      super(fileBits, options);
      this.name = name;
      this.lastModified = options?.lastModified || Date.now();
    }
    webkitRelativePath = "";
  }
  exports.PonyfillFile = PonyfillFile;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value] = entry;
          if (typeof value === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value));
          } else {
            let filenamePart = "";
            if (value.name) {
              filenamePart = `; filename="${value.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name, blob, fileName) {
    Object.defineProperty(blob, "name", {
      configurable: true,
      enumerable: true,
      value: fileName || blob.name || name
    });
    return blob;
  };
  var isBlob = function(value) {
    return value?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFormData = undefined;
  exports.getStreamFromFormData = getStreamFromFormData;
  var ReadableStream_js_1 = require_ReadableStream();

  class PonyfillFormData {
    map = new Map;
    append(name, value, fileName) {
      let values3 = this.map.get(name);
      if (!values3) {
        values3 = [];
        this.map.set(name, values3);
      }
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      values3.push(entry);
    }
    delete(name) {
      this.map.delete(name);
    }
    get(name) {
      const values3 = this.map.get(name);
      return values3 ? values3[0] : null;
    }
    getAll(name) {
      return this.map.get(name) || [];
    }
    has(name) {
      return this.map.has(name);
    }
    set(name, value, fileName) {
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      this.map.set(name, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values3] of this.map) {
        for (const value of values3) {
          yield [key, value];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values3 of this.map.values()) {
        for (const value of values3) {
          yield value;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (isReadableStream(bodyInit)) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value) {
    return value?.forEach != null;
  };
  var isBlob = function(value) {
    return value?.stream != null;
  };
  var isURLSearchParams = function(value) {
    return value?.sort != null;
  };
  var isReadableStream = function(value) {
    return value?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = import.meta.require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob();
  var File_js_1 = require_File();
  var FormData_js_1 = require_FormData();
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    bodyInit;
    options;
    bodyUsed = false;
    contentType = null;
    contentLength = null;
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    bodyType;
    _bodyFactory = () => null;
    _generatedBody = null;
    _buffer;
    generateBody() {
      if (this._generatedBody?.readable?.destroyed && this._buffer) {
        this._generatedBody.readable = stream_1.Readable.from(this._buffer);
      }
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    handleContentLengthHeader(forceSet = false) {
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (forceSet && this.bodyInit == null && !contentLengthInHeaders) {
        this.contentLength = 0;
        this.headers.set("content-length", "0");
      }
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _chunks = null;
    _collectChunksFromReadable() {
      if (this._chunks) {
        return (0, utils_js_1.fakePromise)(this._chunks);
      }
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      this._chunks = [];
      _body.readable.on("data", (chunk) => {
        this._chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(this._chunks);
        });
        _body.readable.once("error", (e) => {
          reject(e);
        });
      });
    }
    _blob = null;
    blob() {
      if (this._blob) {
        return (0, utils_js_1.fakePromise)(this._blob);
      }
      if (this.bodyType === BodyInitType.Blob) {
        this._blob = this.bodyInit;
        return (0, utils_js_1.fakePromise)(this._blob);
      }
      if (this._buffer) {
        this._blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(this._blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        this._blob = new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
        return this._blob;
      });
    }
    _formData = null;
    formData(opts) {
      if (this._formData) {
        return (0, utils_js_1.fakePromise)(this._formData);
      }
      if (this.bodyType === BodyInitType.FormData) {
        this._formData = this.bodyInit;
        return (0, utils_js_1.fakePromise)(this._formData);
      }
      this._formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(this._formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          this._formData.set(name, value);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            this._formData.set(name, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(this._formData);
        });
        bb.on("error", (err = "An error occurred while parsing the form data") => {
          const errMessage = err.message || err.toString();
          reject(new TypeError(errMessage, err.cause));
        });
        _body?.readable.pipe(bb);
      });
    }
    buffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if ((0, Blob_js_1.hasBufferMethod)(this.bodyInit)) {
          return this.bodyInit.buffer().then((buf) => {
            this._buffer = buf;
            return this._buffer;
          });
        }
        if ((0, Blob_js_1.hasBytesMethod)(this.bodyInit)) {
          return this.bodyInit.bytes().then((bytes) => {
            this._buffer = Buffer.from(bytes);
            return this._buffer;
          });
        }
        if ((0, Blob_js_1.hasArrayBufferMethod)(this.bodyInit)) {
          return this.bodyInit.arrayBuffer().then((buf) => {
            this._buffer = Buffer.from(buf, undefined, buf.byteLength);
            return this._buffer;
          });
        }
      }
      return this._collectChunksFromReadable().then((chunks) => {
        if (chunks.length === 1) {
          this._buffer = chunks[0];
          return this._buffer;
        }
        this._buffer = Buffer.concat(chunks);
        return this._buffer;
      });
    }
    bytes() {
      return this.buffer();
    }
    arrayBuffer() {
      return this.buffer();
    }
    _json = null;
    json() {
      if (this._json) {
        return (0, utils_js_1.fakePromise)(this._json);
      }
      return this.text().then((text) => {
        try {
          this._json = JSON.parse(text);
        } catch (e) {
          if (e instanceof SyntaxError) {
            e.message += `, "${text}" is not valid JSON`;
          }
          throw e;
        }
        return this._json;
      });
    }
    _text = null;
    text() {
      if (this._text) {
        return (0, utils_js_1.fakePromise)(this._text);
      }
      if (this.bodyType === BodyInitType.String) {
        this._text = this.bodyInit;
        return (0, utils_js_1.fakePromise)(this._text);
      }
      return this.buffer().then((buffer) => {
        this._text = buffer.toString("utf-8");
        return this._text;
      });
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillHeaders = undefined;
  exports.isHeadersLike = isHeadersLike;
  var util_1 = import.meta.require("util");

  class PonyfillHeaders {
    headersInit;
    _map;
    objectNormalizedKeysOfHeadersInit = [];
    objectOriginalKeysOfHeadersInit = [];
    _setCookies = [];
    constructor(headersInit) {
      this.headersInit = headersInit;
    }
    _get(key) {
      const normalized = key.toLowerCase();
      if (normalized === "set-cookie") {
        return this._setCookies.join(", ");
      }
      if (this._map) {
        return this._map.get(normalized) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k) => {
            this.objectOriginalKeysOfHeadersInit.push(k);
            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach(([key, value]) => {
              const normalizedKey = key.toLowerCase();
              if (normalizedKey === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(normalizedKey, value);
            });
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value, key) => {
              if (key === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(key, value);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                if (normalizedKey === "set-cookie") {
                  this._setCookies.push(initValue);
                  continue;
                }
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies.push(value);
        return;
      }
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value}` : value;
      this.getMap().set(key, finalValue);
    }
    get(name) {
      const value = this._get(name);
      if (value == null) {
        return null;
      }
      return value;
    }
    has(name) {
      if (name === "set-cookie") {
        return this._setCookies.length > 0;
      }
      return !!this._get(name);
    }
    set(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [value];
        return;
      }
      this.getMap().set(key, value);
    }
    delete(name) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [];
        return;
      }
      this.getMap().delete(key);
    }
    forEach(callback) {
      this._setCookies.forEach((setCookie) => {
        callback(setCookie, "set-cookie", this);
      });
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value]) => {
              callback(value, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value]) => {
            if (value != null) {
              callback(value, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value, key) => {
        callback(value, key, this);
      });
    }
    *keys() {
      if (this._setCookies.length) {
        yield "set-cookie";
      }
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.keys();
            return;
          }
          yield* Object.keys(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().keys();
    }
    *values() {
      yield* this._setCookies;
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.values();
            return;
          }
          yield* Object.values(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().values();
    }
    *entries() {
      yield* this._setCookies.map((cookie) => ["set-cookie", cookie]);
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit;
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.entries();
            return;
          }
          yield* Object.entries(this.headersInit);
          return;
        }
      }
      yield* this.getMap().entries();
    }
    getSetCookie() {
      return this._setCookies;
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record = {};
      this.forEach((value, key) => {
        if (key === "set-cookie") {
          record["set-cookie"] = this._setCookies;
        } else {
          record[key] = value.includes(",") ? value.split(",").map((el) => el.trim()) : value;
        }
      });
      return `Headers ${(0, util_1.inspect)(record)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = import.meta.require("http");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    headers;
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      this.handleContentLengthHeader();
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    status;
    statusText;
    url;
    redirected;
    type;
    clone() {
      return this;
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 302) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    if (process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0") {
      curlHandle.setOpt("SSL_VERIFYPEER", false);
    }
    if (process.env.NODE_EXTRA_CA_CERTS) {
      curlHandle.setOpt("CAINFO", process.env.NODE_EXTRA_CA_CERTS);
    } else {
      curlHandle.setOpt("CAINFO_BLOB", tls_1.rootCertificates.join("\n"));
    }
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
      size = Number(value);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    const deferredPromise = (0, utils_js_1.createDeferredPromise)();
    let streamResolved;
    if (fetchRequest["_signal"]) {
      fetchRequest["_signal"].onabort = () => {
        if (curlHandle.isOpen) {
          try {
            curlHandle.pause(CurlPause.Recv);
          } catch (e) {
            deferredPromise.reject(e);
          }
        }
      };
    }
    curlHandle.once("end", function endListener() {
      try {
        curlHandle.close();
      } catch (e) {
        deferredPromise.reject(e);
      }
    });
    curlHandle.once("error", function errorListener(error) {
      if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {
        streamResolved.destroy(error);
      } else {
        if (error.message === "Operation was aborted by an application callback") {
          error.message = "The operation was aborted.";
        }
        deferredPromise.reject(error);
      }
      try {
        curlHandle.close();
      } catch (e) {
        deferredPromise.reject(e);
      }
    });
    curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
      const outputStream = new stream_1.PassThrough;
      stream_1.promises.pipeline(stream, outputStream, {
        end: true,
        signal: fetchRequest["_signal"] ?? undefined
      }).then(() => {
        if (!stream.destroyed) {
          stream.resume();
        }
      }).catch(deferredPromise.reject);
      const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
        if (headerFilter && !headerFilter.startsWith("HTTP/")) {
          if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
            if (!stream.destroyed) {
              stream.resume();
            }
            outputStream.destroy();
            deferredPromise.reject(new Error("redirect is not allowed"));
          }
          return true;
        }
        return false;
      });
      const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
      const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {
        status,
        headers: headersInit,
        url: curlHandle.getInfo(Curl.info.REDIRECT_URL)?.toString() || fetchRequest.url,
        redirected: Number(curlHandle.getInfo(Curl.info.REDIRECT_COUNT)) > 0
      });
      deferredPromise.resolve(ponyfillResponse);
      streamResolved = outputStream;
    });
    let count = 0;
    try {
      count = Curl.getCount();
    } catch {
    }
    if (count > 0) {
      setImmediate(() => {
        curlHandle.perform();
      });
    } else {
      curlHandle.perform();
    }
    return deferredPromise.promise;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = fetchCurl;
  var stream_1 = import.meta.require("stream");
  var tls_1 = import.meta.require("tls");
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.duplex = requestInit?.duplex || "half";
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        this.handleContentLengthHeader(true);
      }
      if (requestInit?.agent != null) {
        if (requestInit.agent === false) {
          this.agent = false;
        } else if (this.url.startsWith("http:/") && requestInit.agent instanceof http_1.Agent) {
          this.agent = requestInit.agent;
        } else if (this.url.startsWith("https:/") && requestInit.agent instanceof https_1.Agent) {
          this.agent = requestInit.agent;
        }
      }
    }
    headersSerializer;
    cache;
    credentials;
    destination;
    headers;
    integrity;
    keepalive;
    method;
    mode;
    priority;
    redirect;
    referrer;
    referrerPolicy;
    url;
    duplex;
    agent;
    _signal;
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return this;
    }
    [Symbol.toStringTag] = "Request";
  }
  exports.PonyfillRequest = PonyfillRequest;
});

// ../../node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// ../../node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse2 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse2;
});

// ../../node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// ../../node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// ../../node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse2,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse2;
  module.exports.stringify = stringify;
});

// ../../node_modules/@kamilkisiela/fast-url-parser/src/punycode.js
var require_punycode = __commonJS((exports, module) => {
  var error = function(type) {
    throw new RangeError(errors4[type]);
  };
  var map = function(array, callback) {
    var result = [];
    var length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  };
  var mapDomain = function(domain, callback) {
    var parts = domain.split("@");
    var result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    var labels = domain.split(".");
    var encoded = map(labels, callback).join(".");
    return result + encoded;
  };
  var ucs2decode = function(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  };
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors4 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag !== 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var encode = function(input) {
    var output = [];
    input = ucs2decode(input);
    var inputLength = input.length;
    var n = initialN;
    var delta = 0;
    var bias = initialBias;
    for (var currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    var basicLength = output.length;
    var handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      var m = maxInt;
      for (var currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      var handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (var currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          var q = delta;
          for (var k = base;; k += base) {
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            var qMinusT = q - t;
            var baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  module.exports = {
    toASCII
  };
});

// ../../node_modules/@kamilkisiela/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS((exports, module) => {
  var Url = function() {
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
  };
  var _escapePath = function(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var _escapeSearch = function(search) {
    return search.replace(/#/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var containsCharacter = function(string, char1, fromIndex, stopCharacterTable) {
    var len2 = string.length;
    for (var i2 = fromIndex;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1) {
        return true;
      } else if (stopCharacterTable[ch] === 1) {
        return false;
      }
    }
    return false;
  };
  var containsCharacter2 = function(string, char1, char2) {
    for (var i2 = 0, len2 = string.length;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1 || ch === char2)
        return true;
    }
    return false;
  };
  var makeAsciiTable = function(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item) {
      if (typeof item === "number") {
        ret[item] = 1;
      } else {
        var start = item[0];
        var end = item[1];
        for (var j = start;j <= end; ++j) {
          ret[j] = 1;
        }
      }
    });
    return ret;
  };
  var f = function() {
  };
  var querystring = import.meta.require("querystring");
  Url.queryString = querystring;
  Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    while (str.charCodeAt(start) <= 32)
      start++;
    while (str.charCodeAt(end) <= 32)
      end--;
    start = this._parseProtocol(str, start, end);
    if (this._protocol !== "javascript") {
      start = this._parseHost(str, start, end, hostDenotesSlash);
      var proto = this._protocol;
      if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
        this.hostname = this.host = "";
      }
    }
    if (start <= end) {
      var ch = str.charCodeAt(start);
      if (ch === 47 || ch === 92) {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else if (ch === 63) {
        this._parseQuery(str, start, end, disableAutoEscapeChars);
      } else if (ch === 35) {
        this._parseHash(str, start, end, disableAutoEscapeChars);
      } else if (this._protocol !== "javascript") {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else {
        this.pathname = str.slice(start, end + 1);
      }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
      this.pathname = "/";
    }
    if (parseQueryString) {
      var search = this.search;
      if (search == null) {
        search = this.search = "";
      }
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      this.query = Url.queryString.parse(search);
    }
  };
  Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
  };
  Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    var q = this.query;
    if (q && typeof q === "object") {
      query = Url.queryString.stringify(q);
    }
    if (!search) {
      search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
      protocol += ":";
    if (this.host) {
      host = auth + this.host;
    } else if (hostname) {
      var ip6 = hostname.indexOf(":") > -1;
      if (ip6)
        hostname = "[" + hostname + "]";
      host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol)
      scheme = protocol + (slashes ? "//" : "");
    else if (slashes)
      scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
      pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 63)
      search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 35)
      hash = "#" + hash;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash;
  };
  Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
      relative = Url.parse(relative, false, true);
    var result = this._clone();
    result.hash = relative.hash;
    if (!relative.href) {
      result._href = "";
      return result;
    }
    if (relative.slashes && !relative._protocol) {
      relative._copyPropsTo(result, true);
      if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
      }
      result._href = "";
      return result;
    }
    if (relative._protocol && relative._protocol !== result._protocol) {
      if (!slashProtocols[relative._protocol]) {
        relative._copyPropsTo(result, false);
        result._href = "";
        return result;
      }
      result._protocol = relative._protocol;
      if (!relative.host && relative._protocol !== "javascript") {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result._port = relative._port;
      result.slashes = result.slashes || relative.slashes;
      result._href = "";
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
    var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    if (psychotic) {
      result.hostname = "";
      result._port = -1;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative._protocol) {
        relative.hostname = "";
        relative._port = -1;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = "";
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host ? relative.host : result.host;
      result.hostname = relative.hostname ? relative.hostname : result.hostname;
      result.search = relative.search;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
    } else if (relative.search) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result._href = "";
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      result._href = "";
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--) {
      last = srcPath[i2];
      if (last === ".") {
        srcPath.splice(i2, 1);
      } else if (last === "..") {
        srcPath.splice(i2, 1);
        up++;
      } else if (up) {
        srcPath.splice(i2, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (;up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
  };
  var punycode = require_punycode();
  Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    return punycode.toASCII(hostname);
  };
  var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 35, 63)) {
      return pathname;
    }
    return _escapePath(pathname);
  };
  var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 35, -1))
      return search;
    return _escapeSearch(search);
  };
  Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        var protocol = str.slice(start, i2);
        if (doLowerCase)
          protocol = protocol.toLowerCase();
        this._protocol = protocol;
        return i2 + 1;
      } else if (protocolCharacters[ch] === 1) {
        if (ch < 97)
          doLowerCase = true;
      } else {
        return start;
      }
    }
    return start;
  };
  Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
      auth = decodeURIComponent(auth);
    }
    this.auth = auth;
  };
  Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    var port = 0;
    var hadChars = false;
    var validPort = true;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (48 <= ch && ch <= 57) {
        port = 10 * port + (ch - 48);
        hadChars = true;
      } else {
        validPort = false;
        if (ch === 92 || ch === 47) {
          validPort = true;
        }
        break;
      }
    }
    if (port === 0 && !hadChars || !validPort) {
      if (!validPort) {
        this._port = -2;
      }
      return 0;
    }
    this._port = port;
    return i2 - start;
  };
  Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
      this.slashes = true;
      if (start === 0) {
        if (end < 2)
          return start;
        var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
        if (!hasAuth && !slashesDenoteHost) {
          this.slashes = null;
          return start;
        }
      }
      start += 2;
    } else if (!this._protocol || slashProtocols[this._protocol]) {
      return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 64) {
        j = i2;
      } else if (ch === 37) {
        authNeedsDecoding = true;
      } else if (hostEndingCharacters[ch] === 1) {
        break;
      }
    }
    if (j > -1) {
      this._parseAuth(str, start, j - 1, authNeedsDecoding);
      start = hostNameStart = j + 1;
    }
    if (str.charCodeAt(start) === 91) {
      for (var i2 = start + 1;i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 93) {
          if (str.charCodeAt(i2 + 1) === 58) {
            portLength = this._parsePort(str, i2 + 2, end) + 1;
          }
          var hostname = str.slice(start + 1, i2).toLowerCase();
          this.hostname = hostname;
          this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
          this.pathname = "/";
          return i2 + portLength + 1;
        }
      }
      return start;
    }
    for (var i2 = start;i2 <= end; ++i2) {
      if (charsAfterDot > 62) {
        this.hostname = this.host = str.slice(start, i2);
        return i2;
      }
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        portLength = this._parsePort(str, i2 + 1, end) + 1;
        hostNameEnd = i2 - 1;
        break;
      } else if (ch < 97) {
        if (ch === 46) {
          charsAfterDot = -1;
        } else if (65 <= ch && ch <= 90) {
          doLowerCase = true;
        } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
          if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
      } else if (ch >= 123) {
        if (ch <= 126) {
          if (this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
        idna = true;
      }
      lastCh = ch;
      charsAfterDot++;
    }
    if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
      var hostname = str.slice(hostNameStart, hostNameEnd + 1);
      if (doLowerCase)
        hostname = hostname.toLowerCase();
      if (idna)
        hostname = this._hostIdna(hostname);
      this.hostname = hostname;
      this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
  };
  Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
      input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
  };
  Url.prototype._clone = function Url$_clone() {
    var ret = new Url;
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
  };
  Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i2 = start;
    var ret = "";
    var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      var escaped = autoEscapeMap2[ch];
      if (escaped !== "" && escaped !== undefined) {
        if (cur < i2)
          ret += str.slice(cur, i2);
        ret += escaped;
        cur = i2 + 1;
      }
    }
    if (cur < i2 + 1)
      ret += str.slice(cur, i2);
    return ret;
  };
  Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (ch === 63) {
        this._parseQuery(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (pathStart > pathEnd) {
      this.pathname = prePath === "" ? "/" : prePath;
      return;
    }
    var path;
    if (escape2) {
      path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
      path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
  };
  Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        queryEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (queryStart > queryEnd) {
      this.search = "";
      return;
    }
    var query;
    if (escape2) {
      query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
      query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
  };
  Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
      this.hash = "";
      return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
  };
  Object.defineProperty(Url.prototype, "port", {
    get: function() {
      if (this._port >= 0) {
        return "" + this._port;
      }
      return null;
    },
    set: function(v) {
      if (v == null) {
        this._port = -1;
      } else {
        this._port = parseInt(v, 10);
      }
    }
  });
  Object.defineProperty(Url.prototype, "query", {
    get: function() {
      var query = this._query;
      if (query != null) {
        return query;
      }
      var search = this.search;
      if (search) {
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        if (search !== "") {
          this._query = search;
          return search;
        }
      }
      return search;
    },
    set: function(v) {
      this._query = v;
    }
  });
  Object.defineProperty(Url.prototype, "path", {
    get: function() {
      var p = this.pathname || "";
      var s = this.search || "";
      if (p || s) {
        return p + s;
      }
      return p == null && s ? "/" + s : null;
    },
    set: function() {
    }
  });
  Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
      var proto = this._protocol;
      return proto ? proto + ":" : proto;
    },
    set: function(v) {
      if (typeof v === "string") {
        var end = v.length - 1;
        if (v.charCodeAt(end) === 58) {
          this._protocol = v.slice(0, end);
        } else {
          this._protocol = v;
        }
      } else if (v == null) {
        this._protocol = null;
      }
    }
  });
  Object.defineProperty(Url.prototype, "href", {
    get: function() {
      var href = this._href;
      if (!href) {
        href = this._href = this.format();
      }
      return href;
    },
    set: function(v) {
      this._href = v;
    }
  });
  Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url)
      return str;
    var ret = new Url;
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
  };
  Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
      obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  };
  Url.resolve = function Url$Resolve(source2, relative) {
    return Url.parse(source2, false, true).resolve(relative);
  };
  Url.resolveObject = function Url$ResolveObject(source2, relative) {
    if (!source2)
      return relative;
    return Url.parse(source2, false, true).resolveObject(relative);
  };
  var autoEscape = [
    "<",
    ">",
    "\"",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
  ];
  var autoEscapeMap = new Array(128);
  for (i = 0, len = autoEscapeMap.length;i < len; ++i) {
    autoEscapeMap[i] = "";
  }
  var i;
  var len;
  for (i = 0, len = autoEscape.length;i < len; ++i) {
    c = autoEscape[i];
    esc = encodeURIComponent(c);
    if (esc === c) {
      esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
  }
  var c;
  var esc;
  var i;
  var len;
  var afterQueryAutoEscapeMap = autoEscapeMap.slice();
  autoEscapeMap[92] = "/";
  var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
  };
  f.prototype = slashProtocols;
  Url.prototype._protocolCharacters = makeAsciiTable([
    [97, 122],
    [65, 90],
    46,
    43,
    45
  ]);
  Url.prototype._hostEndingCharacters = makeAsciiTable([
    35,
    63,
    47,
    92
  ]);
  Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "^",
    "`",
    "\"",
    "%",
    ";"
  ].map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._autoEscapeMap = autoEscapeMap;
  Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
  module.exports = Url;
  Url.replace = function Url$Replace() {
    import.meta.require.cache.url = {
      exports: Url
    };
  };
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var isURLSearchParams = function(value) {
    return value?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    params;
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value] of init) {
            this.params[key] = value;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value] of init.entries()) {
            this.params[key] = value;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name, value) {
      const existingValue = this.params[name];
      const finalValue = existingValue ? `${existingValue},${value}` : value;
      this.params[name] = finalValue;
    }
    delete(name) {
      delete this.params[name];
    }
    get(name) {
      const value = this.params[name];
      if (Array.isArray(value)) {
        return value[0] || null;
      }
      return value || null;
    }
    getAll(name) {
      const value = this.params[name];
      if (!Array.isArray(value)) {
        return value ? [value] : [];
      }
      return value;
    }
    has(name) {
      return name in this.params;
    }
    set(name, value) {
      this.params[name] = value;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value = this.params[key];
        if (Array.isArray(value)) {
          for (const item of value) {
            yield [key, item];
          }
        } else {
          yield [key, value];
        }
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var buffer_1 = import.meta.require("buffer");
  var crypto_1 = import.meta.require("crypto");
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    _searchParams;
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value) {
      this.auth = `${value}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value) {
      this.auth = `${this.username}:${value}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
    static blobRegistry = new Map;
    static createObjectURL(blob) {
      const blobUrl = `blob:whatwgnode:${(0, crypto_1.randomUUID)()}`;
      this.blobRegistry.set(blobUrl, blob);
      return blobUrl;
    }
    static resolveObjectURL(url) {
      if (!this.blobRegistry.has(url)) {
        URL.revokeObjectURL(url);
      } else {
        this.blobRegistry.delete(url);
      }
    }
    static getBlobFromURL(url) {
      return this.blobRegistry.get(url) || (0, buffer_1.resolveObjectURL)(url);
    }
  }
  exports.PonyfillURL = PonyfillURL;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        if (nodeHeaders["accept-encoding"] == null) {
          nodeHeaders["accept-encoding"] = "gzip, deflate, br";
        }
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        nodeRequest.once("response", (nodeResponse) => {
          let outputStream;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              outputStream = (0, zlib_1.createGunzip)();
              break;
            case "x-deflate":
            case "deflate":
              outputStream = (0, zlib_1.createInflate)();
              break;
            case "x-deflate-raw":
            case "deflate-raw":
              outputStream = (0, zlib_1.createInflateRaw)();
              break;
            case "br":
              outputStream = (0, zlib_1.createBrotliDecompress)();
              break;
            default:
              outputStream = new stream_1.PassThrough;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          stream_1.promises.pipeline(nodeResponse, outputStream, {
            signal: fetchRequest["_signal"] ?? undefined,
            end: true
          }).then(() => {
            if (!nodeResponse.destroyed) {
              nodeResponse.resume();
            }
          }).catch(reject);
          const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e) {
        reject(e);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = fetchNodeHttp;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var stream_1 = import.meta.require("stream");
  var zlib_1 = import.meta.require("zlib");
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var getResponseForBlob = function(url) {
    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);
    if (!blob) {
      throw new TypeError("Invalid Blob URL");
    }
    return new Response_js_1.PonyfillResponse(blob, {
      status: 200,
      headers: {
        "content-type": blob.type,
        "content-length": blob.size.toString()
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("blob:")) {
      const response = getResponseForBlob(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl && !fetchRequest.agent) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = fetchPonyfill;
  var fs_1 = import.meta.require("fs");
  var url_1 = import.meta.require("url");
  var fetchCurl_js_1 = require_fetchCurl();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  var BASE64_SUFFIX = ";base64";
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  exports.PonyfillBtoa = PonyfillBtoa;
  var utils_js_1 = require_utils2();

  class PonyfillTextEncoder {
    encoding;
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source2, destination) {
      const buffer = this.encode(source2);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    encoding;
    fatal = false;
    ignoreBOM = false;
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js
var require_WritableStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillWritableStream = undefined;
  var stream_1 = import.meta.require("stream");
  var utils_js_1 = require_utils2();

  class PonyfillWritableStream {
    writable;
    constructor(underlyingSink) {
      if (underlyingSink instanceof stream_1.Writable) {
        this.writable = underlyingSink;
      } else if (underlyingSink) {
        const writable = new stream_1.Writable({
          write(chunk, _encoding, callback) {
            try {
              const result = underlyingSink.write?.(chunk, controller);
              if (result instanceof Promise) {
                result.then(() => {
                  callback();
                }, (err) => {
                  callback(err);
                });
              } else {
                callback();
              }
            } catch (err) {
              callback(err);
            }
          },
          final(callback) {
            const result = underlyingSink.close?.();
            if (result instanceof Promise) {
              result.then(() => {
                callback();
              }, (err) => {
                callback(err);
              });
            } else {
              callback();
            }
          }
        });
        this.writable = writable;
        let onabort;
        let reason;
        const controller = {
          signal: {
            any(signals) {
              return AbortSignal.any([...signals]);
            },
            get reason() {
              return reason;
            },
            get aborted() {
              return writable.destroyed;
            },
            addEventListener: (_event, eventListener) => {
              writable.once("error", eventListener);
              writable.once("close", eventListener);
            },
            removeEventListener: (_event, eventListener) => {
              writable.off("error", eventListener);
              writable.off("close", eventListener);
            },
            dispatchEvent: (_event) => {
              return false;
            },
            get onabort() {
              return onabort;
            },
            set onabort(value) {
              if (onabort) {
                this.removeEventListener("abort", onabort);
              }
              onabort = value;
              if (onabort) {
                this.addEventListener("abort", onabort);
              }
            },
            throwIfAborted() {
              if (writable.destroyed) {
                throw reason;
              }
            }
          },
          error: (e) => {
            this.writable.destroy(e);
          }
        };
        this.writable.once("error", (err) => {
          reason = err;
        });
      } else {
        this.writable = new stream_1.Writable;
      }
    }
    getWriter() {
      const writable = this.writable;
      return {
        closed: new Promise((resolve) => {
          writable.once("close", () => {
            resolve(undefined);
          });
        }),
        get desiredSize() {
          return writable.writableLength;
        },
        ready: new Promise((resolve) => {
          writable.once("drain", () => {
            resolve(undefined);
          });
        }),
        releaseLock() {
        },
        write(chunk) {
          if (chunk == null) {
            return (0, utils_js_1.fakePromise)(undefined);
          }
          return new Promise((resolve, reject) => {
            writable.write(chunk, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          });
        },
        close() {
          if (!writable.errored && writable.closed) {
            return (0, utils_js_1.fakePromise)(undefined);
          }
          return new Promise((resolve, reject) => {
            if (writable.errored) {
              reject(writable.errored);
            } else {
              writable.end((err) => {
                if (err) {
                  reject(err);
                } else {
                  resolve();
                }
              });
            }
          });
        },
        abort(reason) {
          return new Promise((resolve) => {
            writable.destroy(reason);
            writable.once("close", resolve);
          });
        }
      };
    }
    close() {
      if (!this.writable.errored && this.writable.closed) {
        return (0, utils_js_1.fakePromise)(undefined);
      }
      return new Promise((resolve, reject) => {
        if (this.writable.errored) {
          reject(this.writable.errored);
        } else {
          this.writable.end((err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        }
      });
    }
    abort(reason) {
      return new Promise((resolve) => {
        this.writable.destroy(reason);
        this.writable.once("close", resolve);
      });
    }
    locked = false;
  }
  exports.PonyfillWritableStream = PonyfillWritableStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js
var require_TransformStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillTransformStream = undefined;
  var node_stream_1 = import.meta.require("stream");
  var ReadableStream_js_1 = require_ReadableStream();
  var WritableStream_js_1 = require_WritableStream();

  class PonyfillTransformStream {
    transform;
    writable;
    readable;
    constructor(transformer) {
      if (transformer instanceof node_stream_1.Transform) {
        this.transform = transformer;
      } else if (transformer) {
        const controller = {
          enqueue(chunk) {
            transform.push(chunk);
          },
          error(reason) {
            transform.destroy(reason);
          },
          terminate() {
            transform.end();
          },
          get desiredSize() {
            return transform.writableLength;
          }
        };
        const transform = new node_stream_1.Transform({
          read() {
          },
          write(chunk, _encoding, callback) {
            try {
              const result = transformer.transform?.(chunk, controller);
              if (result instanceof Promise) {
                result.then(() => {
                  callback();
                }, (err) => {
                  callback(err);
                });
              } else {
                callback();
              }
            } catch (err) {
              callback(err);
            }
          },
          final(callback) {
            try {
              const result = transformer.flush?.(controller);
              if (result instanceof Promise) {
                result.then(() => {
                  callback();
                }, (err) => {
                  callback(err);
                });
              } else {
                callback();
              }
            } catch (err) {
              callback(err);
            }
          }
        });
        this.transform = transform;
      } else {
        this.transform = new node_stream_1.Transform;
      }
      this.writable = new WritableStream_js_1.PonyfillWritableStream(this.transform);
      this.readable = new ReadableStream_js_1.PonyfillReadableStream(this.transform);
    }
  }
  exports.PonyfillTransformStream = PonyfillTransformStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js
var require_CompressionStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillCompressionStream = undefined;
  var node_zlib_1 = import.meta.require("zlib");
  var TransformStream_js_1 = require_TransformStream();

  class PonyfillCompressionStream extends TransformStream_js_1.PonyfillTransformStream {
    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];
    constructor(compressionFormat) {
      switch (compressionFormat) {
        case "x-gzip":
        case "gzip":
          super((0, node_zlib_1.createGzip)());
          break;
        case "x-deflate":
        case "deflate":
          super((0, node_zlib_1.createDeflate)());
          break;
        case "deflate-raw":
          super((0, node_zlib_1.createDeflateRaw)());
          break;
        case "br":
          super((0, node_zlib_1.createBrotliCompress)());
          break;
        default:
          throw new Error(`Unsupported compression format: ${compressionFormat}`);
      }
    }
  }
  exports.PonyfillCompressionStream = PonyfillCompressionStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js
var require_DecompressionStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillDecompressionStream = undefined;
  var node_zlib_1 = import.meta.require("zlib");
  var TransformStream_js_1 = require_TransformStream();

  class PonyfillDecompressionStream extends TransformStream_js_1.PonyfillTransformStream {
    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];
    constructor(compressionFormat) {
      switch (compressionFormat) {
        case "x-gzip":
        case "gzip":
          super((0, node_zlib_1.createGunzip)());
          break;
        case "x-deflate":
        case "deflate":
          super((0, node_zlib_1.createInflate)());
          break;
        case "deflate-raw":
          super((0, node_zlib_1.createInflateRaw)());
          break;
        case "br":
          super((0, node_zlib_1.createBrotliDecompress)());
          break;
        default:
          throw new TypeError(`Unsupported compression format: '${compressionFormat}'`);
      }
    }
  }
  exports.PonyfillDecompressionStream = PonyfillDecompressionStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DecompressionStream = exports.CompressionStream = exports.TransformStream = exports.WritableStream = exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
  var WritableStream_js_1 = require_WritableStream();
  Object.defineProperty(exports, "WritableStream", { enumerable: true, get: function() {
    return WritableStream_js_1.PonyfillWritableStream;
  } });
  var TransformStream_js_1 = require_TransformStream();
  Object.defineProperty(exports, "TransformStream", { enumerable: true, get: function() {
    return TransformStream_js_1.PonyfillTransformStream;
  } });
  var CompressionStream_js_1 = require_CompressionStream();
  Object.defineProperty(exports, "CompressionStream", { enumerable: true, get: function() {
    return CompressionStream_js_1.PonyfillCompressionStream;
  } });
  var DecompressionStream_js_1 = require_DecompressionStream();
  Object.defineProperty(exports, "DecompressionStream", { enumerable: true, get: function() {
    return DecompressionStream_js_1.PonyfillDecompressionStream;
  } });
});

// ../../node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS((exports, module) => {
  var shouldSkipPonyfill = require_shouldSkipPonyfill();
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    ponyfills.URLPattern = globalThis.URLPattern;
    if (!ponyfills.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill();
      ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (opts.skipPonyfill || shouldSkipPonyfill()) {
      return {
        fetch: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response,
        FormData: globalThis.FormData,
        ReadableStream: globalThis.ReadableStream,
        WritableStream: globalThis.WritableStream,
        TransformStream: globalThis.TransformStream,
        CompressionStream: globalThis.CompressionStream,
        DecompressionStream: globalThis.DecompressionStream,
        Blob: globalThis.Blob,
        File: globalThis.File,
        crypto: globalThis.crypto,
        btoa: globalThis.btoa,
        TextEncoder: globalThis.TextEncoder,
        TextDecoder: globalThis.TextDecoder,
        URLPattern: ponyfills.URLPattern,
        URL: globalThis.URL,
        URLSearchParams: globalThis.URLSearchParams
      };
    }
    const newNodeFetch = require_cjs();
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = newNodeFetch.WritableStream;
    ponyfills.TransformStream = newNodeFetch.TransformStream;
    ponyfills.CompressionStream = newNodeFetch.CompressionStream;
    ponyfills.DecompressionStream = newNodeFetch.DecompressionStream;
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Request = class Request2 extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Response = class Response2 extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills.crypto) {
      const cryptoModule = import.meta.require("crypto");
      ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
  };
});

// ../../node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var to = function(e) {
    return typeof e == "function" ? e : (t) => t.$extends(e);
  };
  var ro = function(e) {
    return e;
  };
  var no = function(...e) {
    return (t) => t;
  };
  var lo = function(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  };
  var In = function(e, t) {
    return t ? `${t}.${e}` : e;
  };
  var mu = function(e) {
    let t = (0, vr.default)(e), r = Object.assign((...n) => (t.log = r.log, n.length !== 0 && It.push([e, ...n]), It.length > du && It.shift(), t("", ...n)), t);
    return r;
  };
  var bo = function(e = 7500) {
    let t = It.map((r) => r.map((n) => typeof n == "string" ? n : JSON.stringify(n)).join(" ")).join(`
`);
    return t.length < e ? t : t.slice(-e);
  };
  var Eo = function() {
    It.length = 0;
  };
  var _ = function(e, t) {
    let r = new RegExp(`\\x1b\\[${t}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${t}m`;
    return function(o) {
      return !fu.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(r, i + n) : o) + i;
    };
  };
  var Vn = function() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && Co.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var jn = function(e, t) {
    let r = t === "url";
    return e.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? r ? `${Cr}.dylib.node` : `${Cr}-${e}.dylib.node` : r ? `${Cr}.so.node` : `${Cr}-${e}.so.node`;
  };
  var Je = function(e) {
    var t;
    return (t = {})[Ar] = function() {
      return { match: function(r) {
        return { matched: !!e(r) };
      } };
    }, t;
  };
  var st = function(e) {
    return new yu(e, []);
  };
  var Ot = function(e) {
    return (0, _o.default)(e, e, { fallback: te });
  };
  var Dt = function(e, ...t) {
    Eu.warn() && console.warn(`${bu.warn} ${e}`, ...t);
  };
  async function Vo() {
    let e = Sr.default.platform(), t = process.arch;
    if (e === "freebsd") {
      let s = await Ir("freebsd-version");
      if (s && s.trim().length > 0) {
        let l = /^(\d+)\.?/.exec(s);
        if (l)
          return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: t };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: t };
    let r = await Tu(), n = await Fu(), i = Au({ arch: t, archFromUname: n, familyDistro: r.familyDistro }), { libssl: o } = await Ru(i);
    return { platform: "linux", libssl: o, arch: t, archFromUname: n, ...r };
  }
  var vu = function(e) {
    let t = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n = t.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = r.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = st({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l }));
    return ie(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
  };
  async function Tu() {
    let e = "/etc/os-release";
    try {
      let t = await Gn.default.readFile(e, { encoding: "utf-8" });
      return vu(t);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var Cu = function(e) {
    let t = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (t) {
      let r = `${t[1]}.x`;
      return jo(r);
    }
  };
  var No = function(e) {
    let t = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (t) {
      let r = `${t[1]}${t[2] ?? ".0"}.x`;
      return jo(r);
    }
  };
  var jo = function(e) {
    let t = (() => {
      if (Uo(e))
        return e;
      let r = e.split(".");
      return r[1] = "0", r.join(".");
    })();
    if (Pu.includes(t))
      return t;
  };
  var Au = function(e) {
    return st(e).with({ familyDistro: "musl" }, () => (ie('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t }) => (ie('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t}-linux-gnu`, `/lib/${t}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ie('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t, arch: r, archFromUname: n }) => (ie(`Don't know any platform-specific paths for "${t}" on ${r} (${n})`), []));
  };
  async function Ru(e) {
    let t = 'grep -v "libssl.so.0"', r = await Lo(e);
    if (r) {
      ie(`Found libssl.so file using platform-specific paths: ${r}`);
      let o = No(r);
      if (ie(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "libssl-specific-path" };
    }
    ie('Falling back to "ldconfig" and other generic paths');
    let n = await Ir(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t}`);
    if (n || (n = await Lo(["/lib64", "/usr/lib64", "/lib"])), n) {
      ie(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
      let o = No(n);
      if (ie(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "ldconfig" };
    }
    let i = await Ir("openssl version -v");
    if (i) {
      ie(`Found openssl binary with version: ${i}`);
      let o = Cu(i);
      if (ie(`The parsed openssl version is: ${o}`), o)
        return { libssl: o, strategy: "openssl-binary" };
    }
    return ie("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Lo(e) {
    for (let t of e) {
      let r = await Mu(t);
      if (r)
        return r;
    }
  }
  async function Mu(e) {
    try {
      return (await Gn.default.readdir(e)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
    } catch (t) {
      if (t.code === "ENOENT")
        return;
      throw t;
    }
  }
  async function ut() {
    let { binaryTarget: e } = await Bo();
    return e;
  }
  var Su = function(e) {
    return e.binaryTarget !== undefined;
  };
  async function Jn() {
    let { memoized: e, ...t } = await Bo();
    return t;
  }
  async function Bo() {
    if (Su(Mr))
      return Promise.resolve({ ...Mr, memoized: true });
    let e = await Vo(), t = Iu(e);
    return Mr = { ...e, binaryTarget: t }, { ...Mr, memoized: false };
  }
  var Iu = function(e) {
    let { platform: t, arch: r, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
    t === "linux" && !["x64", "arm64"].includes(r) && Dt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
    let l = "1.1.x";
    if (t === "linux" && i === undefined) {
      let c = st({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Dt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
    }
    let u = "debian";
    if (t === "linux" && o === undefined && Dt(`Prisma doesn't know which engines to download for the Linux distro "${a}". Falling back to Prisma engines built "${u}".
Please report your experience by creating an issue at ${Ot("https://github.com/prisma/prisma/issues")} so we can add your distro to the list of known supported distros.`), t === "darwin" && r === "arm64")
      return "darwin-arm64";
    if (t === "darwin")
      return "darwin";
    if (t === "win32")
      return "windows";
    if (t === "freebsd")
      return o;
    if (t === "openbsd")
      return "openbsd";
    if (t === "netbsd")
      return "netbsd";
    if (t === "linux" && o === "nixos")
      return "linux-nixos";
    if (t === "linux" && r === "arm64")
      return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
    if (t === "linux" && r === "arm")
      return `linux-arm-openssl-${i || l}`;
    if (t === "linux" && o === "musl") {
      let c = "linux-musl";
      return !i || Uo(i) ? c : `${c}-openssl-${i}`;
    }
    return t === "linux" && o && i ? `${o}-openssl-${i}` : (t !== "linux" && Dt(`Prisma detected unknown OS "${t}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
  };
  async function ku(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  var Ir = function(e) {
    return ku(async () => {
      let t = await wu(e);
      return ie(`Command "${e}" successfully returned "${t.stdout}"`), t.stdout;
    });
  };
  async function Fu() {
    return typeof Sr.default.machine == "function" ? Sr.default.machine() : (await Ir("uname -m"))?.trim();
  }
  var Uo = function(e) {
    return e.startsWith("1.");
  };
  var Jo = function(e) {
    let t = e.ignoreProcessEnv ? {} : process.env, r = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
      let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a)
        return o;
      let l = a[1], u, c;
      if (l === "\\")
        c = a[0], u = c.replace("\\$", "$");
      else {
        let p = a[2];
        c = a[0].substring(l.length), u = Object.hasOwnProperty.call(t, p) ? t[p] : e.parsed[p] || "", u = r(u);
      }
      return o.replace(c, u);
    }, n) ?? n;
    for (let n in e.parsed) {
      let i = Object.hasOwnProperty.call(t, n) ? t[n] : e.parsed[n];
      e.parsed[n] = r(i);
    }
    for (let n in e.parsed)
      t[n] = e.parsed[n];
    return e;
  };
  var _t = function({ rootEnvPath: e, schemaEnvPath: t }, r = { conflictCheck: "none" }) {
    let n = Ho(e);
    r.conflictCheck !== "none" && Bu(n, t, r.conflictCheck);
    let i = null;
    return Wo(n?.path, t) || (i = Ho(t)), !n && !i && zn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(me(ne("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var Bu = function(e, t, r) {
    let n = e?.dotenvResult.parsed, i = !Wo(e?.path, t);
    if (n && t && i && Or.default.existsSync(t)) {
      let o = Yn.default.parse(Or.default.readFileSync(t)), s = [];
      for (let a in o)
        n[a] === o[a] && s.push(a);
      if (s.length > 0) {
        let a = ct.default.relative(process.cwd(), e.path), l = ct.default.relative(process.cwd(), t);
        if (r === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${te(a)} and ${te(l)}
Conflicting env vars:
${s.map((c) => `  ${ne(c)}`).join(`
`)}

We suggest to move the contents of ${te(l)} to ${te(a)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (r === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => ne(c)).join(", ")} in ${te(a)} and ${te(l)}
Env vars from ${te(l)} overwrite the ones from ${te(a)}
      `;
          console.warn(`${he("warn(prisma)")} ${u}`);
        }
      }
    }
  };
  var Ho = function(e) {
    return Uu(e) ? (zn(`Environment variables loaded from ${e}`), { dotenvResult: Jo(Yn.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined })), message: Fe(`Environment variables loaded from ${ct.default.relative(process.cwd(), e)}`), path: e }) : (zn(`Environment variables not found at ${e}`), null);
  };
  var Wo = function(e, t) {
    return e && t && ct.default.resolve(e) === ct.default.resolve(t);
  };
  var Uu = function(e) {
    return !!(e && Or.default.existsSync(e));
  };
  var Zn = function(e) {
    let t = Ku();
    return t || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : zo);
  };
  var Ku = function() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : undefined;
  };
  var rs = function() {
    return N.default.join(import.meta.dir, "../");
  };
  var ti = function(e) {
    if (process.platform === "win32")
      return;
    let t = ei.default.statSync(e), r = t.mode | 64 | 8 | 1;
    if (t.mode === r) {
      ns(`Execution permissions of ${e} are fine`);
      return;
    }
    let n = r.toString(8).slice(-3);
    ns(`Have to call chmodPlusX on ${e}`), ei.default.chmodSync(e, n);
  };
  var ri = function(e) {
    let t = e.e, r = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = t.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Ot("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Fe(e.id)}\`).`, s = st({ message: t.message, code: t.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${r("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${r("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
      let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${r("libssl")}. Please install ${a} and try again.`;
    }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o}
${s}

Details: ${t.message}`;
  };
  var ni = function(e) {
    return Nt.default.sep === Nt.default.posix.sep ? e : e.split(Nt.default.sep).join(Nt.default.posix.sep);
  };
  var si = function(e) {
    return String(new oi(e));
  };
  var Wu = function(e) {
    let t;
    if (e.length > 0) {
      let r = e.find((n) => n.fromEnvVar !== null);
      r ? t = `env("${r.fromEnvVar}")` : t = e.map((n) => n.native ? "native" : n.value);
    } else
      t = undefined;
    return t;
  };
  var zu = function(e) {
    let t = Object.keys(e).reduce((r, n) => Math.max(r, n.length), 0);
    return Object.entries(e).map(([r, n]) => `${r.padEnd(t)} = ${Yu(n)}`).join(`
`);
  };
  var Yu = function(e) {
    return JSON.parse(JSON.stringify(e, (t, r) => Array.isArray(r) ? `[${r.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(r)));
  };
  var Zu = function(...e) {
    console.log(...e);
  };
  var ai = function(e, ...t) {
    ss.warn() && console.warn(`${Lt.warn} ${e}`, ...t);
  };
  var Xu = function(e, ...t) {
    console.info(`${Lt.info} ${e}`, ...t);
  };
  var ec = function(e, ...t) {
    console.error(`${Lt.error} ${e}`, ...t);
  };
  var tc = function(e, ...t) {
    console.log(`${Lt.query} ${e}`, ...t);
  };
  var _r = function(e, t) {
    if (!e)
      throw new Error(`${t}. This should never happen. If you see this error, please, open an issue at https://github.com/prisma/prisma/issues/new?assignees=&labels=kind%2Fbug&projects=&template=bug_report.yml`);
  };
  var He = function(e, t) {
    throw new Error(t);
  };
  var ui = function(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  };
  var pt = function(e, t) {
    let r = {};
    for (let n of Object.keys(e))
      r[n] = t(e[n], n);
    return r;
  };
  var pi = function(e, t) {
    if (e.length === 0)
      return;
    let r = e[0];
    for (let n = 1;n < e.length; n++)
      t(r, e[n]) < 0 && (r = e[n]);
    return r;
  };
  var E = function(e, t) {
    Object.defineProperty(e, "name", { value: t, configurable: true });
  };
  var Vt = function(e) {
    let t;
    return { get() {
      return t || (t = { value: e() }), t.value;
    } };
  };
  var ms = function(e, t) {
    let r = Vt(() => nc(t));
    Object.defineProperty(e, "dmmf", { get: () => r.get() });
  };
  var nc = function(e) {
    return { datamodel: { models: di(e.models), enums: di(e.enums), types: di(e.types) } };
  };
  var di = function(e) {
    return Object.entries(e).map(([t, r]) => ({ name: t, ...r }));
  };
  var fi = function(e, t) {
    Object.defineProperty(e, "name", { value: t, configurable: true });
  };
  var qr = function(e) {
    return { ok: false, error: e, map() {
      return qr(e);
    }, flatMap() {
      return qr(e);
    } };
  };
  var De = function(e, t) {
    return async (...r) => {
      try {
        return await t(...r);
      } catch (n) {
        let i = e.registerNewError(n);
        return qr({ kind: "GenericJsError", id: i });
      }
    };
  };
  var ac = function(e, t) {
    return (...r) => {
      try {
        return t(...r);
      } catch (n) {
        let i = e.registerNewError(n);
        return qr({ kind: "GenericJsError", id: i });
      }
    };
  };
  var gs = function(e, t = ",", r = "", n = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([r, ...Array(e.length - 1).fill(t), n], e);
  };
  var gi = function(e) {
    return new oe([e], []);
  };
  var yi = function(e, ...t) {
    return new oe(e, t);
  };
  var Qt = function(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(t) {
      return e[t];
    } };
  };
  var re = function(e, t) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return t();
    } };
  };
  var We = function(e) {
    let t = new be;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(r) {
      return t.getOrCreate(r, () => e.getPropertyValue(r));
    }, getPropertyDescriptor(r) {
      return e.getPropertyDescriptor?.(r);
    } };
  };
  var jr = function(e) {
    let t = new Set(e);
    return { getOwnPropertyDescriptor: () => Vr, has: (r, n) => t.has(n), set: (r, n, i) => t.add(n) && Reflect.set(r, n, i), ownKeys: () => [...t] };
  };
  var Ee = function(e, t) {
    let r = uc(t), n = new Set, i = new Proxy(e, { get(o, s) {
      if (n.has(s))
        return o[s];
      let a = r.get(s);
      return a ? a.getPropertyValue(s) : o[s];
    }, has(o, s) {
      if (n.has(s))
        return true;
      let a = r.get(s);
      return a ? a.has?.(s) ?? true : Reflect.has(o, s);
    }, ownKeys(o) {
      let s = xs(Reflect.ownKeys(o), r), a = xs(Array.from(r.keys()), r);
      return [...new Set([...s, ...a, ...n])];
    }, set(o, s, a) {
      return r.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
    }, getOwnPropertyDescriptor(o, s) {
      let a = Reflect.getOwnPropertyDescriptor(o, s);
      if (a && !a.configurable)
        return a;
      let l = r.get(s);
      return l ? l.getPropertyDescriptor ? { ...Vr, ...l?.getPropertyDescriptor(s) } : Vr : a;
    }, defineProperty(o, s, a) {
      return n.add(s), Reflect.defineProperty(o, s, a);
    } });
    return i[hs] = function(o, s, a = bs.inspect) {
      let l = { ...this };
      return delete l[hs], a(l, s);
    }, i;
  };
  var uc = function(e) {
    let t = new Map;
    for (let r of e) {
      let n = r.getKeys();
      for (let i of n)
        t.set(i, r);
    }
    return t;
  };
  var xs = function(e, t) {
    return e.filter((r) => t.get(r)?.has?.(r) ?? true);
  };
  var Gt = function(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var ft = function(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  };
  var Br = function(e) {
    return e.toString() !== "Invalid Date";
  };
  var W = function(e) {
    var t, r, n, i = e.length - 1, o = "", s = e[0];
    if (i > 0) {
      for (o += s, t = 1;t < i; t++)
        n = e[t] + "", r = b - n.length, r && (o += _e(r)), o += n;
      s = e[t], n = s + "", r = b - n.length, r && (o += _e(r));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o + s;
  };
  var se = function(e, t, r) {
    if (e !== ~~e || e < t || e > r)
      throw Error(Le + e);
  };
  var Jt = function(e, t, r, n) {
    var i, o, s, a;
    for (o = e[0];o >= 10; o /= 10)
      --t;
    return --t < 0 ? (t += b, i = 0) : (i = Math.ceil((t + 1) / b), t %= b), o = j(10, b - t), a = e[i] % o | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), s = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 50000 || a == 0) : s = (r < 4 && a + 1 == o || r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == j(10, t - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1000 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), s = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : s = ((n || r < 4) && a + 1 == o || !n && r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1000 | 0) == j(10, t - 3) - 1, s;
  };
  var Ur = function(e, t, r) {
    for (var n, i = [0], o, s = 0, a = e.length;s < a; ) {
      for (o = i.length;o--; )
        i[o] *= t;
      for (i[0] += hi.indexOf(e.charAt(s++)), n = 0;n < i.length; n++)
        i[n] > r - 1 && (i[n + 1] === undefined && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
    }
    return i.reverse();
  };
  var gc = function(e, t) {
    var r, n, i;
    if (t.isZero())
      return t;
    n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Wr(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = yt(e, 1, t.times(i), new e(1));
    for (var o = r;o--; ) {
      var s = t.times(t);
      t = s.times(s).minus(s).times(8).plus(1);
    }
    return e.precision -= r, t;
  };
  var h = function(e, t, r, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor;
    e:
      if (t != null) {
        if (p = e.d, !p)
          return e;
        for (i = 1, a = p[0];a >= 10; a /= 10)
          i++;
        if (o = t - i, o < 0)
          o += b, s = t, c = p[d = 0], l = c / j(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o + 1) / b), a = p.length, d >= a)
          if (n) {
            for (;a++ <= d; )
              p.push(0);
            c = l = 0, i = 1, o %= b, s = o - b + 1;
          } else
            break e;
        else {
          for (c = a = p[d], i = 1;a >= 10; a /= 10)
            i++;
          o %= b, s = o - b + i, l = s < 0 ? 0 : c / j(10, i - s - 1) % 10 | 0;
        }
        if (n = n || t < 0 || p[d + 1] !== undefined || (s < 0 ? c : c % j(10, i - s - 1)), u = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && (o > 0 ? s > 0 ? c / j(10, i - s) : 0 : p[d - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !p[0])
          return p.length = 0, u ? (t -= e.e + 1, p[0] = j(10, (b - t % b) % b), e.e = -t || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = j(10, b - o), p[d] = s > 0 ? (c / j(10, i - s) % j(10, s) | 0) * a : 0), u)
          for (;; )
            if (d == 0) {
              for (o = 1, s = p[0];s >= 10; s /= 10)
                o++;
              for (s = p[0] += a, a = 1;s >= 10; s /= 10)
                a++;
              o != a && (e.e++, p[0] == ge && (p[0] = 1));
              break;
            } else {
              if (p[d] += a, p[d] != ge)
                break;
              p[d--] = 0, a = 1;
            }
        for (o = p.length;p[--o] === 0; )
          p.pop();
      }
    return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
  };
  var we = function(e, t, r) {
    if (!e.isFinite())
      return ks(e);
    var n, i = e.e, o = W(e.d), s = o.length;
    return t ? (r && (n = r - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + _e(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + _e(-i - 1) + o, r && (n = r - s) > 0 && (o += _e(n))) : i >= s ? (o += _e(i + 1 - s), r && (n = r - i - 1) > 0 && (o = o + "." + _e(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), r && (n = r - s) > 0 && (i + 1 === s && (o += "."), o += _e(n))), o;
  };
  var Hr = function(e, t) {
    var r = e[0];
    for (t *= b;r >= 10; r /= 10)
      t++;
    return t;
  };
  var Gr = function(e, t, r) {
    if (t > fc)
      throw w = true, r && (e.precision = r), Error(Ts);
    return h(new e(Kr), t, 1, true);
  };
  var fe = function(e, t, r) {
    if (t > bi)
      throw Error(Ts);
    return h(new e(Qr), t, r, true);
  };
  var Ms = function(e) {
    var t = e.length - 1, r = t * b + 1;
    if (t = e[t], t) {
      for (;t % 10 == 0; t /= 10)
        r--;
      for (t = e[0];t >= 10; t /= 10)
        r++;
    }
    return r;
  };
  var _e = function(e) {
    for (var t = "";e--; )
      t += "0";
    return t;
  };
  var Ss = function(e, t, r, n) {
    var i, o = new e(1), s = Math.ceil(n / b + 4);
    for (w = false;; ) {
      if (r % 2 && (o = o.times(t), ws(o.d, s) && (i = true)), r = ee(r / 2), r === 0) {
        r = o.d.length - 1, i && o.d[r] === 0 && ++o.d[r];
        break;
      }
      t = t.times(t), ws(t.d, s);
    }
    return w = true, o;
  };
  var Es = function(e) {
    return e.d[e.d.length - 1] & 1;
  };
  var Is = function(e, t, r) {
    for (var n, i = new e(t[0]), o = 0;++o < t.length; )
      if (n = new e(t[o]), n.s)
        i[r](n) && (i = n);
      else {
        i = n;
        break;
      }
    return i;
  };
  var Ei = function(e, t) {
    var r, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, y = d.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
    for (t == null ? (w = false, l = y) : l = t, a = new d(0.03125);e.e > -2; )
      e = e.times(a), p += 5;
    for (n = Math.log(j(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, r = o = s = new d(1), d.precision = l;; ) {
      if (o = h(o.times(e), l, 1), r = r.times(++c), a = s.plus(O(o, r, l, 1)), W(a.d).slice(0, l) === W(s.d).slice(0, l)) {
        for (i = p;i--; )
          s = h(s.times(s), l, 1);
        if (t == null)
          if (u < 3 && Jt(s.d, l - n, f, u))
            d.precision = l += 10, r = o = a = new d(1), c = 0, u++;
          else
            return h(s, d.precision = y, f, w = true);
        else
          return d.precision = y, s;
      }
      s = a;
    }
  };
  var Ne = function(e, t) {
    var r, n, i, o, s, a, l, u, c, p, d, f = 1, y = 10, g = e, P = g.d, T = g.constructor, C = T.rounding, x = T.precision;
    if (g.s < 0 || !P || !P[0] || !g.e && P[0] == 1 && P.length == 1)
      return new T(P && !P[0] ? -1 / 0 : g.s != 1 ? NaN : P ? 0 : g);
    if (t == null ? (w = false, c = x) : c = t, T.precision = c += y, r = W(P), n = r.charAt(0), Math.abs(o = g.e) < 1500000000000000) {
      for (;n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
        g = g.times(e), r = W(g.d), n = r.charAt(0), f++;
      o = g.e, n > 1 ? (g = new T("0." + r), o++) : g = new T(n + "." + r.slice(1));
    } else
      return u = Gr(T, c + 2, x).times(o + ""), g = Ne(new T(n + "." + r.slice(1)), c - y).plus(u), T.precision = x, t == null ? h(g, x, C, w = true) : g;
    for (p = g, l = s = g = O(g.minus(1), g.plus(1), c, 1), d = h(g.times(g), c, 1), i = 3;; ) {
      if (s = h(s.times(d), c, 1), u = l.plus(O(s, new T(i), c, 1)), W(u.d).slice(0, c) === W(l.d).slice(0, c))
        if (l = l.times(2), o !== 0 && (l = l.plus(Gr(T, c + 2, x).times(o + ""))), l = O(l, new T(f), c, 1), t == null)
          if (Jt(l.d, c - y, C, a))
            T.precision = c += y, u = s = g = O(p.minus(1), p.plus(1), c, 1), d = h(g.times(g), c, 1), i = a = 1;
          else
            return h(l, T.precision = x, C, w = true);
        else
          return T.precision = x, l;
      l = u, i += 2;
    }
  };
  var ks = function(e) {
    return String(e.s * e.s / 0);
  };
  var wi = function(e, t) {
    var r, n, i;
    for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0;t.charCodeAt(n) === 48; n++)
      ;
    for (i = t.length;t.charCodeAt(i - 1) === 48; --i)
      ;
    if (t = t.slice(n, i), t) {
      if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % b, r < 0 && (n += b), n < i) {
        for (n && e.d.push(+t.slice(0, n)), i -= b;n < i; )
          e.d.push(+t.slice(n, n += b));
        t = t.slice(n), n = b - t.length;
      } else
        n -= i;
      for (;n--; )
        t += "0";
      e.d.push(+t), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  };
  var yc = function(e, t) {
    var r, n, i, o, s, a, l, u, c;
    if (t.indexOf("_") > -1) {
      if (t = t.replace(/(\d)_(?=\d)/g, "$1"), Rs.test(t))
        return wi(e, t);
    } else if (t === "Infinity" || t === "NaN")
      return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (pc.test(t))
      r = 16, t = t.toLowerCase();
    else if (cc.test(t))
      r = 2;
    else if (dc.test(t))
      r = 8;
    else
      throw Error(Le + t);
    for (o = t.search(/p/i), o > 0 ? (l = +t.slice(o + 1), t = t.substring(2, o)) : t = t.slice(2), o = t.indexOf("."), s = o >= 0, n = e.constructor, s && (t = t.replace(".", ""), a = t.length, o = a - o, i = Ss(n, new n(r), o, o * 2)), u = Ur(t, r, ge), c = u.length - 1, o = c;u[o] === 0; --o)
      u.pop();
    return o < 0 ? new n(e.s * 0) : (e.e = Hr(u, c), e.d = u, w = false, s && (e = O(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? j(2, l) : ze.pow(2, l))), w = true, e);
  };
  var hc = function(e, t) {
    var r, n = t.d.length;
    if (n < 3)
      return t.isZero() ? t : yt(e, 2, t, t);
    r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Wr(5, r)), t = yt(e, 2, t, t);
    for (var i, o = new e(5), s = new e(16), a = new e(20);r--; )
      i = t.times(t), t = t.times(o.plus(i.times(s.times(i).minus(a))));
    return t;
  };
  var yt = function(e, t, r, n, i) {
    var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / b);
    for (w = false, l = r.times(r), a = new e(n);; ) {
      if (s = O(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(s) : n.minus(s), n = O(s.times(l), new e(t++ * t++), c, 1), s = a.plus(n), s.d[p] !== undefined) {
        for (o = p;s.d[o] === a.d[o] && o--; )
          ;
        if (o == -1)
          break;
      }
      o = a, a = n, n = s, s = o, u++;
    }
    return w = true, s.d.length = p + 1, s;
  };
  var Wr = function(e, t) {
    for (var r = e;--t; )
      r *= e;
    return r;
  };
  var Fs = function(e, t) {
    var r, n = t.s < 0, i = fe(e, e.precision, 1), o = i.times(0.5);
    if (t = t.abs(), t.lte(o))
      return Me = n ? 4 : 1, t;
    if (r = t.divToInt(i), r.isZero())
      Me = n ? 3 : 2;
    else {
      if (t = t.minus(r.times(i)), t.lte(o))
        return Me = Es(r) ? n ? 2 : 3 : n ? 4 : 1, t;
      Me = Es(r) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return t.minus(i).abs();
  };
  var Pi = function(e, t, r, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor, y = r !== undefined;
    if (y ? (se(r, 1, $e), n === undefined ? n = f.rounding : se(n, 0, 8)) : (r = f.precision, n = f.rounding), !e.isFinite())
      c = ks(e);
    else {
      for (c = we(e), s = c.indexOf("."), y ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = Ur(we(d), 10, i), d.e = d.d.length), p = Ur(c, 10, i), o = l = p.length;p[--l] == 0; )
        p.pop();
      if (!p[0])
        c = y ? "0p+0" : "0";
      else {
        if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = O(e, d, r, n, 0, i), p = e.d, o = e.e, u = vs), s = p[r], a = i / 2, u = u || p[r + 1] !== undefined, u = n < 4 ? (s !== undefined || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = r, u)
          for (;++p[--r] > i - 1; )
            p[r] = 0, r || (++o, p.unshift(1));
        for (l = p.length;!p[l - 1]; --l)
          ;
        for (s = 0, c = "";s < l; s++)
          c += hi.charAt(p[s]);
        if (y) {
          if (l > 1)
            if (t == 16 || t == 8) {
              for (s = t == 16 ? 4 : 3, --l;l % s; l++)
                c += "0";
              for (p = Ur(c, i, t), l = p.length;!p[l - 1]; --l)
                ;
              for (s = 1, c = "1.";s < l; s++)
                c += hi.charAt(p[s]);
            } else
              c = c.charAt(0) + "." + c.slice(1);
          c = c + (o < 0 ? "p" : "p+") + o;
        } else if (o < 0) {
          for (;++o; )
            c = "0" + c;
          c = "0." + c;
        } else if (++o > l)
          for (o -= l;o--; )
            c += "0";
        else
          o < l && (c = c.slice(0, o) + "." + c.slice(o));
      }
      c = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + c;
    }
    return e.s < 0 ? "-" + c : c;
  };
  var ws = function(e, t) {
    if (e.length > t)
      return e.length = t, true;
  };
  var xc = function(e) {
    return new this(e).abs();
  };
  var bc = function(e) {
    return new this(e).acos();
  };
  var Ec = function(e) {
    return new this(e).acosh();
  };
  var wc = function(e, t) {
    return new this(e).plus(t);
  };
  var Pc = function(e) {
    return new this(e).asin();
  };
  var vc = function(e) {
    return new this(e).asinh();
  };
  var Tc = function(e) {
    return new this(e).atan();
  };
  var Cc = function(e) {
    return new this(e).atanh();
  };
  var Ac = function(e, t) {
    e = new this(e), t = new this(t);
    var r, n = this.precision, i = this.rounding, o = n + 4;
    return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = fe(this, o, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? fe(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = fe(this, o, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = o, this.rounding = 1, r = this.atan(O(e, t, o, 1)), t = fe(this, o, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(O(e, t, o, 1)), r;
  };
  var Rc = function(e) {
    return new this(e).cbrt();
  };
  var Mc = function(e) {
    return h(e = new this(e), e.e + 1, 2);
  };
  var Sc = function(e, t, r) {
    return new this(e).clamp(t, r);
  };
  var Ic = function(e) {
    if (!e || typeof e != "object")
      throw Error(Jr + "Object expected");
    var t, r, n, i = e.defaults === true, o = ["precision", 1, $e, "rounding", 0, 8, "toExpNeg", -gt, 0, "toExpPos", 0, gt, "maxE", 0, gt, "minE", -gt, 0, "modulo", 0, 9];
    for (t = 0;t < o.length; t += 3)
      if (r = o[t], i && (this[r] = xi[r]), (n = e[r]) !== undefined)
        if (ee(n) === n && n >= o[t + 1] && n <= o[t + 2])
          this[r] = n;
        else
          throw Error(Le + r + ": " + n);
    if (r = "crypto", i && (this[r] = xi[r]), (n = e[r]) !== undefined)
      if (n === true || n === false || n === 0 || n === 1)
        if (n)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r] = true;
          else
            throw Error(Cs);
        else
          this[r] = false;
      else
        throw Error(Le + r + ": " + n);
    return this;
  };
  var kc = function(e) {
    return new this(e).cos();
  };
  var Fc = function(e) {
    return new this(e).cosh();
  };
  var Os = function(e) {
    var t, r, n;
    function i(o) {
      var s, a, l, u = this;
      if (!(u instanceof i))
        return new i(o);
      if (u.constructor = i, Ps(o)) {
        u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
        return;
      }
      if (l = typeof o, l === "number") {
        if (o === 0) {
          u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
          for (s = 0, a = o;a >= 10; a /= 10)
            s++;
          w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
          return;
        } else if (o * 0 !== 0) {
          o || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return wi(u, o.toString());
      } else if (l !== "string")
        throw Error(Le + o);
      return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Rs.test(o) ? wi(u, o) : yc(u, o);
    }
    if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Ic, i.clone = Os, i.isDecimal = Ps, i.abs = xc, i.acos = bc, i.acosh = Ec, i.add = wc, i.asin = Pc, i.asinh = vc, i.atan = Tc, i.atanh = Cc, i.atan2 = Ac, i.cbrt = Rc, i.ceil = Mc, i.clamp = Sc, i.cos = kc, i.cosh = Fc, i.div = Oc, i.exp = Dc, i.floor = _c, i.hypot = Nc, i.ln = Lc, i.log = $c, i.log10 = Vc, i.log2 = qc, i.max = jc, i.min = Bc, i.mod = Uc, i.mul = Kc, i.pow = Qc, i.random = Gc, i.round = Jc, i.sign = Hc, i.sin = Wc, i.sinh = zc, i.sqrt = Yc, i.sub = Zc, i.sum = Xc, i.tan = ep, i.tanh = tp, i.trunc = rp, e === undefined && (e = {}), e && e.defaults !== true)
      for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0;t < n.length; )
        e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
    return i.config(e), i;
  };
  var Oc = function(e, t) {
    return new this(e).div(t);
  };
  var Dc = function(e) {
    return new this(e).exp();
  };
  var _c = function(e) {
    return h(e = new this(e), e.e + 1, 3);
  };
  var Nc = function() {
    var e, t, r = new this(0);
    for (w = false, e = 0;e < arguments.length; )
      if (t = new this(arguments[e++]), t.d)
        r.d && (r = r.plus(t.times(t)));
      else {
        if (t.s)
          return w = true, new this(1 / 0);
        r = t;
      }
    return w = true, r.sqrt();
  };
  var Ps = function(e) {
    return e instanceof ze || e && e.toStringTag === As || false;
  };
  var Lc = function(e) {
    return new this(e).ln();
  };
  var $c = function(e, t) {
    return new this(e).log(t);
  };
  var qc = function(e) {
    return new this(e).log(2);
  };
  var Vc = function(e) {
    return new this(e).log(10);
  };
  var jc = function() {
    return Is(this, arguments, "lt");
  };
  var Bc = function() {
    return Is(this, arguments, "gt");
  };
  var Uc = function(e, t) {
    return new this(e).mod(t);
  };
  var Kc = function(e, t) {
    return new this(e).mul(t);
  };
  var Qc = function(e, t) {
    return new this(e).pow(t);
  };
  var Gc = function(e) {
    var t, r, n, i, o = 0, s = new this(1), a = [];
    if (e === undefined ? e = this.precision : se(e, 1, $e), n = Math.ceil(e / b), this.crypto)
      if (crypto.getRandomValues)
        for (t = crypto.getRandomValues(new Uint32Array(n));o < n; )
          i = t[o], i >= 4290000000 ? t[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (t = crypto.randomBytes(n *= 4);o < n; )
          i = t[o] + (t[o + 1] << 8) + (t[o + 2] << 16) + ((t[o + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(t, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else
        throw Error(Cs);
    else
      for (;o < n; )
        a[o++] = Math.random() * 1e7 | 0;
    for (n = a[--o], e %= b, n && e && (i = j(10, b - e), a[o] = (n / i | 0) * i);a[o] === 0; o--)
      a.pop();
    if (o < 0)
      r = 0, a = [0];
    else {
      for (r = -1;a[0] === 0; r -= b)
        a.shift();
      for (n = 1, i = a[0];i >= 10; i /= 10)
        n++;
      n < b && (r -= b - n);
    }
    return s.e = r, s.d = a, s;
  };
  var Jc = function(e) {
    return h(e = new this(e), e.e + 1, this.rounding);
  };
  var Hc = function(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  };
  var Wc = function(e) {
    return new this(e).sin();
  };
  var zc = function(e) {
    return new this(e).sinh();
  };
  var Yc = function(e) {
    return new this(e).sqrt();
  };
  var Zc = function(e, t) {
    return new this(e).sub(t);
  };
  var Xc = function() {
    var e = 0, t = arguments, r = new this(t[e]);
    for (w = false;r.s && ++e < t.length; )
      r = r.plus(t[e]);
    return w = true, h(r, this.precision, this.rounding);
  };
  var ep = function(e) {
    return new this(e).tan();
  };
  var tp = function(e) {
    return new this(e).tanh();
  };
  var rp = function(e) {
    return h(e = new this(e), e.e + 1, 1);
  };
  var ht = function(e) {
    return ze.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  };
  var xt = function(e) {
    return e instanceof Ht;
  };
  var en = function(e) {
    return new vi(Ns(e));
  };
  var Ns = function(e) {
    let t = new Q;
    for (let [r, n] of Object.entries(e)) {
      let i = new Xr(r, Ls(n));
      t.addField(i);
    }
    return t;
  };
  var Ls = function(e) {
    if (typeof e == "string")
      return new G(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new G(String(e));
    if (typeof e == "bigint")
      return new G(`${e}n`);
    if (e === null)
      return new G("null");
    if (e === undefined)
      return new G("undefined");
    if (ht(e))
      return new G(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new G(`Buffer.alloc(${e.byteLength})`) : new G(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let t = Br(e) ? e.toISOString() : "Invalid Date";
      return new G(`new Date("${t}")`);
    }
    return e instanceof xe ? new G(`Prisma.${e._getName()}`) : xt(e) ? new G(`prisma.${lo(e.modelName)}.\$fields.${e.name}`) : Array.isArray(e) ? ip(e) : typeof e == "object" ? Ns(e) : new G(Object.prototype.toString.call(e));
  };
  var ip = function(e) {
    let t = new Et;
    for (let r of e)
      t.addItem(Ls(r));
    return t;
  };
  var $s = function(e) {
    if (e === undefined)
      return "";
    let t = en(e);
    return new mt(0, { colors: Zr }).write(t).toString();
  };
  var qs = function(e) {
    var t = e.split(`
`);
    return t.reduce(function(r, n) {
      var i = ap(n) || up(n) || dp(n) || yp(n) || fp(n);
      return i && r.push(i), r;
    }, []);
  };
  var ap = function(e) {
    var t = op.exec(e);
    if (!t)
      return null;
    var r = t[2] && t[2].indexOf("native") === 0, n = t[2] && t[2].indexOf("eval") === 0, i = sp.exec(t[2]);
    return n && i != null && (t[2] = i[1], t[3] = i[2], t[4] = i[3]), { file: r ? null : t[2], methodName: t[1] || Wt, arguments: r ? [t[2]] : [], lineNumber: t[3] ? +t[3] : null, column: t[4] ? +t[4] : null };
  };
  var up = function(e) {
    var t = lp.exec(e);
    return t ? { file: t[2], methodName: t[1] || Wt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
  };
  var dp = function(e) {
    var t = cp.exec(e);
    if (!t)
      return null;
    var r = t[3] && t[3].indexOf(" > eval") > -1, n = pp.exec(t[3]);
    return r && n != null && (t[3] = n[1], t[4] = n[2], t[5] = null), { file: t[3], methodName: t[1] || Wt, arguments: t[2] ? t[2].split(",") : [], lineNumber: t[4] ? +t[4] : null, column: t[5] ? +t[5] : null };
  };
  var fp = function(e) {
    var t = mp.exec(e);
    return t ? { file: t[3], methodName: t[1] || Wt, arguments: [], lineNumber: +t[4], column: t[5] ? +t[5] : null } : null;
  };
  var yp = function(e) {
    var t = gp.exec(e);
    return t ? { file: t[2], methodName: t[1] || Wt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
  };
  var Ve = function(e) {
    return e === "minimal" ? new Ti : new Ci;
  };
  var wt = function(e = {}) {
    let t = xp(e);
    return Object.entries(t).reduce((n, [i, o]) => (Vs[i] !== undefined ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
  };
  var xp = function(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  };
  var tn = function(e = {}) {
    return (t) => (typeof e._count == "boolean" && (t._count = t._count._all), t);
  };
  var js = function(e, t) {
    let r = tn(e);
    return t({ action: "aggregate", unpacker: r, argsMapper: wt })(e);
  };
  var bp = function(e = {}) {
    let { select: t, ...r } = e;
    return typeof t == "object" ? wt({ ...r, _count: t }) : wt({ ...r, _count: { _all: true } });
  };
  var Ep = function(e = {}) {
    return typeof e.select == "object" ? (t) => tn(e)(t)._count : (t) => tn(e)(t)._count._all;
  };
  var Bs = function(e, t) {
    return t({ action: "count", unpacker: Ep(e), argsMapper: bp })(e);
  };
  var wp = function(e = {}) {
    let t = wt(e);
    if (Array.isArray(t.by))
      for (let r of t.by)
        typeof r == "string" && (t.select[r] = true);
    else
      typeof t.by == "string" && (t.select[t.by] = true);
    return t;
  };
  var Pp = function(e = {}) {
    return (t) => (typeof e?._count == "boolean" && t.forEach((r) => {
      r._count = r._count._all;
    }), t);
  };
  var Us = function(e, t) {
    return t({ action: "groupBy", unpacker: Pp(e), argsMapper: wp })(e);
  };
  var Ks = function(e, t, r) {
    if (t === "aggregate")
      return (n) => js(n, r);
    if (t === "count")
      return (n) => Bs(n, r);
    if (t === "groupBy")
      return (n) => Us(n, r);
  };
  var Qs = function(e, t) {
    let r = t.fields.filter((i) => !i.relationName), n = ci(r, (i) => i.name);
    return new Proxy({}, { get(i, o) {
      if (o in i || typeof o == "symbol")
        return i[o];
      let s = n[o];
      if (s)
        return new Ht(e, o, s.type, s.isList, s.kind === "enum");
    }, ...jr(Object.keys(n)) });
  };
  var vp = function(e, t) {
    return e === undefined || t === undefined ? [] : [...t, "select", e];
  };
  var Tp = function(e, t, r) {
    return t === undefined ? e ?? {} : Js(t, r, e || true);
  };
  var Ri = function(e, t, r, n, i, o) {
    let a = e._runtimeDataModel.models[t].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
    return (l) => {
      let u = Ve(e._errorFormat), c = vp(n, i), p = Tp(l, o, c), d = r({ dataPath: c, callsite: u })(p), f = Cp(e, t);
      return new Proxy(d, { get(y, g) {
        if (!f.includes(g))
          return y[g];
        let T = [a[g].type, r, g], C = [c, p];
        return Ri(e, ...T, ...C);
      }, ...jr([...f, ...Object.getOwnPropertyNames(d)]) });
    };
  };
  var Cp = function(e, t) {
    return e._runtimeDataModel.models[t].fields.filter((r) => r.kind === "object").map((r) => r.name);
  };
  var ye = function(e, t, r, n, i) {
    this.type = e, this.content = t, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!i;
  };
  var Mp = function(e) {
    return Hs[e] || Ap;
  };
  var Ws = function(e) {
    return Sp(e, v.languages.javascript);
  };
  var Sp = function(e, t) {
    return v.tokenize(e, t).map((n) => ye.stringify(n)).join("");
  };
  var Ys = function(e) {
    return (0, zs.default)(e);
  };
  var Fp = function({ callsite: e, message: t, originalMethod: r, isPanic: n, callArguments: i }, o) {
    let s = { functionName: `prisma.${r}()`, message: t, isPanic: n ?? false, callArguments: i };
    if (!e || typeof window < "u" || false)
      return s;
    let a = e.getLocation();
    if (!a || !a.lineNumber || !a.columnNumber)
      return s;
    let l = Math.max(1, a.lineNumber - 3), u = nn.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
    if (u && c) {
      let p = Dp(c), d = Op(c);
      if (!d)
        return s;
      s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (y) => y.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((y, g) => o.gray(String(g).padStart(f)) + " " + y).mapLines((y) => o.dim(y)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
        let y = p + f + 1;
        y += 2, s.callArguments = (0, Xs.default)(i, y).slice(y);
      }
    }
    return s;
  };
  var Op = function(e) {
    let t = Object.keys(pe.ModelAction).join("|"), n = new RegExp(String.raw`\.(${t})\(`).exec(e);
    if (n) {
      let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
      return { code: e.slice(o, i), openingBraceIndex: i };
    }
    return null;
  };
  var Dp = function(e) {
    let t = 0;
    for (let r = 0;r < e.length; r++) {
      if (e.charAt(r) !== " ")
        return t;
      t++;
    }
    return t;
  };
  var _p = function({ functionName: e, location: t, message: r, isPanic: n, contextLines: i, callArguments: o }, s) {
    let a = [""], l = t ? " in" : ":";
    if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), t && a.push(s.underline(Np(t))), i) {
      a.push("");
      let u = [i.toString()];
      o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
    } else
      a.push(""), o && a.push(o), a.push("");
    return a.push(r), a.join(`
`);
  };
  var Np = function(e) {
    let t = [e.fileName];
    return e.lineNumber && t.push(String(e.lineNumber)), e.columnNumber && t.push(String(e.columnNumber)), t.join(":");
  };
  var Pt = function(e) {
    let t = e.showColors ? Ip : kp, r = Fp(e, t);
    return _p(r, t);
  };
  var ea = function(e, t, r, n) {
    return e === pe.ModelAction.findFirstOrThrow || e === pe.ModelAction.findUniqueOrThrow ? Lp(t, r, n) : n;
  };
  var Lp = function(e, t, r) {
    return async (n) => {
      if ("rejectOnNotFound" in n.args) {
        let o = Pt({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new X(o, { clientVersion: t });
      }
      return await r(n).catch((o) => {
        throw o instanceof U && o.code === "P2025" ? new Re(`No ${e} found`, t) : o;
      });
    };
  };
  var Te = function(e) {
    return e.replace(/^./, (t) => t.toLowerCase());
  };
  var Mi = function(e, t) {
    let r = e._extensions.getAllModelExtensions(t) ?? {}, n = [Vp(e, t), Bp(e, t), Qt(r), re("name", () => t), re("$name", () => t), re("$parent", () => e._appliedParent)];
    return Ee({}, n);
  };
  var Vp = function(e, t) {
    let r = Te(t), n = Object.keys(pe.ModelAction).concat("count");
    return { getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = i, s = (l) => e._request(l);
      s = ea(o, t, e._clientVersion, s);
      let a = (l) => (u) => {
        let c = Ve(e._errorFormat);
        return e._createPrismaPromise((p) => {
          let d = { args: u, dataPath: [], action: o, model: t, clientMethod: `${r}.${i}`, jsModelName: r, transaction: p, callsite: c };
          return s({ ...d, ...l });
        });
      };
      return $p.includes(o) ? Ri(e, t, a) : jp(i) ? Ks(e, i, a) : a({});
    } };
  };
  var jp = function(e) {
    return qp.includes(e);
  };
  var Bp = function(e, t) {
    return We(re("fields", () => {
      let r = e._runtimeDataModel.models[t];
      return Qs(t, r);
    }));
  };
  var ta = function(e) {
    return e.replace(/^./, (t) => t.toUpperCase());
  };
  var zt = function(e) {
    let t = [Up(e), re(Si, () => e), re("$parent", () => e._appliedParent)], r = e._extensions.getAllClientExtensions();
    return r && t.push(Qt(r)), Ee(e, t);
  };
  var Up = function(e) {
    let t = Object.keys(e._runtimeDataModel.models), r = t.map(Te), n = [...new Set(t.concat(r))];
    return We({ getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = ta(i);
      if (e._runtimeDataModel.models[o] !== undefined)
        return Mi(e, o);
      if (e._runtimeDataModel.models[i] !== undefined)
        return Mi(e, i);
    }, getPropertyDescriptor(i) {
      if (!r.includes(i))
        return { enumerable: false };
    } });
  };
  var on = function(e) {
    return e[Si] ? e[Si] : e;
  };
  var ra = function(e) {
    if (typeof e == "function")
      return e(this);
    let t = on(this), r = Object.create(t, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return zt(r);
  };
  var na = function({ result: e, modelName: t, select: r, extensions: n }) {
    let i = n.getAllComputedFields(t);
    if (!i)
      return e;
    let o = [], s = [];
    for (let a of Object.values(i)) {
      if (r) {
        if (!r[a.name])
          continue;
        let l = a.needs.filter((u) => !r[u]);
        l.length > 0 && s.push(Gt(l));
      }
      Kp(e, a.needs) && o.push(Qp(a, Ee(e, o)));
    }
    return o.length > 0 || s.length > 0 ? Ee(e, [...o, ...s]) : e;
  };
  var Kp = function(e, t) {
    return t.every((r) => ui(e, r));
  };
  var Qp = function(e, t) {
    return We(re(e.name, () => e.compute(t)));
  };
  var sn = function({ visitor: e, result: t, args: r, runtimeDataModel: n, modelName: i }) {
    if (Array.isArray(t)) {
      for (let s = 0;s < t.length; s++)
        t[s] = sn({ result: t[s], args: r, modelName: i, runtimeDataModel: n, visitor: e });
      return t;
    }
    let o = e(t, i, r) ?? t;
    return r.include && ia({ includeOrSelect: r.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), r.select && ia({ includeOrSelect: r.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
  };
  var ia = function({ includeOrSelect: e, result: t, parentModelName: r, runtimeDataModel: n, visitor: i }) {
    for (let [o, s] of Object.entries(e)) {
      if (!s || t[o] == null)
        continue;
      let l = n.models[r].fields.find((c) => c.name === o);
      if (!l || l.kind !== "object" || !l.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      t[o] = sn({ visitor: i, result: t[o], args: u, modelName: l.type, runtimeDataModel: n });
    }
  };
  var oa = function({ result: e, modelName: t, args: r, extensions: n, runtimeDataModel: i }) {
    return n.isEmpty() || e == null || typeof e != "object" || !i.models[t] ? e : sn({ result: e, args: r ?? {}, modelName: t, runtimeDataModel: i, visitor: (s, a, l) => na({ result: s, modelName: Te(a), select: l.select, extensions: n }) });
  };
  var sa = function(e) {
    if (e instanceof oe)
      return Gp(e);
    if (Array.isArray(e)) {
      let r = [e[0]];
      for (let n = 1;n < e.length; n++)
        r[n] = Yt(e[n]);
      return r;
    }
    let t = {};
    for (let r in e)
      t[r] = Yt(e[r]);
    return t;
  };
  var Gp = function(e) {
    return new oe(e.strings, e.values);
  };
  var Yt = function(e) {
    if (typeof e != "object" || e == null || e instanceof xe || xt(e))
      return e;
    if (ht(e))
      return new Pe(e.toFixed());
    if (ft(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let t = e.length, r;
      for (r = Array(t);t--; )
        r[t] = Yt(e[t]);
      return r;
    }
    if (typeof e == "object") {
      let t = {};
      for (let r in e)
        r === "__proto__" ? Object.defineProperty(t, r, { value: Yt(e[r]), configurable: true, enumerable: true, writable: true }) : t[r] = Yt(e[r]);
      return t;
    }
    He(e, "Unknown value");
  };
  var la = function(e, t, r, n = 0) {
    return e._createPrismaPromise((i) => {
      let o = t.customDataProxyFetch;
      return "transaction" in t && i !== undefined && (t.transaction?.kind === "batch" && t.transaction.lock.then(), t.transaction = i), n === r.length ? e._executeRequest(t) : r[n]({ model: t.model, operation: t.model ? t.action : t.clientMethod, args: sa(t.args ?? {}), __internalParams: t, query: (s, a = t) => {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = da(o, l), a.args = s, la(e, a, r, n + 1);
      } });
    });
  };
  var ua = function(e, t) {
    let { jsModelName: r, action: n, clientMethod: i } = t, o = r ? n : i;
    if (e._extensions.isEmpty())
      return e._executeRequest(t);
    let s = e._extensions.getAllQueryCallbacks(r ?? "$none", o);
    return la(e, t, s);
  };
  var ca = function(e) {
    return (t) => {
      let r = { requests: t }, n = t[0].extensions.getAllBatchQueryCallbacks();
      return n.length ? pa(r, n, 0, e) : e(r);
    };
  };
  var pa = function(e, t, r, n) {
    if (r === t.length)
      return n(e);
    let i = e.customDataProxyFetch, o = e.requests[0].transaction;
    return t[r]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : undefined } : undefined }, __internalParams: e, query(s, a = e) {
      let l = a.customDataProxyFetch;
      return a.customDataProxyFetch = da(i, l), pa(a, t, r + 1, n);
    } });
  };
  var da = function(e = aa, t = aa) {
    return (r) => e(t(r));
  };
  var fa = function(e, t, r) {
    let n = Te(r);
    return !t.result || !(t.result.$allModels || t.result[n]) ? e : Jp({ ...e, ...ma(t.name, e, t.result.$allModels), ...ma(t.name, e, t.result[n]) });
  };
  var Jp = function(e) {
    let t = new be, r = (n, i) => t.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => r(o, i)) : [n]));
    return pt(e, (n) => ({ ...n, needs: r(n.name, new Set) }));
  };
  var ma = function(e, t, r) {
    return r ? pt(r, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Hp(t, o, i) })) : {};
  };
  var Hp = function(e, t, r) {
    let n = e?.[t]?.compute;
    return n ? (i) => r({ ...i, [t]: n(i) }) : r;
  };
  var ga = function(e, t) {
    if (!t)
      return e;
    let r = { ...e };
    for (let n of Object.values(t))
      if (e[n.name])
        for (let i of n.needs)
          r[i] = true;
    return r;
  };
  var xa = function({ postinstall: e, ciName: t, clientVersion: r }) {
    if (ya("checkPlatformCaching:postinstall", e), ya("checkPlatformCaching:ciName", t), e === true && t && t in ha) {
      let n = `Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ha[t]}-build`;
      throw console.error(n), new F(n, r);
    }
  };
  var ba = function(e, t) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t[0]]: { url: e.datasourceUrl } } : {} : {};
  };
  var Zt = function({ error: e, user_facing_error: t }, r) {
    return t.error_code ? new U(t.message, { code: t.error_code, clientVersion: r, meta: t.meta, batchRequestIdx: t.batch_request_idx }) : new K(e, { clientVersion: r, batchRequestIdx: t.batch_request_idx });
  };
  var un = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `Add "${t}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Wp(e)}`;
  };
  var Wp = function(e) {
    let { generator: t, generatorBinaryTargets: r, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...r, i];
    return si({ ...t, binaryTargets: o });
  };
  var je = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${t}".`;
  };
  var Be = function(e) {
    let { searchedLocations: t } = e;
    return `The following locations have been searched:
${[...new Set(t)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var Ea = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `${je(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t}".
${un(e)}

${Be(e)}`;
  };
  var cn = function(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  };
  var wa = function(e) {
    let { queryEngineName: t } = e;
    return `${je(e)}

This is likely caused by a bundler that has not copied "${t}" next to the resulting bundle.
Ensure that "${t}" has been copied next to the bundle or in "${e.expectedLocation}".

${cn("engine-not-found-bundler-investigation")}

${Be(e)}`;
  };
  var Pa = function(e) {
    let { runtimeBinaryTarget: t, generatorBinaryTargets: r } = e, n = r.find((i) => i.native);
    return `${je(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${t}".
${un(e)}

${Be(e)}`;
  };
  var va = function(e) {
    let { queryEngineName: t } = e;
    return `${je(e)}

This is likely caused by tooling that has not copied "${t}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t}" has been copied to "${e.expectedLocation}".

${cn("engine-not-found-tooling-investigation")}

${Be(e)}`;
  };
  async function Ca(e, t) {
    let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? t.prismaPath;
    if (r !== undefined)
      return r;
    let { enginePath: n, searchedLocations: i } = await Zp(e, t);
    if (zp("enginePath", n), n !== undefined && e === "binary" && ti(n), n !== undefined)
      return t.prismaPath = n;
    let o = await ut(), s = t.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = import.meta.file.match(Yp()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: t.generator, runtimeBinaryTarget: o, queryEngineName: Aa(e, o), expectedLocation: Xt.default.relative(process.cwd(), t.dirname) }, p;
    throw a && l ? p = Pa(c) : l ? p = Ea(c) : u ? p = wa(c) : p = va(c), new F(p, t.clientVersion);
  }
  async function Zp(engineType, config) {
    let binaryTarget = await ut(), searchedLocations = [], dirname = import.meta.dir, searchLocations = [config.dirname, Xt.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, Xt.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    import.meta.file.includes("resolveEnginePath") && searchLocations.push(rs());
    for (let e of searchLocations) {
      let t = Aa(engineType, binaryTarget), r = Xt.default.join(e, t);
      if (searchedLocations.push(e), Ta.default.existsSync(r))
        return { enginePath: r, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  var Aa = function(e, t) {
    return e === "library" ? jn(t, "fs") : `query-engine-${t}${t === "windows" ? ".exe" : ""}`;
  };
  var pn = function(e, t) {
    return { batch: e, transaction: t?.kind === "batch" ? { isolationLevel: t.options.isolationLevel } : undefined };
  };
  var Ra = function(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t) => `${t[0]}5`) : "";
  };
  var Ma = function(e) {
    return e.split(`
`).map((t) => t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  };
  var Ia = function({ title: e, user: t = "prisma", repo: r = "prisma", template: n = "bug_report.md", body: i }) {
    return (0, Sa.default)({ user: t, repo: r, template: n, title: e, body: i });
  };
  var ka = function({ version: e, platform: t, title: r, description: n, engineVersion: i, database: o, query: s }) {
    let a = bo(6000 - (s?.length ?? 0)), l = Ma((0, Ii.default)(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, Ii.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? Ra(s) : ""}
\`\`\`
`), p = Ia({ title: r, body: c });
    return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${te(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  };
  var dn = function({ inlineDatasources: e, overrideDatasources: t, env: r, clientVersion: n }) {
    let i, o = Object.keys(e)[0], s = e[o]?.url, a = t[o]?.url;
    if (o === undefined ? i = undefined : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = r[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new F(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
    if (i === undefined)
      throw new F("error: Missing URL environment variable, value, or override.", n);
    return i;
  };
  var M = function(e, t) {
    return { ...e, isRetryable: t };
  };
  async function td(e) {
    let t;
    try {
      t = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r = JSON.parse(t);
      if (typeof r == "string")
        switch (r) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r };
          default:
            return { type: "UnknownTextError", body: r };
        }
      if (typeof r == "object" && r !== null) {
        if ("is_panic" in r && "message" in r && "error_code" in r)
          return { type: "QueryEngineError", body: r };
        if ("EngineNotStarted" in r || "InteractiveTransactionMisrouted" in r || "InvalidRequestError" in r) {
          let n = Object.values(r)[0].reason;
          return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
        }
      }
      return { type: "UnknownJsonError", body: r };
    } catch {
      return t === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t };
    }
  }
  async function cr(e, t) {
    if (e.ok)
      return;
    let r = { clientVersion: t, response: e }, n = await td(e);
    if (n.type === "QueryEngineError")
      throw new U(n.body.message, { code: n.body.error_code, clientVersion: t });
    if (n.type === "DataProxyError") {
      if (n.body === "InternalDataProxyError")
        throw new Ct(r, "Internal Data Proxy error");
      if ("EngineNotStarted" in n.body) {
        if (n.body.EngineNotStarted.reason === "SchemaMissing")
          return new Xe(r);
        if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new nr(r);
        if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
          throw new rr(r, i, o);
        }
        if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new F(i, t, o);
        }
        if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
          let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new tr(r, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new or(r, i[n.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n.body)
        throw new sr(r, n.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new lr(r, At(_i, n));
    if (e.status === 404)
      return new ar(r, At(Oi, n));
    if (e.status === 429)
      throw new ur(r, At(Ni, n));
    if (e.status === 504)
      throw new ir(r, At(Fi, n));
    if (e.status >= 500)
      throw new Ct(r, At(Di, n));
    if (e.status >= 400)
      throw new er(r, At(ki, n));
  }
  var At = function(e, t) {
    return t.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t)}`;
  };
  var Fa = function(e) {
    let t = Math.pow(2, e) * 50, r = Math.ceil(Math.random() * t) - Math.ceil(t / 2), n = t + r;
    return new Promise((i) => setTimeout(() => i(n), n));
  };
  var Oa = function(e) {
    if (!!e.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics")))
      throw new F("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  };
  async function et(e, t, r = (n) => n) {
    let n = t.clientVersion;
    try {
      return typeof fetch == "function" ? await r(fetch)(e, t) : await r(Li)(e, t);
    } catch (i) {
      console.log(e);
      let o = i.message ?? "Unknown error";
      throw new pr(o, { clientVersion: n });
    }
  }
  var nd = function(e) {
    return { ...e.headers, "Content-Type": "application/json" };
  };
  var id = function(e) {
    return { method: e.method, headers: nd(e) };
  };
  var od = function(e, t) {
    return { text: () => Promise.resolve(Buffer.concat(e).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e).toString())), ok: t.statusCode >= 200 && t.statusCode <= 299, status: t.statusCode, url: t.url, headers: new $i(t.headers) };
  };
  async function Li(e, t = {}) {
    let r = sd("https"), n = id(t), i = [], { origin: o } = new URL(e);
    return new Promise((s, a) => {
      let l = r.request(e, n, (u) => {
        let { statusCode: c, headers: { location: p } } = u;
        c >= 301 && c <= 399 && p && (p.startsWith("http") === false ? s(Li(`${o}${p}`, t)) : s(Li(p, t))), u.on("data", (d) => i.push(d)), u.on("end", () => s(od(i, u))), u.on("error", a);
      });
      l.on("error", a), l.end(t.body ?? "");
    });
  }
  async function ld(e, t) {
    let r = Da["@prisma/engines-version"], n = t.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
      return n;
    let [i, o] = n?.split("-") ?? [];
    if (o === undefined && ad.test(i))
      return i;
    if (o !== undefined || n === "0.0.0" || n === "in-memory") {
      if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s] = r.split("-") ?? [], [a, l, u] = s.split("."), c = ud(`<=${a}.${l}.${u}`), p = await et(c, { clientVersion: n });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let d = await p.text();
      _a("length of body fetched from unpkg.com", d.length);
      let f;
      try {
        f = JSON.parse(d);
      } catch (y) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), y;
      }
      return f.version;
    }
    throw new Ze("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
  }
  async function Na(e, t) {
    let r = await ld(e, t);
    return _a("version", r), r;
  }
  var ud = function(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  };
  var $a = function(e) {
    if (e?.kind === "itx")
      return e.options.id;
  };
  var cd = function() {
    let e = globalThis;
    return e[ji] === undefined && (e[ji] = {}), e[ji];
  };
  var pd = function(e) {
    let t = cd();
    if (t[e] !== undefined)
      return t[e];
    let r = qa.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Bi.default.constants.dlopen.RTLD_LAZY | Bi.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, r, i), t[e] = n.exports, n.exports;
  };
  var md = function(e) {
    return e.item_type === "query" && "query" in e;
  };
  var fd = function(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  };
  var Ua = function(e, t) {
    let r;
    try {
      r = dn({ inlineDatasources: t.inlineDatasources, overrideDatasources: t.overrideDatasources, env: { ...t.env, ...process.env }, clientVersion: t.clientVersion });
    } catch {
    }
    e.noEngine !== true && r?.startsWith("prisma://") && qt("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n = Zn(t.generator);
    if (r?.startsWith("prisma://") || e.noEngine)
      return new dr(t);
    if (n === "library")
      return new mr(t);
    throw "binary", new X("Invalid client engine type, please use `library` or `binary`", { clientVersion: t.clientVersion });
  };
  var gn = function({ generator: e }) {
    return e?.previewFeatures ?? [];
  };
  var Ja = function(e, t) {
    let r = Ha(e), n = gd(r), i = hd(n);
    i ? yn(i, t) : t.addErrorMessage(() => "Unknown error");
  };
  var Ha = function(e) {
    return e.errors.flatMap((t) => t.kind === "Union" ? Ha(t) : [t]);
  };
  var gd = function(e) {
    let t = new Map, r = [];
    for (let n of e) {
      if (n.kind !== "InvalidArgumentType") {
        r.push(n);
        continue;
      }
      let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = t.get(i);
      o ? t.set(i, { ...n, argument: { ...n.argument, typeNames: yd(o.argument.typeNames, n.argument.typeNames) } }) : t.set(i, n);
    }
    return r.push(...t.values()), r;
  };
  var yd = function(e, t) {
    return [...new Set(e.concat(t))];
  };
  var hd = function(e) {
    return pi(e, (t, r) => {
      let n = Qa(t), i = Qa(r);
      return n !== i ? n - i : Ga(t) - Ga(r);
    });
  };
  var Qa = function(e) {
    let t = 0;
    return Array.isArray(e.selectionPath) && (t += e.selectionPath.length), Array.isArray(e.argumentPath) && (t += e.argumentPath.length), t;
  };
  var Ga = function(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  };
  var yn = function(e, t) {
    switch (e.kind) {
      case "IncludeAndSelect":
        xd(e, t);
        break;
      case "IncludeOnScalar":
        bd(e, t);
        break;
      case "EmptySelection":
        Ed(e, t);
        break;
      case "UnknownSelectionField":
        wd(e, t);
        break;
      case "UnknownArgument":
        Pd(e, t);
        break;
      case "UnknownInputField":
        vd(e, t);
        break;
      case "RequiredArgumentMissing":
        Td(e, t);
        break;
      case "InvalidArgumentType":
        Cd(e, t);
        break;
      case "InvalidArgumentValue":
        Ad(e, t);
        break;
      case "ValueTooLarge":
        Rd(e, t);
        break;
      case "SomeFieldsMissing":
        Md(e, t);
        break;
      case "TooManyFieldsGiven":
        Sd(e, t);
        break;
      case "Union":
        Ja(e, t);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  };
  var xd = function(e, t) {
    let r = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    r && r instanceof Q && (r.getField("include")?.markAsError(), r.getField("select")?.markAsError()), t.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green("`include`")} or ${n.green("`select`")}, but ${n.red("not both")} at the same time.`);
  };
  var bd = function(e, t) {
    let [r, n] = xn(e.selectionPath), i = e.outputType, o = t.arguments.getDeepSelectionParent(r)?.value;
    if (o && (o.getField(n)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o.addSuggestion(new Se(s.name, "true"));
    t.addErrorMessage((s) => {
      let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
      return i ? a += ` on model ${s.bold(i.name)}. ${fr(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
    });
  };
  var Ed = function(e, t) {
    let r = e.outputType, n = t.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
    n && (n.removeAllFields(), Za(n, r)), t.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${fr(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`);
  };
  var wd = function(e, t) {
    let [r, n] = xn(e.selectionPath), i = t.arguments.getDeepSelectionParent(r);
    i && (i.value.getField(n)?.markAsError(), Za(i.value, e.outputType)), t.addErrorMessage((o) => {
      let s = [`Unknown field ${o.red(`\`${n}\``)}`];
      return i && s.push(`for ${o.bold(i.kind)} statement`), s.push(`on model ${o.bold(`\`${e.outputType.name}\``)}.`), s.push(fr(o)), s.join(" ");
    });
  };
  var Pd = function(e, t) {
    let r = e.argumentPath[0], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && (n.getField(r)?.markAsError(), Id(n, e.arguments)), t.addErrorMessage((i) => za(i, r, e.arguments.map((o) => o.name)));
  };
  var vd = function(e, t) {
    let [r, n] = xn(e.argumentPath), i = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (i instanceof Q) {
      i.getDeepField(e.argumentPath)?.markAsError();
      let o = i.getDeepFieldValue(r);
      o instanceof Q && Xa(o, e.inputType);
    }
    t.addErrorMessage((o) => za(o, n, e.inputType.fields.map((s) => s.name)));
  };
  var za = function(e, t, r) {
    let n = [`Unknown argument \`${e.red(t)}\`.`], i = Fd(t, r);
    return i && n.push(`Did you mean \`${e.green(i)}\`?`), r.length > 0 && n.push(fr(e)), n.join(" ");
  };
  var Td = function(e, t) {
    let r;
    t.addErrorMessage((l) => r?.value instanceof G && r.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
    let n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (!(n instanceof Q))
      return;
    let [i, o] = xn(e.argumentPath), s = new hn, a = n.getDeepFieldValue(i);
    if (a instanceof Q)
      if (r = a.getField(o), r && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l of e.inputTypes[0].fields)
          s.addField(l.name, l.typeNames.join(" | "));
        a.addSuggestion(new Se(o, s).makeRequired());
      } else {
        let l = e.inputTypes.map(Ya).join(" | ");
        a.addSuggestion(new Se(o, l).makeRequired());
      }
  };
  var Ya = function(e) {
    return e.kind === "list" ? `${Ya(e.elementType)}[]` : e.name;
  };
  var Cd = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
      let o = bn("or", e.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
    });
  };
  var Ad = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
      let o = [`Invalid value for argument \`${i.bold(r)}\``];
      if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
        let s = bn("or", e.argument.typeNames.map((a) => i.green(a)));
        o.push(` Expected ${s}.`);
      }
      return o.join("");
    });
  };
  var Rd = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i;
    if (n instanceof Q) {
      let s = n.getDeepField(e.argumentPath)?.value;
      s?.markAsError(), s instanceof G && (i = s.text);
    }
    t.addErrorMessage((o) => {
      let s = ["Unable to fit value"];
      return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``), s.join(" ");
    });
  };
  var Md = function(e, t) {
    let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (n instanceof Q) {
      let i = n.getDeepFieldValue(e.argumentPath);
      i instanceof Q && Xa(i, e.inputType);
    }
    t.addErrorMessage((i) => {
      let o = [`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${bn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(fr(i)), o.join(" ");
    });
  };
  var Sd = function(e, t) {
    let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i = [];
    if (n instanceof Q) {
      let o = n.getDeepFieldValue(e.argumentPath);
      o instanceof Q && (o.markAsError(), i = Object.keys(o.getFields()));
    }
    t.addErrorMessage((o) => {
      let s = [`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${bn("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
    });
  };
  var Za = function(e, t) {
    for (let r of t.fields)
      e.hasField(r.name) || e.addSuggestion(new Se(r.name, "true"));
  };
  var Id = function(e, t) {
    for (let r of t)
      e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var Xa = function(e, t) {
    if (t.kind === "object")
      for (let r of t.fields)
        e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var xn = function(e) {
    let t = [...e], r = t.pop();
    if (!r)
      throw new Error("unexpected empty path");
    return [t, r];
  };
  var fr = function({ green: e, enabled: t }) {
    return "Available options are " + (t ? `listed in ${e("green")}` : "marked with ?") + ".";
  };
  var bn = function(e, t) {
    if (t.length === 1)
      return t[0];
    let r = [...t], n = r.pop();
    return `${r.join(", ")} ${e} ${n}`;
  };
  var Fd = function(e, t) {
    let r = 1 / 0, n;
    for (let i of t) {
      let o = (0, Wa.default)(e, i);
      o > kd || o < r && (r = o, n = i);
    }
    return n;
  };
  var En = function({ args: e, errors: t, errorFormat: r, callsite: n, originalMethod: i, clientVersion: o }) {
    let s = en(e);
    for (let p of t)
      yn(p, s);
    let a = r === "pretty" ? Ds : Zr, l = s.renderAllMessages(a), u = new mt(0, { colors: a }).write(s).toString(), c = Pt({ message: l, callsite: n, originalMethod: i, showColors: r === "pretty", callArguments: u });
    throw new X(c, { clientVersion: o });
  };
  var el = function({ modelName: e, action: t, args: r, runtimeDataModel: n, extensions: i, callsite: o, clientMethod: s, errorFormat: a, clientVersion: l }) {
    let u = new Ki({ runtimeDataModel: n, modelName: e, action: t, rootArgs: r, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l });
    return { modelName: e, action: Od[t], query: Qi(r, u) };
  };
  var Qi = function({ select: e, include: t, ...r } = {}, n) {
    return { arguments: rl(r, n), selection: Dd(e, t, n) };
  };
  var Dd = function(e, t, r) {
    return e && t && r.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r.getSelectionPath() }), e ? Ld(e, r) : _d(r, t);
  };
  var _d = function(e, t) {
    let r = {};
    return e.model && !e.isRawAction() && (r.$composites = true, r.$scalars = true), t && Nd(r, t, e), r;
  };
  var Nd = function(e, t, r) {
    for (let [n, i] of Object.entries(t)) {
      let o = r.findField(n);
      o && o?.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n), outputType: r.getOutputTypeDescription() }), i === true ? e[n] = true : typeof i == "object" && (e[n] = Qi(i, r.nestSelection(n)));
    }
  };
  var Ld = function(e, t) {
    let r = {}, n = t.getComputedFields(), i = ga(e, n);
    for (let [o, s] of Object.entries(i)) {
      let a = t.findField(o);
      n?.[o] && !a || (s === true ? r[o] = true : typeof s == "object" && (r[o] = Qi(s, t.nestSelection(o))));
    }
    return r;
  };
  var tl = function(e, t) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (ft(e)) {
      if (Br(e))
        return { $type: "DateTime", value: e.toISOString() };
      t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (xt(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return $d(e, t);
    if (ArrayBuffer.isView(e))
      return { $type: "Bytes", value: Buffer.from(e).toString("base64") };
    if (qd(e))
      return e.values;
    if (ht(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof xe) {
      if (e !== $r.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (Vd(e))
      return e.toJSON();
    if (typeof e == "object")
      return rl(e, t);
    t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  };
  var rl = function(e, t) {
    if (e.$type)
      return { $type: "Json", value: JSON.stringify(e) };
    let r = {};
    for (let n in e) {
      let i = e[n];
      i !== undefined && (r[n] = tl(i, t.nestArgument(n)));
    }
    return r;
  };
  var $d = function(e, t) {
    let r = [];
    for (let n = 0;n < e.length; n++) {
      let i = t.nestArgument(String(n)), o = e[n];
      o === undefined && t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r.push(tl(o, i));
    }
    return r;
  };
  var qd = function(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  };
  var Vd = function(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  };
  var gr = function(e) {
    try {
      return ol(e, "fast");
    } catch {
      return ol(e, "slow");
    }
  };
  var ol = function(e, t) {
    return JSON.stringify(e.map((r) => jd(r, t)));
  };
  var jd = function(e, t) {
    return typeof e == "bigint" ? { prisma__type: "bigint", prisma__value: e.toString() } : ft(e) ? { prisma__type: "date", prisma__value: e.toJSON() } : Pe.isDecimal(e) ? { prisma__type: "decimal", prisma__value: e.toJSON() } : Buffer.isBuffer(e) ? { prisma__type: "bytes", prisma__value: e.toString("base64") } : Bd(e) || ArrayBuffer.isView(e) ? { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") } : typeof e == "object" && t === "slow" ? al(e) : e;
  };
  var Bd = function(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  };
  var al = function(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(sl);
    let t = {};
    for (let r of Object.keys(e))
      t[r] = sl(e[r]);
    return t;
  };
  var sl = function(e) {
    return typeof e == "bigint" ? e.toString() : al(e);
  };
  var Gi = function(e, t, r, n) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && r.length > 0 && Ud.exec(t))
      throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  };
  var Hi = function(e) {
    return function(r) {
      let n, i = (o = e) => {
        try {
          return o === undefined || o?.kind === "itx" ? n ?? (n = pl(r(o))) : pl(r(o));
        } catch (s) {
          return Promise.reject(s);
        }
      };
      return { then(o, s) {
        return i().then(o, s);
      }, catch(o) {
        return i().catch(o);
      }, finally(o) {
        return i().finally(o);
      }, requestTransaction(o) {
        let s = i(o);
        return s.requestTransaction ? s.requestTransaction(o) : s;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  };
  var pl = function(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  };
  var ml = function(e) {
    return e.includes("tracing") ? new Wi : dl;
  };
  var fl = function(e, t = () => {
  }) {
    let r, n = new Promise((i) => r = i);
    return { then(i) {
      return --e === 0 && r(t()), i?.(n);
    } };
  };
  var gl = function(e) {
    return typeof e == "string" ? e : e.reduce((t, r) => {
      let n = typeof r == "string" ? r : r.level;
      return n === "query" ? t : t && (r === "info" || t === "info") ? "info" : n;
    }, undefined);
  };
  var Pn = function(e) {
    return typeof e.batchRequestIdx == "number";
  };
  var vn = function(e) {
    return e === null ? e : Array.isArray(e) ? e.map(vn) : typeof e == "object" ? Qd(e) ? Gd(e) : pt(e, vn) : e;
  };
  var Qd = function(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  };
  var Gd = function({ $type: e, value: t }) {
    switch (e) {
      case "BigInt":
        return BigInt(t);
      case "Bytes":
        return Buffer.from(t, "base64");
      case "DateTime":
        return new Date(t);
      case "Decimal":
        return new Pe(t);
      case "Json":
        return JSON.parse(t);
      default:
        He(t, "Unknown tagged value");
    }
  };
  var yl = function(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let t = [];
    return e.modelName && t.push(e.modelName), e.query.arguments && t.push(Yi(e.query.arguments)), t.push(Yi(e.query.selection)), t.join("");
  };
  var Yi = function(e) {
    return `(${Object.keys(e).sort().map((r) => {
      let n = e[r];
      return typeof n == "object" && n !== null ? `(${r} ${Yi(n)})` : r;
    }).join(" ")})`;
  };
  var Zi = function(e) {
    return Jd[e];
  };
  var Wd = function(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: xl(e) };
      He(e, "Unknown transaction kind");
    }
  };
  var xl = function(e) {
    return { id: e.id, payload: e.payload };
  };
  var zd = function(e, t) {
    return Pn(e) && t?.kind === "batch" && e.batchRequestIdx !== t.index;
  };
  var Yd = function(e) {
    return e.code === "P2009" || e.code === "P2012";
  };
  var bl = function(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map(bl) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...t] = e.selectionPath;
      return { ...e, selectionPath: t };
    }
    return e;
  };
  var Pl = function(e) {
    return e.map((t) => {
      let r = {};
      for (let n of Object.keys(t))
        r[n] = vl(t[n]);
      return r;
    });
  };
  var vl = function({ prisma__type: e, prisma__value: t }) {
    switch (e) {
      case "bigint":
        return BigInt(t);
      case "bytes":
        return Buffer.from(t, "base64");
      case "decimal":
        return new Pe(t);
      case "datetime":
      case "date":
        return new Date(t);
      case "time":
        return new Date(`1970-01-01T${t}Z`);
      case "array":
        return t.map(vl);
      default:
        return t;
    }
  };
  var Ml = function(e, t) {
    for (let [r, n] of Object.entries(e)) {
      if (!Tl.includes(r)) {
        let i = Rt(r, Tl);
        throw new q(`Unknown property ${r} provided to PrismaClient constructor.${i}`);
      }
      Xd[r](n, t);
    }
    if (e.datasourceUrl && e.datasources)
      throw new q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  };
  var Rt = function(e, t) {
    if (t.length === 0 || typeof e != "string")
      return "";
    let r = em(e, t);
    return r ? ` Did you mean "${r}"?` : "";
  };
  var em = function(e, t) {
    if (t.length === 0)
      return null;
    let r = t.map((i) => ({ value: i, distance: (0, Rl.default)(e, i) }));
    r.sort((i, o) => i.distance < o.distance ? -1 : 1);
    let n = r[0];
    return n.distance < 3 ? n.value : null;
  };
  var Sl = function(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((t, r) => {
      let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
        o || (s++, s === e.length && (o = true, i ? r(i) : t(n)));
      }, l = (u) => {
        o || (o = true, r(u));
      };
      for (let u = 0;u < e.length; u++)
        e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!Pn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
    });
  };
  var Dl = function(e) {

    class t {
      constructor(n) {
        this._middlewares = new wn;
        this._createPrismaPromise = Hi();
        this.$extends = ra;
        xa(e), n && Ml(n, e);
        let i = n?.adapter ? fs(n.adapter) : undefined, o = new Fl.EventEmitter().on("error", () => {
        });
        this._extensions = ln.empty(), this._previewFeatures = gn(e), this._clientVersion = e.clientVersion ?? wl, this._activeProvider = e.activeProvider, this._tracingHelper = ml(this._previewFeatures);
        let s = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && yr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && yr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, a = !i && _t(s, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
          c && D.enable("prisma:client");
          let p = yr.default.resolve(e.dirname, e.relativePath);
          Ol.default.existsSync(p) || (p = e.dirname), Ue("dirname", e.dirname), Ue("relativePath", e.relativePath), Ue("cwd", p);
          let d = u.engine || {};
          if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c, allowTriggerPanic: d.allowTriggerPanic, datamodelPath: yr.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: d.binaryPath ?? undefined, engineEndpoint: d.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && gl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a?.parsed ?? {}, flags: [], clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: ba(l, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: o, isBundled: e.isBundled, adapter: i }, Ue("clientVersion", e.clientVersion), this._engine = Ua(e, this._engineConfig), this._requestHandler = new Cn(this, o), l.log)
            for (let f of l.log) {
              let y = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              y && this.$on(y, (g) => {
                $t.log(`${$t.tags[y] ?? ""}`, g.message || g.query);
              });
            }
          this._metrics = new dt(this._engine);
        } catch (l) {
          throw l.clientVersion = this._clientVersion, l;
        }
        return this._appliedParent = zt(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n) {
        this._middlewares.use(n);
      }
      $on(n, i) {
        n === "beforeExit" ? this._engine.on("beforeExit", i) : this._engine.on(n, (o) => {
          let s = o.fields;
          return i(n === "query" ? { timestamp: o.timestamp, query: s?.query ?? o.query, params: s?.params ?? o.params, duration: s?.duration_ms ?? o.duration, target: o.target } : { timestamp: o.timestamp, message: s?.message ?? o.message, target: o.target });
        });
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        } finally {
          Eo();
        }
      }
      $executeRawInternal(n, i, o, s) {
        let a = this._activeProvider, l = this._engineConfig.adapter?.flavour;
        return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Ji({ clientMethod: i, activeProvider: a, activeProviderFlavour: l }), callsite: Ve(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined) {
            let [s, a] = Il(n, i);
            return Gi(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
          }
          throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => (Gi(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
      }
      $runCommandRaw(n) {
        if (e.activeProvider !== "mongodb")
          throw new X(`The ${e.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: nl, callsite: Ve(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n, i, o, s) {
        let a = this._activeProvider, l = this._engineConfig.adapter?.flavour;
        return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Ji({ clientMethod: i, activeProvider: a, activeProviderFlavour: l }), callsite: Ve(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(Pl);
      }
      $queryRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined)
            return this.$queryRawInternal(o, "$queryRaw", ...Il(n, i));
          throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
      }
      _transactionWithArray({ promises: n, options: i }) {
        let o = nm.nextId(), s = fl(n.length), a = n.map((l, u) => {
          if (l?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c = i?.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
          return l.requestTransaction?.(p) ?? l;
        });
        return Sl(a);
      }
      async _transactionWithCallback({ callback: n, options: i }) {
        let o = { traceparent: this._tracingHelper.getTraceParent() }, s = await this._engine.transaction("start", o, i), a;
        try {
          let l = { kind: "itx", ...s };
          a = await n(this._createItxClient(l)), await this._engine.transaction("commit", o, s);
        } catch (l) {
          throw await this._engine.transaction("rollback", o, s).catch(() => {
          }), l;
        }
        return a;
      }
      _createItxClient(n) {
        return zt(Ee(on(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Hi(n)), re(rm, () => n.id), Gt(zi)]));
      }
      $transaction(n, i) {
        let o;
        typeof n == "function" ? o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o);
      }
      _request(n) {
        n.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n.middlewareArgsMapper ?? tm, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = -1, l = async (u) => {
          let c = this._middlewares.get(++a);
          if (c)
            return this._tracingHelper.runInChildSpan(s.middleware, (P) => c(u, (T) => (P?.end(), l(T))));
          let { runInTransaction: p, args: d, ...f } = u, y = { ...n, ...f };
          d && (y.args = i.middlewareArgsToRequestArgs(d)), n.transaction !== undefined && p === false && delete y.transaction;
          let g = await ua(this, y);
          return y.model ? oa({ result: g, modelName: y.model, args: y.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : g;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new kl.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
      }
      async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
        try {
          n = u ? u(n) : n;
          let y = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(y, () => el({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return D.enabled("prisma:client") && (Ue("Prisma Client call:"), Ue(`prisma.${i}(${$s(n)})`), Ue("Generated request:"), Ue(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (y) {
          throw y.clientVersion = this._clientVersion, y;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new X("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n) {
        return !!this._engineConfig.previewFeatures?.includes(n);
      }
    }
    return t;
  };
  var Il = function(e, t) {
    return im(e) ? [new oe(e, t), ul] : [e, cl];
  };
  var im = function(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  };
  var _l = function(e) {
    return new Proxy(e, { get(t, r) {
      if (r in t)
        return t[r];
      if (!om.has(r))
        throw new TypeError(`Invalid enum value: ${String(r)}`);
    } });
  };
  var Nl = function(e) {
    _t(e, { conflictCheck: "warn" });
  };
  var Ll = Object.create;
  var Mt = Object.defineProperty;
  var $l = Object.getOwnPropertyDescriptor;
  var ql = Object.getOwnPropertyNames;
  var Vl = Object.getPrototypeOf;
  var jl = Object.prototype.hasOwnProperty;
  var Bl = (e, t, r) => (t in e) ? Mt(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
  var V = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
  var St = (e, t) => {
    for (var r in t)
      Mt(e, r, { get: t[r], enumerable: true });
  };
  var Xi = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of ql(t))
        !jl.call(e, i) && i !== r && Mt(e, i, { get: () => t[i], enumerable: !(n = $l(t, i)) || n.enumerable });
    return e;
  };
  var S = (e, t, r) => (r = e != null ? Ll(Vl(e)) : {}, Xi(t || !e || !e.__esModule ? Mt(r, "default", { value: e, enumerable: true }) : r, e));
  var Ul = (e) => Xi(Mt({}, "__esModule", { value: true }), e);
  var eo = (e, t, r) => (Bl(e, typeof t != "symbol" ? t + "" : t, r), r);
  var co = V((xm, uo) => {
    var rt = 1000, nt = rt * 60, it = nt * 60, Qe = it * 24, Kl = Qe * 7, Ql = Qe * 365.25;
    uo.exports = function(e, t) {
      t = t || {};
      var r = typeof e;
      if (r === "string" && e.length > 0)
        return Gl(e);
      if (r === "number" && isFinite(e))
        return t.long ? Hl(e) : Jl(e);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
    };
    function Gl(e) {
      if (e = String(e), !(e.length > 100)) {
        var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
        if (t) {
          var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
          switch (n) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return r * Ql;
            case "weeks":
            case "week":
            case "w":
              return r * Kl;
            case "days":
            case "day":
            case "d":
              return r * Qe;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return r * it;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return r * nt;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return r * rt;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return r;
            default:
              return;
          }
        }
      }
    }
    function Jl(e) {
      var t = Math.abs(e);
      return t >= Qe ? Math.round(e / Qe) + "d" : t >= it ? Math.round(e / it) + "h" : t >= nt ? Math.round(e / nt) + "m" : t >= rt ? Math.round(e / rt) + "s" : e + "ms";
    }
    function Hl(e) {
      var t = Math.abs(e);
      return t >= Qe ? br(e, t, Qe, "day") : t >= it ? br(e, t, it, "hour") : t >= nt ? br(e, t, nt, "minute") : t >= rt ? br(e, t, rt, "second") : e + " ms";
    }
    function br(e, t, r, n) {
      var i = t >= r * 1.5;
      return Math.round(e / r) + " " + n + (i ? "s" : "");
    }
  });
  var kn = V((bm, po) => {
    function Wl(e) {
      r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = i, r.enabled = s, r.humanize = co(), r.destroy = u, Object.keys(e).forEach((c) => {
        r[c] = e[c];
      }), r.names = [], r.skips = [], r.formatters = {};
      function t(c) {
        let p = 0;
        for (let d = 0;d < c.length; d++)
          p = (p << 5) - p + c.charCodeAt(d), p |= 0;
        return r.colors[Math.abs(p) % r.colors.length];
      }
      r.selectColor = t;
      function r(c) {
        let p, d = null, f, y;
        function g(...P) {
          if (!g.enabled)
            return;
          let T = g, C = Number(new Date), x = C - (p || C);
          T.diff = x, T.prev = p, T.curr = C, p = C, P[0] = r.coerce(P[0]), typeof P[0] != "string" && P.unshift("%O");
          let R = 0;
          P[0] = P[0].replace(/%([a-zA-Z%])/g, (J, Ke) => {
            if (J === "%%")
              return "%";
            R++;
            let $ = r.formatters[Ke];
            if (typeof $ == "function") {
              let z = P[R];
              J = $.call(T, z), P.splice(R, 1), R--;
            }
            return J;
          }), r.formatArgs.call(T, P), (T.log || r.log).apply(T, P);
        }
        return g.namespace = c, g.useColors = r.useColors(), g.color = r.selectColor(c), g.extend = n, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: true, configurable: false, get: () => d !== null ? d : (f !== r.namespaces && (f = r.namespaces, y = r.enabled(c)), y), set: (P) => {
          d = P;
        } }), typeof r.init == "function" && r.init(g), g;
      }
      function n(c, p) {
        let d = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
        return d.log = this.log, d;
      }
      function i(c) {
        r.save(c), r.namespaces = c, r.names = [], r.skips = [];
        let p, d = (typeof c == "string" ? c : "").split(/[\s,]+/), f = d.length;
        for (p = 0;p < f; p++)
          d[p] && (c = d[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
      }
      function o() {
        let c = [...r.names.map(a), ...r.skips.map(a).map((p) => "-" + p)].join(",");
        return r.enable(""), c;
      }
      function s(c) {
        if (c[c.length - 1] === "*")
          return true;
        let p, d;
        for (p = 0, d = r.skips.length;p < d; p++)
          if (r.skips[p].test(c))
            return false;
        for (p = 0, d = r.names.length;p < d; p++)
          if (r.names[p].test(c))
            return true;
        return false;
      }
      function a(c) {
        return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function l(c) {
        return c instanceof Error ? c.stack || c.message : c;
      }
      function u() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return r.enable(r.load()), r;
    }
    po.exports = Wl;
  });
  var mo = V((le, Er) => {
    le.formatArgs = Yl;
    le.save = Zl;
    le.load = Xl;
    le.useColors = zl;
    le.storage = eu();
    le.destroy = (() => {
      let e = false;
      return () => {
        e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    le.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function zl() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function Yl(e) {
      if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Er.exports.humanize(this.diff), !this.useColors)
        return;
      let t = "color: " + this.color;
      e.splice(1, 0, t, "color: inherit");
      let r = 0, n = 0;
      e[0].replace(/%[a-zA-Z%]/g, (i) => {
        i !== "%%" && (r++, i === "%c" && (n = r));
      }), e.splice(n, 0, t);
    }
    le.log = console.debug || console.log || (() => {
    });
    function Zl(e) {
      try {
        e ? le.storage.setItem("debug", e) : le.storage.removeItem("debug");
      } catch {
      }
    }
    function Xl() {
      let e;
      try {
        e = le.storage.getItem("debug");
      } catch {
      }
      return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
    }
    function eu() {
      try {
        return localStorage;
      } catch {
      }
    }
    Er.exports = kn()(le);
    var { formatters: tu } = Er.exports;
    tu.j = function(e) {
      try {
        return JSON.stringify(e);
      } catch (t) {
        return "[UnexpectedJSONParseError]: " + t.message;
      }
    };
  });
  var Fn = V((Em, fo) => {
    fo.exports = (e, t = process.argv) => {
      let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
      return n !== -1 && (i === -1 || n < i);
    };
  });
  var _n = V((wm, yo) => {
    var ru = import.meta.require("os"), go = import.meta.require("tty"), de = Fn(), { env: B } = process, ke;
    de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? ke = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (ke = 1);
    "FORCE_COLOR" in B && (B.FORCE_COLOR === "true" ? ke = 1 : B.FORCE_COLOR === "false" ? ke = 0 : ke = B.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(B.FORCE_COLOR, 10), 3));
    function On(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function Dn(e, t) {
      if (ke === 0)
        return 0;
      if (de("color=16m") || de("color=full") || de("color=truecolor"))
        return 3;
      if (de("color=256"))
        return 2;
      if (e && !t && ke === undefined)
        return 0;
      let r = ke || 0;
      if (B.TERM === "dumb")
        return r;
      if (process.platform === "win32") {
        let n = ru.release().split(".");
        return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in B)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => (n in B)) || B.CI_NAME === "codeship" ? 1 : r;
      if ("TEAMCITY_VERSION" in B)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(B.TEAMCITY_VERSION) ? 1 : 0;
      if (B.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in B) {
        let n = parseInt((B.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (B.TERM_PROGRAM) {
          case "iTerm.app":
            return n >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(B.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(B.TERM) || ("COLORTERM" in B) ? 1 : r;
    }
    function nu(e) {
      let t = Dn(e, e && e.isTTY);
      return On(t);
    }
    yo.exports = { supportsColor: nu, stdout: On(Dn(true, go.isatty(1))), stderr: On(Dn(true, go.isatty(2))) };
  });
  var xo = V((H, Pr) => {
    var iu = import.meta.require("tty"), wr = import.meta.require("util");
    H.init = pu;
    H.log = lu;
    H.formatArgs = su;
    H.save = uu;
    H.load = cu;
    H.useColors = ou;
    H.destroy = wr.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    H.colors = [6, 2, 3, 4, 5, 1];
    try {
      let e = _n();
      e && (e.stderr || e).level >= 2 && (H.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    H.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
      let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o) => o.toUpperCase()), n = process.env[t];
      return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), e[r] = n, e;
    }, {});
    function ou() {
      return "colors" in H.inspectOpts ? !!H.inspectOpts.colors : iu.isatty(process.stderr.fd);
    }
    function su(e) {
      let { namespace: t, useColors: r } = this;
      if (r) {
        let n = this.color, i = "\x1B[3" + (n < 8 ? n : "8;5;" + n), o = `  ${i};1m${t} \x1B[0m`;
        e[0] = o + e[0].split(`
`).join(`
` + o), e.push(i + "m+" + Pr.exports.humanize(this.diff) + "\x1B[0m");
      } else
        e[0] = au() + t + " " + e[0];
    }
    function au() {
      return H.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }
    function lu(...e) {
      return process.stderr.write(wr.format(...e) + `
`);
    }
    function uu(e) {
      e ? process.env.DEBUG = e : delete process.env.DEBUG;
    }
    function cu() {
      return process.env.DEBUG;
    }
    function pu(e) {
      e.inspectOpts = {};
      let t = Object.keys(H.inspectOpts);
      for (let r = 0;r < t.length; r++)
        e.inspectOpts[t[r]] = H.inspectOpts[t[r]];
    }
    Pr.exports = kn()(H);
    var { formatters: ho } = Pr.exports;
    ho.o = function(e) {
      return this.inspectOpts.colors = this.useColors, wr.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
    };
    ho.O = function(e) {
      return this.inspectOpts.colors = this.useColors, wr.inspect(e, this.inspectOpts);
    };
  });
  var Ln = V((Pm, Nn) => {
    typeof process > "u" || process.type === "renderer" || false || process.__nwjs ? Nn.exports = mo() : Nn.exports = xo();
  });
  var So = V((ef, Un) => {
    var A = Un.exports;
    Un.exports.default = A;
    var I = "\x1B[", kt = "\x1B]", at = "\x07", Rr = ";", Mo = false;
    A.cursorTo = (e, t) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t != "number" ? I + (e + 1) + "G" : I + (t + 1) + ";" + (e + 1) + "H";
    };
    A.cursorMove = (e, t) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      let r = "";
      return e < 0 ? r += I + -e + "D" : e > 0 && (r += I + e + "C"), t < 0 ? r += I + -t + "A" : t > 0 && (r += I + t + "B"), r;
    };
    A.cursorUp = (e = 1) => I + e + "A";
    A.cursorDown = (e = 1) => I + e + "B";
    A.cursorForward = (e = 1) => I + e + "C";
    A.cursorBackward = (e = 1) => I + e + "D";
    A.cursorLeft = I + "G";
    A.cursorSavePosition = Mo ? "\x1B7" : I + "s";
    A.cursorRestorePosition = Mo ? "\x1B8" : I + "u";
    A.cursorGetPosition = I + "6n";
    A.cursorNextLine = I + "E";
    A.cursorPrevLine = I + "F";
    A.cursorHide = I + "?25l";
    A.cursorShow = I + "?25h";
    A.eraseLines = (e) => {
      let t = "";
      for (let r = 0;r < e; r++)
        t += A.eraseLine + (r < e - 1 ? A.cursorUp() : "");
      return e && (t += A.cursorLeft), t;
    };
    A.eraseEndLine = I + "K";
    A.eraseStartLine = I + "1K";
    A.eraseLine = I + "2K";
    A.eraseDown = I + "J";
    A.eraseUp = I + "1J";
    A.eraseScreen = I + "2J";
    A.scrollUp = I + "S";
    A.scrollDown = I + "T";
    A.clearScreen = "\x1Bc";
    A.clearTerminal = process.platform === "win32" ? `${A.eraseScreen}${I}0f` : `${A.eraseScreen}${I}3J${I}H`;
    A.beep = at;
    A.link = (e, t) => [kt, "8", Rr, Rr, t, at, e, kt, "8", Rr, Rr, at].join("");
    A.image = (e, t = {}) => {
      let r = `${kt}1337;File=inline=1`;
      return t.width && (r += `;width=${t.width}`), t.height && (r += `;height=${t.height}`), t.preserveAspectRatio === false && (r += ";preserveAspectRatio=0"), r + ":" + e.toString("base64") + at;
    };
    A.iTerm = { setCwd: (e = process.cwd()) => `${kt}50;CurrentDir=${e}${at}`, annotation: (e, t = {}) => {
      let r = `${kt}1337;`, n = typeof t.x < "u", i = typeof t.y < "u";
      if ((n || i) && !(n && i && typeof t.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replace(/\|/g, ""), r += t.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t.length > 0 ? r += (n ? [e, t.length, t.x, t.y] : [t.length, e]).join("|") : r += e, r + at;
    } };
  });
  var Fo = V((tf, ko) => {
    var hu = _n(), lt = Fn();
    function Io(e) {
      if (/^\d{3,4}$/.test(e)) {
        let r = /(\d{1,2})(\d{2})/.exec(e);
        return { major: 0, minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) };
      }
      let t = (e || "").split(".").map((r) => parseInt(r, 10));
      return { major: t[0], minor: t[1], patch: t[2] };
    }
    function Kn(e) {
      let { env: t } = process;
      if ("FORCE_HYPERLINK" in t)
        return !(t.FORCE_HYPERLINK.length > 0 && parseInt(t.FORCE_HYPERLINK, 10) === 0);
      if (lt("no-hyperlink") || lt("no-hyperlinks") || lt("hyperlink=false") || lt("hyperlink=never"))
        return false;
      if (lt("hyperlink=true") || lt("hyperlink=always") || "NETLIFY" in t)
        return true;
      if (!hu.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || "CI" in t || "TEAMCITY_VERSION" in t)
        return false;
      if ("TERM_PROGRAM" in t) {
        let r = Io(t.TERM_PROGRAM_VERSION);
        switch (t.TERM_PROGRAM) {
          case "iTerm.app":
            return r.major === 3 ? r.minor >= 1 : r.major > 3;
          case "WezTerm":
            return r.major >= 20200620;
          case "vscode":
            return r.major > 1 || r.major === 1 && r.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t) {
        if (t.VTE_VERSION === "0.50.0")
          return false;
        let r = Io(t.VTE_VERSION);
        return r.major > 0 || r.minor >= 50;
      }
      return false;
    }
    ko.exports = { supportsHyperlink: Kn, stdout: Kn(process.stdout), stderr: Kn(process.stderr) };
  });
  var Do = V((rf, Ft) => {
    var xu = So(), Qn = Fo(), Oo = (e, t, { target: r = "stdout", ...n } = {}) => Qn[r] ? xu.link(e, t) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, t) : `${e} (\u200B${t}\u200B)`;
    Ft.exports = (e, t, r = {}) => Oo(e, t, r);
    Ft.exports.stderr = (e, t, r = {}) => Oo(e, t, { target: "stderr", ...r });
    Ft.exports.isSupported = Qn.stdout;
    Ft.exports.stderr.isSupported = Qn.stderr;
  });
  var Ko = V((wf, Ou) => {
    Ou.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Go = V((Pf, Fr) => {
    var Du = import.meta.require("fs"), Qo = import.meta.require("path"), _u = import.meta.require("os"), Nu = Ko(), Lu = Nu.version, $u = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function qu(e) {
      let t = {}, r = e.toString();
      r = r.replace(/\r\n?/mg, `
`);
      let n;
      for (;(n = $u.exec(r)) != null; ) {
        let i = n[1], o = n[2] || "";
        o = o.trim();
        let s = o[0];
        o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), t[i] = o;
      }
      return t;
    }
    function Wn(e) {
      console.log(`[dotenv@${Lu}][DEBUG] ${e}`);
    }
    function Vu(e) {
      return e[0] === "~" ? Qo.join(_u.homedir(), e.slice(1)) : e;
    }
    function ju(e) {
      let t = Qo.resolve(process.cwd(), ".env"), r = "utf8", n = !!(e && e.debug), i = !!(e && e.override);
      e && (e.path != null && (t = Vu(e.path)), e.encoding != null && (r = e.encoding));
      try {
        let o = kr.parse(Du.readFileSync(t, { encoding: r }));
        return Object.keys(o).forEach(function(s) {
          Object.prototype.hasOwnProperty.call(process.env, s) ? (i === true && (process.env[s] = o[s]), n && Wn(i === true ? `"${s}" is already defined in \`process.env\` and WAS overwritten` : `"${s}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s] = o[s];
        }), { parsed: o };
      } catch (o) {
        return n && Wn(`Failed to load ${t} ${o.message}`), { error: o };
      }
    }
    var kr = { config: ju, parse: qu };
    Fr.exports.config = kr.config;
    Fr.exports.parse = kr.parse;
    Fr.exports = kr;
  });
  var Zo = V((Sf, Yo) => {
    Yo.exports = (e) => {
      let t = e.match(/^[ \t]*(?=\S)/gm);
      return t ? t.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
    };
  });
  var es = V((If, Xo) => {
    var Qu = Zo();
    Xo.exports = (e) => {
      let t = Qu(e);
      if (t === 0)
        return e;
      let r = new RegExp(`^[ \\t]{${t}}`, "gm");
      return e.replace(r, "");
    };
  });
  var ts = V((kf, Gu) => {
    Gu.exports = { name: "@prisma/engines-version", version: "5.4.1-2.ac9d7041ed77bcc8a8dbd2ab6616b39013829574", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.18.4", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var Xn = V((Dr) => {
    Object.defineProperty(Dr, "__esModule", { value: true });
    Dr.enginesVersion = undefined;
    Dr.enginesVersion = ts().prisma.enginesVersion;
  });
  var ii = V((Kf, is) => {
    is.exports = (e, t = 1, r) => {
      if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof t != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);
      if (typeof r.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
      if (t === 0)
        return e;
      let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n, r.indent.repeat(t));
    };
  });
  var ls = V((Jf, as) => {
    as.exports = ({ onlyFirst: e = false } = {}) => {
      let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t, e ? undefined : "g");
    };
  });
  var li = V((Hf, us) => {
    var rc = ls();
    us.exports = (e) => typeof e == "string" ? e.replace(rc(), "") : e;
  });
  var cs = V((Yf, Nr) => {
    Nr.exports = (e = {}) => {
      let t;
      if (e.repoUrl)
        t = e.repoUrl;
      else if (e.user && e.repo)
        t = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r = new URL(`${t}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n) {
        let o = e[i];
        if (o !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o = o.join(",");
          }
          r.searchParams.set(i, o);
        }
      }
      return r.toString();
    };
    Nr.exports.default = Nr.exports;
  });
  var Ui = V((CP, Ka) => {
    Ka.exports = function() {
      function e(t, r, n, i, o) {
        return t < r || n < r ? t > n ? n + 1 : t + 1 : i === o ? r : r + 1;
      }
      return function(t, r) {
        if (t === r)
          return 0;
        if (t.length > r.length) {
          var n = t;
          t = r, r = n;
        }
        for (var i = t.length, o = r.length;i > 0 && t.charCodeAt(i - 1) === r.charCodeAt(o - 1); )
          i--, o--;
        for (var s = 0;s < i && t.charCodeAt(s) === r.charCodeAt(s); )
          s++;
        if (i -= s, o -= s, i === 0 || o < 3)
          return o;
        var a = 0, l, u, c, p, d, f, y, g, P, T, C, x, R = [];
        for (l = 0;l < i; l++)
          R.push(l + 1), R.push(t.charCodeAt(s + l));
        for (var ce = R.length - 1;a < o - 3; )
          for (P = r.charCodeAt(s + (u = a)), T = r.charCodeAt(s + (c = a + 1)), C = r.charCodeAt(s + (p = a + 2)), x = r.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0;l < ce; l += 2)
            y = R[l], g = R[l + 1], u = e(y, u, c, P, g), c = e(u, c, p, T, g), p = e(c, p, d, C, g), f = e(p, d, f, x, g), R[l] = f, d = p, p = c, c = u, u = y;
        for (;a < o; )
          for (P = r.charCodeAt(s + (u = a)), f = ++a, l = 0;l < ce; l += 2)
            y = R[l], R[l] = f = e(y, u, f, P, R[l + 1]), u = y;
        return f;
      };
    }();
  });
  var sm = {};
  St(sm, { DMMF: () => pe, DMMFClass: () => xr, Debug: () => $n, Decimal: () => Pe, Extensions: () => Rn, MetricsClient: () => dt, NotFoundError: () => Re, ObjectEnumValue: () => xe, PrismaClientInitializationError: () => F, PrismaClientKnownRequestError: () => U, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => K, PrismaClientValidationError: () => X, Public: () => Mn, Sql: () => oe, Types: () => Sn, defineDmmfProperty: () => ms, empty: () => ys, getPrismaClient: () => Dl, itxClientDenyList: () => zi, join: () => gs, makeStrictEnum: () => _l, objectEnumNames: () => ic, objectEnumValues: () => $r, raw: () => gi, sqltag: () => yi, warnEnvConflicts: () => Nl, warnOnce: () => qt });
  module.exports = Ul(sm);
  var Rn = {};
  St(Rn, { defineExtension: () => to, getExtensionContext: () => ro });
  var Mn = {};
  St(Mn, { validator: () => no });
  var Sn = {};
  St(Sn, { Extensions: () => io, Public: () => oo, Result: () => so, Utils: () => ao });
  var io = {};
  var oo = {};
  var so = {};
  var ao = {};
  var Ie = (e, t) => {
    let r = {};
    for (let n of e) {
      let i = n[t];
      r[i] = n;
    }
    return r;
  };
  var xr = class {
    constructor(t) {
      this.document = t;
      this.compositeNames = new Set(this.datamodel.types.map((r) => r.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
    }
    get datamodel() {
      return this.document.datamodel;
    }
    get mappings() {
      return this.document.mappings;
    }
    get schema() {
      return this.document.schema;
    }
    get inputObjectTypes() {
      return this.schema.inputObjectTypes;
    }
    get outputObjectTypes() {
      return this.schema.outputObjectTypes;
    }
    isComposite(t) {
      return this.compositeNames.has(t);
    }
    getOtherOperationNames() {
      return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
    }
    hasEnumInNamespace(t, r) {
      return this.schema.enumTypes[r]?.find((n) => n.name === t) !== undefined;
    }
    resolveInputObjectType(t) {
      return this.inputTypesByName.get(In(t.type, t.namespace));
    }
    resolveOutputObjectType(t) {
      if (t.location === "outputObjectTypes")
        return this.outputObjectTypes[t.namespace ?? "prisma"].find((r) => r.name === t.type);
    }
    buildModelMap() {
      return Ie(this.datamodel.models, "name");
    }
    buildTypeMap() {
      return Ie(this.datamodel.types, "name");
    }
    buildTypeModelMap() {
      return { ...this.buildTypeMap(), ...this.buildModelMap() };
    }
    buildMappingsMap() {
      return Ie(this.mappings.modelOperations, "model");
    }
    buildMergedOutputTypeMap() {
      return { model: Ie(this.schema.outputObjectTypes.model, "name"), prisma: Ie(this.schema.outputObjectTypes.prisma, "name") };
    }
    buildRootFieldMap() {
      return { ...Ie(this.outputTypeMap.prisma.Query.fields, "name"), ...Ie(this.outputTypeMap.prisma.Mutation.fields, "name") };
    }
    buildInputTypesMap() {
      let t = new Map;
      for (let r of this.inputObjectTypes.prisma)
        t.set(In(r.name, "prisma"), r);
      if (!this.inputObjectTypes.model)
        return t;
      for (let r of this.inputObjectTypes.model)
        t.set(In(r.name, "model"), r);
      return t;
    }
  };
  var pe;
  ((t) => {
    let e;
    ((x) => (x.findUnique = "findUnique", x.findUniqueOrThrow = "findUniqueOrThrow", x.findFirst = "findFirst", x.findFirstOrThrow = "findFirstOrThrow", x.findMany = "findMany", x.create = "create", x.createMany = "createMany", x.update = "update", x.updateMany = "updateMany", x.upsert = "upsert", x.delete = "delete", x.deleteMany = "deleteMany", x.groupBy = "groupBy", x.count = "count", x.aggregate = "aggregate", x.findRaw = "findRaw", x.aggregateRaw = "aggregateRaw"))(e = t.ModelAction || (t.ModelAction = {}));
  })(pe || (pe = {}));
  var vr = S(Ln());
  var du = 100;
  var It = [];
  typeof process < "u" && typeof process.stderr?.write != "function" && (vr.default.log = console.debug ?? console.log);
  var $n = Object.assign(mu, vr.default);
  var D = $n;
  var qn;
  var wo;
  var Po;
  var vo;
  var To = true;
  typeof process < "u" && ({ FORCE_COLOR: qn, NODE_DISABLE_COLORS: wo, NO_COLOR: Po, TERM: vo } = process.env || {}, To = process.stdout && process.stdout.isTTY);
  var fu = { enabled: !wo && Po == null && vo !== "dumb" && (qn != null && qn !== "0" || To) };
  var Tm = _(0, 0);
  var ne = _(1, 22);
  var Fe = _(2, 22);
  var Cm = _(3, 23);
  var te = _(4, 24);
  var Am = _(7, 27);
  var Rm = _(8, 28);
  var Mm = _(9, 29);
  var Sm = _(30, 39);
  var me = _(31, 39);
  var Ge = _(32, 39);
  var he = _(33, 39);
  var ot = _(34, 39);
  var Im = _(35, 39);
  var Oe = _(36, 39);
  var km = _(37, 39);
  var Tr = _(90, 39);
  var Fm = _(90, 39);
  var Om = _(40, 49);
  var Dm = _(41, 49);
  var _m = _(42, 49);
  var Nm = _(43, 49);
  var Lm = _(44, 49);
  var $m = _(45, 49);
  var qm = _(46, 49);
  var Vm = _(47, 49);
  var Co = S(import.meta.require("fs"));
  var Cr = "libquery_engine";
  var $o = S(import.meta.require("child_process"));
  var Gn = S(import.meta.require("fs/promises"));
  var Sr = S(import.meta.require("os"));
  var Ar = Symbol("@ts-pattern/matcher");
  var Ao = "@ts-pattern/anonymous-select-key";
  var Ro = function(e) {
    return !!(e && typeof e == "object");
  };
  var Bn = function(e) {
    return e && !!e[Ar];
  };
  var gu = function e(t, r, n) {
    if (Ro(t)) {
      if (Bn(t)) {
        var i = t[Ar]().match(r), o = i.matched, s = i.selections;
        return o && s && Object.keys(s).forEach(function(l) {
          return n(l, s[l]);
        }), o;
      }
      if (!Ro(r))
        return false;
      if (Array.isArray(t))
        return !!Array.isArray(r) && t.length === r.length && t.every(function(l, u) {
          return e(l, r[u], n);
        });
      if (t instanceof Map)
        return r instanceof Map && Array.from(t.keys()).every(function(l) {
          return e(t.get(l), r.get(l), n);
        });
      if (t instanceof Set) {
        if (!(r instanceof Set))
          return false;
        if (t.size === 0)
          return r.size === 0;
        if (t.size === 1) {
          var a = Array.from(t.values())[0];
          return Bn(a) ? Array.from(r.values()).every(function(l) {
            return e(a, l, n);
          }) : r.has(a);
        }
        return Array.from(t.values()).every(function(l) {
          return r.has(l);
        });
      }
      return Object.keys(t).every(function(l) {
        var u, c = t[l];
        return ((l in r) || Bn(u = c) && u[Ar]().matcherType === "optional") && e(c, r[l], n);
      });
    }
    return Object.is(r, t);
  };
  var Gm = Je(function(e) {
    return true;
  });
  var Jm = Je(function(e) {
    return typeof e == "string";
  });
  var Hm = Je(function(e) {
    return typeof e == "number";
  });
  var Wm = Je(function(e) {
    return typeof e == "boolean";
  });
  var zm = Je(function(e) {
    return typeof e == "bigint";
  });
  var Ym = Je(function(e) {
    return typeof e == "symbol";
  });
  var Zm = Je(function(e) {
    return e == null;
  });
  var yu = function() {
    function e(r, n) {
      this.value = undefined, this.cases = undefined, this.value = r, this.cases = n;
    }
    var t = e.prototype;
    return t.with = function() {
      var r = [].slice.call(arguments), n = r[r.length - 1], i = [r[0]], o = [];
      return r.length === 3 && typeof r[1] == "function" ? (i.push(r[0]), o.push(r[1])) : r.length > 2 && i.push.apply(i, r.slice(1, r.length - 1)), new e(this.value, this.cases.concat([{ match: function(s) {
        var a = {}, l = !!(i.some(function(u) {
          return gu(u, s, function(c, p) {
            a[c] = p;
          });
        }) && o.every(function(u) {
          return u(s);
        }));
        return { matched: l, value: l && Object.keys(a).length ? Ao in a ? a[Ao] : a : s };
      }, handler: n }]));
    }, t.when = function(r, n) {
      return new e(this.value, this.cases.concat([{ match: function(i) {
        return { matched: !!r(i), value: i };
      }, handler: n }]));
    }, t.otherwise = function(r) {
      return new e(this.value, this.cases.concat([{ match: function(n) {
        return { matched: true, value: n };
      }, handler: r }])).run();
    }, t.exhaustive = function() {
      return this.run();
    }, t.run = function() {
      for (var r = this.value, n = undefined, i = 0;i < this.cases.length; i++) {
        var o = this.cases[i], s = o.match(this.value);
        if (s.matched) {
          r = s.value, n = o.handler;
          break;
        }
      }
      if (!n) {
        var a;
        try {
          a = JSON.stringify(this.value);
        } catch {
          a = this.value;
        }
        throw new Error("Pattern matching error: no pattern matches value " + a);
      }
      return n(r, this.value);
    }, e;
  }();
  var qo = import.meta.require("util");
  var _o = S(Do());
  var bu = { warn: he("prisma:warn") };
  var Eu = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var wu = (0, qo.promisify)($o.default.exec);
  var ie = D("prisma:get-platform");
  var Pu = ["1.0.x", "1.1.x", "3.0.x"];
  var Mr = {};
  var Hn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "openbsd", "netbsd", "arm"];
  var Yn = S(Go());
  var Or = S(import.meta.require("fs"));
  var ct = S(import.meta.require("path"));
  var zn = D("prisma:tryLoadEnv");
  var zo = "library";
  var Ju = S(Xn());
  var N = S(import.meta.require("path"));
  var Hu = S(Xn());
  var Df = D("prisma:engines");
  N.default.join(import.meta.dir, "../query-engine-darwin");
  N.default.join(import.meta.dir, "../query-engine-darwin-arm64");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-1.0.x");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-1.1.x");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-3.0.x");
  N.default.join(import.meta.dir, "../query-engine-linux-static-x64");
  N.default.join(import.meta.dir, "../query-engine-linux-static-arm64");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-1.0.x");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-1.1.x");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-3.0.x");
  N.default.join(import.meta.dir, "../libquery_engine-darwin.dylib.node");
  N.default.join(import.meta.dir, "../libquery_engine-darwin-arm64.dylib.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-musl.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../query_engine-windows.dll.node");
  var ei = S(import.meta.require("fs"));
  var ns = D("chmodPlusX");
  var Nt = S(import.meta.require("path"));
  var os = S(ii());
  var oi = class {
    constructor(t) {
      this.config = t;
    }
    toString() {
      let { config: t } = this, r = t.provider.fromEnvVar ? `env("${t.provider.fromEnvVar}")` : t.provider.value, n = JSON.parse(JSON.stringify({ provider: r, binaryTargets: Wu(t.binaryTargets) }));
      return `generator ${t.name} {
${(0, os.default)(zu(n), 2)}
}`;
    }
  };
  var $t = {};
  St($t, { error: () => ec, info: () => Xu, log: () => Zu, query: () => tc, should: () => ss, tags: () => Lt, warn: () => ai });
  var Lt = { error: me("prisma:error"), warn: he("prisma:warn"), info: Oe("prisma:info"), query: ot("prisma:query") };
  var ss = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var ci = (e, t) => e.reduce((r, n) => (r[t(n)] = n, r), {});
  var ps = new Set;
  var qt = (e, t, ...r) => {
    ps.has(e) || (ps.add(e), ai(t, ...r));
  };
  var U = class extends Error {
    constructor(r, { code: n, clientVersion: i, meta: o, batchRequestIdx: s }) {
      super(r);
      this.name = "PrismaClientKnownRequestError", this.code = n, this.clientVersion = i, this.meta = o, Object.defineProperty(this, "batchRequestIdx", { value: s, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  E(U, "PrismaClientKnownRequestError");
  var Re = class extends U {
    constructor(t, r) {
      super(t, { code: "P2025", clientVersion: r }), this.name = "NotFoundError";
    }
  };
  E(Re, "NotFoundError");
  var F = class e extends Error {
    constructor(r, n, i) {
      super(r);
      this.name = "PrismaClientInitializationError", this.clientVersion = n, this.errorCode = i, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  E(F, "PrismaClientInitializationError");
  var ue = class extends Error {
    constructor(r, n) {
      super(r);
      this.name = "PrismaClientRustPanicError", this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  E(ue, "PrismaClientRustPanicError");
  var K = class extends Error {
    constructor(r, { clientVersion: n, batchRequestIdx: i }) {
      super(r);
      this.name = "PrismaClientUnknownRequestError", this.clientVersion = n, Object.defineProperty(this, "batchRequestIdx", { value: i, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  E(K, "PrismaClientUnknownRequestError");
  var X = class extends Error {
    constructor(r, { clientVersion: n }) {
      super(r);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  E(X, "PrismaClientValidationError");
  var dt = class {
    constructor(t) {
      this._engine = t;
    }
    prometheus(t) {
      return this._engine.metrics({ format: "prometheus", ...t });
    }
    json(t) {
      return this._engine.metrics({ format: "json", ...t });
    }
  };
  var ic = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
  var Lr = Symbol();
  var mi = new WeakMap;
  var xe = class {
    constructor(t) {
      t === Lr ? mi.set(this, `Prisma.${this._getName()}`) : mi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return mi.get(this);
    }
  };
  var jt = class extends xe {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var Bt = class extends jt {
  };
  fi(Bt, "DbNull");
  var Ut = class extends jt {
  };
  fi(Ut, "JsonNull");
  var Kt = class extends jt {
  };
  fi(Kt, "AnyNull");
  var $r = { classes: { DbNull: Bt, JsonNull: Ut, AnyNull: Kt }, instances: { DbNull: new Bt(Lr), JsonNull: new Ut(Lr), AnyNull: new Kt(Lr) } };
  var lc = S(Ln(), 1);
  var oc = class {
    constructor() {
      eo(this, "registeredErrors", []);
    }
    consumeError(e) {
      return this.registeredErrors[e];
    }
    registerNewError(e) {
      let t = 0;
      for (;this.registeredErrors[t] !== undefined; )
        t++;
      return this.registeredErrors[t] = { error: e }, t;
    }
  };
  var fs = (e) => {
    let t = new oc, r = De(t, e.startTransaction.bind(e));
    return { errorRegistry: t, queryRaw: De(t, e.queryRaw.bind(e)), executeRaw: De(t, e.executeRaw.bind(e)), flavour: e.flavour, startTransaction: async (...n) => (await r(...n)).map((o) => sc(t, o)), close: De(t, e.close.bind(e)) };
  };
  var sc = (e, t) => ({ flavour: t.flavour, options: t.options, queryRaw: De(e, t.queryRaw.bind(t)), executeRaw: De(e, t.executeRaw.bind(t)), commit: De(e, t.commit.bind(t)), rollback: De(e, t.rollback.bind(t)), dispose: ac(e, t.dispose.bind(t)) });
  var kl = import.meta.require("async_hooks");
  var Fl = import.meta.require("events");
  var Ol = S(import.meta.require("fs"));
  var yr = S(import.meta.require("path"));
  var oe = class e {
    constructor(t, r) {
      if (t.length - 1 !== r.length)
        throw t.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t.length} strings to have ${t.length - 1} values`);
      let n = r.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
      this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = t[0];
      let i = 0, o = 0;
      for (;i < r.length; ) {
        let s = r[i++], a = t[i];
        if (s instanceof e) {
          this.strings[o] += s.strings[0];
          let l = 0;
          for (;l < s.values.length; )
            this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
          this.strings[o] += a;
        } else
          this.values[o++] = s, this.strings[o] = a;
      }
    }
    get text() {
      let t = 1, r = this.strings[0];
      for (;t < this.strings.length; )
        r += `\$${t}${this.strings[t++]}`;
      return r;
    }
    get sql() {
      let t = 1, r = this.strings[0];
      for (;t < this.strings.length; )
        r += `?${this.strings[t++]}`;
      return r;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var ys = gi("");
  var be = class {
    constructor() {
      this._map = new Map;
    }
    get(t) {
      return this._map.get(t)?.value;
    }
    set(t, r) {
      this._map.set(t, { value: r });
    }
    getOrCreate(t, r) {
      let n = this._map.get(t);
      if (n)
        return n.value;
      let i = r();
      return this.set(t, i), i;
    }
  };
  var bs = import.meta.require("util");
  var Vr = { enumerable: true, configurable: true, writable: true };
  var hs = Symbol.for("nodejs.util.inspect.custom");
  var mt = class {
    constructor(t = 0, r) {
      this.context = r;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t;
    }
    write(t) {
      return typeof t == "string" ? this.currentLine += t : t.write(this), this;
    }
    writeJoined(t, r) {
      let n = r.length - 1;
      for (let i = 0;i < r.length; i++)
        this.write(r[i]), i !== n && this.write(t);
      return this;
    }
    writeLine(t) {
      return this.write(t).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t?.(), this;
    }
    withIndent(t) {
      return this.indent(), t(this), this.unindent(), this;
    }
    afterNextNewline(t) {
      return this.afterNextNewLineCallback = t, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t) {
      return this.marginSymbol = t, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t.slice(1) : t;
    }
  };
  var gt = 9000000000000000;
  var $e = 1e9;
  var hi = "0123456789abcdef";
  var Kr = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var Qr = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var xi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -gt, maxE: gt, crypto: false };
  var vs;
  var Me;
  var w = true;
  var Jr = "[DecimalError] ";
  var Le = Jr + "Invalid argument: ";
  var Ts = Jr + "Precision limit exceeded";
  var Cs = Jr + "crypto unavailable";
  var As = "[object Decimal]";
  var ee = Math.floor;
  var j = Math.pow;
  var cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var pc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var dc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Rs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var ge = 1e7;
  var b = 7;
  var mc = 9007199254740991;
  var fc = Kr.length - 1;
  var bi = Qr.length - 1;
  var m = { toStringTag: As };
  m.absoluteValue = m.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), h(e);
  };
  m.ceil = function() {
    return h(new this.constructor(this), this.e + 1, 2);
  };
  m.clampedTo = m.clamp = function(e, t) {
    var r, n = this, i = n.constructor;
    if (e = new i(e), t = new i(t), !e.s || !t.s)
      return new i(NaN);
    if (e.gt(t))
      throw Error(Le + t);
    return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
  };
  m.comparedTo = m.cmp = function(e) {
    var t, r, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
    if (!s || !a)
      return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
    if (!s[0] || !a[0])
      return s[0] ? l : a[0] ? -u : 0;
    if (l !== u)
      return l;
    if (o.e !== e.e)
      return o.e > e.e ^ l < 0 ? 1 : -1;
    for (n = s.length, i = a.length, t = 0, r = n < i ? n : i;t < r; ++t)
      if (s[t] !== a[t])
        return s[t] > a[t] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
  };
  m.cosine = m.cos = function() {
    var e, t, r = this, n = r.constructor;
    return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = gc(n, Fs(n, r)), n.precision = e, n.rounding = t, h(Me == 2 || Me == 3 ? r.neg() : r, e, t, true)) : new n(1) : new n(NaN);
  };
  m.cubeRoot = m.cbrt = function() {
    var e, t, r, n, i, o, s, a, l, u, c = this, p = c.constructor;
    if (!c.isFinite() || c.isZero())
      return new p(c);
    for (w = false, o = c.s * j(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (r = W(c.d), e = c.e, (o = (e - r.length + 1) % 3) && (r += o == 1 || o == -2 ? "0" : "00"), o = j(r, 1 / 3), e = ee((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? r = "5e" + e : (r = o.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new p(r), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3;; )
      if (a = n, l = a.times(a).times(a), u = l.plus(c), n = O(u.plus(c).times(a), u.plus(l), s + 2, 1), W(a.d).slice(0, s) === (r = W(n.d)).slice(0, s))
        if (r = r.slice(s - 3, s + 1), r == "9999" || !i && r == "4999") {
          if (!i && (h(a, e + 1, 0), a.times(a).times(a).eq(c))) {
            n = a;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (h(n, e + 1, 1), t = !n.times(n).times(n).eq(c));
          break;
        }
    return w = true, h(n, e, p.rounding, t);
  };
  m.decimalPlaces = m.dp = function() {
    var e, t = this.d, r = NaN;
    if (t) {
      if (e = t.length - 1, r = (e - ee(this.e / b)) * b, e = t[e], e)
        for (;e % 10 == 0; e /= 10)
          r--;
      r < 0 && (r = 0);
    }
    return r;
  };
  m.dividedBy = m.div = function(e) {
    return O(this, new this.constructor(e));
  };
  m.dividedToIntegerBy = m.divToInt = function(e) {
    var t = this, r = t.constructor;
    return h(O(t, new r(e), 0, 1, 1), r.precision, r.rounding);
  };
  m.equals = m.eq = function(e) {
    return this.cmp(e) === 0;
  };
  m.floor = function() {
    return h(new this.constructor(this), this.e + 1, 3);
  };
  m.greaterThan = m.gt = function(e) {
    return this.cmp(e) > 0;
  };
  m.greaterThanOrEqualTo = m.gte = function(e) {
    var t = this.cmp(e);
    return t == 1 || t === 0;
  };
  m.hyperbolicCosine = m.cosh = function() {
    var e, t, r, n, i, o = this, s = o.constructor, a = new s(1);
    if (!o.isFinite())
      return new s(o.s ? 1 / 0 : NaN);
    if (o.isZero())
      return a;
    r = s.precision, n = s.rounding, s.precision = r + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Wr(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), o = yt(s, 1, o.times(t), new s(1), true);
    for (var l, u = e, c = new s(8);u--; )
      l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
    return h(o, s.precision = r, s.rounding = n, true);
  };
  m.hyperbolicSine = m.sinh = function() {
    var e, t, r, n, i = this, o = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o(i);
    if (t = o.precision, r = o.rounding, o.precision = t + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
      i = yt(o, 2, i, i, true);
    else {
      e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Wr(5, e)), i = yt(o, 2, i, i, true);
      for (var s, a = new o(5), l = new o(16), u = new o(20);e--; )
        s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
    }
    return o.precision = t, o.rounding = r, h(i, t, r, true);
  };
  m.hyperbolicTangent = m.tanh = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, O(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
  };
  m.inverseCosine = m.acos = function() {
    var e, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, o = r.rounding;
    return n !== -1 ? n === 0 ? t.isNeg() ? fe(r, i, o) : new r(0) : new r(NaN) : t.isZero() ? fe(r, i + 4, o).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = fe(r, i + 4, o).times(0.5), r.precision = i, r.rounding = o, e.minus(t));
  };
  m.inverseHyperbolicCosine = m.acosh = function() {
    var e, t, r = this, n = r.constructor;
    return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, w = false, r = r.times(r).minus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln()) : new n(r);
  };
  m.inverseHyperbolicSine = m.asinh = function() {
    var e, t, r = this, n = r.constructor;
    return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, w = false, r = r.times(r).plus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln());
  };
  m.inverseHyperbolicTangent = m.atanh = function() {
    var e, t, r, n, i = this, o = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, t = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? h(new o(i), e, t, true) : (o.precision = r = n - i.e, i = O(i.plus(1), new o(1).minus(i), r + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = t, i.times(0.5))) : new o(NaN);
  };
  m.inverseSine = m.asin = function() {
    var e, t, r, n, i = this, o = i.constructor;
    return i.isZero() ? new o(i) : (t = i.abs().cmp(1), r = o.precision, n = o.rounding, t !== -1 ? t === 0 ? (e = fe(o, r + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = r + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = r, o.rounding = n, i.times(2)));
  };
  m.inverseTangent = m.atan = function() {
    var e, t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c(u);
      if (u.abs().eq(1) && p + 4 <= bi)
        return s = fe(c, p + 4, d).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c(NaN);
      if (p + 4 <= bi)
        return s = fe(c, p + 4, d).times(0.5), s.s = u.s, s;
    }
    for (c.precision = a = p + 10, c.rounding = 1, r = Math.min(28, a / b + 2 | 0), e = r;e; --e)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (w = false, t = Math.ceil(a / b), n = 1, l = u.times(u), s = new c(u), i = u;e !== -1; )
      if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[t] !== undefined)
        for (e = t;s.d[e] === o.d[e] && e--; )
          ;
    return r && (s = s.times(2 << r - 1)), w = true, h(s, c.precision = p, c.rounding = d, true);
  };
  m.isFinite = function() {
    return !!this.d;
  };
  m.isInteger = m.isInt = function() {
    return !!this.d && ee(this.e / b) > this.d.length - 2;
  };
  m.isNaN = function() {
    return !this.s;
  };
  m.isNegative = m.isNeg = function() {
    return this.s < 0;
  };
  m.isPositive = m.isPos = function() {
    return this.s > 0;
  };
  m.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m.lessThan = m.lt = function(e) {
    return this.cmp(e) < 0;
  };
  m.lessThanOrEqualTo = m.lte = function(e) {
    return this.cmp(e) < 1;
  };
  m.logarithm = m.log = function(e) {
    var t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
    if (e == null)
      e = new c(10), t = true;
    else {
      if (e = new c(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
        return new c(NaN);
      t = e.eq(10);
    }
    if (r = u.d, u.s < 0 || !r || !r[0] || u.eq(1))
      return new c(r && !r[0] ? -1 / 0 : u.s != 1 ? NaN : r ? 0 : 1 / 0);
    if (t)
      if (r.length > 1)
        o = true;
      else {
        for (i = r[0];i % 10 === 0; )
          i /= 10;
        o = i !== 1;
      }
    if (w = false, a = p + f, s = Ne(u, a), n = t ? Gr(c, a + 10) : Ne(e, a), l = O(s, n, a, 1), Jt(l.d, i = p, d))
      do
        if (a += 10, s = Ne(u, a), n = t ? Gr(c, a + 10) : Ne(e, a), l = O(s, n, a, 1), !o) {
          +W(l.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l = h(l, p + 1, 0));
          break;
        }
      while (Jt(l.d, i += 10, d));
    return w = true, h(l, p, d);
  };
  m.minus = m.sub = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.constructor;
    if (e = new y(e), !f.d || !e.d)
      return !f.s || !e.s ? e = new y(NaN) : f.d ? e.s = -e.s : e = new y(e.d || f.s !== e.s ? f : NaN), e;
    if (f.s != e.s)
      return e.s = -e.s, f.plus(e);
    if (u = f.d, d = e.d, a = y.precision, l = y.rounding, !u[0] || !d[0]) {
      if (d[0])
        e.s = -e.s;
      else if (u[0])
        e = new y(f);
      else
        return new y(l === 3 ? -0 : 0);
      return w ? h(e, a, l) : e;
    }
    if (r = ee(e.e / b), c = ee(f.e / b), u = u.slice(), o = c - r, o) {
      for (p = o < 0, p ? (t = u, o = -o, s = d.length) : (t = d, r = c, s = u.length), n = Math.max(Math.ceil(a / b), s) + 2, o > n && (o = n, t.length = 1), t.reverse(), n = o;n--; )
        t.push(0);
      t.reverse();
    } else {
      for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0;n < s; n++)
        if (u[n] != d[n]) {
          p = u[n] < d[n];
          break;
        }
      o = 0;
    }
    for (p && (t = u, u = d, d = t, e.s = -e.s), s = u.length, n = d.length - s;n > 0; --n)
      u[s++] = 0;
    for (n = d.length;n > o; ) {
      if (u[--n] < d[n]) {
        for (i = n;i && u[--i] === 0; )
          u[i] = ge - 1;
        --u[i], u[n] += ge;
      }
      u[n] -= d[n];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --r;
    return u[0] ? (e.d = u, e.e = Hr(u, r), w ? h(e, a, l) : e) : new y(l === 3 ? -0 : 0);
  };
  m.modulo = m.mod = function(e) {
    var t, r = this, n = r.constructor;
    return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? h(new n(r), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (t = O(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = O(r, e, 0, n.modulo, 1), t = t.times(e), w = true, r.minus(t));
  };
  m.naturalExponential = m.exp = function() {
    return Ei(this);
  };
  m.naturalLogarithm = m.ln = function() {
    return Ne(this);
  };
  m.negated = m.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, h(e);
  };
  m.plus = m.add = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
    if (e = new d(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0])
      return c[0] || (e = new d(p)), w ? h(e, a, l) : e;
    if (o = ee(p.e / b), n = ee(e.e / b), u = u.slice(), i = o - n, i) {
      for (i < 0 ? (r = u, i = -i, s = c.length) : (r = c, n = o, s = u.length), o = Math.ceil(a / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, r.length = 1), r.reverse();i--; )
        r.push(0);
      r.reverse();
    }
    for (s = u.length, i = c.length, s - i < 0 && (i = s, r = c, c = u, u = r), t = 0;i; )
      t = (u[--i] = u[i] + c[i] + t) / ge | 0, u[i] %= ge;
    for (t && (u.unshift(t), ++n), s = u.length;u[--s] == 0; )
      u.pop();
    return e.d = u, e.e = Hr(u, n), w ? h(e, a, l) : e;
  };
  m.precision = m.sd = function(e) {
    var t, r = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(Le + e);
    return r.d ? (t = Ms(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
  };
  m.round = function() {
    var e = this, t = e.constructor;
    return h(new t(e), e.e + 1, t.rounding);
  };
  m.sine = m.sin = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = hc(n, Fs(n, r)), n.precision = e, n.rounding = t, h(Me > 2 ? r.neg() : r, e, t, true)) : new n(NaN);
  };
  m.squareRoot = m.sqrt = function() {
    var e, t, r, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
    if (u !== 1 || !a || !a[0])
      return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
    for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (t = W(a), (t.length + l) % 2 == 0 && (t += "0"), u = Math.sqrt(t), l = ee((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? t = "5e" + l : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new c(t)) : n = new c(u.toString()), r = (l = c.precision) + 3;; )
      if (o = n, n = o.plus(O(s, o, r + 2, 1)).times(0.5), W(o.d).slice(0, r) === (t = W(n.d)).slice(0, r))
        if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
          if (!i && (h(o, l + 1, 0), o.times(o).eq(s))) {
            n = o;
            break;
          }
          r += 4, i = 1;
        } else {
          (!+t || !+t.slice(1) && t.charAt(0) == "5") && (h(n, l + 1, 1), e = !n.times(n).eq(s));
          break;
        }
    return w = true, h(n, l, c.rounding, e);
  };
  m.tangent = m.tan = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = O(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, h(Me == 2 || Me == 4 ? r.neg() : r, e, t, true)) : new n(NaN);
  };
  m.times = m.mul = function(e) {
    var t, r, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
    if (e.s *= c.s, !d || !d[0] || !f || !f[0])
      return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
    for (r = ee(c.e / b) + ee(e.e / b), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s;n--; )
      o.push(0);
    for (n = u;--n >= 0; ) {
      for (t = 0, i = l + n;i > n; )
        a = o[i] + f[n] * d[i - n - 1] + t, o[i--] = a % ge | 0, t = a / ge | 0;
      o[i] = (o[i] + t) % ge | 0;
    }
    for (;!o[--s]; )
      o.pop();
    return t ? ++r : o.shift(), e.d = o, e.e = Hr(o, r), w ? h(e, p.precision, p.rounding) : e;
  };
  m.toBinary = function(e, t) {
    return Pi(this, 2, e, t);
  };
  m.toDecimalPlaces = m.toDP = function(e, t) {
    var r = this, n = r.constructor;
    return r = new n(r), e === undefined ? r : (se(e, 0, $e), t === undefined ? t = n.rounding : se(t, 0, 8), h(r, e + r.e + 1, t));
  };
  m.toExponential = function(e, t) {
    var r, n = this, i = n.constructor;
    return e === undefined ? r = we(n, true) : (se(e, 0, $e), t === undefined ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e + 1, t), r = we(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
  };
  m.toFixed = function(e, t) {
    var r, n, i = this, o = i.constructor;
    return e === undefined ? r = we(i) : (se(e, 0, $e), t === undefined ? t = o.rounding : se(t, 0, 8), n = h(new o(i), e + i.e + 1, t), r = we(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
  };
  m.toFraction = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.d, g = f.constructor;
    if (!y)
      return new g(f);
    if (u = r = new g(1), n = l = new g(0), t = new g(n), o = t.e = Ms(y) - f.e - 1, s = o % b, t.d[0] = j(10, s < 0 ? b + s : s), e == null)
      e = o > 0 ? t : u;
    else {
      if (a = new g(e), !a.isInt() || a.lt(u))
        throw Error(Le + a);
      e = a.gt(t) ? o > 0 ? t : u : a;
    }
    for (w = false, a = new g(W(y)), c = g.precision, g.precision = o = y.length * b * 2;p = O(a, t, 0, 1, 1), i = r.plus(p.times(n)), i.cmp(e) != 1; )
      r = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = t, t = a.minus(p.times(i)), a = i;
    return i = O(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(u)), r = r.plus(i.times(n)), l.s = u.s = f.s, d = O(u, n, o, 1).minus(f).abs().cmp(O(l, r, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, r], g.precision = c, w = true, d;
  };
  m.toHexadecimal = m.toHex = function(e, t) {
    return Pi(this, 16, e, t);
  };
  m.toNearest = function(e, t) {
    var r = this, n = r.constructor;
    if (r = new n(r), e == null) {
      if (!r.d)
        return r;
      e = new n(1), t = n.rounding;
    } else {
      if (e = new n(e), t === undefined ? t = n.rounding : se(t, 0, 8), !r.d)
        return e.s ? r : e;
      if (!e.d)
        return e.s && (e.s = r.s), e;
    }
    return e.d[0] ? (w = false, r = O(r, e, 0, t, 1).times(e), w = true, h(r)) : (e.s = r.s, r = e), r;
  };
  m.toNumber = function() {
    return +this;
  };
  m.toOctal = function(e, t) {
    return Pi(this, 8, e, t);
  };
  m.toPower = m.pow = function(e) {
    var t, r, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
    if (!a.d || !e.d || !a.d[0] || !e.d[0])
      return new l(j(+a, u));
    if (a = new l(a), a.eq(1))
      return a;
    if (n = l.precision, o = l.rounding, e.eq(1))
      return h(a, n, o);
    if (t = ee(e.e / b), t >= e.d.length - 1 && (r = u < 0 ? -u : u) <= mc)
      return i = Ss(l, a, r, n), e.s < 0 ? new l(1).div(i) : h(i, n, o);
    if (s = a.s, s < 0) {
      if (t < e.d.length - 1)
        return new l(NaN);
      if (e.d[t] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
        return a.s = s, a;
    }
    return r = j(+a, u), t = r == 0 || !isFinite(r) ? ee(u * (Math.log("0." + W(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = Ei(e.times(Ne(a, n + r)), n), i.d && (i = h(i, n + 5, 1), Jt(i.d, n, o) && (t = n + 10, i = h(Ei(e.times(Ne(a, t + r)), t), t + 5, 1), +W(i.d).slice(n + 1, n + 15) + 1 == 100000000000000 && (i = h(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, h(i, n, o));
  };
  m.toPrecision = function(e, t) {
    var r, n = this, i = n.constructor;
    return e === undefined ? r = we(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (se(e, 1, $e), t === undefined ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e, t), r = we(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
  };
  m.toSignificantDigits = m.toSD = function(e, t) {
    var r = this, n = r.constructor;
    return e === undefined ? (e = n.precision, t = n.rounding) : (se(e, 1, $e), t === undefined ? t = n.rounding : se(t, 0, 8)), h(new n(r), e, t);
  };
  m.toString = function() {
    var e = this, t = e.constructor, r = we(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + r : r;
  };
  m.truncated = m.trunc = function() {
    return h(new this.constructor(this), this.e + 1, 1);
  };
  m.valueOf = m.toJSON = function() {
    var e = this, t = e.constructor, r = we(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
    return e.isNeg() ? "-" + r : r;
  };
  var O = function() {
    function e(n, i, o) {
      var s, a = 0, l = n.length;
      for (n = n.slice();l--; )
        s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
      return a && n.unshift(a), n;
    }
    function t(n, i, o, s) {
      var a, l;
      if (o != s)
        l = o > s ? 1 : -1;
      else
        for (a = l = 0;a < o; a++)
          if (n[a] != i[a]) {
            l = n[a] > i[a] ? 1 : -1;
            break;
          }
      return l;
    }
    function r(n, i, o, s) {
      for (var a = 0;o--; )
        n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
      for (;!n[0] && n.length > 1; )
        n.shift();
    }
    return function(n, i, o, s, a, l) {
      var u, c, p, d, f, y, g, P, T, C, x, R, ce, J, Ke, $, z, Ae, Y, tt, hr = n.constructor, An = n.s == i.s ? 1 : -1, Z = n.d, k = i.d;
      if (!Z || !Z[0] || !k || !k[0])
        return new hr(!n.s || !i.s || (Z ? k && Z[0] == k[0] : !k) ? NaN : Z && Z[0] == 0 || !k ? An * 0 : An / 0);
      for (l ? (f = 1, c = n.e - i.e) : (l = ge, f = b, c = ee(n.e / f) - ee(i.e / f)), Y = k.length, z = Z.length, T = new hr(An), C = T.d = [], p = 0;k[p] == (Z[p] || 0); p++)
        ;
      if (k[p] > (Z[p] || 0) && c--, o == null ? (J = o = hr.precision, s = hr.rounding) : a ? J = o + (n.e - i.e) + 1 : J = o, J < 0)
        C.push(1), y = true;
      else {
        if (J = J / f + 2 | 0, p = 0, Y == 1) {
          for (d = 0, k = k[0], J++;(p < z || d) && J--; p++)
            Ke = d * l + (Z[p] || 0), C[p] = Ke / k | 0, d = Ke % k | 0;
          y = d || p < z;
        } else {
          for (d = l / (k[0] + 1) | 0, d > 1 && (k = e(k, d, l), Z = e(Z, d, l), Y = k.length, z = Z.length), $ = Y, x = Z.slice(0, Y), R = x.length;R < Y; )
            x[R++] = 0;
          tt = k.slice(), tt.unshift(0), Ae = k[0], k[1] >= l / 2 && ++Ae;
          do
            d = 0, u = t(k, x, Y, R), u < 0 ? (ce = x[0], Y != R && (ce = ce * l + (x[1] || 0)), d = ce / Ae | 0, d > 1 ? (d >= l && (d = l - 1), g = e(k, d, l), P = g.length, R = x.length, u = t(g, x, P, R), u == 1 && (d--, r(g, Y < P ? tt : k, P, l))) : (d == 0 && (u = d = 1), g = k.slice()), P = g.length, P < R && g.unshift(0), r(x, g, R, l), u == -1 && (R = x.length, u = t(k, x, Y, R), u < 1 && (d++, r(x, Y < R ? tt : k, R, l))), R = x.length) : u === 0 && (d++, x = [0]), C[p++] = d, u && x[0] ? x[R++] = Z[$] || 0 : (x = [Z[$]], R = 1);
          while (($++ < z || x[0] !== undefined) && J--);
          y = x[0] !== undefined;
        }
        C[0] || C.shift();
      }
      if (f == 1)
        T.e = c, vs = y;
      else {
        for (p = 1, d = C[0];d >= 10; d /= 10)
          p++;
        T.e = p + c * f - 1, h(T, a ? o + T.e + 1 : o, s, y);
      }
      return T;
    };
  }();
  m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
  m[Symbol.toStringTag] = "Decimal";
  var ze = m.constructor = Os(xi);
  Kr = new ze(Kr);
  Qr = new ze(Qr);
  var Pe = ze;
  var Ht = class {
    constructor(t, r, n, i, o) {
      this.modelName = t, this.name = r, this.typeName = n, this.isList = i, this.isEnum = o;
    }
    _toGraphQLInputType() {
      let t = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
      return `${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var zr = class {
    constructor(t) {
      this.value = t;
    }
    write(t) {
      t.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var Yr = (e) => e;
  var Zr = { bold: Yr, red: Yr, green: Yr, dim: Yr, enabled: false };
  var Ds = { bold: ne, red: me, green: Ge, dim: Fe, enabled: true };
  var bt = { write(e) {
    e.writeLine(",");
  } };
  var ve = class {
    constructor(t) {
      this.contents = t;
      this.isUnderlined = false;
      this.color = (t2) => t2;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t) {
      return this.color = t, this;
    }
    write(t) {
      let r = t.getCurrentLineLength();
      t.write(this.color(this.contents)), this.isUnderlined && t.afterNextNewline(() => {
        t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var qe = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Et = class extends qe {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r) {
      return this.items.push(new zr(r)), this;
    }
    getField(r) {
      return this.items[r];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
    }
    write(r) {
      if (this.items.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithItems(r);
    }
    writeEmpty(r) {
      let n = new ve("[]");
      this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
    }
    writeWithItems(r) {
      let { colors: n } = r.context;
      r.writeLine("[").withIndent(() => r.writeJoined(bt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(n.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var _s = ": ";
  var Xr = class {
    constructor(t, r) {
      this.name = t;
      this.value = r;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + _s.length;
    }
    write(t) {
      let r = new ve(this.name);
      this.hasError && r.underline().setColor(t.context.colors.red), t.write(r).write(_s).write(this.value);
    }
  };
  var Q = class e extends qe {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r) {
      this.fields[r.name] = r;
    }
    addSuggestion(r) {
      this.suggestions.push(r);
    }
    getField(r) {
      return this.fields[r];
    }
    getDeepField(r) {
      let [n, ...i] = r, o = this.getField(n);
      if (!o)
        return;
      let s = o;
      for (let a of i) {
        let l;
        if (s.value instanceof e ? l = s.value.getField(a) : s.value instanceof Et && (l = s.value.getField(Number(a))), !l)
          return;
        s = l;
      }
      return s;
    }
    getDeepFieldValue(r) {
      return r.length === 0 ? this : this.getDeepField(r)?.value;
    }
    hasField(r) {
      return !!this.getField(r);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r) {
      delete this.fields[r];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r) {
      return this.getField(r)?.value;
    }
    getDeepSubSelectionValue(r) {
      let n = this;
      for (let i of r) {
        if (!(n instanceof e))
          return;
        let o = n.getSubSelectionValue(i);
        if (!o)
          return;
        n = o;
      }
      return n;
    }
    getDeepSelectionParent(r) {
      let n = this.getSelectionParent();
      if (!n)
        return;
      let i = n;
      for (let o of r) {
        let s = i.value.getFieldValue(o);
        if (!s || !(s instanceof e))
          return;
        let a = s.getSelectionParent();
        if (!a)
          return;
        i = a;
      }
      return i;
    }
    getSelectionParent() {
      let r = this.getField("select");
      if (r?.value instanceof e)
        return { kind: "select", value: r.value };
      let n = this.getField("include");
      if (n?.value instanceof e)
        return { kind: "include", value: n.value };
    }
    getSubSelectionValue(r) {
      return this.getSelectionParent()?.value.fields[r].value;
    }
    getPrintWidth() {
      let r = Object.values(this.fields);
      return r.length == 0 ? 2 : Math.max(...r.map((i) => i.getPrintWidth())) + 2;
    }
    write(r) {
      let n = Object.values(this.fields);
      if (n.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithContents(r, n);
    }
    writeEmpty(r) {
      let n = new ve("{}");
      this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
    }
    writeWithContents(r, n) {
      r.writeLine("{").withIndent(() => {
        r.writeJoined(bt, [...n, ...this.suggestions]).newLine();
      }), r.write("}"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var G = class extends qe {
    constructor(r) {
      super();
      this.text = r;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r) {
      let n = new ve(this.text);
      this.hasError && n.underline().setColor(r.context.colors.red), r.write(n);
    }
  };
  var vi = class {
    constructor(t) {
      this.errorMessages = [];
      this.arguments = t;
    }
    write(t) {
      t.write(this.arguments);
    }
    addErrorMessage(t) {
      this.errorMessages.push(t);
    }
    renderAllMessages(t) {
      return this.errorMessages.map((r) => r(t)).join(`
`);
    }
  };
  var Wt = "<unknown>";
  var op = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var sp = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var lp = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var cp = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var pp = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var mp = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var gp = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Ti = class {
    getLocation() {
      return null;
    }
  };
  var Ci = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t = this._error.stack;
      if (!t)
        return null;
      let n = qs(t).find((i) => {
        if (!i.file)
          return false;
        let o = ni(i.file);
        return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
    }
  };
  var Vs = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var Gs = (e) => Array.isArray(e) ? e : e.split(".");
  var Ai = (e, t) => Gs(t).reduce((r, n) => r && r[n], e);
  var Js = (e, t, r) => Gs(t).reduceRight((n, i, o, s) => Object.assign({}, Ai(e, s.slice(0, o)), { [i]: n }), r);
  var Xs = S(ii());
  var Zs = S(import.meta.require("fs"));
  var Hs = { keyword: Oe, entity: Oe, value: (e) => ne(ot(e)), punctuation: ot, directive: Oe, function: Oe, variable: (e) => ne(ot(e)), string: (e) => ne(Ge(e)), boolean: he, number: Oe, comment: Tr };
  var Ap = (e) => e;
  var rn = {};
  var Rp = 0;
  var v = { manual: rn.Prism && rn.Prism.manual, disableWorkerMessageHandler: rn.Prism && rn.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ye) {
      let t = e;
      return new ye(t.type, v.util.encode(t.content), t.alias);
    } else
      return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++Rp }), e.__id;
  }, clone: function e(t, r) {
    let n, i, o = v.util.type(t);
    switch (r = r || {}, o) {
      case "Object":
        if (i = v.util.objId(t), r[i])
          return r[i];
        n = {}, r[i] = n;
        for (let s in t)
          t.hasOwnProperty(s) && (n[s] = e(t[s], r));
        return n;
      case "Array":
        return i = v.util.objId(t), r[i] ? r[i] : (n = [], r[i] = n, t.forEach(function(s, a) {
          n[a] = e(s, r);
        }), n);
      default:
        return t;
    }
  } }, languages: { extend: function(e, t) {
    let r = v.util.clone(v.languages[e]);
    for (let n in t)
      r[n] = t[n];
    return r;
  }, insertBefore: function(e, t, r, n) {
    n = n || v.languages;
    let i = n[e], o = {};
    for (let a in i)
      if (i.hasOwnProperty(a)) {
        if (a == t)
          for (let l in r)
            r.hasOwnProperty(l) && (o[l] = r[l]);
        r.hasOwnProperty(a) || (o[a] = i[a]);
      }
    let s = n[e];
    return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
      l === s && a != e && (this[a] = o);
    }), o;
  }, DFS: function e(t, r, n, i) {
    i = i || {};
    let o = v.util.objId;
    for (let s in t)
      if (t.hasOwnProperty(s)) {
        r.call(t, s, t[s], n || s);
        let a = t[s], l = v.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, r, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, r, s, i));
      }
  } }, plugins: {}, highlight: function(e, t, r) {
    let n = { code: e, grammar: t, language: r };
    return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ye.stringify(v.util.encode(n.tokens), n.language);
  }, matchGrammar: function(e, t, r, n, i, o, s) {
    for (let g in r) {
      if (!r.hasOwnProperty(g) || !r[g])
        continue;
      if (g == s)
        return;
      let P = r[g];
      P = v.util.type(P) === "Array" ? P : [P];
      for (let T = 0;T < P.length; ++T) {
        let C = P[T], x = C.inside, R = !!C.lookbehind, ce = !!C.greedy, J = 0, Ke = C.alias;
        if (ce && !C.pattern.global) {
          let $ = C.pattern.toString().match(/[imuy]*$/)[0];
          C.pattern = RegExp(C.pattern.source, $ + "g");
        }
        C = C.pattern || C;
        for (let $ = n, z = i;$ < t.length; z += t[$].length, ++$) {
          let Ae = t[$];
          if (t.length > e.length)
            return;
          if (Ae instanceof ye)
            continue;
          if (ce && $ != t.length - 1) {
            C.lastIndex = z;
            var p = C.exec(e);
            if (!p)
              break;
            var c = p.index + (R ? p[1].length : 0), d = p.index + p[0].length, a = $, l = z;
            for (let k = t.length;a < k && (l < d || !t[a].type && !t[a - 1].greedy); ++a)
              l += t[a].length, c >= l && (++$, z = l);
            if (t[$] instanceof ye)
              continue;
            u = a - $, Ae = e.slice(z, l), p.index -= z;
          } else {
            C.lastIndex = 0;
            var p = C.exec(Ae), u = 1;
          }
          if (!p) {
            if (o)
              break;
            continue;
          }
          R && (J = p[1] ? p[1].length : 0);
          var c = p.index + J, p = p[0].slice(J), d = c + p.length, f = Ae.slice(0, c), y = Ae.slice(d);
          let Y = [$, u];
          f && (++$, z += f.length, Y.push(f));
          let tt = new ye(g, x ? v.tokenize(p, x) : p, Ke, p, ce);
          if (Y.push(tt), y && Y.push(y), Array.prototype.splice.apply(t, Y), u != 1 && v.matchGrammar(e, t, r, $, z, true, g), o)
            break;
        }
      }
    }
  }, tokenize: function(e, t) {
    let r = [e], n = t.rest;
    if (n) {
      for (let i in n)
        t[i] = n[i];
      delete t.rest;
    }
    return v.matchGrammar(e, r, t, 0, 0, false), r;
  }, hooks: { all: {}, add: function(e, t) {
    let r = v.hooks.all;
    r[e] = r[e] || [], r[e].push(t);
  }, run: function(e, t) {
    let r = v.hooks.all[e];
    if (!(!r || !r.length))
      for (var n = 0, i;i = r[n++]; )
        i(t);
  } }, Token: ye };
  v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
  v.languages.js = v.languages.javascript;
  v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  v.languages.ts = v.languages.typescript;
  ye.stringify = function(e, t) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r) {
      return ye.stringify(r, t);
    }).join("") : Mp(e.type)(e.content);
  };
  var zs = S(es());
  var nn = class e {
    static read(t) {
      let r;
      try {
        r = Zs.default.readFileSync(t, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(r);
    }
    static fromContent(t) {
      let r = t.split(/\r?\n/);
      return new e(1, r);
    }
    constructor(t, r) {
      this.firstLineNumber = t, this.lines = r;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t, r) {
      if (t < this.firstLineNumber || t > this.lines.length + this.firstLineNumber)
        return this;
      let n = t - this.firstLineNumber, i = [...this.lines];
      return i[n] = r(i[n]), new e(this.firstLineNumber, i);
    }
    mapLines(t) {
      return new e(this.firstLineNumber, this.lines.map((r, n) => t(r, this.firstLineNumber + n)));
    }
    lineAt(t) {
      return this.lines[t - this.firstLineNumber];
    }
    prependSymbolAt(t, r) {
      return this.mapLines((n, i) => i === t ? `${r} ${n}` : `  ${n}`);
    }
    slice(t, r) {
      let n = this.lines.slice(t - 1, r).join(`
`);
      return new e(t, Ys(n).split(`
`));
    }
    highlight() {
      let t = Ws(this.toString());
      return new e(this.firstLineNumber, t.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Ip = { red: me, gray: Tr, dim: Fe, bold: ne, underline: te, highlightSource: (e) => e.highlight() };
  var kp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  var $p = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var qp = ["aggregate", "count", "groupBy"];
  var Si = Symbol();
  var aa = (e) => e;
  var an = class {
    constructor(t, r) {
      this.extension = t;
      this.previous = r;
      this.computedFieldsCache = new be;
      this.modelExtensionsCache = new be;
      this.queryCallbacksCache = new be;
      this.clientExtensions = Vt(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = Vt(() => {
        let t2 = this.previous?.getAllBatchQueryCallbacks() ?? [], r2 = this.extension.query?.$__internalBatch;
        return r2 ? t2.concat(r2) : t2;
      });
    }
    getAllComputedFields(t) {
      return this.computedFieldsCache.getOrCreate(t, () => fa(this.previous?.getAllComputedFields(t), this.extension, t));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t) {
      return this.modelExtensionsCache.getOrCreate(t, () => {
        let r = Te(t);
        return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t) : { ...this.previous?.getAllModelExtensions(t), ...this.extension.model.$allModels, ...this.extension.model[r] };
      });
    }
    getAllQueryCallbacks(t, r) {
      return this.queryCallbacksCache.getOrCreate(`${t}:${r}`, () => {
        let n = this.previous?.getAllQueryCallbacks(t, r) ?? [], i = [], o = this.extension.query;
        return !o || !(o[t] || o.$allModels || o[r] || o.$allOperations) ? n : (o[t] !== undefined && (o[t][r] !== undefined && i.push(o[t][r]), o[t].$allOperations !== undefined && i.push(o[t].$allOperations)), t !== "$none" && o.$allModels !== undefined && (o.$allModels[r] !== undefined && i.push(o.$allModels[r]), o.$allModels.$allOperations !== undefined && i.push(o.$allModels.$allOperations)), o[r] !== undefined && i.push(o[r]), o.$allOperations !== undefined && i.push(o.$allOperations), n.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var ln = class e {
    constructor(t) {
      this.head = t;
    }
    static empty() {
      return new e;
    }
    static single(t) {
      return new e(new an(t));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t) {
      return new e(new an(t, this.head));
    }
    getAllComputedFields(t) {
      return this.head?.getAllComputedFields(t);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t) {
      return this.head?.getAllModelExtensions(t);
    }
    getAllQueryCallbacks(t, r) {
      return this.head?.getAllQueryCallbacks(t, r) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ya = D("prisma:client");
  var ha = { Vercel: "vercel", "Netlify CI": "netlify" };
  var vt = class {
  };
  var Ta = S(import.meta.require("fs"));
  var Xt = S(import.meta.require("path"));
  var zp = D("prisma:client:engines:resolveEnginePath");
  var Yp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Ii = S(li());
  var Sa = S(cs());
  var mn = class extends Error {
    constructor(r, n) {
      super(r);
      this.clientVersion = n.clientVersion, this.cause = n.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends mn {
    constructor(r, n) {
      super(r, n);
      this.isRetryable = n.isRetryable ?? true;
    }
  };
  var Tt = class extends ae {
    constructor(r) {
      super("This request must be retried", M(r, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  E(Tt, "ForcedRetryError");
  var Ye = class extends ae {
    constructor(r, n) {
      super(r, M(n, false));
      this.name = "InvalidDatasourceError";
      this.code = "P5002";
    }
  };
  E(Ye, "InvalidDatasourceError");
  var Ze = class extends ae {
    constructor(r, n) {
      super(r, M(n, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  E(Ze, "NotImplementedYetError");
  var L = class extends ae {
    constructor(r, n) {
      super(r, n);
      this.response = n.response;
      let i = this.response.headers.get("prisma-request-id");
      if (i) {
        let o = `(The request id was: ${i})`;
        this.message = this.message + " " + o;
      }
    }
  };
  var Xe = class extends L {
    constructor(r) {
      super("Schema needs to be uploaded", M(r, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  E(Xe, "SchemaMissingError");
  var ki = "This request could not be understood by the server";
  var er = class extends L {
    constructor(r, n, i) {
      super(n || ki, M(r, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  E(er, "BadRequestError");
  var tr = class extends L {
    constructor(r, n) {
      super("Engine not started: healthcheck timeout", M(r, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n;
    }
  };
  E(tr, "HealthcheckTimeoutError");
  var rr = class extends L {
    constructor(r, n, i) {
      super(n, M(r, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  E(rr, "EngineStartupError");
  var nr = class extends L {
    constructor(r) {
      super("Engine version is not supported", M(r, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  E(nr, "EngineVersionNotSupportedError");
  var Fi = "Request timed out";
  var ir = class extends L {
    constructor(r, n = Fi) {
      super(n, M(r, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  E(ir, "GatewayTimeoutError");
  var Xp = "Interactive transaction error";
  var or = class extends L {
    constructor(r, n = Xp) {
      super(n, M(r, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  E(or, "InteractiveTransactionError");
  var ed = "Request parameters are invalid";
  var sr = class extends L {
    constructor(r, n = ed) {
      super(n, M(r, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  E(sr, "InvalidRequestError");
  var Oi = "Requested resource does not exist";
  var ar = class extends L {
    constructor(r, n = Oi) {
      super(n, M(r, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  E(ar, "NotFoundError");
  var Di = "Unknown server error";
  var Ct = class extends L {
    constructor(r, n, i) {
      super(n || Di, M(r, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  E(Ct, "ServerError");
  var _i = "Unauthorized, check your connection string";
  var lr = class extends L {
    constructor(r, n = _i) {
      super(n, M(r, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  E(lr, "UnauthorizedError");
  var Ni = "Usage exceeded, retry again later";
  var ur = class extends L {
    constructor(r, n = Ni) {
      super(n, M(r, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  E(ur, "UsageExceededError");
  var Da = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.4.1-2.ac9d7041ed77bcc8a8dbd2ab6616b39013829574", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.75", "@swc/jest": "0.2.29", "@types/jest": "29.5.5", "@types/node": "18.18.0", execa: "5.1.1", jest: "29.7.0", typescript: "5.2.2" };
  var pr = class extends ae {
    constructor(r, n) {
      super(`Cannot fetch data from service:
${r}`, M(n, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  E(pr, "RequestError");
  var sd = typeof import.meta.require < "u" ? import.meta.require : () => {
  };
  var $i = class {
    constructor(t = {}) {
      this.headers = new Map;
      for (let [r, n] of Object.entries(t))
        if (typeof n == "string")
          this.headers.set(r, n);
        else if (Array.isArray(n))
          for (let i of n)
            this.headers.set(r, i);
    }
    append(t, r) {
      this.headers.set(t, r);
    }
    delete(t) {
      this.headers.delete(t);
    }
    get(t) {
      return this.headers.get(t) ?? null;
    }
    has(t) {
      return this.headers.has(t);
    }
    set(t, r) {
      this.headers.set(t, r);
    }
    forEach(t, r) {
      for (let [n, i] of this.headers)
        t.call(r, i, n, this);
    }
  };
  var ad = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var _a = D("prisma:client:dataproxyEngine");
  var La = 3;
  var qi = D("prisma:client:dataproxyEngine");
  var Vi = class {
    constructor({ apiKey: t, tracingHelper: r, logLevel: n, logQueries: i }) {
      this.apiKey = t, this.tracingHelper = r, this.logLevel = n, this.logQueries = i;
    }
    build({ traceparent: t, interactiveTransaction: r } = {}) {
      let n = { Authorization: `Bearer ${this.apiKey}` };
      this.tracingHelper.isEnabled() && (n.traceparent = t ?? this.tracingHelper.getTraceParent()), r && (n["X-transaction-id"] = r.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
    }
    buildCaptureSettings() {
      let t = [];
      return this.tracingHelper.isEnabled() && t.push("tracing"), this.logLevel && t.push(this.logLevel), this.logQueries && t.push("query"), t;
    }
  };
  var dr = class extends vt {
    constructor(r) {
      super();
      Oa(r), this.config = r, this.env = { ...this.config.env, ...process.env }, this.inlineSchema = r.inlineSchema ?? "", this.inlineDatasources = r.inlineDatasources ?? {}, this.inlineSchemaHash = r.inlineSchemaHash ?? "", this.clientVersion = r.clientVersion ?? "unknown", this.logEmitter = r.logEmitter, this.tracingHelper = this.config.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return "unknown";
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [r, n] = this.extractHostAndApiKey();
        this.host = r, this.headerBuilder = new Vi({ apiKey: n, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries }), this.remoteClientVersion = await Na(r, this.config), qi("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(r) {
      r?.logs?.length && r.logs.forEach((n) => {
        switch (n.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let i = typeof n.attributes.query == "string" ? n.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [o] = i.split("/* traceparent");
              i = o;
            }
            this.logEmitter.emit("query", { query: i, timestamp: n.timestamp, duration: n.attributes.duration_ms, params: n.attributes.params, target: n.attributes.target });
          }
        }
      }), r?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
    }
    on(r, n) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      this.logEmitter.on(r, n);
    }
    async url(r) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
    }
    async uploadSchema() {
      let r = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r, async () => {
        let n = await et(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        n.ok || qi("schema response status", n.status);
        let i = await cr(n, this.clientVersion);
        if (i)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${i.message}` }), i;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
      });
    }
    request(r, { traceparent: n, interactiveTransaction: i, customDataProxyFetch: o }) {
      return this.requestInternal({ body: r, traceparent: n, interactiveTransaction: i, customDataProxyFetch: o });
    }
    async requestBatch(r, { traceparent: n, transaction: i, customDataProxyFetch: o }) {
      let s = i?.kind === "itx" ? i.options : undefined, a = pn(r, i), { batchResult: l, elapsed: u } = await this.requestInternal({ body: a, customDataProxyFetch: o, interactiveTransaction: s, traceparent: n });
      return l.map((c) => ("errors" in c) && c.errors.length > 0 ? Zt(c.errors[0], this.clientVersion) : { data: c, elapsed: u });
    }
    requestInternal({ body: r, traceparent: n, customDataProxyFetch: i, interactiveTransaction: o }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s }) => {
        let a = o ? `${o.payload.endpoint}/graphql` : await this.url("graphql");
        s(a);
        let l = await et(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n, interactiveTransaction: o }), body: JSON.stringify(r), clientVersion: this.clientVersion }, i);
        l.ok || qi("graphql response status", l.status), await this.handleError(await cr(l, this.clientVersion));
        let u = await l.json(), c = u.extensions;
        if (c && this.propagateResponseExtensions(c), u.errors)
          throw u.errors.length === 1 ? Zt(u.errors[0], this.config.clientVersion) : new K(u.errors, { clientVersion: this.config.clientVersion });
        return u;
      } });
    }
    async transaction(r, n, i) {
      let o = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${o[r]} transaction`, callback: async ({ logHttpCall: s }) => {
        if (r === "start") {
          let a = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel }), l = await this.url("transaction/start");
          s(l);
          let u = await et(l, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), body: a, clientVersion: this.clientVersion });
          await this.handleError(await cr(u, this.clientVersion));
          let c = await u.json(), p = c.extensions;
          p && this.propagateResponseExtensions(p);
          let d = c.id, f = c["data-proxy"].endpoint;
          return { id: d, payload: { endpoint: f } };
        } else {
          let a = `${i.payload.endpoint}/${r}`;
          s(a);
          let l = await et(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await cr(l, this.clientVersion));
          let c = (await l.json()).extensions;
          c && this.propagateResponseExtensions(c);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let r = { clientVersion: this.clientVersion }, n = Object.keys(this.inlineDatasources)[0], i = dn({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), o;
      try {
        o = new URL(i);
      } catch {
        throw new Ye(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: s, host: a, searchParams: l } = o;
      if (s !== "prisma:")
        throw new Ye(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
      let u = l.get("api_key");
      if (u === null || u.length < 1)
        throw new Ye(`Error validating datasource \`${n}\`: the URL must contain a valid API key`, r);
      return [a, u];
    }
    metrics() {
      throw new Ze("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r) {
      for (let n = 0;; n++) {
        let i = (o) => {
          this.logEmitter.emit("info", { message: `Calling ${o} (n=${n})` });
        };
        try {
          return await r.callback({ logHttpCall: i });
        } catch (o) {
          if (!(o instanceof ae) || !o.isRetryable)
            throw o;
          if (n >= La)
            throw o instanceof Tt ? o.cause : o;
          this.logEmitter.emit("warn", { message: `Attempt ${n + 1}/${La} failed for ${r.actionGerund}: ${o.message ?? "(unknown)"}` });
          let s = await Fa(n);
          this.logEmitter.emit("warn", { message: `Retrying after ${s}ms` });
        }
      }
    }
    async handleError(r) {
      if (r instanceof Xe)
        throw await this.uploadSchema(), new Tt({ clientVersion: this.clientVersion, cause: r });
      if (r)
        throw r;
    }
  };
  var Ba = S(import.meta.require("fs"));
  var Bi = S(import.meta.require("os"));
  var qa = S(import.meta.require("path"));
  var ji = Symbol("PrismaLibraryEngineCache");
  var fn = class {
    constructor(t) {
      this.config = t;
    }
    async loadLibrary() {
      let t = await Jn(), r = await Ca("library", this.config);
      try {
        return this.config.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => pd(r));
      } catch (n) {
        let i = ri({ e: n, platformInfo: t, id: r });
        throw new F(i, this.config.clientVersion);
      }
    }
  };
  var dd = "P2036";
  var Ce = D("prisma:client:libraryEngine");
  var Va = [...Hn, "native"];
  var ja = 0;
  var mr = class extends vt {
    constructor(r, n = new fn(r)) {
      super();
      try {
        this.datamodel = Ba.default.readFileSync(r.datamodelPath, "utf-8");
      } catch (s) {
        throw s.stack.match(/\/\.next|\/next@|\/next\//) ? new F(`Your schema.prisma could not be found, and we detected that you are using Next.js.
Find out why and learn how to fix this: https://pris.ly/d/schema-not-found-nextjs`, r.clientVersion) : r.isBundled === true ? new F("Prisma Client could not find its `schema.prisma`. This is likely caused by a bundling step, which leads to `schema.prisma` not being copied near the resulting bundle. We would appreciate if you could take the time to share some information with us.\nPlease help us by answering a few questions: https://pris.ly/bundler-investigation-error", r.clientVersion) : s;
      }
      this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.libraryLoader = n, this.logEmitter = r.logEmitter, r.enableDebugLogs && (this.logLevel = "debug");
      let i = Object.keys(r.overrideDatasources)[0], o = r.overrideDatasources[i]?.url;
      i !== undefined && o !== undefined && (this.datasourceOverrides = { [i]: o }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      ja === 10 && console.warn(`${he("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(r, n, i) {
      await this.start();
      let o = JSON.stringify(n), s;
      if (r === "start") {
        let l = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel });
        s = await this.engine?.startTransaction(l, o);
      } else
        r === "commit" ? s = await this.engine?.commitTransaction(i.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(i.id, o));
      let a = this.parseEngineResponse(s);
      if (a.error_code)
        throw new U(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
      return a;
    }
    async instantiateLibrary() {
      if (Ce("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Vn(), this.platform = await this.getPlatform(), await this.loadEngine(), this.version();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      let r = await ut();
      if (!Va.includes(r))
        throw new F(`Unknown ${me("PRISMA_QUERY_ENGINE_LIBRARY")} ${me(ne(r))}. Possible binaryTargets: ${Ge(Va.join(", "))} or a path to the query engine library.
You may have to run ${Ge("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      return r;
    }
    parseEngineResponse(r) {
      if (!r)
        throw new K("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r);
      } catch {
        throw new K("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r = new WeakRef(this), { adapter: n } = this.config;
          n && Ce("Using driver adapter: %O", n), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (i) => {
            r.deref()?.logger(i);
          }, n), ja++;
        } catch (r) {
          let n = r, i = this.parseInitError(n.message);
          throw typeof i == "string" ? n : new F(i.message, this.config.clientVersion, i.error_code);
        }
      }
    }
    logger(r) {
      let n = this.parseEngineResponse(r);
      if (n) {
        if ("span" in n) {
          this.config.tracingHelper.createEngineSpan(n);
          return;
        }
        n.level = n?.level.toLowerCase() ?? "unknown", md(n) ? this.logEmitter.emit("query", { timestamp: new Date, query: n.query, params: n.params, duration: Number(n.duration_ms), target: n.module_path }) : fd(n) ? this.loggerRustPanic = new ue(this.getErrorMessageWithLink(`${n.message}: ${n.reason} in ${n.file}:${n.line}:${n.column}`), this.config.clientVersion) : this.logEmitter.emit(n.level, { timestamp: new Date, message: n.message, target: n.module_path });
      }
    }
    getErrorMessageWithLink(r) {
      return ka({ platform: this.platform, title: r, version: this.config.clientVersion, engineVersion: this.versionInfo?.commit, database: this.config.activeProvider, query: this.lastQuery });
    }
    parseInitError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    parseRequestError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    on(r, n) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      this.logEmitter.on(r, n);
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ce(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r = async () => {
        Ce("library starting");
        try {
          let n = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(n)), this.libraryStarted = true, Ce("library started");
        } catch (n) {
          let i = this.parseInitError(n.message);
          throw typeof i == "string" ? n : new F(i.message, this.config.clientVersion, i.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ce("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let r = async () => {
        await new Promise((i) => setTimeout(i, 5)), Ce("library stopping");
        let n = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(n)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Ce("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r) {
      return this.library?.debugPanic(r);
    }
    async request(r, { traceparent: n, interactiveTransaction: i }) {
      Ce(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let o = JSON.stringify({ traceparent: n }), s = JSON.stringify(r);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(s, o, i?.id), this.lastQuery = s;
        let a = this.parseEngineResponse(await this.executingQueryPromise);
        if (a.errors)
          throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: a, elapsed: 0 };
      } catch (a) {
        if (a instanceof F)
          throw a;
        if (a.code === "GenericFailure" && a.message?.startsWith("PANIC:"))
          throw new ue(this.getErrorMessageWithLink(a.message), this.config.clientVersion);
        let l = this.parseRequestError(a.message);
        throw typeof l == "string" ? a : new K(`${l.message}
${l.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r, { transaction: n, traceparent: i }) {
      Ce("requestBatch");
      let o = pn(r, n);
      await this.start(), this.lastQuery = JSON.stringify(o), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: i }), $a(n));
      let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
      if (a.errors)
        throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: l, errors: u } = a;
      if (Array.isArray(l))
        return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0]) : { data: c, elapsed: 0 });
      throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
    }
    buildQueryError(r) {
      if (r.user_facing_error.is_panic)
        return new ue(this.getErrorMessageWithLink(r.user_facing_error.message), this.config.clientVersion);
      if (r.user_facing_error.error_code === dd && this.config.adapter) {
        let n = r.user_facing_error.meta?.id;
        _r(typeof n == "number", "Malformed external JS error received from the engine");
        let i = this.config.adapter.errorRegistry.consumeError(n);
        return _r(i, "External error with reported id was not registered"), i.error;
      }
      return Zt(r, this.config.clientVersion);
    }
    async metrics(r) {
      await this.start();
      let n = await this.engine.metrics(JSON.stringify(r));
      return r.format === "prometheus" ? n : this.parseEngineResponse(n);
    }
  };
  var Wa = S(Ui());
  var Se = class {
    constructor(t, r) {
      this.name = t;
      this.value = r;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t) {
      let { colors: { green: r } } = t.context;
      t.addMarginSymbol(r(this.isRequired ? "+" : "?")), t.write(r(this.name)), this.isRequired || t.write(r("?")), t.write(r(": ")), typeof this.value == "string" ? t.write(r(this.value)) : t.write(this.value);
    }
  };
  var hn = class {
    constructor() {
      this.fields = [];
    }
    addField(t, r) {
      return this.fields.push({ write(n) {
        let { green: i, dim: o } = n.context.colors;
        n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")));
      } }), this;
    }
    write(t) {
      let { colors: { green: r } } = t.context;
      t.writeLine(r("{")).withIndent(() => {
        t.writeJoined(bt, this.fields).newLine();
      }).write(r("}")).addMarginSymbol(r("+"));
    }
  };
  var kd = 3;
  var Od = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var Ki = class e {
    constructor(t) {
      this.params = t;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(t) {
      En({ errors: [t], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((t) => ({ name: t.name, typeName: "boolean", isRelation: t.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t) {
      return this.model?.fields.find((r) => r.name === t);
    }
    nestSelection(t) {
      let r = this.findField(t), n = r?.kind === "object" ? r.type : undefined;
      return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(t) });
    }
    nestArgument(t) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t) });
    }
  };
  var nl = (e) => ({ command: e });
  var il = (e) => e.strings.reduce((t, r, n) => `${t}@P${n}${r}`);
  var Ud = /^(\s*alter\s)/i;
  var ll = D("prisma:client");
  var Ji = ({ clientMethod: e, activeProvider: t, activeProviderFlavour: r }) => (n) => {
    r !== undefined && (t = r);
    let i = "", o;
    if (Array.isArray(n)) {
      let [s, ...a] = n;
      i = s, o = { values: gr(a || []), __prismaRawParameters__: true };
    } else
      switch (t) {
        case "sqlite":
        case "mysql": {
          i = n.sql, o = { values: gr(n.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          i = n.text, o = { values: gr(n.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          i = il(n), o = { values: gr(n.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t} provider does not support ${e}`);
      }
    return o?.values ? ll(`prisma.${e}(${i}, ${o.values})`) : ll(`prisma.${e}(${i})`), { query: i, parameters: o };
  };
  var ul = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [t, ...r] = e;
    return new oe(t, r);
  } };
  var cl = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  var dl = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e, t) {
    return t();
  } };
  var Wi = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t) {
      return this.getGlobalTracingHelper().getTraceParent(t);
    }
    createEngineSpan(t) {
      return this.getGlobalTracingHelper().createEngineSpan(t);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t, r) {
      return this.getGlobalTracingHelper().runInChildSpan(t, r);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? dl;
    }
  };
  var Kd = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var zi = Kd;
  var wn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t) {
      this._middlewares.push(t);
    }
    get(t) {
      return this._middlewares[t];
    }
    has(t) {
      return !!this._middlewares[t];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var hl = S(li());
  var Jd = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var Tn = class {
    constructor(t) {
      this.options = t;
      this.tickActive = false;
      this.batches = {};
    }
    request(t) {
      let r = this.options.batchBy(t);
      return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n, i) => {
        this.batches[r].push({ request: t, resolve: n, reject: i });
      })) : this.options.singleLoader(t);
    }
    dispatchBatches() {
      for (let t in this.batches) {
        let r = this.batches[t];
        delete this.batches[t], r.length === 1 ? this.options.singleLoader(r[0].request).then((n) => {
          n instanceof Error ? r[0].reject(n) : r[0].resolve(n);
        }).catch((n) => {
          r[0].reject(n);
        }) : (r.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(r.map((n) => n.request)).then((n) => {
          if (n instanceof Error)
            for (let i = 0;i < r.length; i++)
              r[i].reject(n);
          else
            for (let i = 0;i < r.length; i++) {
              let o = n[i];
              o instanceof Error ? r[i].reject(o) : r[i].resolve(o);
            }
        }).catch((n) => {
          for (let i = 0;i < r.length; i++)
            r[i].reject(n);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var Hd = D("prisma:client:request_handler");
  var Cn = class {
    constructor(t, r) {
      this.logEmitter = r, this.client = t, this.dataloader = new Tn({ batchLoader: ca(async ({ requests: n, customDataProxyFetch: i }) => {
        let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Zi(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: Wd(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n[d], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n) => {
        let i = n.transaction?.kind === "itx" ? xl(n.transaction) : undefined, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Zi(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
        return this.mapQueryEngineResult(n, o);
      }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : yl(n.protocolQuery), batchOrder(n, i) {
        return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(t) {
      try {
        return await this.dataloader.request(t);
      } catch (r) {
        let { clientMethod: n, callsite: i, transaction: o, args: s } = t;
        this.handleAndLogRequestError({ error: r, clientMethod: n, callsite: i, transaction: o, args: s });
      }
    }
    mapQueryEngineResult({ dataPath: t, unpacker: r }, n) {
      let i = n?.data, o = n?.elapsed, s = this.unpack(i, t, r);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: o } : s;
    }
    handleAndLogRequestError(t) {
      try {
        this.handleRequestError(t);
      } catch (r) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t.clientMethod, timestamp: new Date }), r;
      }
    }
    handleRequestError({ error: t, clientMethod: r, callsite: n, transaction: i, args: o }) {
      if (Hd(t), zd(t, i) || t instanceof Re)
        throw t;
      if (t instanceof U && Yd(t)) {
        let a = bl(t.meta);
        En({ args: o, errors: [a], callsite: n, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion });
      }
      let s = t.message;
      throw n && (s = Pt({ callsite: n, originalMethod: r, isPanic: t.isPanic, showColors: this.client._errorFormat === "pretty", message: s })), s = this.sanitizeMessage(s), t.code ? new U(s, { code: t.code, clientVersion: this.client._clientVersion, meta: t.meta, batchRequestIdx: t.batchRequestIdx }) : t.isPanic ? new ue(s, this.client._clientVersion) : t instanceof K ? new K(s, { clientVersion: this.client._clientVersion, batchRequestIdx: t.batchRequestIdx }) : t instanceof F ? new F(s, this.client._clientVersion) : t instanceof ue ? new ue(s, this.client._clientVersion) : (t.clientVersion = this.client._clientVersion, t);
    }
    sanitizeMessage(t) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, hl.default)(t) : t;
    }
    unpack(t, r, n) {
      if (!t || (t.data && (t = t.data), !t))
        return t;
      let i = Object.values(t)[0], o = r.filter((a) => a !== "select" && a !== "include"), s = vn(Ai(i, o));
      return n ? n(s) : s;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var El = "5.4.2";
  var wl = El;
  var Rl = S(Ui());
  var q = class extends Error {
    constructor(t) {
      super(t + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  E(q, "PrismaClientConstructorValidationError");
  var Tl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "__internal"];
  var Cl = ["pretty", "colorless", "minimal"];
  var Al = ["info", "query", "warn", "error"];
  var Xd = { datasources: (e, { datasourceNames: t }) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new q(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [r, n] of Object.entries(e)) {
        if (!t.includes(r)) {
          let i = Rt(r, t) || ` Available datasources: ${t.join(", ")}`;
          throw new q(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n != "object" || Array.isArray(n))
          throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n && typeof n == "object")
          for (let [i, o] of Object.entries(n)) {
            if (i !== "url")
              throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string")
              throw new q(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e, t) => {
    if (e === null)
      return;
    if (e === undefined)
      throw new q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!gn(t).includes("driverAdapters"))
      throw new q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new q(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new q(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!Cl.includes(e)) {
        let t = Rt(e, Cl);
        throw new q(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new q(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function t(r) {
      if (typeof r == "string" && !Al.includes(r)) {
        let n = Rt(r, Al);
        throw new q(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
      }
    }
    for (let r of e) {
      t(r);
      let n = { level: t, emit: (i) => {
        let o = ["stdout", "event"];
        if (!o.includes(i)) {
          let s = Rt(i, o);
          throw new q(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (r && typeof r == "object")
        for (let [i, o] of Object.entries(r))
          if (n[i])
            n[i](o);
          else
            throw new q(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, __internal: (e) => {
    if (!e)
      return;
    let t = ["debug", "hooks", "engine", "measurePerformance"];
    if (typeof e != "object")
      throw new q(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [r] of Object.entries(e))
      if (!t.includes(r)) {
        let n = Rt(r, t);
        throw new q(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
  } };
  var Ue = D("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var tm = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var rm = Symbol.for("prisma.client.transaction.id");
  var nm = { id: 0, nextId() {
    return ++this.id;
  } };
  var om = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// ../../node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join3,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.4.2",
    engine: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join3;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.DayScalarFieldEnum = {
    date: "date",
    tasksOrder: "tasksOrder"
  };
  exports.Prisma.NoteScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    date: "date",
    slug: "slug",
    title: "title",
    content: "content"
  };
  exports.Prisma.NoteTagScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    color: "color",
    isPrivate: "isPrivate"
  };
  exports.Prisma.TaskScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    title: "title",
    status: "status",
    completedAt: "completedAt",
    date: "date",
    durationInMinutes: "durationInMinutes",
    subtasksOrder: "subtasksOrder",
    itemId: "itemId",
    parentTaskId: "parentTaskId"
  };
  exports.Prisma.TaskTagScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    color: "color",
    isPrivate: "isPrivate"
  };
  exports.Prisma.TaskPluginDataScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    min: "min",
    full: "full",
    pluginSlug: "pluginSlug",
    originalId: "originalId",
    taskId: "taskId"
  };
  exports.Prisma.ItemPluginDataScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    min: "min",
    full: "full",
    pluginSlug: "pluginSlug",
    originalId: "originalId",
    itemId: "itemId"
  };
  exports.Prisma.ItemScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    title: "title",
    isRelevant: "isRelevant",
    scheduledAt: "scheduledAt",
    durationInMinutes: "durationInMinutes",
    isAllDay: "isAllDay",
    color: "color",
    inboxPoints: "inboxPoints",
    listId: "listId"
  };
  exports.Prisma.ListScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    description: "description"
  };
  exports.Prisma.StoreScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    key: "key",
    value: "value",
    pluginSlug: "pluginSlug",
    isSecret: "isSecret",
    isServerOnly: "isServerOnly"
  };
  exports.Prisma.RoutineScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    actionName: "actionName",
    time: "time",
    repeats: "repeats",
    firstDay: "firstDay",
    lastDay: "lastDay",
    isActive: "isActive",
    stepsOrder: "stepsOrder"
  };
  exports.Prisma.RoutineStepScalarFieldEnum = {
    id: "id",
    pluginSlug: "pluginSlug",
    stepSlug: "stepSlug",
    shouldSkip: "shouldSkip",
    config: "config",
    routineId: "routineId"
  };
  exports.Prisma.TemplateScalarFieldEnum = {
    slug: "slug",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    template: "template",
    metadata: "metadata",
    routineStepId: "routineStepId"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.JsonNullValueInput = {
    JsonNull: Prisma.JsonNull
  };
  exports.Prisma.NullableJsonNullValueInput = {
    DbNull: Prisma.DbNull,
    JsonNull: Prisma.JsonNull
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.JsonNullValueFilter = {
    DbNull: Prisma.DbNull,
    JsonNull: Prisma.JsonNull,
    AnyNull: Prisma.AnyNull
  };
  exports.Color = exports.$Enums.Color = {
    slate: "slate",
    gray: "gray",
    zinc: "zinc",
    neutral: "neutral",
    stone: "stone",
    red: "red",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    green: "green",
    emerald: "emerald",
    teal: "teal",
    cyan: "cyan",
    sky: "sky",
    blue: "blue",
    indigo: "indigo",
    violet: "violet",
    purple: "purple",
    fuchsia: "fuchsia",
    pink: "pink",
    rose: "rose"
  };
  exports.TaskStatus = exports.$Enums.TaskStatus = {
    TODO: "TODO",
    DONE: "DONE",
    CANCELED: "CANCELED"
  };
  exports.RepetitionPattern = exports.$Enums.RepetitionPattern = {
    MONDAY: "MONDAY",
    TUESDAY: "TUESDAY",
    WEDNESDAY: "WEDNESDAY",
    THURSDAY: "THURSDAY",
    FRIDAY: "FRIDAY",
    SATURDAY: "SATURDAY",
    SUNDAY: "SUNDAY"
  };
  exports.Prisma.ModelName = {
    Day: "Day",
    Note: "Note",
    NoteTag: "NoteTag",
    Task: "Task",
    TaskTag: "TaskTag",
    TaskPluginData: "TaskPluginData",
    ItemPluginData: "ItemPluginData",
    Item: "Item",
    List: "List",
    Store: "Store",
    Routine: "Routine",
    RoutineStep: "RoutineStep",
    Template: "Template"
  };
  var config = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/Users/richardguerre/Projects/flow/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "darwin-arm64",
          native: true
        },
        {
          fromEnvVar: null,
          value: "linux-arm64-openssl-3.0.x"
        },
        {
          fromEnvVar: null,
          value: "darwin-arm64"
        },
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x"
        }
      ],
      previewFeatures: []
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../apps/server/.env"
    },
    relativePath: "../../../apps/server/prisma",
    clientVersion: "5.4.2",
    engineVersion: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    postinstall: false,
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "ZGF0YXNvdXJjZSBkYiB7CiAgcHJvdmlkZXIgPSAicG9zdGdyZXNxbCIKICB1cmwgICAgICA9IGVudigiREFUQUJBU0VfVVJMIikKfQoKZ2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgICAgICA9ICJwcmlzbWEtY2xpZW50LWpzIgogIC8vIG5hdGl2ZSBmb3IgZGV2ZWxvcG1lbnQKICAvLyBsaW51eC1hcm02NC1vcGVuc3NsLTMuMC54IGZvciBwcm9kdWN0aW9uIChhbWF6b24gbGludXggMjAyMyBvbiBFQzIgcjZnIGFybSBpbnN0YW5jZXMpCiAgLy8gZGFyd2luLWFybTY0IGZvciBNMSBNYWNzCiAgLy8gZGViaWFuLW9wZW5zc2wtMy4wLnggZm9yIEdpdEh1YiBBY3Rpb25zIG9uIHVidW50dS1sYXRlc3QKICBiaW5hcnlUYXJnZXRzID0gWyJuYXRpdmUiLCAibGludXgtYXJtNjQtb3BlbnNzbC0zLjAueCIsICJkYXJ3aW4tYXJtNjQiLCAiZGViaWFuLW9wZW5zc2wtMy4wLngiXQp9CgpnZW5lcmF0b3IgcG90aG9zIHsKICBwcm92aWRlciAgICA9ICJwcmlzbWEtcG90aG9zLXR5cGVzIgogIHByaXNtYVV0aWxzID0gdHJ1ZQp9CgovLy8gQSBkYXkgYSB1c2VyIGhhcyBwbGFubmVkIG9yIGFscmVhZHkgZG9uZS4KLy8vIERheXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBwbGFubmVkIGFyZSB2aXJ0dWFsbHkgY3JlYXRlZCBpbiB0aGUgR3JhcGhRTCBBUEkuCm1vZGVsIERheSB7CiAgLy8vIFRoZSBkYXRlIG9mIHRoZSBkYXksIHdoaWNoIGFjdHMgYXMgdGhlIElECiAgZGF0ZSAgICAgICBEYXRlVGltZSBAaWQgQGRiLkRhdGUKICAvLy8gVGhlIG9yZGVyIG9mIHRoZSB0YXNrcyBpbiB0aGUgZGF5CiAgdGFza3NPcmRlciBJbnRbXQoKICAvLy8gVGhlIHRhc2tzIGxpbmtlZCB0byB0aGUgZGF5LgogIHRhc2tzICAgICAgICAgICAgIFRhc2tbXQogIC8vLyBUaGUgbm90ZXMgbGlua2VkIHRvIHRoZSBkYXkuCiAgbm90ZXMgICAgICAgICAgICAgTm90ZVtdCiAgLy8vIFRoZSByb3V0aW5lcyBjb21wbGV0ZWQgb24gdGhlIGRheS4KICByb3V0aW5lc0NvbXBsZXRlZCBSb3V0aW5lW10KfQoKLy8vIEEgbm90ZSB0aGF0IHRoZSB1c2VyIGhhcyBjcmVhdGVkLgptb2RlbCBOb3RlIHsKICAvLy8gVGhlIGlkIG9mIHRoZSBub3RlCiAgaWQgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSBub3RlCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgbm90ZSB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgdGhlIG5vdGUgd2FzIGNyZWF0ZWQKICBkYXRlICAgICAgRGF0ZVRpbWUgQGRiLkRhdGUKICAvLy8gVGhlIGRheSB0aGUgbm90ZSB3YXMgY3JlYXRlZAogIGRheSAgICAgICBEYXkgICAgICBAcmVsYXRpb24oZmllbGRzOiBbZGF0ZV0sIHJlZmVyZW5jZXM6IFtkYXRlXSkKICAvLy8gVGhlIHNsdWcgb2YgdGhlIG5vdGUgd2hpY2ggbmVlZHMgdG8gYmUgdW5pcXVlLgogIC8vLyBJdCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgbm90ZSBhbmQgdXBkYXRlIGl0LgogIHNsdWcgICAgICBTdHJpbmcgICBAdW5pcXVlCiAgLy8vIFRoZSB0aXRsZSBvZiB0aGUgbm90ZQogIHRpdGxlICAgICBTdHJpbmcKICAvLy8gVGhlIGNvbnRlbnQgb2YgdGhlIG5vdGUgaW4gSFRNTC4gSWYgaXQncyB0ZXh0IChpLmUuIG9uZSBsaW5lKSwKICAvLy8gaXQgd2lsbCBtb3N0IGxpa2VseSBiZSBjb252ZXJ0ZWQgdG8gSFRNTCBieSB0aGUgVGlwVGFwIGVkaXRvci4KICBjb250ZW50ICAgU3RyaW5nCgogIC8vLyBUaGUgdGFncyBvZiB0aGUgbm90ZQogIHRhZ3MgTm90ZVRhZ1tdCn0KCi8vLyBBIHRhZyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGEgbm90ZS4KbW9kZWwgTm90ZVRhZyB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgbm90ZSB0YWcKICBpZCAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIG5vdGUgdGFnCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgbm90ZSB0YWcgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub3RlIHRhZwogIG5hbWUgICAgICBTdHJpbmcKICAvLy8gVGhlIHNsdWcgKGkuZS4gdGhlIHVybC1zYWZlIHZlcnNpb24pIG9mIHRoZSBub3RlIHRhZyBuYW1lCiAgc2x1ZyAgICAgIFN0cmluZyAgIEB1bmlxdWUKICAvLy8gVGhlIGNvbG9yIG9mIHRoZSBub3RlIHRhZyBpbiBoZXgKICBjb2xvciAgICAgQ29sb3IKICAvLy8gV2hldGhlciBub3RlcyB3aXRoIHRoaXMgdGFnIHNob3VsZCBiZSBwcml2YXRlLiAoZGVmYXVsdDogdHJ1ZSkKICBpc1ByaXZhdGUgQm9vbGVhbiAgQGRlZmF1bHQodHJ1ZSkKCiAgLy8vIFRoZSBub3RlcyB3aXRoIHRoaXMgdGFnCiAgbm90ZXMgTm90ZVtdCn0KCi8vLyBBIHRhc2sgdGhhdCB0aGUgdXNlciBvciBhIHBsdWdpbiBoYXMgY3JlYXRlZC4KbW9kZWwgVGFzayB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgdGFzay4KICBpZCAgICAgICAgICAgICAgICBJbnQgICAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSB0YXNrCiAgY3JlYXRlZEF0ICAgICAgICAgRGF0ZVRpbWUgICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIHRhc2sgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCAgICAgICAgIERhdGVUaW1lICAgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgdGl0bGUgb2YgdGhlIHRhc2sgaW4gdGV4dCBvciBIVE1MLgogIHRpdGxlICAgICAgICAgICAgIFN0cmluZwogIC8vLyBUaGUgc3RhdHVzIG9mIHRoZSB0YXNrCiAgc3RhdHVzICAgICAgICAgICAgVGFza1N0YXR1cyBAZGVmYXVsdChUT0RPKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgdGFzayB3YXMgY29tcGxldGVkLgogIGNvbXBsZXRlZEF0ICAgICAgIERhdGVUaW1lPyAgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRheSB0aGUgdGFzayBpcyBzY2hlZHVsZWQgZm9yCiAgZGF5ICAgICAgICAgICAgICAgRGF5ICAgICAgICBAcmVsYXRpb24oZmllbGRzOiBbZGF0ZV0sIHJlZmVyZW5jZXM6IFtkYXRlXSkKICAvLy8gVGhlIGRhdGUgdGhlIHRhc2sgaXMgc2NoZWR1bGVkIGZvcgogIGRhdGUgICAgICAgICAgICAgIERhdGVUaW1lICAgQGRiLkRhdGUKICAvLy8gVGhlIGxlbmd0aCBvZiB0aW1lIHRoZSB0YXNrIGlzIGV4cGVjdGVkIHRvIHRha2UuCiAgZHVyYXRpb25Jbk1pbnV0ZXMgSW50PwogIC8vLyBPcmRlciBvZiB0aGUgc3VidGFza3MgaW4gdGhlIHRhc2sKICBzdWJ0YXNrc09yZGVyICAgICBJbnRbXQoKICAvLy8gVGhlIGl0ZW0gbGlua2VkIHRvIHRoZSB0YXNrCiAgaXRlbSAgIEl0ZW0/IEByZWxhdGlvbihmaWVsZHM6IFtpdGVtSWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGl0ZW1JZCBJbnQ/CgogIC8vLyBUaGUgcGFyZW50IHRhc2sgb2YgdGhlIHRhc2sKICBwYXJlbnRUYXNrICAgVGFzaz8gQHJlbGF0aW9uKCJTdWJ0YXNrIiwgZmllbGRzOiBbcGFyZW50VGFza0lkXSwgcmVmZXJlbmNlczogW2lkXSkKICBwYXJlbnRUYXNrSWQgSW50PwoKICAvLy8gVGhlIHN1YnRhc2tzIG9mIHRoZSB0YXNrCiAgc3VidGFza3MgICAgVGFza1tdICAgICAgICAgICBAcmVsYXRpb24oIlN1YnRhc2siKQogIC8vLyBUaGUgdGFncyBvZiB0aGUgdGFzayAKICB0YWdzICAgICAgICBUYXNrVGFnW10KICAvLy8gVGhlIHBsdWdpbiBkYXRhcyBvZiB0aGUgdGFzawogIHBsdWdpbkRhdGFzIFRhc2tQbHVnaW5EYXRhW10KfQoKLy8gVGhlIGRlc2NyaXB0aW9uIG9mIGVhY2ggZW51bSB2YWx1ZSBpcyBjb3BpZWQgaW50byBzcmMvZ3JhcGhxbC9UYXNrLnRzCi8vLyBUaGUgc3RhdHVzIG9mIGEgdGFzawplbnVtIFRhc2tTdGF0dXMgewogIC8vLyBXaGVuIHRoZSB0YXNrIGlzIHBsYW5uZWQgb3IgaW4gcHJvZ3Jlc3MuCiAgVE9ETwogIC8vLyBXaGVuIHRoZSB0YXNrIGlzIGRvbmUuCiAgRE9ORQogIC8vLyBXaGVuIHRoZSB0YXNrIHdhcyBkZWNpZGVkIG5vdCB0byBiZSBkb25lIGFueW1vcmUuCiAgQ0FOQ0VMRUQKfQoKLy8vIEEgdGFnIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSB0YXNrLgptb2RlbCBUYXNrVGFnIHsKICAvLy8gVGhlIGlkIG9mIHRoZSB0YXNrIHRhZwogIGlkICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgdGFzayB0YWcKICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSB0YXNrIHRhZyB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIG5hbWUgb2YgdGhlIHRhc2sgdGFnCiAgbmFtZSAgICAgIFN0cmluZwogIC8vLyBUaGUgc2x1ZyAoaS5lLiB0aGUgdXJsLXNhZmUgdmVyc2lvbikgb2YgdGhlIHRhc2sgdGFnIG5hbWUKICBzbHVnICAgICAgU3RyaW5nICAgQHVuaXF1ZQogIC8vLyBUaGUgY29sb3Igb2YgdGhlIHRhc2sgdGFnCiAgY29sb3IgICAgIENvbG9yCiAgLy8vIFdoZXRoZXIgdGFza3Mgd2l0aCB0aGlzIHRhZyBzaG91bGQgYmUgcHJpdmF0ZS4gKGRlZmF1bHQ6IHRydWUpCiAgaXNQcml2YXRlIEJvb2xlYW4gIEBkZWZhdWx0KHRydWUpCgogIC8vLyBUaGUgdGFza3MgbGlua2VkIHRvIHRoZSB0YWcKICB0YXNrcyBUYXNrW10KICAvLy8gdGhlIGl0ZW1zIGxpbmtlZCB0byB0aGUgdGFnCiAgaXRlbXMgSXRlbVtdCn0KCi8vLyBUaGUgZGF0YSByZXF1aXJlZCBieSBhIHBsdWdpbiB0byBiZSBsaW5rZWQgdG8gYSB0YXNrLgptb2RlbCBUYXNrUGx1Z2luRGF0YSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgdGFzayBwbHVnaW4gZGF0YQogIGlkICAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIHRhc2sgcGx1Z2luIGRhdGEKICBjcmVhdGVkQXQgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgdGFzayBwbHVnaW4gZGF0YSB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0ICBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBtaW5pbXVtIGRhdGEgcmVxdWlyZWQgdG8gcmVuZGVyIHRoZSBpbmZvcm1hdGlvbiBvbiB0YXNrIGNhcmRzLgogIG1pbiAgICAgICAgSnNvbgogIC8vLyBUaGUgZnVsbCBkYXRhIHJlcXVpcmVkIGJ5IHRoZSBwbHVnaW4gdG8gYmUgbGlua2VkIHRvIHRoZSB0YXNrLgogIGZ1bGwgICAgICAgSnNvbgogIC8vLyBUaGUgc2x1ZyBvZiB0aGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgZGF0YQogIHBsdWdpblNsdWcgU3RyaW5nCiAgLy8vIFRoZSBvcmlnaW5hbCBpZCBvZiB0aGUgdGFzayBnaXZlbiBieSB0aGUgcGx1Z2luLCBpZiBhbnkKICBvcmlnaW5hbElkIFN0cmluZz8KCiAgLy8vIFRoZSB0YXNrIGxpbmtlZCB0byB0aGUgcGx1Z2luIGRhdGEKICB0YXNrICAgVGFzayBAcmVsYXRpb24oZmllbGRzOiBbdGFza0lkXSwgcmVmZXJlbmNlczogW2lkXSwgb25EZWxldGU6IENhc2NhZGUpCiAgdGFza0lkIEludAp9CgovLy8gVGhlIGRhdGEgYSBwbHVnaW4gbGlua3MgdG8gYW4gaXRlbS4KbW9kZWwgSXRlbVBsdWdpbkRhdGEgewogIC8vLyBUaGUgaWQgb2YgdGhlIGl0ZW0gcGx1Z2luIGRhdGEKICBpZCAgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSBpdGVtIHBsdWdpbiBkYXRhCiAgY3JlYXRlZEF0ICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIGl0ZW0gcGx1Z2luIGRhdGEgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCAgRGF0ZVRpbWUgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbWluaW11bSBkYXRhIHJlcXVpcmVkIHRvIHJlbmRlciB0aGUgaW5mb3JtYXRpb24gb24gaXRlbSBjYXJkcy4KICBtaW4gICAgICAgIEpzb24KICAvLy8gVGhlIGZ1bGwgZGF0YSByZXF1aXJlZCBieSB0aGUgcGx1Z2luIHRvIGJlIGxpbmtlZCB0byB0aGUgaXRlbS4KICBmdWxsICAgICAgIEpzb24KICAvLy8gVGhlIHNsdWcgb2YgdGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIGRhdGEKICBwbHVnaW5TbHVnIFN0cmluZwogIC8vLyBUaGUgb3JpZ2luYWwgaWQgb2YgdGhlIGl0ZW0gZ2l2ZW4gYnkgdGhlIHBsdWdpbiwgaWYgYW55CiAgb3JpZ2luYWxJZCBTdHJpbmc/CgogIC8vLyBUaGUgaXRlbSBsaW5rZWQgdG8gdGhlIHBsdWdpbiBkYXRhCiAgaXRlbSAgIEl0ZW0gQHJlbGF0aW9uKGZpZWxkczogW2l0ZW1JZF0sIHJlZmVyZW5jZXM6IFtpZF0sIG9uRGVsZXRlOiBDYXNjYWRlKQogIGl0ZW1JZCBJbnQKfQoKLy8vIEFuIGl0ZW0gY3JlYXRlZCBieSB0aGUgdXNlciBvciBhIHBsdWdpbi4gVGhlIHVzZXIgY2FuIHRoZW4gY3JlYXRlIDEgb3IgbW9yZSB0YXNrcyBmcm9tIHRoZSBpdGVtLgovLy8gSXQgY2FuIGJlIGEgY2FsZW5kYXIgZXZlbnQsIGEgVHJlbGxvIHRhc2ssIGEgTGluZWFyIGlzc3VlLCBhIEdpdEh1YiByZXF1ZXN0IGZvciByZXZpZXcsIGEgbm90aWZpY2F0aW9uLCBldGMuCm1vZGVsIEl0ZW0gewogIC8vLyBUaGUgaWQgb2YgdGhlIGl0ZW0KICBpZCAgICAgICAgICAgICAgICBJbnQgICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIGl0ZW0KICBjcmVhdGVkQXQgICAgICAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBpdGVtIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICAgICAgICBEYXRlVGltZSAgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgdGl0bGUgb2YgdGhlIGl0ZW0uCiAgLy8vIEl0IGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgdGl0bGUgd2hlbiBjcmVhdGluZyBhIHRhc2sgZnJvbSB0aGUgaXRlbS4KICB0aXRsZSAgICAgICAgICAgICBTdHJpbmcKICAvLy8gV2hldGhlciB0aGUgaXRlbSBpcyByZWxldmFudCB0byB0aGUgdXNlciBhbmQgc2hvdWxkIGJlIHNob3duLiAoZGVmYXVsdDogdHJ1ZSkKICAvLy8gRm9yIGV4YW1wbGUgd2hlbiBhIHBsdWdpbiBjcmVhdGVzIGFuIGl0ZW0gZm9yIGEgVHJlbGxvIHRhc2ssIHRoZW4gbGF0ZXIgb24gdGhlIHVzZXIgYXJoaXZlcyB0aGUgdGFzaywgdGhlIGl0ZW0gaXMgbm8gbG9uZ2VyIHJlbGV2YW50LgogIGlzUmVsZXZhbnQgICAgICAgIEJvb2xlYW4gICBAZGVmYXVsdCh0cnVlKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgaXRlbSBpcyBzY2hlZHVsZWQgZm9yLgogIHNjaGVkdWxlZEF0ICAgICAgIERhdGVUaW1lPyBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbGVuZ3RoIG9mIHRpbWUgdGhlIGl0ZW0gaXMgZXhwZWN0ZWQgdG8gdGFrZS4gSWYgdGhlIGl0ZW0gaXMgYWxsLWRheSwgdGhpcyBpcyBudWxsLgogIGR1cmF0aW9uSW5NaW51dGVzIEludD8KICAvLy8gV2hldGhlciB0aGUgaXRlbSBpcyBhbGwtZGF5IG9uIHRoZSBkYXRlIG9mIGBzY2hlZHVsZWRBdGAuCiAgaXNBbGxEYXkgICAgICAgICAgQm9vbGVhbiAgIEBkZWZhdWx0KGZhbHNlKQogIC8vLyBUaGUgdGFpbHdpbmQgY29sb3Igb2YgdGhlIGl0ZW0uIFVzZWQgaW4gdGhlIGNhbGVuZGFyIHZpZXcuCiAgY29sb3IgICAgICAgICAgICAgQ29sb3I/CiAgLy8vIFRoZSBudW1iZXIgb2YgaW5ib3ggcG9pbnRzIHRoZSBpdGVtIGhhcyB0byBiZSBzaG93biBpbiB0aGUgaW5ib3guCiAgLy8vIFRoZSBtb3JlIGluYm94IHBvaW50cyBhbiBpdGVtIGhhcywgdGhlIGhpZ2hlciBpdCBpcyBpbiB0aGUgaW5ib3guCiAgaW5ib3hQb2ludHMgICAgICAgSW50PwoKICAvLy8gVGhlIHRhc2tzIGxpbmtlZCB0byB0aGUgaXRlbQogIHRhc2tzICAgICAgIFRhc2tbXQogIC8vLyBUaGUgdGFncyBsaW5rZWQgdG8gdGhlIGl0ZW0KICB0YWdzICAgICAgICBUYXNrVGFnW10KICAvLy8gVGhlIHBsdWdpbiBkYXRhcyBsaW5rZWQgdG8gdGhlIGl0ZW0KICBwbHVnaW5EYXRhcyBJdGVtUGx1Z2luRGF0YVtdCiAgLy8vIFRoZSBsaXN0IGluIHdoaWNoIHRoZSBpdGVtIGlzIGluCiAgbGlzdCAgICAgICAgTGlzdD8gICAgICAgICAgICBAcmVsYXRpb24oZmllbGRzOiBbbGlzdElkXSwgcmVmZXJlbmNlczogW2lkXSkKICBsaXN0SWQgICAgICBJbnQ/Cn0KCi8vLyBMaXN0IG9mIGl0ZW1zCm1vZGVsIExpc3QgewogIC8vLyBUaGUgaWQgb2YgdGhlIGxpc3QKICBpZCAgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgbGlzdAogIGNyZWF0ZWRBdCAgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgbGlzdCB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0ICAgRGF0ZVRpbWUgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbmFtZSBvZiB0aGUgbGlzdAogIG5hbWUgICAgICAgIFN0cmluZwogIC8vLyBUaGUgc2x1ZyAoaS5lLiB0aGUgdXJsLXNhZmUgdmVyc2lvbikgb2YgdGhlIGxpc3QgbmFtZQogIHNsdWcgICAgICAgIFN0cmluZyAgIEB1bmlxdWUKICAvLy8gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBsaXN0CiAgZGVzY3JpcHRpb24gU3RyaW5nPwoKICAvLy8gVGhlIGl0ZW1zIGxpbmtlZCB0byB0aGUgbGlzdAogIGl0ZW1zIEl0ZW1bXQp9CgovLy8gQSBrZXktdmFsdWUgc3RvcmUgY29udGFpbmluZyBzZXR0aW5ncyB0aGUgdXNlciBoYXMgbW9kaWZpZWQgZm9yIGJvdGggRmxvdyBhbmQgcGx1Z2lucyAoYnkgY29udmVudGlvbiwgdGhlIGtleSBpcyBwcmVmaXhlZCB3aXRoIHRoZSBwbHVnaW4ncyBzbHVnKSwgb3IgY29uZmlncyBhbmQgc2VjcmVudHMgdGhhdCBwbHVnaW5zIGhhdmUgc3RvcmVkIHN1Y2ggYXMgQVBJIGtleXMuCm1vZGVsIFN0b3JlIHsKICAvLy8gVGhlIGlkIG9mIHRoZSBzdG9yZSBpdGVtCiAgaWQgICAgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSBzdG9yZSBpdGVtCiAgY3JlYXRlZEF0ICAgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgc3RvcmUgaXRlbSB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0ICAgIERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGtleSBvZiB0aGUgc3RvcmUgaXRlbQogIGtleSAgICAgICAgICBTdHJpbmcKICAvLy8gVGhlIHZhbHVlIG9mIHRoZSBzdG9yZSBpdGVtCiAgdmFsdWUgICAgICAgIEpzb24KICAvLy8gVGhlIHNsdWcgb2YgdGhlIHBsdWdpbiB0aGUgc3RvcmUgaXRlbSBpcyBsaW5rZWQgdG8uCiAgcGx1Z2luU2x1ZyAgIFN0cmluZwogIC8vLyBXaGV0aGVyIHRoZSBzdG9yZSBpdGVtIGlzIHNlY3JldC4KICAvLy8gU2VjcmV0IGl0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IHNlcnZlci1vbmx5IGFzIHdlbGwgKGV2ZW4gaWYgdGhlIHZhbHVlIG9mIGlzU2VydmVyT25seSBpcyBmYWxzZSkKICAvLy8gYW5kIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGJ5IHRoZSBwbHVnaW4gd2l0aCB0aGUgc2FtZSBwbHVnaW5TbHVnLgogIGlzU2VjcmV0ICAgICBCb29sZWFuICBAZGVmYXVsdChmYWxzZSkKICAvLy8gV2hldGhlciB0aGUgc3RvcmUgaXRlbSBpcyBzZXJ2ZXItb25seS4KICAvLy8gU2VydmVyLW9ubHkgaXRlbXMgYXJlIG5vdCBzZW50IHRvIHRoZSBjbGllbnQuCiAgaXNTZXJ2ZXJPbmx5IEJvb2xlYW4gIEBkZWZhdWx0KGZhbHNlKQoKICBAQHVuaXF1ZShbcGx1Z2luU2x1Zywga2V5XSwgbmFtZTogInBsdWdpblNsdWdfa2V5X3VuaXF1ZSIpCn0KCi8vLyBBIHJvdXRpbmUgdGhlIHVzZXIgaGFzIHNldCB1cC4KbW9kZWwgUm91dGluZSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgcm91dGluZQogIGlkICAgICAgICAgICAgICBJbnQgICAgICAgICAgICAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSByb3V0aW5lCiAgY3JlYXRlZEF0ICAgICAgIERhdGVUaW1lICAgICAgICAgICAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSByb3V0aW5lIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICAgICAgRGF0ZVRpbWUgICAgICAgICAgICBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBuYW1lIG9mIHRoZSByb3V0aW5lCiAgbmFtZSAgICAgICAgICAgIFN0cmluZwogIC8vLyBBY3Rpb24gbmFtZSB1c2VkIG9uIHRoZSBidXR0b24gdG8gc3RhcnQgdGhlIHJvdXRpbmUKICBhY3Rpb25OYW1lICAgICAgU3RyaW5nCiAgLy8vIFRoZSB0aW1lIHRoZSByb3V0aW5lIHRha2VzIHBsYWNlCiAgdGltZSAgICAgICAgICAgIERhdGVUaW1lICAgICAgICAgICAgQGRiLlRpbWUoMCkKICAvLy8gVGhlIHBhdHRlcm4ocykgdGhlIHJvdXRpbmUgcmVwZWF0cyBvbgogIHJlcGVhdHMgICAgICAgICBSZXBldGl0aW9uUGF0dGVybltdCiAgLy8vIFRoZSBkYXRlIHRoZSByb3V0aW5lIHN0YXJ0cyByZXBlYXRpbmcgZnJvbQogIGZpcnN0RGF5ICAgICAgICBEYXRlVGltZSAgICAgICAgICAgIEBkZWZhdWx0KG5vdygpKSBAZGIuRGF0ZQogIC8vLyBUaGUgZGF0ZSB0aGUgcm91dGluZSBlbmQgcmVwZWF0aW5nIG9uCiAgbGFzdERheSAgICAgICAgIERhdGVUaW1lPyAgICAgICAgICAgQGRiLkRhdGUKICAvLy8gV2hldGhlciB0aGUgcm91dGluZSBpcyBhY3RpdmUuIFRoaXMgY2FuIGJlIHVzZWQgdG8gcGF1c2UgYSByb3V0aW5lLgogIGlzQWN0aXZlICAgICAgICBCb29sZWFuICAgICAgICAgICAgIEBkZWZhdWx0KHRydWUpCiAgLy8vIFRoZSBzdGVwcyBvZiB0aGUgcm91dGluZS4KICBzdGVwcyAgICAgICAgICAgUm91dGluZVN0ZXBbXQogIC8vLyBUaGUgb3JkZXIgdGhlIHN0ZXBzIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4KICBzdGVwc09yZGVyICAgICAgSW50W10KICAvLy8gVGhlIGRheXMgdGhlIHJvdXRpbmUgaGFzIGJlZW4gY29tcGxldGVkIG9uLgogIGRheXNDb21wbGV0ZWRPbiBEYXlbXQp9Cgptb2RlbCBSb3V0aW5lU3RlcCB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgc3RlcAogIGlkICAgICAgICAgSW50ICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgcGx1Z2luIHNsdWcgb2YgdGhlIHN0ZXAKICBwbHVnaW5TbHVnIFN0cmluZwogIC8vLyBUaGUgc3RlcCBzbHVnIG9mIHRoZSBzdGVwCiAgc3RlcFNsdWcgICBTdHJpbmcKICAvLy8gV2hldGhlciB0aGUgc3RlcCBzaG91bGQgYmUgc2tpcHBlZCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBsZXRlZCBpbiB0aGUgcHJldmlvdXMgcm91dGluZQogIHNob3VsZFNraXAgQm9vbGVhbgogIC8vLyBFeHRyYSBkYXRhIHRvIGNvbmZpZ3VyZSB0aGUgc3RlcAogIGNvbmZpZyAgICAgSnNvbj8KCiAgLy8vIFRoZSByb3V0aW5lIHRoZSBzdGVwIGlzIGluCiAgcm91dGluZSAgIFJvdXRpbmUgQHJlbGF0aW9uKGZpZWxkczogW3JvdXRpbmVJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgLy8vIFRoZSBpZCBvZiByb3V0aW5lIHRoZSBzdGVwIGlzIGluCiAgcm91dGluZUlkIEludAoKICAvLy8gVGhlIHRlbXBsYXRlcyB0aGUgc3RlcCB1c2VzCiAgdGVtcGxhdGVzIFRlbXBsYXRlW10KfQoKbW9kZWwgVGVtcGxhdGUgewogIC8vLyBUaGUgc2x1ZyBhbmQgaWQgb2YgdGhlIHRlbXBsYXRlCiAgc2x1ZyAgICAgIFN0cmluZyAgIEBpZAogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgdGVtcGxhdGUKICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSB0ZW1wbGF0ZSB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIEhhbmRsZWJhcnMgdGVtcGxhdGUgLS0gaHR0cHM6Ly9oYW5kbGViYXJzanMuY29tL2d1aWRlCiAgdGVtcGxhdGUgIFN0cmluZwogIC8vLyBFeHRyYSBkYXRhIGF0dGFjaGVkIHRvIHRoZSB0ZW1wbGF0ZS4KICBtZXRhZGF0YSAgSnNvbj8KCiAgLy8vIFRoZSByb3V0aW5lU3RlcCAoaWYgYW55KSB0aGUgdGVtcGxhdGUgaXMgdXNlZCBpbgogIHJvdXRpbmVTdGVwICAgUm91dGluZVN0ZXA/IEByZWxhdGlvbihmaWVsZHM6IFtyb3V0aW5lU3RlcElkXSwgcmVmZXJlbmNlczogW2lkXSkKICAvLy8gVGhlIGlkIG9mIHRoZSByb3V0aW5lU3RlcCAoaWYgYW55KSB0aGUgdGVtcGxhdGUgaXMgdXNlZCBpbgogIHJvdXRpbmVTdGVwSWQgSW50Pwp9CgplbnVtIFJlcGV0aXRpb25QYXR0ZXJuIHsKICBNT05EQVkKICBUVUVTREFZCiAgV0VETkVTREFZCiAgVEhVUlNEQVkKICBGUklEQVkKICBTQVRVUkRBWQogIFNVTkRBWQoKICAvLyBmb2xsb3dpbmcgd2lsbCBiZSBhZGRlZCBsYXRlcgogIC8vIEJJV0VFS0xZX01PTkRBWQogIC8vIEJJV0VFS0xZX1RVRVNEQVkKICAvLyBCSVdFRUtMWV9XRURORVNEQVkKICAvLyBCSVdFRUtMWV9USFVSU0RBWQogIC8vIEJJV0VFS0xZX0ZSSURBWQogIC8vIEJJV0VFS0xZX1NBVFVSREFZCiAgLy8gQklXRUVLTFlfU1VOREFZCiAgLy8gVFJJV0VFS0xZX01PTkRBWQogIC8vIFRSSVdFRUtMWV9UVUVTREFZCiAgLy8gVFJJV0VFS0xZX1dFRE5FU0RBWQogIC8vIFRSSVdFRUtMWV9USFVSU0RBWQogIC8vIFRSSVdFRUtMWV9GUklEQVkKICAvLyBUUklXRUVLTFlfU0FUVVJEQVkKICAvLyBUUklXRUVLTFlfU1VOREFZCiAgLy8gRklSU1RfT0ZfTU9OVEgKICAvLyBMQVNUX09GX01PTlRICn0KCi8vLyBUYWlsd2luZENTUyBjb2xvcnMuIFVzZWZ1bCB0byBnZW5lcmF0ZSBhIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgZnJvbSBlYWNoIGNvbG9yLAovLy8gaW5zdGVhZCBvZiBoYXZpbmcgaW5kZXBlbmRlbnQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvcnMKZW51bSBDb2xvciB7CiAgc2xhdGUKICBncmF5CiAgemluYwogIG5ldXRyYWwKICBzdG9uZQogIHJlZAogIG9yYW5nZQogIGFtYmVyCiAgeWVsbG93CiAgbGltZQogIGdyZWVuCiAgZW1lcmFsZAogIHRlYWwKICBjeWFuCiAgc2t5CiAgYmx1ZQogIGluZGlnbwogIHZpb2xldAogIHB1cnBsZQogIGZ1Y2hzaWEKICBwaW5rCiAgcm9zZQp9Cg==",
    inlineSchemaHash: "74724be2f4231e3263c485ff9942bf6e7f07747b6e0c06bd59753d0c7299a6e5",
    noEngine: false
  };
  var fs = import.meta.require("fs");
  config.dirname = import.meta.dir;
  if (!fs.existsSync(path.join(import.meta.dir, "schema.prisma"))) {
    const alternativePaths = [
      "../../node_modules/.prisma/client",
      "../node_modules/.prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config.dirname = path.join(process.cwd(), alternativePath);
    config.isBundled = true;
  }
  config.runtimeDataModel = JSON.parse("{\"models\":{\"Day\":{\"dbName\":null,\"fields\":[{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date of the day, which acts as the ID\"},{\"name\":\"tasksOrder\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The order of the tasks in the day\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"DayToTask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the day.\"},{\"name\":\"notes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Note\",\"relationName\":\"DayToNote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The notes linked to the day.\"},{\"name\":\"routinesCompleted\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Routine\",\"relationName\":\"DayToRoutine\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The routines completed on the day.\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A day a user has planned or already done.\\\\nDays that have not yet been planned are virtually created in the GraphQL API.\"},\"Note\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the note\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the note\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the note was last updated\"},{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the note was created\"},{\"name\":\"day\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToNote\",\"relationFromFields\":[\"date\"],\"relationToFields\":[\"date\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The day the note was created\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the note which needs to be unique.\\\\nIt can be used to retrieve the note and update it.\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the note\"},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The content of the note in HTML. If it's text (i.e. one line),\\\\nit will most likely be converted to HTML by the TipTap editor.\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"NoteTag\",\"relationName\":\"NoteToNoteTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags of the note\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A note that the user has created.\"},\"NoteTag\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the note tag\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the note tag\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the note tag was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the note tag\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the note tag name\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The color of the note tag in hex\"},{\"name\":\"isPrivate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether notes with this tag should be private. (default: true)\"},{\"name\":\"notes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Note\",\"relationName\":\"NoteToNoteTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The notes with this tag\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A tag that can be applied to a note.\"},\"Task\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task.\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task was last updated\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the task in text or HTML.\"},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"TaskStatus\",\"default\":\"TODO\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The status of the task\"},{\"name\":\"completedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time the task was completed.\"},{\"name\":\"day\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToTask\",\"relationFromFields\":[\"date\"],\"relationToFields\":[\"date\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The day the task is scheduled for\"},{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the task is scheduled for\"},{\"name\":\"durationInMinutes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The length of time the task is expected to take.\"},{\"name\":\"subtasksOrder\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Order of the subtasks in the task\"},{\"name\":\"item\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToTask\",\"relationFromFields\":[\"itemId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The item linked to the task\"},{\"name\":\"itemId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"parentTask\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"Subtask\",\"relationFromFields\":[\"parentTaskId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The parent task of the task\"},{\"name\":\"parentTaskId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"subtasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"Subtask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The subtasks of the task\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskTag\",\"relationName\":\"TaskToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags of the task \"},{\"name\":\"pluginDatas\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskPluginData\",\"relationName\":\"TaskToTaskPluginData\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin datas of the task\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A task that the user or a plugin has created.\"},\"TaskTag\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task tag\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task tag\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task tag was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the task tag\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the task tag name\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The color of the task tag\"},{\"name\":\"isPrivate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether tasks with this tag should be private. (default: true)\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"TaskToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the tag\"},{\"name\":\"items\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"the items linked to the tag\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A tag that can be applied to a task.\"},\"TaskPluginData\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task plugin data\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task plugin data\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task plugin data was last updated\"},{\"name\":\"min\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The minimum data required to render the information on task cards.\"},{\"name\":\"full\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The full data required by the plugin to be linked to the task.\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin that created the data\"},{\"name\":\"originalId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The original id of the task given by the plugin, if any\"},{\"name\":\"task\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"TaskToTaskPluginData\",\"relationFromFields\":[\"taskId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The task linked to the plugin data\"},{\"name\":\"taskId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"The data required by a plugin to be linked to a task.\"},\"ItemPluginData\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the item plugin data\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the item plugin data\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the item plugin data was last updated\"},{\"name\":\"min\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The minimum data required to render the information on item cards.\"},{\"name\":\"full\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The full data required by the plugin to be linked to the item.\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin that created the data\"},{\"name\":\"originalId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The original id of the item given by the plugin, if any\"},{\"name\":\"item\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToItemPluginData\",\"relationFromFields\":[\"itemId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The item linked to the plugin data\"},{\"name\":\"itemId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"The data a plugin links to an item.\"},\"Item\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the item\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the item\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the item was last updated\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the item.\\\\nIt is used as the initial title when creating a task from the item.\"},{\"name\":\"isRelevant\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the item is relevant to the user and should be shown. (default: true)\\\\nFor example when a plugin creates an item for a Trello task, then later on the user arhives the task, the item is no longer relevant.\"},{\"name\":\"scheduledAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time the item is scheduled for.\"},{\"name\":\"durationInMinutes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The length of time the item is expected to take. If the item is all-day, this is null.\"},{\"name\":\"isAllDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the item is all-day on the date of `scheduledAt`.\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tailwind color of the item. Used in the calendar view.\"},{\"name\":\"inboxPoints\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The number of inbox points the item has to be shown in the inbox.\\\\nThe more inbox points an item has, the higher it is in the inbox.\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"ItemToTask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the item\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskTag\",\"relationName\":\"ItemToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags linked to the item\"},{\"name\":\"pluginDatas\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"ItemPluginData\",\"relationName\":\"ItemToItemPluginData\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin datas linked to the item\"},{\"name\":\"list\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"List\",\"relationName\":\"ItemToList\",\"relationFromFields\":[\"listId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The list in which the item is in\"},{\"name\":\"listId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"An item created by the user or a plugin. The user can then create 1 or more tasks from the item.\\\\nIt can be a calendar event, a Trello task, a Linear issue, a GitHub request for review, a notification, etc.\"},\"List\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the list\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the list\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the list was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the list\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the list name\"},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The description of the list\"},{\"name\":\"items\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToList\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The items linked to the list\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"List of items\"},\"Store\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the store item\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the store item\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the store item was last updated\"},{\"name\":\"key\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The key of the store item\"},{\"name\":\"value\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The value of the store item\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin the store item is linked to.\"},{\"name\":\"isSecret\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the store item is secret.\\\\nSecret items are automatically server-only as well (even if the value of isServerOnly is false)\\\\nand can only be accessed by the plugin with the same pluginSlug.\"},{\"name\":\"isServerOnly\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the store item is server-only.\\\\nServer-only items are not sent to the client.\"}],\"primaryKey\":null,\"uniqueFields\":[[\"pluginSlug\",\"key\"]],\"uniqueIndexes\":[{\"name\":\"pluginSlug_key_unique\",\"fields\":[\"pluginSlug\",\"key\"]}],\"isGenerated\":false,\"documentation\":\"A key-value store containing settings the user has modified for both Flow and plugins (by convention, the key is prefixed with the plugin's slug), or configs and secrents that plugins have stored such as API keys.\"},\"Routine\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the routine\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the routine\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the routine was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the routine\"},{\"name\":\"actionName\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Action name used on the button to start the routine\"},{\"name\":\"time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The time the routine takes place\"},{\"name\":\"repeats\",\"kind\":\"enum\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"RepetitionPattern\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The pattern(s) the routine repeats on\"},{\"name\":\"firstDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the routine starts repeating from\"},{\"name\":\"lastDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the routine end repeating on\"},{\"name\":\"isActive\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the routine is active. This can be used to pause a routine.\"},{\"name\":\"steps\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"RoutineStep\",\"relationName\":\"RoutineToRoutineStep\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The steps of the routine.\"},{\"name\":\"stepsOrder\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The order the steps should be displayed in\"},{\"name\":\"daysCompletedOn\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToRoutine\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The days the routine has been completed on.\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A routine the user has set up.\"},\"RoutineStep\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the step\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin slug of the step\"},{\"name\":\"stepSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The step slug of the step\"},{\"name\":\"shouldSkip\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the step should be skipped if it has already been completed in the previous routine\"},{\"name\":\"config\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Extra data to configure the step\"},{\"name\":\"routine\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Routine\",\"relationName\":\"RoutineToRoutineStep\",\"relationFromFields\":[\"routineId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The routine the step is in\"},{\"name\":\"routineId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of routine the step is in\"},{\"name\":\"templates\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Template\",\"relationName\":\"RoutineStepToTemplate\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The templates the step uses\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Template\":{\"dbName\":null,\"fields\":[{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug and id of the template\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the template\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the template was last updated\"},{\"name\":\"template\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The Handlebars template -- https://handlebarsjs.com/guide\"},{\"name\":\"metadata\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Extra data attached to the template.\"},{\"name\":\"routineStep\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"RoutineStep\",\"relationName\":\"RoutineStepToTemplate\",\"relationFromFields\":[\"routineStepId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The routineStep (if any) the template is used in\"},{\"name\":\"routineStepId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the routineStep (if any) the template is used in\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"TaskStatus\":{\"values\":[{\"name\":\"TODO\",\"dbName\":null,\"documentation\":\"When the task is planned or in progress.\"},{\"name\":\"DONE\",\"dbName\":null,\"documentation\":\"When the task is done.\"},{\"name\":\"CANCELED\",\"dbName\":null,\"documentation\":\"When the task was decided not to be done anymore.\"}],\"dbName\":null,\"documentation\":\"The status of a task\"},\"RepetitionPattern\":{\"values\":[{\"name\":\"MONDAY\",\"dbName\":null},{\"name\":\"TUESDAY\",\"dbName\":null},{\"name\":\"WEDNESDAY\",\"dbName\":null},{\"name\":\"THURSDAY\",\"dbName\":null},{\"name\":\"FRIDAY\",\"dbName\":null},{\"name\":\"SATURDAY\",\"dbName\":null},{\"name\":\"SUNDAY\",\"dbName\":null}],\"dbName\":null},\"Color\":{\"values\":[{\"name\":\"slate\",\"dbName\":null},{\"name\":\"gray\",\"dbName\":null},{\"name\":\"zinc\",\"dbName\":null},{\"name\":\"neutral\",\"dbName\":null},{\"name\":\"stone\",\"dbName\":null},{\"name\":\"red\",\"dbName\":null},{\"name\":\"orange\",\"dbName\":null},{\"name\":\"amber\",\"dbName\":null},{\"name\":\"yellow\",\"dbName\":null},{\"name\":\"lime\",\"dbName\":null},{\"name\":\"green\",\"dbName\":null},{\"name\":\"emerald\",\"dbName\":null},{\"name\":\"teal\",\"dbName\":null},{\"name\":\"cyan\",\"dbName\":null},{\"name\":\"sky\",\"dbName\":null},{\"name\":\"blue\",\"dbName\":null},{\"name\":\"indigo\",\"dbName\":null},{\"name\":\"violet\",\"dbName\":null},{\"name\":\"purple\",\"dbName\":null},{\"name\":\"fuchsia\",\"dbName\":null},{\"name\":\"pink\",\"dbName\":null},{\"name\":\"rose\",\"dbName\":null}],\"dbName\":null,\"documentation\":\"TailwindCSS colors. Useful to generate a foreground and background color from each color,\\\\ninstead of having independent foreground and background colors\"}},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(import.meta.dir, "libquery_engine-darwin-arm64.dylib.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-darwin-arm64.dylib.node");
  path.join(import.meta.dir, "libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  path.join(import.meta.dir, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(import.meta.dir, "schema.prisma");
  path.join(process.cwd(), "../../node_modules/.prisma/client/schema.prisma");
});

// ../../node_modules/@prisma/client/index.js
var require_client2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_client()
  };
});

// ../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e();
  })(exports, function() {
    var t = 1000, e = 60000, n = 3600000, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t(e2, n2) {
      if (e2.date() < n2.date())
        return -t(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === undefined;
    } }, g = "en", D = {};
    D[g] = M;
    var p = function(t2) {
      return t2 instanceof _;
    }, S = function t(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if (typeof e2 == "string") {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, w = function(t2, e2) {
      if (p(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, O = v;
    O.l = S, O.i = p, O.w = function(t2, e2) {
      return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var { date: e2, utc: n2 } = t3;
          if (e2 === null)
            return new Date(NaN);
          if (O.u(e2))
            return new Date;
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = w(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return w(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < w(t2);
      }, m2.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), l2 = function(t3, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (h2) {
          case c:
            return r2 ? l2(1, 0) : l2(31, 11);
          case f:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[O.p(t2)]();
      }, m2.add = function(r2, h2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = O.p(h2), y2 = function(t2) {
          var e2 = w(l2);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($2 === f)
          return this.set(f, this.$M + r2);
        if ($2 === c)
          return this.set(c, this.$y + r2);
        if ($2 === a)
          return y2(1);
        if ($2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, c2 = function(t3) {
          return O.s(s2 % 12 || 12, t3, "0");
        }, d2 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e3) {
          return e3 || $2[t3] || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
        return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h] = g2 / 3, $2[o] = (v2 - m3) / 604800000, $2[a] = (v2 - m3) / 86400000, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t, $2)[y2] || v2, l2 ? g2 : O.a(g2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
      T[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
      return w(1000 * t2);
    }, w.en = D[g], w.Ls = D, w.p = {}, w;
  });
});

// ../../node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
  })(exports, function() {
    var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e2) {
      return (e2 = +e2) + (e2 > 68 ? 1900 : 2000);
    };
    var a = function(e2) {
      return function(t2) {
        this[e2] = +t2;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
      (this.zone || (this.zone = {})).offset = function(e3) {
        if (!e3)
          return 0;
        if (e3 === "Z")
          return 0;
        var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
        return n2 === 0 ? 0 : t2[0] === "+" ? -n2 : n2;
      }(e2);
    }], h = function(e2) {
      var t2 = o[e2];
      return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
    }, u = function(e2, t2) {
      var n2, r2 = o.meridiem;
      if (r2) {
        for (var i2 = 1;i2 <= 24; i2 += 1)
          if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = e2 === (t2 ? "pm" : "PM");
      return n2;
    }, d = { A: [i, function(e2) {
      this.afternoon = u(e2, false);
    }], a: [i, function(e2) {
      this.afternoon = u(e2, true);
    }], S: [/\d/, function(e2) {
      this.milliseconds = 100 * +e2;
    }], SS: [n, function(e2) {
      this.milliseconds = 10 * +e2;
    }], SSS: [/\d{3}/, function(e2) {
      this.milliseconds = +e2;
    }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
      var t2 = o.ordinal, n2 = e2.match(/\d+/);
      if (this.day = n2[0], t2)
        for (var r2 = 1;r2 <= 31; r2 += 1)
          t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
    }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
      var t2 = h("months"), n2 = (h("monthsShort") || t2.map(function(e3) {
        return e3.slice(0, 3);
      })).indexOf(e2) + 1;
      if (n2 < 1)
        throw new Error;
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(e2) {
      var t2 = h("months").indexOf(e2) + 1;
      if (t2 < 1)
        throw new Error;
      this.month = t2 % 12 || t2;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
      this.year = s(e2);
    }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
    function c(n2) {
      var r2, i2;
      r2 = n2, i2 = o && o.formats;
      for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
        var o2 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
          return t3 || n4.slice(1);
        });
      })).match(t), a2 = s2.length, f2 = 0;f2 < a2; f2 += 1) {
        var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l = u2 && u2[1];
        s2[f2] = l ? { regex: c2, parser: l } : h2.replace(/^\[|\]$/g, "");
      }
      return function(e2) {
        for (var t2 = {}, n3 = 0, r3 = 0;n3 < a2; n3 += 1) {
          var i3 = s2[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var { regex: o2, parser: f3 } = i3, h3 = e2.slice(r3), u3 = o2.exec(h3)[0];
            f3.call(t2, u3), e2 = e2.replace(u3, "");
          }
        }
        return function(e3) {
          var t3 = e3.afternoon;
          if (t3 !== undefined) {
            var n4 = e3.hours;
            t3 ? n4 < 12 && (e3.hours += 12) : n4 === 12 && (e3.hours = 0), delete e3.afternoon;
          }
        }(t2), t2;
      };
    }
    return function(e2, t2, n2) {
      n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
      var r2 = t2.prototype, i2 = r2.parse;
      r2.parse = function(e3) {
        var { date: t3, utc: r3, args: s2 } = e3;
        this.$u = r3;
        var a2 = s2[1];
        if (typeof a2 == "string") {
          var f2 = s2[2] === true, h2 = s2[3] === true, u2 = f2 || h2, d2 = s2[2];
          h2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
            try {
              if (["x", "X"].indexOf(t4) > -1)
                return new Date((t4 === "X" ? 1000 : 1) * e4);
              var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h3 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = new Date, m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
              i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
              var p = a3 || 0, v = f3 || 0, D = h3 || 0, g = u3 || 0;
              return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1000)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
            } catch (e5) {
              return new Date("");
            }
          }(t3, a2, r3), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l = a2.length, m = 1;m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M = n2.apply(this, s2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          }
        else
          i2.call(this, e3);
      };
    };
  });
});

// ../../node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS((exports, module) => {
  (function(t, i) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_utc = i();
  })(exports, function() {
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
      var u = f.prototype;
      n.utc = function(t2) {
        var i2 = { date: t2, utc: true, args: arguments };
        return new f(i2);
      }, u.utc = function(i2) {
        var e2 = n(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e2.add(this.utcOffset(), t) : e2;
      }, u.local = function() {
        return n(this.toDate(), { locale: this.$L, utc: false });
      };
      var o = u.parse;
      u.parse = function(t2) {
        t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
      };
      var r = u.init;
      u.init = function() {
        if (this.$u) {
          var t2 = this.$d;
          this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
        } else
          r.call(this);
      };
      var a = u.utcOffset;
      u.utcOffset = function(s2, f2) {
        var n2 = this.$utils().u;
        if (n2(s2))
          return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
        if (typeof s2 == "string" && (s2 = function(t2) {
          t2 === undefined && (t2 = "");
          var s3 = t2.match(i);
          if (!s3)
            return null;
          var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
          return u3 === 0 ? 0 : n3 === "+" ? u3 : -u3;
        }(s2), s2 === null))
          return this;
        var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f2)
          return o2.$offset = u2, o2.$u = s2 === 0, o2;
        if (s2 !== 0) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
        } else
          o2 = this.utc();
        return o2;
      };
      var h = u.format;
      u.format = function(t2) {
        var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i2);
      }, u.valueOf = function() {
        var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 60000 * t2;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var l = u.toDate;
      u.toDate = function(t2) {
        return t2 === "s" && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
      };
      var c = u.diff;
      u.diff = function(t2, i2, e2) {
        if (t2 && this.$u === t2.$u)
          return c.call(this, t2, i2, e2);
        var s2 = this.local(), f2 = n(t2).local();
        return c.call(s2, f2, i2, e2);
      };
    };
  });
});

// ../../node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_timezone = e();
  })(exports, function() {
    var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
    return function(n, i, o) {
      var r, a = function(t2, n2, i2) {
        i2 === undefined && (i2 = {});
        var o2 = new Date(t2), r2 = function(t3, n3) {
          n3 === undefined && (n3 = {});
          var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
          return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
        }(n2, i2);
        return r2.formatToParts(o2);
      }, u = function(e2, n2) {
        for (var i2 = a(e2, n2), r2 = [], u2 = 0;u2 < i2.length; u2 += 1) {
          var f2 = i2[u2], s2 = f2.type, m = f2.value, c = t[s2];
          c >= 0 && (r2[c] = parseInt(m, 10));
        }
        var d = r2[3], l = d === 24 ? 0 : d, v = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", h = +e2;
        return (o.utc(v).valueOf() - (h -= h % 1000)) / 60000;
      }, f = i.prototype;
      f.tz = function(t2, e2) {
        t2 === undefined && (t2 = r);
        var n2 = this.utcOffset(), i2 = this.toDate(), a2 = i2.toLocaleString("en-US", { timeZone: t2 }), u2 = Math.round((i2 - new Date(a2)) / 1000 / 60), f2 = o(a2).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u2, true);
        if (e2) {
          var s2 = f2.utcOffset();
          f2 = f2.add(n2 - s2, "minute");
        }
        return f2.$x.$timezone = t2, f2;
      }, f.offsetName = function(t2) {
        var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, { timeZoneName: t2 }).find(function(t3) {
          return t3.type.toLowerCase() === "timezonename";
        });
        return n2 && n2.value;
      };
      var s = f.startOf;
      f.startOf = function(t2, e2) {
        if (!this.$x || !this.$x.$timezone)
          return s.call(this, t2, e2);
        var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));
        return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
      }, o.tz = function(t2, e2, n2) {
        var i2 = n2 && e2, a2 = n2 || e2 || r, f2 = u(+o(), a2);
        if (typeof t2 != "string")
          return o(t2).tz(a2);
        var s2 = function(t3, e3, n3) {
          var i3 = t3 - 60 * e3 * 1000, o2 = u(i3, n3);
          if (e3 === o2)
            return [i3, e3];
          var r2 = u(i3 -= 60 * (o2 - e3) * 1000, n3);
          return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1000, Math.max(o2, r2)];
        }(o.utc(t2, i2).valueOf(), f2, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
        return d.$x.$timezone = a2, d;
      }, o.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o.tz.setDefault = function(t2) {
        r = t2;
      };
    };
  });
});

// ../../node_modules/pg-boss/src/plans.js
var require_plans = __commonJS((exports, module) => {
  var locked = function(schema3, query3) {
    if (Array.isArray(query3)) {
      query3 = query3.join(";\n");
    }
    return `
    BEGIN;
    SET LOCAL statement_timeout = '30s';
    ${advisoryLock(schema3)};
    ${query3};
    COMMIT;
  `;
  };
  var create = function(schema3, version2) {
    const commands = [
      createSchema(schema3),
      createVersionTable(schema3),
      createJobStateEnum(schema3),
      createJobTable(schema3),
      cloneJobTableForArchive(schema3),
      createScheduleTable(schema3),
      createSubscriptionTable(schema3),
      addIdIndexToArchive(schema3),
      addArchivedOnToArchive(schema3),
      addArchivedOnIndexToArchive(schema3),
      createIndexJobName(schema3),
      createIndexJobFetch(schema3),
      createIndexSingletonOn(schema3),
      createIndexSingletonKeyOn(schema3),
      createIndexSingletonKey(schema3),
      createIndexSingletonQueue(schema3),
      insertVersion(schema3, version2)
    ];
    return locked(schema3, commands);
  };
  var createSchema = function(schema3) {
    return `
    CREATE SCHEMA IF NOT EXISTS ${schema3}
  `;
  };
  var createVersionTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.version (
      version int primary key,
      maintained_on timestamp with time zone,
      cron_on timestamp with time zone
    )
  `;
  };
  var createJobStateEnum = function(schema3) {
    return `
    CREATE TYPE ${schema3}.job_state AS ENUM (
      '${states.created}',
      '${states.retry}',
      '${states.active}',
      '${states.completed}',
      '${states.expired}',
      '${states.cancelled}',
      '${states.failed}'
    )
  `;
  };
  var createJobTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.job (
      id uuid primary key not null default gen_random_uuid(),
      name text not null,
      priority integer not null default(0),
      data jsonb,
      state ${schema3}.job_state not null default('${states.created}'),
      retryLimit integer not null default(0),
      retryCount integer not null default(0),
      retryDelay integer not null default(0),
      retryBackoff boolean not null default false,
      startAfter timestamp with time zone not null default now(),
      startedOn timestamp with time zone,
      singletonKey text,
      singletonOn timestamp without time zone,
      expireIn interval not null default interval '15 minutes',
      createdOn timestamp with time zone not null default now(),
      completedOn timestamp with time zone,
      keepUntil timestamp with time zone NOT NULL default now() + interval '14 days',
      on_complete boolean not null default false,
      output jsonb
    )
  `;
  };
  var cloneJobTableForArchive = function(schema3) {
    return `CREATE TABLE ${schema3}.archive (LIKE ${schema3}.job)`;
  };
  var addArchivedOnToArchive = function(schema3) {
    return `ALTER TABLE ${schema3}.archive ADD archivedOn timestamptz NOT NULL DEFAULT now()`;
  };
  var addArchivedOnIndexToArchive = function(schema3) {
    return `CREATE INDEX archive_archivedon_idx ON ${schema3}.archive(archivedon)`;
  };
  var addIdIndexToArchive = function(schema3) {
    return `CREATE INDEX archive_id_idx ON ${schema3}.archive(id)`;
  };
  var setMaintenanceTime = function(schema3) {
    return `UPDATE ${schema3}.version SET maintained_on = now()`;
  };
  var getMaintenanceTime = function(schema3) {
    return `SELECT maintained_on, EXTRACT( EPOCH FROM (now() - maintained_on) ) seconds_ago FROM ${schema3}.version`;
  };
  var setCronTime = function(schema3, time) {
    time = time || "now()";
    return `UPDATE ${schema3}.version SET cron_on = ${time}`;
  };
  var getCronTime = function(schema3) {
    return `SELECT cron_on, EXTRACT( EPOCH FROM (now() - cron_on) ) seconds_ago FROM ${schema3}.version`;
  };
  var deleteQueue = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `DELETE FROM ${schema3}.job WHERE name = \$1 and state < '${options.before}'`;
  };
  var deleteAllQueues = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `DELETE FROM ${schema3}.job WHERE state < '${options.before}'`;
  };
  var clearStorage = function(schema3) {
    return `TRUNCATE ${schema3}.job, ${schema3}.archive`;
  };
  var getQueueSize = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `SELECT count(*) as count FROM ${schema3}.job WHERE name = \$1 AND state < '${options.before}'`;
  };
  var createIndexSingletonKey = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < '${states.completed}' AND singletonOn IS NULL AND NOT singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
  `;
  };
  var createIndexSingletonQueue = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < '${states.active}' AND singletonOn IS NULL AND singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
  `;
  };
  var createIndexSingletonOn = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonOn ON ${schema3}.job (name, singletonOn) WHERE state < '${states.expired}' AND singletonKey IS NULL
  `;
  };
  var createIndexSingletonKeyOn = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonKeyOn ON ${schema3}.job (name, singletonOn, singletonKey) WHERE state < '${states.expired}'
  `;
  };
  var createIndexJobName = function(schema3) {
    return `
    CREATE INDEX job_name ON ${schema3}.job (name text_pattern_ops)
  `;
  };
  var createIndexJobFetch = function(schema3) {
    return `
    CREATE INDEX job_fetch ON ${schema3}.job (name text_pattern_ops, startAfter) WHERE state < '${states.active}'
  `;
  };
  var createScheduleTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.schedule (
      name text primary key,
      cron text not null,
      timezone text,
      data jsonb,
      options jsonb,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now()
    )
  `;
  };
  var createSubscriptionTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.subscription (
      event text not null,
      name text not null,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now(),
      PRIMARY KEY(event, name)
    )
  `;
  };
  var getSchedules = function(schema3) {
    return `
    SELECT * FROM ${schema3}.schedule
  `;
  };
  var schedule = function(schema3) {
    return `
    INSERT INTO ${schema3}.schedule (name, cron, timezone, data, options)
    VALUES (\$1, \$2, \$3, \$4, \$5)
    ON CONFLICT (name) DO UPDATE SET
      cron = EXCLUDED.cron,
      timezone = EXCLUDED.timezone,
      data = EXCLUDED.data,
      options = EXCLUDED.options,
      updated_on = now()
  `;
  };
  var unschedule = function(schema3) {
    return `
    DELETE FROM ${schema3}.schedule
    WHERE name = \$1
  `;
  };
  var subscribe3 = function(schema3) {
    return `
    INSERT INTO ${schema3}.subscription (event, name)
    VALUES (\$1, \$2)
    ON CONFLICT (event, name) DO UPDATE SET
      event = EXCLUDED.event,
      name = EXCLUDED.name,
      updated_on = now()
  `;
  };
  var unsubscribe = function(schema3) {
    return `
    DELETE FROM ${schema3}.subscription
    WHERE event = \$1 and name = \$2
  `;
  };
  var getQueuesForEvent = function(schema3) {
    return `
    SELECT name FROM ${schema3}.subscription
    WHERE event = \$1
  `;
  };
  var getTime = function() {
    return "SELECT round(date_part('epoch', now()) * 1000) as time";
  };
  var getVersion = function(schema3) {
    return `SELECT version from ${schema3}.version`;
  };
  var setVersion = function(schema3, version2) {
    return `UPDATE ${schema3}.version SET version = '${version2}'`;
  };
  var versionTableExists = function(schema3) {
    return `SELECT to_regclass('${schema3}.version') as name`;
  };
  var insertVersion = function(schema3, version2) {
    return `INSERT INTO ${schema3}.version(version) VALUES ('${version2}')`;
  };
  var fetchNextJob = function(schema3) {
    return (includeMetadata, enforceSingletonQueueActiveLimit) => `
    WITH nextJob as (
      SELECT id
      FROM ${schema3}.job j
      WHERE state < '${states.active}'
        AND name LIKE \$1
        AND startAfter < now()
        ${enforceSingletonQueueActiveLimit ? `AND (
          CASE
            WHEN singletonKey IS NOT NULL
              AND singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
              THEN NOT EXISTS (
                SELECT 1
                FROM ${schema3}.job active_job
                WHERE active_job.state = '${states.active}'
                  AND active_job.name = j.name
                  AND active_job.singletonKey = j.singletonKey
                  LIMIT 1
              )
            ELSE
              true
          END
        )` : ""}
      ORDER BY priority desc, createdOn, id
      LIMIT \$2
      FOR UPDATE SKIP LOCKED
    )
    UPDATE ${schema3}.job j SET
      state = '${states.active}',
      startedOn = now(),
      retryCount = CASE WHEN state = '${states.retry}' THEN retryCount + 1 ELSE retryCount END
    FROM nextJob
    WHERE j.id = nextJob.id
    RETURNING ${includeMetadata ? "j.*" : "j.id, name, data"}, EXTRACT(epoch FROM expireIn) as expire_in_seconds
  `;
  };
  var buildJsonCompletionObject = function(withResponse) {
    return `jsonb_build_object(
    'request', jsonb_build_object('id', id, 'name', name, 'data', data),
    'response', ${withResponse ? "$2::jsonb" : "null"},
    'state', state,
    'retryCount', retryCount,
    'createdOn', createdOn,
    'startedOn', startedOn,
    'completedOn', completedOn,
    'failed', CASE WHEN state = '${states.completed}' THEN false ELSE true END
  )`;
  };
  var completeJobs = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET completedOn = now(),
        state = '${states.completed}',
        output = \$2::jsonb
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state = '${states.active}'
      RETURNING *
    ), completion_jobs as (
      INSERT INTO ${schema3}.job (name, data, keepUntil)
      SELECT
        '${COMPLETION_JOB_PREFIX}' || name,
        ${buildJsonCompletionObject(true)},
        ${keepUntilInheritance}
      FROM results
      WHERE NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
        AND on_complete
    )
    SELECT COUNT(*) FROM results
  `;
  };
  var failJobs = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET state = CASE
          WHEN retryCount < retryLimit
          THEN '${states.retry}'::${schema3}.job_state
          ELSE '${states.failed}'::${schema3}.job_state
          END,
        completedOn = ${retryCompletedOnCase},
        startAfter = ${retryStartAfterCase},
        output = \$2::jsonb
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state < '${states.completed}'
      RETURNING *
    ), completion_jobs as (
      INSERT INTO ${schema3}.job (name, data, keepUntil)
      SELECT
        '${COMPLETION_JOB_PREFIX}' || name,
        ${buildJsonCompletionObject(true)},
        ${keepUntilInheritance}
      FROM results
      WHERE state = '${states.failed}'
        AND NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
        AND on_complete
    )
    SELECT COUNT(*) FROM results
  `;
  };
  var expire = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET state = CASE
          WHEN retryCount < retryLimit THEN '${states.retry}'::${schema3}.job_state
          ELSE '${states.expired}'::${schema3}.job_state
          END,
        completedOn = ${retryCompletedOnCase},
        startAfter = ${retryStartAfterCase}
      WHERE state = '${states.active}'
        AND (startedOn + expireIn) < now()
      RETURNING *
    )
    INSERT INTO ${schema3}.job (name, data, keepUntil)
    SELECT
      '${COMPLETION_JOB_PREFIX}' || name,
      ${buildJsonCompletionObject()},
      ${keepUntilInheritance}
    FROM results
    WHERE state = '${states.expired}'
      AND NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
      AND on_complete
  `;
  };
  var cancelJobs = function(schema3) {
    return `
    with results as (
      UPDATE ${schema3}.job
      SET completedOn = now(),
        state = '${states.cancelled}'
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state < '${states.completed}'
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
  };
  var resumeJobs = function(schema3) {
    return `
    with results as (
      UPDATE ${schema3}.job
      SET completedOn = NULL,
        state = '${states.created}'
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
  };
  var insertJob = function(schema3) {
    return `
    INSERT INTO ${schema3}.job (
      id,
      name,
      priority,
      state,
      retryLimit,
      startAfter,
      expireIn,
      data,
      singletonKey,
      singletonOn,
      retryDelay,
      retryBackoff,
      keepUntil,
      on_complete
    )
    SELECT
      id,
      name,
      priority,
      state,
      retryLimit,
      startAfter,
      expireIn,
      data,
      singletonKey,
      singletonOn,
      retryDelay,
      retryBackoff,
      keepUntil,
      on_complete
    FROM
    ( SELECT *,
        CASE
          WHEN right(keepUntilValue, 1) = 'Z' THEN CAST(keepUntilValue as timestamp with time zone)
          ELSE startAfter + CAST(COALESCE(keepUntilValue,'0') as interval)
          END as keepUntil
      FROM
      ( SELECT *,
          CASE
            WHEN right(startAfterValue, 1) = 'Z' THEN CAST(startAfterValue as timestamp with time zone)
            ELSE now() + CAST(COALESCE(startAfterValue,'0') as interval)
            END as startAfter
        FROM
        ( SELECT
            \$1::uuid as id,
            \$2::text as name,
            \$3::int as priority,
            '${states.created}'::${schema3}.job_state as state,
            \$4::int as retryLimit,
            \$5::text as startAfterValue,
            CAST(\$6 as interval) as expireIn,
            \$7::jsonb as data,
            \$8::text as singletonKey,
            CASE
              WHEN \$9::integer IS NOT NULL THEN 'epoch'::timestamp + '1 second'::interval * (\$9 * floor((date_part('epoch', now()) + \$10) / \$9))
              ELSE NULL
              END as singletonOn,
            \$11::int as retryDelay,
            \$12::bool as retryBackoff,
            \$13::text as keepUntilValue,
            \$14::boolean as on_complete
        ) j1
      ) j2
    ) j3
    ON CONFLICT DO NOTHING
    RETURNING id
  `;
  };
  var insertJobs = function(schema3) {
    return `
    INSERT INTO ${schema3}.job (
      id,
      name,
      data,
      priority,
      startAfter,
      expireIn,
      retryLimit,
      retryDelay,
      retryBackoff,
      singletonKey,
      keepUntil,
      on_complete
    )
    SELECT
      COALESCE(id, gen_random_uuid()) as id,
      name,
      data,
      COALESCE(priority, 0) as priority,
      COALESCE("startAfter", now()) as startAfter,
      COALESCE("expireInSeconds", 15 * 60) * interval '1s' as expireIn,
      COALESCE("retryLimit", 0) as retryLimit,
      COALESCE("retryDelay", 0) as retryDelay,
      COALESCE("retryBackoff", false) as retryBackoff,
      "singletonKey",
      COALESCE("keepUntil", now() + interval '14 days') as keepUntil,
      COALESCE("onComplete", false) as onComplete
    FROM json_to_recordset(\$1) as x(
      id uuid,
      name text,
      priority integer,
      data jsonb,
      "retryLimit" integer,
      "retryDelay" integer,
      "retryBackoff" boolean,
      "startAfter" timestamp with time zone,
      "singletonKey" text,
      "expireInSeconds" integer,
      "keepUntil" timestamp with time zone,
      "onComplete" boolean
    )
    ON CONFLICT DO NOTHING
  `;
  };
  var purge = function(schema3, interval) {
    return `
    DELETE FROM ${schema3}.archive
    WHERE archivedOn < (now() - interval '${interval}')
  `;
  };
  var archive = function(schema3, completedInterval, failedInterval = completedInterval) {
    return `
    WITH archived_rows AS (
      DELETE FROM ${schema3}.job
      WHERE (
          state <> '${states.failed}' AND completedOn < (now() - interval '${completedInterval}')
        )
        OR (
          state = '${states.failed}' AND completedOn < (now() - interval '${failedInterval}')
        )
        OR (
          state < '${states.active}' AND keepUntil < now()
        )
      RETURNING *
    )
    INSERT INTO ${schema3}.archive (
      id, name, priority, data, state, retryLimit, retryCount, retryDelay, retryBackoff, startAfter, startedOn, singletonKey, singletonOn, expireIn, createdOn, completedOn, keepUntil, on_complete, output
    )
    SELECT
      id, name, priority, data, state, retryLimit, retryCount, retryDelay, retryBackoff, startAfter, startedOn, singletonKey, singletonOn, expireIn, createdOn, completedOn, keepUntil, on_complete, output
    FROM archived_rows
  `;
  };
  var countStates = function(schema3) {
    return `
    SELECT name, state, count(*) size
    FROM ${schema3}.job
    GROUP BY rollup(name), rollup(state)
  `;
  };
  var advisoryLock = function(schema3) {
    return `SELECT pg_advisory_xact_lock(
      ('x' || md5(current_database() || '.pgboss.${schema3}'))::bit(64)::bigint
  )`;
  };
  var assertMigration = function(schema3, version2) {
    return `SELECT version::int/(version::int-${version2}) from ${schema3}.version`;
  };
  var getJobById = function(schema3) {
    return getJobByTableAndId(schema3, "job");
  };
  var getArchivedJobById = function(schema3) {
    return getJobByTableAndId(schema3, "archive");
  };
  var getJobByTableAndId = function(schema3, table) {
    return `SELECT * From ${schema3}.${table} WHERE id = \$1`;
  };
  var assert = import.meta.require("assert");
  var states = {
    created: "created",
    retry: "retry",
    active: "active",
    completed: "completed",
    expired: "expired",
    cancelled: "cancelled",
    failed: "failed"
  };
  var DEFAULT_SCHEMA = "pgboss";
  var COMPLETION_JOB_PREFIX = `__state__${states.completed}__`;
  var SINGLETON_QUEUE_KEY = "__pgboss__singleton_queue";
  var SINGLETON_QUEUE_KEY_ESCAPED = SINGLETON_QUEUE_KEY.replace(/_/g, "\\_");
  var MIGRATE_RACE_MESSAGE = "division by zero";
  var CREATE_RACE_MESSAGE = "already exists";
  module.exports = {
    create,
    insertVersion,
    getVersion,
    setVersion,
    versionTableExists,
    fetchNextJob,
    completeJobs,
    cancelJobs,
    resumeJobs,
    failJobs,
    insertJob,
    insertJobs,
    getTime,
    getSchedules,
    schedule,
    unschedule,
    subscribe: subscribe3,
    unsubscribe,
    getQueuesForEvent,
    expire,
    archive,
    purge,
    countStates,
    deleteQueue,
    deleteAllQueues,
    clearStorage,
    getQueueSize,
    getMaintenanceTime,
    setMaintenanceTime,
    getCronTime,
    setCronTime,
    locked,
    assertMigration,
    getArchivedJobById,
    getJobById,
    states: { ...states },
    COMPLETION_JOB_PREFIX,
    SINGLETON_QUEUE_KEY,
    MIGRATE_RACE_MESSAGE,
    CREATE_RACE_MESSAGE,
    DEFAULT_SCHEMA
  };
  var retryCompletedOnCase = `CASE
          WHEN retryCount < retryLimit
          THEN NULL
          ELSE now()
          END`;
  var retryStartAfterCase = `CASE
          WHEN retryCount = retryLimit THEN startAfter
          WHEN NOT retryBackoff THEN now() + retryDelay * interval '1'
          ELSE now() +
            (
                retryDelay * 2 ^ LEAST(16, retryCount + 1) / 2
                +
                retryDelay * 2 ^ LEAST(16, retryCount + 1) / 2 * random()
            )
            * interval '1'
          END`;
  var keepUntilInheritance = "keepUntil + (keepUntil - startAfter)";
});

// ../../node_modules/pg-boss/src/attorney.js
var require_attorney = __commonJS((exports, module) => {
  var checkSendArgs = function(args, defaults) {
    let name, data, options;
    if (typeof args[0] === "string") {
      name = args[0];
      data = args[1];
      assert(typeof data !== "function", "send() cannot accept a function as the payload.  Did you intend to use work()?");
      options = args[2];
    } else if (typeof args[0] === "object") {
      assert(args.length === 1, "send object API only accepts 1 argument");
      const job = args[0];
      assert(job, "boss requires all jobs to have a name");
      name = job.name;
      data = job.data;
      options = job.options;
    }
    options = options || {};
    assert(name, "boss requires all jobs to have a queue name");
    assert(typeof options === "object", "options should be an object");
    options = { ...options };
    assert(!("priority" in options) || Number.isInteger(options.priority), "priority must be an integer");
    options.priority = options.priority || 0;
    applyRetryConfig(options, defaults);
    applyExpirationConfig(options, defaults);
    applyRetentionConfig(options, defaults);
    applyCompletionConfig(options, defaults);
    applySingletonKeyConfig(options);
    const { startAfter, singletonSeconds, singletonMinutes, singletonHours } = options;
    options.startAfter = startAfter instanceof Date && typeof startAfter.toISOString === "function" ? startAfter.toISOString() : startAfter > 0 ? "" + startAfter : typeof startAfter === "string" ? startAfter : null;
    options.singletonSeconds = singletonHours > 0 ? singletonHours * 60 * 60 : singletonMinutes > 0 ? singletonMinutes * 60 : singletonSeconds > 0 ? singletonSeconds : null;
    assert(!singletonSeconds || singletonSeconds <= defaults.archiveSeconds, `throttling interval ${singletonSeconds}s cannot exceed archive interval ${defaults.archiveSeconds}s`);
    return { name, data, options };
  };
  var checkInsertArgs = function(jobs) {
    assert(Array.isArray(jobs), `jobs argument should be an array.  Received '${typeof jobs}'`);
    return jobs.map((job) => {
      job = { ...job };
      applySingletonKeyConfig(job);
      return job;
    });
  };
  var applySingletonKeyConfig = function(options) {
    if (options.singletonKey && options.useSingletonQueue && options.singletonKey !== SINGLETON_QUEUE_KEY) {
      options.singletonKey = SINGLETON_QUEUE_KEY + options.singletonKey;
    }
    delete options.useSingletonQueue;
  };
  var checkWorkArgs = function(name, args, defaults) {
    let options, callback;
    assert(name, "missing job name");
    if (args.length === 1) {
      callback = args[0];
      options = {};
    } else if (args.length > 1) {
      options = args[0] || {};
      callback = args[1];
    }
    assert(typeof callback === "function", "expected callback to be a function");
    assert(typeof options === "object", "expected config to be an object");
    options = { ...options };
    applyNewJobCheckInterval(options, defaults);
    assert(!("teamConcurrency" in options) || Number.isInteger(options.teamConcurrency) && options.teamConcurrency >= 1 && options.teamConcurrency <= 1000, "teamConcurrency must be an integer between 1 and 1000");
    assert(!("teamSize" in options) || Number.isInteger(options.teamSize) && options.teamSize >= 1, "teamSize must be an integer > 0");
    assert(!("batchSize" in options) || Number.isInteger(options.batchSize) && options.batchSize >= 1, "batchSize must be an integer > 0");
    assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
    assert(!("enforceSingletonQueueActiveLimit" in options) || typeof options.enforceSingletonQueueActiveLimit === "boolean", "enforceSingletonQueueActiveLimit must be a boolean");
    return { options, callback };
  };
  var checkFetchArgs = function(name, batchSize, options) {
    assert(name, "missing queue name");
    name = sanitizeQueueNameForFetch(name);
    assert(!batchSize || Number.isInteger(batchSize) && batchSize >= 1, "batchSize must be an integer > 0");
    assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
    assert(!("enforceSingletonQueueActiveLimit" in options) || typeof options.enforceSingletonQueueActiveLimit === "boolean", "enforceSingletonQueueActiveLimit must be a boolean");
    return { name };
  };
  var sanitizeQueueNameForFetch = function(name) {
    return name.replace(/[%_*]/g, (match) => match === "*" ? "%" : "\\" + match);
  };
  var getConfig = function(value) {
    assert(value && (typeof value === "object" || typeof value === "string"), "configuration assert: string or config object is required to connect to postgres");
    const config = typeof value === "string" ? { connectionString: value } : { ...value };
    applyDatabaseConfig(config);
    applyMaintenanceConfig(config);
    applyArchiveConfig(config);
    applyArchiveFailedConfig(config);
    applyDeleteConfig(config);
    applyMonitoringConfig(config);
    applyUuidConfig(config);
    applyNewJobCheckInterval(config);
    applyExpirationConfig(config);
    applyRetentionConfig(config);
    applyCompletionConfig(config);
    return config;
  };
  var applyDatabaseConfig = function(config) {
    if (config.schema) {
      assert(typeof config.schema === "string", "configuration assert: schema must be a string");
      assert(config.schema.length <= 50, "configuration assert: schema name cannot exceed 50 characters");
      assert(!/\W/.test(config.schema), `configuration assert: ${config.schema} cannot be used as a schema. Only alphanumeric characters and underscores are allowed`);
    }
    config.schema = config.schema || DEFAULT_SCHEMA;
  };
  var applyArchiveConfig = function(config) {
    const ARCHIVE_DEFAULT = 60 * 60 * 12;
    assert(!("archiveCompletedAfterSeconds" in config) || config.archiveCompletedAfterSeconds >= 1, "configuration assert: archiveCompletedAfterSeconds must be at least every second and less than ");
    config.archiveSeconds = config.archiveCompletedAfterSeconds || ARCHIVE_DEFAULT;
    config.archiveInterval = `${config.archiveSeconds} seconds`;
    if (config.archiveSeconds < 60) {
      emitWarning2(WARNINGS.CRON_DISABLED);
    }
  };
  var applyArchiveFailedConfig = function(config) {
    assert(!("archiveFailedAfterSeconds" in config) || config.archiveFailedAfterSeconds >= 1, "configuration assert: archiveFailedAfterSeconds must be at least every second and less than ");
    config.archiveFailedSeconds = config.archiveFailedAfterSeconds || config.archiveSeconds;
    config.archiveFailedInterval = `${config.archiveFailedSeconds} seconds`;
    if (config.archiveFailedSeconds < 60 && config.archiveSeconds >= 60) {
      emitWarning2(WARNINGS.CRON_DISABLED);
    }
  };
  var applyCompletionConfig = function(config, defaults) {
    assert(!("onComplete" in config) || config.onComplete === true || config.onComplete === false, "configuration assert: onComplete must be either true or false");
    if (!("onComplete" in config)) {
      config.onComplete = defaults ? defaults.onComplete : false;
    }
  };
  var applyRetentionConfig = function(config, defaults) {
    assert(!("retentionSeconds" in config) || config.retentionSeconds >= 1, "configuration assert: retentionSeconds must be at least every second");
    assert(!("retentionMinutes" in config) || config.retentionMinutes >= 1, "configuration assert: retentionMinutes must be at least every minute");
    assert(!("retentionHours" in config) || config.retentionHours >= 1, "configuration assert: retentionHours must be at least every hour");
    assert(!("retentionDays" in config) || config.retentionDays >= 1, "configuration assert: retentionDays must be at least every day");
    const keepUntil = "retentionDays" in config ? `${config.retentionDays} days` : ("retentionHours" in config) ? `${config.retentionHours} hours` : ("retentionMinutes" in config) ? `${config.retentionMinutes} minutes` : ("retentionSeconds" in config) ? `${config.retentionSeconds} seconds` : defaults ? defaults.keepUntil : "14 days";
    config.keepUntil = keepUntil;
  };
  var applyExpirationConfig = function(config, defaults) {
    if ("expireIn" in config) {
      emitWarning2(WARNINGS.EXPIRE_IN_REMOVED);
    }
    assert(!("expireInSeconds" in config) || config.expireInSeconds >= 1, "configuration assert: expireInSeconds must be at least every second");
    assert(!("expireInMinutes" in config) || config.expireInMinutes >= 1, "configuration assert: expireInMinutes must be at least every minute");
    assert(!("expireInHours" in config) || config.expireInHours >= 1, "configuration assert: expireInHours must be at least every hour");
    const expireIn = "expireInHours" in config ? `${config.expireInHours} hours` : ("expireInMinutes" in config) ? `${config.expireInMinutes} minutes` : ("expireInSeconds" in config) ? `${config.expireInSeconds} seconds` : defaults ? defaults.expireIn : "15 minutes";
    config.expireIn = expireIn;
  };
  var applyRetryConfig = function(config, defaults) {
    assert(!("retryDelay" in config) || Number.isInteger(config.retryDelay) && config.retryDelay >= 0, "retryDelay must be an integer >= 0");
    assert(!("retryLimit" in config) || Number.isInteger(config.retryLimit) && config.retryLimit >= 0, "retryLimit must be an integer >= 0");
    assert(!("retryBackoff" in config) || (config.retryBackoff === true || config.retryBackoff === false), "retryBackoff must be either true or false");
    if (defaults) {
      config.retryDelay = config.retryDelay || defaults.retryDelay;
      config.retryLimit = config.retryLimit || defaults.retryLimit;
      config.retryBackoff = config.retryBackoff || defaults.retryBackoff;
    }
    config.retryDelay = config.retryDelay || 0;
    config.retryLimit = config.retryLimit || 0;
    config.retryBackoff = !!config.retryBackoff;
    config.retryDelay = config.retryBackoff && !config.retryDelay ? 1 : config.retryDelay;
    config.retryLimit = config.retryDelay && !config.retryLimit ? 1 : config.retryLimit;
  };
  var applyNewJobCheckInterval = function(config, defaults) {
    const second = 1000;
    assert(!("newJobCheckInterval" in config) || config.newJobCheckInterval >= 100, "configuration assert: newJobCheckInterval must be at least every 100ms");
    assert(!("newJobCheckIntervalSeconds" in config) || config.newJobCheckIntervalSeconds >= 1, "configuration assert: newJobCheckIntervalSeconds must be at least every second");
    config.newJobCheckInterval = "newJobCheckIntervalSeconds" in config ? config.newJobCheckIntervalSeconds * second : ("newJobCheckInterval" in config) ? config.newJobCheckInterval : defaults ? defaults.newJobCheckInterval : second * 2;
  };
  var applyMaintenanceConfig = function(config) {
    assert(!("maintenanceIntervalSeconds" in config) || config.maintenanceIntervalSeconds >= 1, "configuration assert: maintenanceIntervalSeconds must be at least every second");
    assert(!("maintenanceIntervalMinutes" in config) || config.maintenanceIntervalMinutes >= 1, "configuration assert: maintenanceIntervalMinutes must be at least every minute");
    config.maintenanceIntervalSeconds = "maintenanceIntervalMinutes" in config ? config.maintenanceIntervalMinutes * 60 : ("maintenanceIntervalSeconds" in config) ? config.maintenanceIntervalSeconds : 120;
  };
  var applyDeleteConfig = function(config) {
    assert(!("deleteAfterSeconds" in config) || config.deleteAfterSeconds >= 1, "configuration assert: deleteAfterSeconds must be at least every second");
    assert(!("deleteAfterMinutes" in config) || config.deleteAfterMinutes >= 1, "configuration assert: deleteAfterMinutes must be at least every minute");
    assert(!("deleteAfterHours" in config) || config.deleteAfterHours >= 1, "configuration assert: deleteAfterHours must be at least every hour");
    assert(!("deleteAfterDays" in config) || config.deleteAfterDays >= 1, "configuration assert: deleteAfterDays must be at least every day");
    const deleteAfter = "deleteAfterDays" in config ? `${config.deleteAfterDays} days` : ("deleteAfterHours" in config) ? `${config.deleteAfterHours} hours` : ("deleteAfterMinutes" in config) ? `${config.deleteAfterMinutes} minutes` : ("deleteAfterSeconds" in config) ? `${config.deleteAfterSeconds} seconds` : "7 days";
    config.deleteAfter = deleteAfter;
  };
  var applyMonitoringConfig = function(config) {
    assert(!("monitorStateIntervalSeconds" in config) || config.monitorStateIntervalSeconds >= 1, "configuration assert: monitorStateIntervalSeconds must be at least every second");
    assert(!("monitorStateIntervalMinutes" in config) || config.monitorStateIntervalMinutes >= 1, "configuration assert: monitorStateIntervalMinutes must be at least every minute");
    config.monitorStateIntervalSeconds = "monitorStateIntervalMinutes" in config ? config.monitorStateIntervalMinutes * 60 : ("monitorStateIntervalSeconds" in config) ? config.monitorStateIntervalSeconds : null;
    const TEN_MINUTES_IN_SECONDS = 600;
    assert(!("clockMonitorIntervalSeconds" in config) || config.clockMonitorIntervalSeconds >= 1 && config.clockMonitorIntervalSeconds <= TEN_MINUTES_IN_SECONDS, "configuration assert: clockMonitorIntervalSeconds must be between 1 second and 10 minutes");
    assert(!("clockMonitorIntervalMinutes" in config) || config.clockMonitorIntervalMinutes >= 1 && config.clockMonitorIntervalMinutes <= 10, "configuration assert: clockMonitorIntervalMinutes must be between 1 and 10");
    config.clockMonitorIntervalSeconds = "clockMonitorIntervalMinutes" in config ? config.clockMonitorIntervalMinutes * 60 : ("clockMonitorIntervalSeconds" in config) ? config.clockMonitorIntervalSeconds : TEN_MINUTES_IN_SECONDS;
    assert(!("cronMonitorIntervalSeconds" in config) || config.cronMonitorIntervalSeconds >= 1 && config.cronMonitorIntervalSeconds <= 60, "configuration assert: cronMonitorIntervalSeconds must be between 1 and 60 seconds");
    config.cronMonitorIntervalSeconds = "cronMonitorIntervalSeconds" in config ? config.cronMonitorIntervalSeconds : 60;
    assert(!("cronWorkerIntervalSeconds" in config) || config.cronWorkerIntervalSeconds >= 1 && config.cronWorkerIntervalSeconds <= 60, "configuration assert: cronWorkerIntervalSeconds must be between 1 and 60 seconds");
    config.cronWorkerIntervalSeconds = "cronWorkerIntervalSeconds" in config ? config.cronWorkerIntervalSeconds : 4;
  };
  var applyUuidConfig = function(config) {
    assert(!("uuid" in config) || config.uuid === "v1" || config.uuid === "v4", "configuration assert: uuid option only supports v1 or v4");
    config.uuid = config.uuid || "v4";
  };
  var warnClockSkew = function(message) {
    emitWarning2(WARNINGS.CLOCK_SKEW, message, { force: true });
  };
  var emitWarning2 = function(warning, message, options = {}) {
    const { force } = options;
    if (force || !warning.warned) {
      warning.warned = true;
      message = `${warning.message} ${message || ""}`;
      process.emitWarning(message, warning.type, warning.code);
    }
  };
  var assert = import.meta.require("assert");
  var { DEFAULT_SCHEMA, SINGLETON_QUEUE_KEY } = require_plans();
  module.exports = {
    getConfig,
    checkSendArgs,
    checkInsertArgs,
    checkWorkArgs,
    checkFetchArgs,
    warnClockSkew
  };
  var WARNINGS = {
    EXPIRE_IN_REMOVED: {
      message: "\'expireIn\' option detected. This option has been removed. Use expireInSeconds, expireInMinutes or expireInHours.",
      code: "pg-boss-w01"
    },
    CLOCK_SKEW: {
      message: "Timekeeper detected clock skew between this instance and the database server. This will not affect scheduling operations, but this warning is shown any time the skew exceeds 60 seconds.",
      code: "pg-boss-w02"
    },
    CRON_DISABLED: {
      message: "Archive interval is set less than 60s.  Cron processing is disabled.",
      code: "pg-boss-w03"
    }
  };
});

// ../../node_modules/pg-boss/src/migrationStore.js
var require_migrationStore = __commonJS((exports, module) => {
  var flatten = function(schema3, commands, version2) {
    commands.unshift(plans.assertMigration(schema3, version2));
    commands.push(plans.setVersion(schema3, version2));
    return plans.locked(schema3, commands);
  };
  var rollback = function(schema3, version2, migrations) {
    migrations = migrations || getAll(schema3);
    const result = migrations.find((i) => i.version === version2);
    assert(result, `Version ${version2} not found.`);
    return flatten(schema3, result.uninstall || [], result.previous);
  };
  var next = function(schema3, version2, migrations) {
    migrations = migrations || getAll(schema3);
    const result = migrations.find((i) => i.previous === version2);
    assert(result, `Version ${version2} not found.`);
    return flatten(schema3, result.install, result.version);
  };
  var migrate = function(value, version2, migrations) {
    let schema3, config;
    if (typeof value === "string") {
      config = null;
      schema3 = value;
    } else {
      config = value;
      schema3 = config.schema;
    }
    migrations = migrations || getAll(schema3, config);
    const result = migrations.filter((i) => i.previous >= version2).sort((a, b) => a.version - b.version).reduce((acc, i) => {
      acc.install = acc.install.concat(i.install);
      acc.version = i.version;
      return acc;
    }, { install: [], version: version2 });
    assert(result.install.length > 0, `Version ${version2} not found.`);
    return flatten(schema3, result.install, result.version);
  };
  var getAll = function(schema3) {
    return [
      {
        release: "7.4.0",
        version: 20,
        previous: 19,
        install: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey LIKE '\\_\\_pgboss\\_\\_singleton\\_queue%'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey LIKE '\\_\\_pgboss\\_\\_singleton\\_queue%'`
        ],
        uninstall: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey = '__pgboss__singleton_queue'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey = '__pgboss__singleton_queue'`
        ]
      },
      {
        release: "7.0.0",
        version: 19,
        previous: 18,
        install: [
          `CREATE TABLE ${schema3}.subscription (
          event text not null,
          name text not null,
          created_on timestamp with time zone not null default now(),
          updated_on timestamp with time zone not null default now(),
          PRIMARY KEY(event, name)
        )`
        ],
        uninstall: [
          `DROP TABLE ${schema3}.subscription`
        ]
      },
      {
        release: "6.1.1",
        version: 18,
        previous: 17,
        install: [
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT false`
        ]
      },
      {
        release: "6.0.0",
        version: 17,
        previous: 16,
        install: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey = '__pgboss__singleton_queue'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey = '__pgboss__singleton_queue'`,
          `CREATE INDEX IF NOT EXISTS job_fetch ON ${schema3}.job (name text_pattern_ops, startAfter) WHERE state < 'active'`,
          `ALTER TABLE ${schema3}.job ADD output jsonb`,
          `ALTER TABLE ${schema3}.archive ADD output jsonb`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT false`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN keepuntil SET DEFAULT now() + interval '14 days'`
        ],
        uninstall: [
          `DROP INDEX ${schema3}.job_fetch`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `DROP INDEX ${schema3}.job_singletonKey`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL`,
          `ALTER TABLE ${schema3}.job DROP COLUMN output`,
          `ALTER TABLE ${schema3}.archive DROP COLUMN output`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN keepuntil SET DEFAULT now() + interval '30 days'`
        ]
      },
      {
        release: "5.2.0",
        version: 16,
        previous: 15,
        install: [
          `ALTER TABLE ${schema3}.job ADD on_complete boolean`,
          `UPDATE ${schema3}.job SET on_complete = true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET NOT NULL`,
          `ALTER TABLE ${schema3}.archive ADD on_complete boolean`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.job DROP COLUMN on_complete`,
          `ALTER TABLE ${schema3}.archive DROP COLUMN on_complete`
        ]
      },
      {
        release: "5.0.6",
        version: 15,
        previous: 14,
        install: [
          `ALTER TABLE ${schema3}.version ADD cron_on timestamp with time zone`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.version DROP COLUMN cron_on`
        ]
      },
      {
        release: "5.0.0",
        version: 14,
        previous: 13,
        install: [
          `ALTER TABLE ${schema3}.version ADD maintained_on timestamp with time zone`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.version DROP COLUMN maintained_on`
        ]
      }
    ];
  };
  var assert = import.meta.require("assert");
  var plans = require_plans();
  module.exports = {
    rollback,
    next,
    migrate,
    getAll
  };
});

// ../../node_modules/pg-boss/version.json
var require_version = __commonJS((exports, module) => {
  module.exports = {
    schema: 20
  };
});

// ../../node_modules/pg-boss/src/contractor.js
var require_contractor = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var plans = require_plans();
  var { DEFAULT_SCHEMA } = plans;
  var migrationStore = require_migrationStore();
  var schemaVersion = require_version().schema;

  class Contractor {
    static constructionPlans(schema3 = DEFAULT_SCHEMA) {
      return plans.create(schema3, schemaVersion);
    }
    static migrationPlans(schema3 = DEFAULT_SCHEMA, version2 = schemaVersion - 1) {
      return migrationStore.migrate(schema3, version2);
    }
    static rollbackPlans(schema3 = DEFAULT_SCHEMA, version2 = schemaVersion) {
      return migrationStore.rollback(schema3, version2);
    }
    constructor(db, config) {
      this.config = config;
      this.db = db;
      this.migrations = this.config.migrations || migrationStore.getAll(this.config.schema);
    }
    async version() {
      const result = await this.db.executeSql(plans.getVersion(this.config.schema));
      return result.rows.length ? parseInt(result.rows[0].version) : null;
    }
    async isInstalled() {
      const result = await this.db.executeSql(plans.versionTableExists(this.config.schema));
      return result.rows.length ? result.rows[0].name : null;
    }
    async start() {
      const installed = await this.isInstalled();
      if (installed) {
        const version2 = await this.version();
        if (schemaVersion > version2) {
          await this.migrate(version2);
        }
      } else {
        await this.create();
      }
    }
    async create() {
      try {
        const commands = plans.create(this.config.schema, schemaVersion);
        await this.db.executeSql(commands);
      } catch (err) {
        assert(err.message.includes(plans.CREATE_RACE_MESSAGE), err);
      }
    }
    async migrate(version2) {
      try {
        const commands = migrationStore.migrate(this.config, version2, this.migrations);
        await this.db.executeSql(commands);
      } catch (err) {
        assert(err.message.includes(plans.MIGRATE_RACE_MESSAGE), err);
      }
    }
    async next(version2) {
      const commands = migrationStore.next(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    }
    async rollback(version2) {
      const commands = migrationStore.rollback(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    }
  }
  module.exports = Contractor;
});

// ../../node_modules/delay/index.js
var require_delay = __commonJS((exports, module) => {
  var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
  var createAbortError = () => {
    const error8 = new Error("Delay aborted");
    error8.name = "AbortError";
    return error8;
  };
  var createDelay = ({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (ms, { value, signal } = {}) => {
    if (signal && signal.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFn;
    const clear = defaultClear || clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFn(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject2) => {
      settle = () => {
        cleanup();
        if (willResolve) {
          resolve(value);
        } else {
          reject2(value);
        }
      };
      rejectFn = reject2;
      timeoutId = (set || setTimeout)(settle, ms);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    delayPromise.clear = () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    };
    return delayPromise;
  };
  var createWithTimers = (clearAndSet) => {
    const delay2 = createDelay({ ...clearAndSet, willResolve: true });
    delay2.reject = createDelay({ ...clearAndSet, willResolve: false });
    delay2.range = (minimum, maximum, options) => delay2(randomInteger(minimum, maximum), options);
    return delay2;
  };
  var delay = createWithTimers();
  delay.createWithTimers = createWithTimers;
  module.exports = delay;
  module.exports.default = delay;
});

// ../../node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// ../../node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate3 = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate3;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  };
  var stringify4 = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = stringify4;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node3 = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node3 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node3 == null) {
        node3 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node3[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse2 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse2;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify2();
  var _parse = _interopRequireDefault(require_parse2());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// ../../node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  var _default = v4;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// ../../node_modules/uuid/dist/version.js
var require_version2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version2 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version2;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version2());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _parse = _interopRequireDefault(require_parse2());
});

// ../../node_modules/lodash.debounce/index.js
var require_lodash = __commonJS((exports, module) => {
  var debounce = function(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = undefined;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }
    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  };
  var isObject2 = function(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  };
  var isObjectLike11 = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike11(value) && objectToString.call(value) == symbolTag;
  };
  var toNumber = function(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root6 = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var now = function() {
    return root6.Date.now();
  };
  module.exports = debounce;
});

// ../../node_modules/serialize-error/index.js
var require_serialize_error = __commonJS((exports, module) => {
  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
  }
  var commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  var isCalled = Symbol(".toJSON called");
  var toJSON = (from) => {
    from[isCalled] = true;
    const json = from.toJSON();
    delete from[isCalled];
    return json;
  };
  var destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value === "function") {
        continue;
      }
      if (!value || typeof value !== "object") {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  var serializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === "object" && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value === "function") {
      return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
  };
  var deserializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
      return value;
    }
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const newError = new Error;
      destroyCircular({
        from: value,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value);
  };
  module.exports = {
    serializeError,
    deserializeError
  };
});

// ../../node_modules/pg-boss/src/worker.js
var require_worker = __commonJS((exports, module) => {
  var delay = require_delay();
  var WORKER_STATES = {
    created: "created",
    active: "active",
    stopping: "stopping",
    stopped: "stopped"
  };

  class Worker {
    constructor({ id, name, options, interval, fetch: fetch6, onFetch, onError }) {
      this.id = id;
      this.name = name;
      this.options = options;
      this.fetch = fetch6;
      this.onFetch = onFetch;
      this.onError = onError;
      this.interval = interval;
      this.jobs = [];
      this.createdOn = Date.now();
      this.lastFetchedOn = null;
      this.lastJobStartedOn = null;
      this.lastJobEndedOn = null;
      this.lastError = null;
      this.lastErrorOn = null;
      this.state = WORKER_STATES.created;
      this.stopping = false;
      this.stopped = false;
      this.loopDelayPromise = null;
      this.beenNotified = false;
    }
    notify() {
      this.beenNotified = true;
      if (this.loopDelayPromise) {
        this.loopDelayPromise.clear();
      }
    }
    async start() {
      this.state = WORKER_STATES.active;
      while (!this.stopping) {
        const started = Date.now();
        try {
          this.beenNotified = false;
          const jobs = await this.fetch();
          this.lastFetchedOn = Date.now();
          if (jobs) {
            this.jobs = jobs;
            this.lastJobStartedOn = this.lastFetchedOn;
            await this.onFetch(jobs);
            this.lastJobEndedOn = Date.now();
            this.jobs = [];
          }
        } catch (err) {
          this.lastErrorOn = Date.now();
          this.lastError = err;
          err.message = `${err.message} (Queue: ${this.name}, Worker: ${this.id})`;
          this.onError(err);
        }
        const duration = Date.now() - started;
        this.lastJobDuration = duration;
        if (!this.stopping && !this.beenNotified && duration < this.interval) {
          this.loopDelayPromise = delay(this.interval - duration);
          await this.loopDelayPromise;
          this.loopDelayPromise = null;
        }
      }
      this.stopping = false;
      this.stopped = true;
      this.state = WORKER_STATES.stopped;
    }
    stop() {
      this.stopping = true;
      this.state = WORKER_STATES.stopping;
      if (this.loopDelayPromise) {
        this.loopDelayPromise.clear();
      }
    }
  }
  module.exports = Worker;
});

// ../../node_modules/pg/node_modules/pg-types/node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  var identity2 = function(value) {
    return value;
  };
  exports.parse = function(source2, transform) {
    return new ArrayParser(source2, transform).parse();
  };

  class ArrayParser {
    constructor(source2, transform) {
      this.source = source2;
      this.transform = transform || identity2;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
});

// ../../node_modules/pg/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source2, transform) {
      return {
        parse: function() {
          return array.parse(source2, transform);
        }
      };
    }
  };
});

// ../../node_modules/pg/node_modules/pg-types/node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var getDate = function(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var date = new Date(year, month, day2);
    if (is0To99(year)) {
      date.setFullYear(year);
    }
    return date;
  };
  var timeZoneOffset = function(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type2 = zone[1];
    if (type2 === "Z") {
      return 0;
    }
    var sign = type2 === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  };
  var bcYearToNegativeYear = function(year) {
    return -(year - 1);
  };
  var is0To99 = function(num) {
    return num >= 0 && num < 100;
  };
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date = new Date(Date.UTC(year, month, day2, hour, minute, second, ms));
      if (is0To99(year)) {
        date.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date.setTime(date.getTime() - offset);
      }
    } else {
      date = new Date(year, month, day2, hour, minute, second, ms);
      if (is0To99(year)) {
        date.setFullYear(year);
      }
    }
    return date;
  };
});

// ../../node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  var extend = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (hasOwnProperty3.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  module.exports = extend;
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
});

// ../../node_modules/pg/node_modules/pg-types/node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var PostgresInterval = function(raw2) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw2);
    }
    extend(this, parse2(raw2));
  };
  var parseMilliseconds = function(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  };
  var parse2 = function(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  };
  var extend = require_mutable();
  module.exports = PostgresInterval;
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
});

// ../../node_modules/pg/node_modules/pg-types/node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input6) {
    if (/^\\x/.test(input6)) {
      return new Buffer(input6.substr(2), "hex");
    }
    var output2 = "";
    var i = 0;
    while (i < input6.length) {
      if (input6[i] !== "\\") {
        output2 += input6[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input6.substr(i + 1, 3))) {
          output2 += String.fromCharCode(parseInt(input6.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input6.length && input6[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output2 += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output2, "binary");
  };
});

// ../../node_modules/pg/node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var allowNull = function(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  };
  var parseBool = function(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  };
  var parseBoolArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  };
  var parseBaseTenInt = function(string) {
    return parseInt(string, 10);
  };
  var parseIntegerArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  };
  var parseBigIntegerArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  };
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate2 = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate2(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate2);
    register(1114, parseDate2);
    register(1184, parseDate2);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// ../../node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var readInt8 = function(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  };
  var BASE = 1e6;
  module.exports = readInt8;
});

// ../../node_modules/pg/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : (-Infinity);
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate2 = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse2 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse2(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse2(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate2.bind(null, false));
    register(1184, parseDate2.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// ../../node_modules/pg/node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// ../../node_modules/pg/node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var noParse = function(val) {
    return String(val);
  };
  var getTypeParser = function(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  };
  var setTypeParser = function(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  };
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// ../../node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : "richardguerre",
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// ../../node_modules/pg/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var escapeElement = function(elementRepresentation) {
    var escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + escaped + '"';
  };
  var arrayString = function(val) {
    var result = "{";
    for (var i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        var item = val[i];
        if (!(item instanceof Buffer)) {
          var buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  };
  var prepareObject = function(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  };
  var pad = function(number, digits) {
    number = "" + number;
    while (number.length < digits) {
      number = "0" + number;
    }
    return number;
  };
  var dateToString = function(date) {
    var offset = -date.getTimezoneOffset();
    var year = date.getFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = pad(year, 4) + "-" + pad(date.getMonth() + 1, 2) + "-" + pad(date.getDate(), 2) + "T" + pad(date.getHours(), 2) + ":" + pad(date.getMinutes(), 2) + ":" + pad(date.getSeconds(), 2) + "." + pad(date.getMilliseconds(), 3);
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += pad(Math.floor(offset / 60), 2) + ":" + pad(offset % 60, 2);
    if (isBCYear)
      ret += " BC";
    return ret;
  };
  var dateToStringUTC = function(date) {
    var year = date.getUTCFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = pad(year, 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + "T" + pad(date.getUTCHours(), 2) + ":" + pad(date.getUTCMinutes(), 2) + ":" + pad(date.getUTCSeconds(), 2) + "." + pad(date.getUTCMilliseconds(), 3);
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  };
  var normalizeQueryConfig = function(config, values4, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values4) {
      if (typeof values4 === "function") {
        config.callback = values4;
      } else {
        config.values = values4;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  };
  var defaults = require_defaults();
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (val instanceof Buffer) {
      return val;
    }
    if (ArrayBuffer.isView(val)) {
      var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
      if (buf.length === val.byteLength) {
        return buf;
      }
      return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
    }
    if (val instanceof Date) {
      if (defaults.parseInputDatesAsUTC) {
        return dateToStringUTC(val);
      } else {
        return dateToString(val);
      }
    }
    if (Array.isArray(val)) {
      return arrayString(val);
    }
    if (typeof val === "object") {
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    var hasBackslash = false;
    var escaped = "'";
    for (var i = 0;i < str.length; i++) {
      var c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// ../../node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var md5 = function(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  };
  var postgresMd5PasswordHash = function(user, password, salt) {
    var inner = md5(password + user);
    var outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  };
  var sha256 = function(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  };
  var hmacSha256 = function(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  };
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
});

// ../../node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var randomBytes = function(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  };
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    var inner = await md5(password + user);
    var outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params3 = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params3, key, 32 * 8, ["deriveBits"]);
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
});

// ../../node_modules/pg/lib/crypto/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// ../../node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var startSession = function(mechanisms) {
    if (mechanisms.indexOf("SCRAM-SHA-256") === -1) {
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    return {
      mechanism: "SCRAM-SHA-256",
      clientNonce,
      response: "n,,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  };
  async function continueSession(session, password, serverData) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    var clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    var serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    var clientFinalMessageWithoutProof = "c=biws,r=" + sv.nonce;
    var authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    var saltBytes = Buffer.from(sv.salt, "base64");
    var saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    var clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    var storedKey = await crypto2.sha256(clientKey);
    var clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    var clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    var serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    var serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  var finalizeSession = function(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  };
  var isPrintableChars = function(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  };
  var isBase64 = function(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  };
  var parseAttributePairs = function(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  };
  var parseServerFirstMessage = function(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  };
  var parseServerFinalMessage = function(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  };
  var xorBuffers = function(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  };
  var crypto2 = require_utils4();
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// ../../node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var TypeOverrides = function(userTypes) {
    this._types = userTypes || types25;
    this.text = {};
    this.binary = {};
  };
  var types25 = require_pg_types();
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// ../../node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  var parse2 = function(str) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
    }
    try {
      result = new URL(str, "postgres://base");
    } catch (e) {
      result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
      dummyHost = true;
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? import.meta.require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    switch (config.sslmode) {
      case "disable": {
        config.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full": {
        break;
      }
      case "no-verify": {
        config.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return config;
  };
  module.exports = parse2;
  parse2.parse = parse2;
});

// ../../node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = import.meta.require("dns");
  var defaults = require_defaults();
  var parse2 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {
    } else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params3, config, paramName) {
    var value = config[paramName];
    if (value !== undefined && value !== null) {
      params3.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse2(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse2(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      var params3 = [];
      add(params3, this, "user");
      add(params3, this, "password");
      add(params3, this, "port");
      add(params3, this, "application_name");
      add(params3, this, "fallback_application_name");
      add(params3, this, "connect_timeout");
      add(params3, this, "options");
      var ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params3, ssl, "sslmode");
      add(params3, ssl, "sslca");
      add(params3, ssl, "sslkey");
      add(params3, ssl, "sslcert");
      add(params3, ssl, "sslrootcert");
      if (this.database) {
        params3.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params3.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params3.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params3.join(" "));
      }
      if (this.client_encoding) {
        params3.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params3.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params3.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// ../../node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types25 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types26) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types26;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      var match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      var row = new Array(rowData.length);
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      var row = { ...this._prebuiltEmptyResultObject };
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        var field3 = this.fields[i].name;
        if (rawValue !== null) {
          row[field3] = this._parsers[i](rawValue);
        } else {
          row[field3] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      var row = {};
      for (var i = 0;i < fieldDescriptions.length; i++) {
        var desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types25.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// ../../node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = import.meta.require("events");
  var Result = require_result();
  var utils31 = require_utils3();

  class Query extends EventEmitter {
    constructor(config, values4, callback) {
      super();
      config = utils31.normalizeQueryConfig(config, values4, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this.types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection2) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection2.sync();
      }
    }
    handleEmptyQuery(connection2) {
      if (this.rows) {
        connection2.sync();
      }
    }
    handleError(err, connection2) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection2) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection2.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        this.prepare(connection2);
      } else {
        connection2.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection2) {
      return this.name && connection2.parsedStatements[this.name];
    }
    handlePortalSuspended(connection2) {
      this._getRows(connection2, this.rows);
    }
    _getRows(connection2, rows) {
      connection2.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection2.sync();
      } else {
        connection2.flush();
      }
    }
    prepare(connection2) {
      if (!this.hasBeenParsed(connection2)) {
        connection2.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection2.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils31.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection2);
        return;
      }
      connection2.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection2, this.rows);
    }
    handleCopyInResponse(connection2) {
      connection2.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection2) {
    }
  }
  module.exports = Query;
});

// ../../node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields2) {
      this.length = length;
      this.fields = fields2;
      this.name = "dataRow";
      this.fieldCount = fields2.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// ../../node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      var remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        var oldBuffer = this.buffer;
        var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        var len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      var len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      var result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// ../../node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    var bodyBuffer = writer.addCString("").flush();
    var length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query3 = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse2 = (query4) => {
    const name = query4.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types25 = query4.types || emptyArray;
    var len = types25.length;
    var buffer = writer.addCString(name).addCString(query4.text).addInt16(len);
    for (var i = 0;i < len; i++) {
      buffer.addInt32(types25[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values4, valueMapper) {
    for (let i = 0;i < values4.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values4[i], i) : values4[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values4 = config.values || emptyArray;
    const len = values4.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values4, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute5 = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query: query3,
    parse: parse2,
    bind,
    execute: execute5,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// ../../node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {
      }
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// ../../node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser2 {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.int32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.int32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields2 = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields2[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields2);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          message.name = "authenticationSASL";
          message.mechanisms = [];
          let mechanism;
          do {
            mechanism = this.reader.cstring();
            if (mechanism) {
              message.mechanisms.push(mechanism);
            }
          } while (mechanism);
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields2 = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\0") {
        fields2[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields2.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields2.S;
      message.code = fields2.C;
      message.detail = fields2.D;
      message.hint = fields2.H;
      message.position = fields2.P;
      message.internalPosition = fields2.p;
      message.internalQuery = fields2.q;
      message.where = fields2.W;
      message.schema = fields2.s;
      message.table = fields2.t;
      message.column = fields2.c;
      message.dataType = fields2.d;
      message.constraint = fields2.n;
      message.file = fields2.F;
      message.line = fields2.L;
      message.routine = fields2.R;
      return message;
    }
  }
  exports.Parser = Parser2;
});

// ../../node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var parse2 = function(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  exports.parse = parse2;
});

// ../../node_modules/pg-cloudflare/dist/empty.js
var exports_empty = {};
__export(exports_empty, {
  default: () => {
    {
      return empty_default;
    }
  }
});
var empty_default;
var init_empty = __esm(() => {
  empty_default = {};
});

// ../../node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  exports.getStream = function getStream(ssl) {
    const net = import.meta.require("net");
    if (typeof net.Socket === "function") {
      return new net.Socket;
    } else {
      const { CloudflareSocket } = (init_empty(), __toCommonJS(exports_empty));
      return new CloudflareSocket(ssl);
    }
  };
  exports.getSecureStream = function getSecureStream(options) {
    var tls = import.meta.require("tls");
    if (tls.connect) {
      return tls.connect(options);
    } else {
      options.socket.startTls(options);
      return options.socket;
    }
  };
});

// ../../node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var net = import.meta.require("net");
  var EventEmitter = import.meta.require("events").EventEmitter;
  var { parse: parse2, serialize } = require_dist2();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      var self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      var self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error8) {
        if (self2._ending && (error8.code === "ECONNRESET" || error8.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error8);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        var responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        var net2 = import.meta.require("net");
        if (net2.isIP && net2.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse2(stream, (msg) => {
        var eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize.query(text));
    }
    parse(query3) {
      this._send(serialize.parse(query3));
    }
    bind(config) {
      this._send(serialize.bind(config));
    }
    execute(config) {
      this._send(serialize.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// ../../node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var transform = function(chunk, enc, cb) {
    let list6;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list6 = buf.split(this.matcher);
      if (list6.length === 1)
        return cb();
      list6.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list6 = this[kLast].split(this.matcher);
    }
    this[kLast] = list6.pop();
    for (let i = 0;i < list6.length; i++) {
      try {
        push2(this, this.mapper(list6[i]));
      } catch (error8) {
        return cb(error8);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  };
  var flush = function(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push2(this, this.mapper(this[kLast]));
      } catch (error8) {
        return cb(error8);
      }
    }
    cb();
  };
  var push2 = function(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  };
  var noop2 = function(incoming) {
    return incoming;
  };
  var split = function(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop2;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop2;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  };
  var { Transform } = import.meta.require("stream");
  var { StringDecoder } = import.meta.require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  module.exports = split;
});

// ../../node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var isRegFile = function(mode) {
    return (mode & S_IFMT) == S_IFREG;
  };
  var warn = function() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat("\n");
      warnStream.write(util2.format.apply(util2, args));
    }
  };
  var path = import.meta.require("path");
  var Stream = import.meta.require("stream").Stream;
  var split = require_split2();
  var util2 = import.meta.require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env3 = rawEnv || process.env;
    var file = env3.PGPASSFILE || (isWin ? path.join(env3.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env3.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field3, idx) {
      if (idx == 1) {
        if (Number(connInfo[field3] || defaultPort) === Number(entry[field3])) {
          return prev && true;
        }
      }
      return prev && (entry[field3] === "*" || entry[field3] === connInfo[field3]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i12) {
      var field3 = line.substring(i0, i12);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field3 = field3.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field3;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// ../../node_modules/pgpass/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var fs = import.meta.require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// ../../node_modules/pg/lib/client.js
var require_client3 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var utils31 = require_utils3();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils4();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      var c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query3) => {
        process.nextTick(() => {
          query3.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      var self2 = this;
      var con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      this.connectionTimeoutHandle;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error8 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error8);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error8);
            } else {
              this._handleErrorEvent(error8);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error8);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject2) => {
        this._connect((error8) => {
          if (error8) {
            reject2(error8);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib3();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete(msg) {
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      var params3 = this.connectionParameters;
      var data = {
        user: params3.user,
        database: params3.database
      };
      var appName = params3.application_name || params3.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params3.replication) {
        data.replication = "" + params3.replication;
      }
      if (params3.statement_timeout) {
        data.statement_timeout = String(parseInt(params3.statement_timeout, 10));
      }
      if (params3.lock_timeout) {
        data.lock_timeout = String(parseInt(params3.lock_timeout, 10));
      }
      if (params3.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params3.idle_in_transaction_session_timeout, 10));
      }
      if (params3.options) {
        data.options = params3.options;
      }
      return data;
    }
    cancel(client2, query3) {
      if (client2.activeQuery === query3) {
        var con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client2.processID, client2.secretKey);
        });
      } else if (client2.queryQueue.indexOf(query3) !== -1) {
        client2.queryQueue.splice(client2.queryQueue.indexOf(query3), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils31.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils31.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values4, callback) {
      var query3;
      var result;
      var readTimeout;
      var readTimeoutTimer;
      var queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query3 = config;
        if (typeof values4 === "function") {
          query3.callback = query3.callback || values4;
        }
      } else {
        readTimeout = this.connectionParameters.query_timeout;
        query3 = new Query(config, values4, callback);
        if (!query3.callback) {
          result = new this._Promise((resolve, reject2) => {
            query3.callback = (err, res) => err ? reject2(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query3.callback;
        readTimeoutTimer = setTimeout(() => {
          var error8 = new Error("Query read timeout");
          process.nextTick(() => {
            query3.handleError(error8, this.connection);
          });
          queryCallback(error8);
          query3.callback = () => {
          };
          var index = this.queryQueue.indexOf(query3);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query3.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query3.binary) {
        query3.binary = true;
      }
      if (query3._result && !query3._result._types) {
        query3._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query3.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query3.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query3);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// ../../node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var throwOnDoubleRelease = function() {
    throw new Error("Release called on client which has already been released to the pool.");
  };
  var promisify = function(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client2) {
      err ? rej(err) : res(client2);
    };
    const result = new Promise2(function(resolve, reject2) {
      res = resolve;
      rej = reject2;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  };
  var makeIdleListener = function(pool, client2) {
    return function idleListener(err) {
      err.client = client2;
      client2.removeListener("error", idleListener);
      client2.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client2);
      pool.emit("error", err, client2);
    };
  };
  var EventEmitter = import.meta.require("events").EventEmitter;
  var NOOP2 = function() {
  };
  var removeWhere = (list6, predicate) => {
    const i = list6.findIndex(predicate);
    return i === -1 ? undefined : list6.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client2, idleListener, timeoutId) {
      this.client = client2;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {
      };
      this.Client = this.options.Client || Client || require_lib4().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client2 = idleItem.client;
        client2.ref && client2.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client2, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client2) {
      const removed = removeWhere(this._idle, (item) => item.client === client2);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client2);
      client2.end();
      this.emit("remove", client2);
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client2 = new this.Client(this.options);
      this._clients.push(client2);
      const idleListener = makeIdleListener(this, client2);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client2.connection ? client2.connection.stream.destroy() : client2.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client2.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client2.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client2);
          if (timeoutHit) {
            err.message = "Connection terminated due to connection timeout";
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP2);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client2);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client2);
              if (idleIndex !== -1) {
                this._acquireClient(client2, new PendingItem((err2, client3, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client2.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client2, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client2, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client2);
      }
      this.emit("acquire", client2);
      client2.release = this._releaseOnce(client2, idleListener);
      client2.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client2, (err) => {
            if (err) {
              client2.release(err);
              return pendingItem.callback(err, undefined, NOOP2);
            }
            pendingItem.callback(undefined, client2, client2.release);
          });
        } else {
          pendingItem.callback(undefined, client2, client2.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client2, client2.release);
        } else {
          client2.release();
        }
      }
    }
    _releaseOnce(client2, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client2, idleListener, err);
      };
    }
    _release(client2, idleListener, err) {
      client2.on("error", idleListener);
      client2._poolUseCount = (client2._poolUseCount || 0) + 1;
      this.emit("release", err, client2);
      if (err || this.ending || !client2._queryable || client2._ending || client2._poolUseCount >= this.options.maxUses) {
        if (client2._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        this._remove(client2);
        this._pulseQueue();
        return;
      }
      const isExpired = this._expired.has(client2);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client2);
        this._remove(client2);
        this._pulseQueue();
        return;
      }
      let tid;
      if (this.options.idleTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client2);
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client2.unref();
      }
      this._idle.push(new IdleItem(client2, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values4, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values4 === "function") {
        cb = values4;
        values4 = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client2) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client2.release(err2);
          cb(err2);
        };
        client2.once("error", onError);
        this.log("dispatching query");
        try {
          client2.query(text, values4, (err2, res) => {
            this.log("query dispatched");
            client2.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client2.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client2.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client2) => acc + (this._expired.has(client2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// ../../node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var utils31 = require_utils3();
  var NativeQuery = module.exports = function(config, values4, callback) {
    EventEmitter.call(this);
    config = utils31.normalizeQueryConfig(config, values4, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util2.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    var fields2 = this.native.pq.resultErrorFields();
    if (fields2) {
      for (var key in fields2) {
        var normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields2[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject2) {
      this._once("end", resolve);
      this._once("error", reject2);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client2) {
    this.state = "running";
    var self2 = this;
    this.native = client2.native;
    client2.native.arrayMode = this._arrayMode;
    var after = function(err, rows, results) {
      client2.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      var values4 = (this.values || []).map(utils31.prepareValue);
      if (client2.namedQueries[this.name]) {
        if (this.text && client2.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client2.native.execute(this.name, values4, after);
      }
      return client2.native.prepare(this.name, this.text, values4.length, function(err) {
        if (err)
          return after(err);
        client2.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values4, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      var vals = this.values.map(utils31.prepareValue);
      client2.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client2.native.query(this.text, [], after);
    } else {
      client2.native.query(this.text, after);
    }
  };
});

// ../../node_modules/pg/lib/native/client.js
var require_client4 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error(`Cannot require module "pg-native"`);})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    var cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util2.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query3) => {
      process.nextTick(() => {
        query3.native = this.native;
        query3.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    var self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject2) => {
      this._connect((error8) => {
        if (error8) {
          reject2(error8);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values4, callback) {
    var query3;
    var result;
    var readTimeout;
    var readTimeoutTimer;
    var queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query3 = config;
      if (typeof values4 === "function") {
        config.callback = values4;
      }
    } else {
      readTimeout = this.connectionParameters.query_timeout;
      query3 = new NativeQuery(config, values4, callback);
      if (!query3.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject2) => {
          resolveOut = resolve;
          rejectOut = reject2;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query3.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query3.callback;
      readTimeoutTimer = setTimeout(() => {
        var error8 = new Error("Query read timeout");
        process.nextTick(() => {
          query3.handleError(error8, this.connection);
        });
        queryCallback(error8);
        query3.callback = () => {
        };
        var index = this._queryQueue.indexOf(query3);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query3.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query3.native = this.native;
      process.nextTick(() => {
        query3.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query3.native = this.native;
      process.nextTick(() => {
        query3.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query3);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    var self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    var result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject2) {
        cb = (err) => err ? reject2(err) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    var query3 = this._queryQueue.shift();
    if (!query3) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query3;
    query3.submit(this);
    var self2 = this;
    query3.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query3) {
    if (this._activeQuery === query3) {
      this.native.cancel(function() {
      });
    } else if (this._queryQueue.indexOf(query3) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query3), 1);
    }
  };
  Client.prototype.ref = function() {
  };
  Client.prototype.unref = function() {
  };
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// ../../node_modules/pg/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var Client = require_client3();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Pool = require_pg_pool();
  var { DatabaseError } = require_dist2();
  var { escapeIdentifier, escapeLiteral } = require_utils3();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client4());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        var native = null;
        try {
          native = new PG(require_client4());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// ../../node_modules/pg-boss/src/db.js
var require_db = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var pg = require_lib4();

  class Db extends EventEmitter {
    constructor(config) {
      super();
      config.application_name = config.application_name || "pgboss";
      this.config = config;
    }
    async open() {
      this.pool = new pg.Pool(this.config);
      this.pool.on("error", (error8) => this.emit("error", error8));
      this.opened = true;
    }
    async close() {
      if (!this.pool.ending) {
        this.opened = false;
        await this.pool.end();
      }
    }
    async executeSql(text, values4) {
      if (this.opened) {
        return await this.pool.query(text, values4);
      }
    }
    static quotePostgresStr(str) {
      const delimeter = "$sanitize$";
      if (str.includes(delimeter)) {
        throw new Error(`Attempted to quote string that contains reserved Postgres delimeter: ${str}`);
      }
      return `${delimeter}${str}${delimeter}`;
    }
  }
  module.exports = Db;
});

// ../../node_modules/indent-string/index.js
var require_indent_string = __commonJS((exports, module) => {
  module.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// ../../node_modules/clean-stack/index.js
var require_clean_stack = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
  var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
  var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
  module.exports = (stack, options) => {
    options = Object.assign({ pretty: false }, options);
    return stack.replace(/\\/g, "/").split("\n").filter((line) => {
      const pathMatches = line.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1]) {
        return true;
      }
      const match = pathMatches[1];
      if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
        return false;
      }
      return !pathRegex.test(match);
    }).filter((line) => line.trim() !== "").map((line) => {
      if (options.pretty) {
        return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
      }
      return line;
    }).join("\n");
  };
});

// ../../node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS((exports, module) => {
  var indentString = require_indent_string();
  var cleanStack = require_clean_stack();
  var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");

  class AggregateError2 extends Error {
    constructor(errors17) {
      if (!Array.isArray(errors17)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors17}`);
      }
      errors17 = [...errors17].map((error8) => {
        if (error8 instanceof Error) {
          return error8;
        }
        if (error8 !== null && typeof error8 === "object") {
          return Object.assign(new Error(error8.message), error8);
        }
        return new Error(error8);
      });
      let message = errors17.map((error8) => {
        return typeof error8.stack === "string" ? cleanInternalStack(cleanStack(error8.stack)) : String(error8);
      }).join("\n");
      message = "\n" + indentString(message, 4);
      super(message);
      this.name = "AggregateError";
      Object.defineProperty(this, "_errors", { value: errors17 });
    }
    *[Symbol.iterator]() {
      for (const error8 of this._errors) {
        yield error8;
      }
    }
  }
  module.exports = AggregateError2;
});

// ../../node_modules/p-map/index.js
var require_p_map = __commonJS((exports, module) => {
  var AggregateError2 = require_aggregate_error();
  module.exports = async (iterable, mapper, {
    concurrency = Infinity,
    stopOnError = true
  } = {}) => {
    return new Promise((resolve, reject2) => {
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const result = [];
      const errors17 = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const index = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            if (!stopOnError && errors17.length !== 0) {
              reject2(new AggregateError2(errors17));
            } else {
              resolve(result);
            }
          }
          return;
        }
        resolvingCount++;
        (async () => {
          try {
            const element = await nextItem.value;
            result[index] = await mapper(element, index);
            resolvingCount--;
            next();
          } catch (error8) {
            if (stopOnError) {
              isRejected = true;
              reject2(error8);
            } else {
              errors17.push(error8);
              resolvingCount--;
              next();
            }
          }
        })();
      };
      for (let i = 0;i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
  };
});

// ../../node_modules/pg-boss/src/boss.js
var require_boss = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var { states } = require_plans();
  var { COMPLETION_JOB_PREFIX } = plans;
  var queues = {
    MAINTENANCE: "__pgboss__maintenance",
    MONITOR_STATES: "__pgboss__monitor-states"
  };
  var events2 = {
    error: "error",
    monitorStates: "monitor-states",
    maintenance: "maintenance"
  };

  class Boss extends EventEmitter {
    constructor(db, config) {
      super();
      this.db = db;
      this.config = config;
      this.manager = config.manager;
      this.maintenanceIntervalSeconds = config.maintenanceIntervalSeconds;
      this.monitorStates = config.monitorStateIntervalSeconds !== null;
      if (this.monitorStates) {
        this.monitorIntervalSeconds = config.monitorStateIntervalSeconds;
      }
      this.events = events2;
      this.expireCommand = plans.locked(config.schema, plans.expire(config.schema));
      this.archiveCommand = plans.locked(config.schema, plans.archive(config.schema, config.archiveInterval, config.archiveFailedInterval));
      this.purgeCommand = plans.locked(config.schema, plans.purge(config.schema, config.deleteAfter));
      this.getMaintenanceTimeCommand = plans.getMaintenanceTime(config.schema);
      this.setMaintenanceTimeCommand = plans.setMaintenanceTime(config.schema);
      this.countStatesCommand = plans.countStates(config.schema);
      this.functions = [
        this.expire,
        this.archive,
        this.purge,
        this.countStates,
        this.getQueueNames
      ];
    }
    async supervise() {
      this.metaMonitor();
      await this.manager.deleteQueue(COMPLETION_JOB_PREFIX + queues.MAINTENANCE);
      await this.manager.deleteQueue(queues.MAINTENANCE);
      await this.maintenanceAsync();
      const maintenanceWorkOptions = {
        newJobCheckIntervalSeconds: Math.max(1, this.maintenanceIntervalSeconds / 2)
      };
      await this.manager.work(queues.MAINTENANCE, maintenanceWorkOptions, (job) => this.onMaintenance(job));
      if (this.monitorStates) {
        await this.manager.deleteQueue(COMPLETION_JOB_PREFIX + queues.MONITOR_STATES);
        await this.manager.deleteQueue(queues.MONITOR_STATES);
        await this.monitorStatesAsync();
        const monitorStatesWorkOptions = {
          newJobCheckIntervalSeconds: Math.max(1, this.monitorIntervalSeconds / 2)
        };
        await this.manager.work(queues.MONITOR_STATES, monitorStatesWorkOptions, (job) => this.onMonitorStates(job));
      }
    }
    metaMonitor() {
      this.metaMonitorInterval = setInterval(async () => {
        try {
          if (this.config.__test__throw_meta_monitor) {
            throw new Error(this.config.__test__throw_meta_monitor);
          }
          const { secondsAgo } = await this.getMaintenanceTime();
          if (secondsAgo > this.maintenanceIntervalSeconds * 2) {
            await this.manager.deleteQueue(queues.MAINTENANCE, { before: states.completed });
            await this.maintenanceAsync();
          }
        } catch (err) {
          this.emit(events2.error, err);
        }
      }, this.maintenanceIntervalSeconds * 2 * 1000);
    }
    async maintenanceAsync(options = {}) {
      const { startAfter } = options;
      options = {
        startAfter,
        retentionSeconds: this.maintenanceIntervalSeconds * 4,
        singletonKey: queues.MAINTENANCE,
        onComplete: false
      };
      await this.manager.send(queues.MAINTENANCE, null, options);
    }
    async monitorStatesAsync(options = {}) {
      const { startAfter } = options;
      options = {
        startAfter,
        retentionSeconds: this.monitorIntervalSeconds * 4,
        singletonKey: queues.MONITOR_STATES,
        onComplete: false
      };
      await this.manager.send(queues.MONITOR_STATES, null, options);
    }
    async onMaintenance(job) {
      try {
        if (this.config.__test__throw_maint) {
          throw new Error(this.config.__test__throw_maint);
        }
        const started = Date.now();
        await this.expire();
        await this.archive();
        await this.purge();
        const ended = Date.now();
        await this.setMaintenanceTime();
        this.emit("maintenance", { ms: ended - started });
        if (!this.stopped) {
          await this.manager.complete(job.id);
          await this.maintenanceAsync({ startAfter: this.maintenanceIntervalSeconds });
        }
      } catch (err) {
        this.emit(events2.error, err);
      }
    }
    async onMonitorStates(job) {
      try {
        if (this.config.__test__throw_monitor) {
          throw new Error(this.config.__test__throw_monitor);
        }
        const states2 = await this.countStates();
        this.emit(events2.monitorStates, states2);
        if (!this.stopped && this.monitorStates) {
          await this.manager.complete(job.id);
          await this.monitorStatesAsync({ startAfter: this.monitorIntervalSeconds });
        }
      } catch (err) {
        this.emit(events2.error, err);
      }
    }
    async stop() {
      if (this.config.__test__throw_stop) {
        throw new Error(this.config.__test__throw_stop);
      }
      if (!this.stopped) {
        if (this.metaMonitorInterval) {
          clearInterval(this.metaMonitorInterval);
        }
        await this.manager.offWork(queues.MAINTENANCE);
        if (this.monitorStates) {
          await this.manager.offWork(queues.MONITOR_STATES);
        }
        this.stopped = true;
      }
    }
    async countStates() {
      const stateCountDefault = { ...plans.states };
      Object.keys(stateCountDefault).forEach((key) => {
        stateCountDefault[key] = 0;
      });
      const counts = await this.executeSql(this.countStatesCommand);
      const states2 = counts.rows.reduce((acc, item) => {
        if (item.name) {
          acc.queues[item.name] = acc.queues[item.name] || { ...stateCountDefault };
        }
        const queue = item.name ? acc.queues[item.name] : acc;
        const state = item.state || "all";
        queue[state] = parseFloat(item.size);
        return acc;
      }, { ...stateCountDefault, queues: {} });
      return states2;
    }
    async expire() {
      await this.executeSql(this.expireCommand);
    }
    async archive() {
      await this.executeSql(this.archiveCommand);
    }
    async purge() {
      await this.executeSql(this.purgeCommand);
    }
    async setMaintenanceTime() {
      await this.executeSql(this.setMaintenanceTimeCommand);
    }
    async getMaintenanceTime() {
      if (!this.stopped) {
        const { rows } = await this.db.executeSql(this.getMaintenanceTimeCommand);
        let { maintained_on: maintainedOn, seconds_ago: secondsAgo } = rows[0];
        secondsAgo = secondsAgo !== null ? parseFloat(secondsAgo) : this.maintenanceIntervalSeconds * 10;
        return { maintainedOn, secondsAgo };
      }
    }
    getQueueNames() {
      return queues;
    }
    async executeSql(sql, params3) {
      if (!this.stopped) {
        return await this.db.executeSql(sql, params3);
      }
    }
  }
  module.exports = Boss;
  module.exports.QUEUES = queues;
});

// ../../node_modules/luxon/build/node/luxon.js
var require_luxon = __commonJS((exports) => {
  var makeDTF = function(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  };
  var hackyOffset = function(dtf, date) {
    const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  };
  var partsOffset = function(dtf, date) {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i = 0;i < formatted.length; i++) {
      const {
        type: type2,
        value
      } = formatted[i];
      const pos = typeToPos[type2];
      if (type2 === "era") {
        filled[pos] = value;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value, 10);
      }
    }
    return filled;
  };
  var getCachedLF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedDTF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedINF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  };
  var getCachedRTF = function(locString, opts = {}) {
    const {
      base: base18,
      ...cacheKeyOpts
    } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  };
  var systemLocale = function() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  };
  var getCachedWeekInfo = function(locString) {
    let data = weekInfoCache[locString];
    if (!data) {
      const locale = new Intl.Locale(locString);
      data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
      weekInfoCache[locString] = data;
    }
    return data;
  };
  var parseLocaleString = function(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const {
        numberingSystem,
        calendar
      } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  };
  var intlConfigString = function(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  };
  var mapMonths = function(f) {
    const ms = [];
    for (let i = 1;i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  };
  var mapWeekdays = function(f) {
    const ms = [];
    for (let i = 1;i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  };
  var listStuff = function(loc, length, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  };
  var supportsFastNumbers = function(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  };
  var normalizeZone = function(input6, defaultZone2) {
    if (isUndefined(input6) || input6 === null) {
      return defaultZone2;
    } else if (input6 instanceof Zone) {
      return input6;
    } else if (isString(input6)) {
      const lowered = input6.toLowerCase();
      if (lowered === "default")
        return defaultZone2;
      else if (lowered === "local" || lowered === "system")
        return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt")
        return FixedOffsetZone.utcInstance;
      else
        return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input6);
    } else if (isNumber(input6)) {
      return FixedOffsetZone.instance(input6);
    } else if (typeof input6 === "object" && "offset" in input6 && typeof input6.offset === "function") {
      return input6;
    } else {
      return new InvalidZone(input6);
    }
  };
  var parseDigits = function(str) {
    let value = parseInt(str, 10);
    if (isNaN(value)) {
      value = "";
      for (let i = 0;i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value += code - min;
            }
          }
        }
      }
      return parseInt(value, 10);
    } else {
      return value;
    }
  };
  var resetDigitRegexCache = function() {
    digitRegexCache = {};
  };
  var digitRegex = function({
    numberingSystem
  }, append = "") {
    const ns = numberingSystem || "latn";
    if (!digitRegexCache[ns]) {
      digitRegexCache[ns] = {};
    }
    if (!digitRegexCache[ns][append]) {
      digitRegexCache[ns][append] = new RegExp(`${numberingSystems[ns]}${append}`);
    }
    return digitRegexCache[ns][append];
  };
  var unitOutOfRange = function(unit, value) {
    return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
  };
  var dayOfWeek = function(year, month, day2) {
    const d = new Date(Date.UTC(year, month - 1, day2));
    if (year < 100 && year >= 0) {
      d.setUTCFullYear(d.getUTCFullYear() - 1900);
    }
    const js = d.getUTCDay();
    return js === 0 ? 7 : js;
  };
  var computeOrdinal = function(year, month, day2) {
    return day2 + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  };
  var uncomputeOrdinal = function(year, ordinal) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day2 = ordinal - table[month0];
    return {
      month: month0 + 1,
      day: day2
    };
  };
  var isoWeekdayToLocal = function(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  };
  var gregorianToWeek = function(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const {
      year,
      month,
      day: day2
    } = gregObj, ordinal = computeOrdinal(year, month, day2), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day2), startOfWeek);
    let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return {
      weekYear,
      weekNumber,
      weekday,
      ...timeObject(gregObj)
    };
  };
  var weekToGregorian = function(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const {
      weekYear,
      weekNumber,
      weekday
    } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const {
      month,
      day: day2
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day: day2,
      ...timeObject(weekData)
    };
  };
  var gregorianToOrdinal = function(gregData) {
    const {
      year,
      month,
      day: day2
    } = gregData;
    const ordinal = computeOrdinal(year, month, day2);
    return {
      year,
      ordinal,
      ...timeObject(gregData)
    };
  };
  var ordinalToGregorian = function(ordinalData) {
    const {
      year,
      ordinal
    } = ordinalData;
    const {
      month,
      day: day2
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day: day2,
      ...timeObject(ordinalData)
    };
  };
  var usesLocalWeekValues = function(obj, loc) {
    const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
      }
      if (!isUndefined(obj.localWeekday))
        obj.weekday = obj.localWeekday;
      if (!isUndefined(obj.localWeekNumber))
        obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined(obj.localWeekYear))
        obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return {
        minDaysInFirstWeek: 4,
        startOfWeek: 1
      };
    }
  };
  var hasInvalidWeekData = function(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else
      return false;
  };
  var hasInvalidOrdinalData = function(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else
      return false;
  };
  var hasInvalidGregorianData = function(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else
      return false;
  };
  var hasInvalidTimeData = function(obj) {
    const {
      hour,
      minute,
      second,
      millisecond
    } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else
      return false;
  };
  var isUndefined = function(o) {
    return typeof o === "undefined";
  };
  var isNumber = function(o) {
    return typeof o === "number";
  };
  var isInteger = function(o) {
    return typeof o === "number" && o % 1 === 0;
  };
  var isString = function(o) {
    return typeof o === "string";
  };
  var isDate = function(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  };
  var hasRelative = function() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e) {
      return false;
    }
  };
  var hasLocaleWeekInfo = function() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && (("weekInfo" in Intl.Locale.prototype) || ("getWeekInfo" in Intl.Locale.prototype));
    } catch (e) {
      return false;
    }
  };
  var maybeArray = function(thing) {
    return Array.isArray(thing) ? thing : [thing];
  };
  var bestBy = function(arr, by, compare) {
    if (arr.length === 0) {
      return;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  };
  var pick = function(obj, keys) {
    return keys.reduce((a, k) => {
      a[k] = obj[k];
      return a;
    }, {});
  };
  var hasOwnProperty3 = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  var validateWeekSettings = function(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  };
  var integerBetween = function(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  };
  var floorMod = function(x, n2) {
    return x - n2 * Math.floor(x / n2);
  };
  var padStart = function(input6, n2 = 2) {
    const isNeg = input6 < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input6).padStart(n2, "0");
    } else {
      padded = ("" + input6).padStart(n2, "0");
    }
    return padded;
  };
  var parseInteger = function(string) {
    if (isUndefined(string) || string === null || string === "") {
      return;
    } else {
      return parseInt(string, 10);
    }
  };
  var parseFloating = function(string) {
    if (isUndefined(string) || string === null || string === "") {
      return;
    } else {
      return parseFloat(string);
    }
  };
  var parseMillis = function(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return;
    } else {
      const f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  };
  var roundTo = function(number, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number * factor) / factor;
  };
  var isLeapYear = function(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var daysInYear = function(year) {
    return isLeapYear(year) ? 366 : 365;
  };
  var daysInMonth = function(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  };
  var objToLocalTS = function(obj) {
    let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
    if (obj.year < 100 && obj.year >= 0) {
      d = new Date(d);
      d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d;
  };
  var firstWeekOffset = function(year, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  };
  var weeksInWeekYear = function(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  };
  var untruncateYear = function(year) {
    if (year > 99) {
      return year;
    } else
      return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
  };
  var parseZoneInfo = function(ts, offsetFormat, locale, timeZone = null) {
    const date = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = {
      timeZoneName: offsetFormat,
      ...intlOpts
    };
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  };
  var signedOffset = function(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  };
  var asNumber = function(value) {
    const numericValue = Number(value);
    if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value}`);
    return numericValue;
  };
  var normalizeObject = function(obj, normalizer) {
    const normalized = {};
    for (const u2 in obj) {
      if (hasOwnProperty3(obj, u2)) {
        const v = obj[u2];
        if (v === undefined || v === null)
          continue;
        normalized[normalizer(u2)] = asNumber(v);
      }
    }
    return normalized;
  };
  var formatOffset = function(offset2, format) {
    const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
    switch (format) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  };
  var timeObject = function(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  };
  var months = function(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  };
  var weekdays = function(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  };
  var eras = function(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  };
  var meridiemForDateTime = function(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  };
  var weekdayForDateTime = function(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  };
  var monthForDateTime = function(dt, length) {
    return months(length)[dt.month - 1];
  };
  var eraForDateTime = function(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  };
  var formatRelativeTime = function(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  };
  var stringifyTokens = function(splits, tokenToString) {
    let s2 = "";
    for (const token of splits) {
      if (token.literal) {
        s2 += token.val;
      } else {
        s2 += tokenToString(token.val);
      }
    }
    return s2;
  };
  var combineRegexes = function(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}\$`);
  };
  var combineExtractors = function(...extractors) {
    return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{
        ...mergedVals,
        ...val
      }, zone || mergedZone, next];
    }, [{}, null, 1]).slice(0, 2);
  };
  var parse2 = function(s2, ...patterns) {
    if (s2 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns) {
      const m = regex.exec(s2);
      if (m) {
        return extractor(m);
      }
    }
    return [null, null];
  };
  var simpleParse = function(...keys) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0;i < keys.length; i++) {
        ret[keys[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  };
  var int = function(match2, pos, fallback) {
    const m = match2[pos];
    return isUndefined(m) ? fallback : parseInteger(m);
  };
  var extractISOYmd = function(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  };
  var extractISOTime = function(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  };
  var extractISOOffset = function(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  };
  var extractIANAZone = function(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  };
  var extractISODuration = function(match2) {
    const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s2[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
    return [{
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }];
  };
  var fromStrings = function(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr)
      result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  };
  var extractRFC2822 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset2;
    if (obsOffset) {
      offset2 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset2 = 0;
    } else {
      offset2 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset2)];
  };
  var preprocessRFC2822 = function(s2) {
    return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  };
  var extractRFC1123Or850 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  };
  var extractASCII = function(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  };
  var parseISODate = function(s2) {
    return parse2(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
  };
  var parseRFC2822Date = function(s2) {
    return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
  };
  var parseHTTPDate = function(s2) {
    return parse2(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
  };
  var parseISODuration = function(s2) {
    return parse2(s2, [isoDuration, extractISODuration]);
  };
  var parseISOTimeOnly = function(s2) {
    return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
  };
  var parseSQL = function(s2) {
    return parse2(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
  };
  var clone$1 = function(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : {
        ...dur.values,
        ...alts.values || {}
      },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  };
  var durationToMillis = function(matrix, vals) {
    var _vals$milliseconds;
    let sum = (_vals$milliseconds = vals.milliseconds) != null ? _vals$milliseconds : 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum += vals[unit] * matrix[unit]["milliseconds"];
      }
    }
    return sum;
  };
  var normalizeValues = function(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits$1.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits$1.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  };
  var removeZeroes = function(vals) {
    const newVals = {};
    for (const [key, value] of Object.entries(vals)) {
      if (value !== 0) {
        newVals[key] = value;
      }
    }
    return newVals;
  };
  var validateStartEnd = function(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
    } else {
      return null;
    }
  };
  var dayDiff = function(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  };
  var highOrderDiffs = function(cursor, later, units) {
    const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
      const days = dayDiff(a, b);
      return (days - days % 7) / 7;
    }], ["days", dayDiff]];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  };
  var diff = function(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter((u2) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0);
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({
          [lowestOrder]: 1
        });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  };
  var intUnit = function(regex, post = (i) => i) {
    return {
      regex,
      deser: ([s2]) => post(parseDigits(s2))
    };
  };
  var fixListRegex = function(s2) {
    return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  };
  var stripInsensitivities = function(s2) {
    return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  };
  var oneOf = function(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
      };
    }
  };
  var offset = function(regex, groups) {
    return {
      regex,
      deser: ([, h, m]) => signedOffset(h, m),
      groups
    };
  };
  var simple = function(regex) {
    return {
      regex,
      deser: ([s2]) => s2
    };
  };
  var escapeToken = function(value) {
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  };
  var unitForToken = function(token, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({
      regex: RegExp(escapeToken(t.val)),
      deser: ([s2]) => s2,
      literal: true
    }), unitate = (t) => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal(t);
      }
    };
    const unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token;
    return unit;
  };
  var tokenForPart = function(part, formatOpts, resolvedOpts) {
    const {
      type: type2,
      value
    } = part;
    if (type2 === "literal") {
      const isSpace = /^\s+$/.test(value);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value
      };
    }
    const style = formatOpts[type2];
    let actualType = type2;
    if (type2 === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return;
  };
  var buildRegex = function(units) {
    const re = units.map((u2) => u2.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re}\$`, units];
  };
  var match = function(input6, regex, handlers) {
    const matches = input6.match(regex);
    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty3(handlers, i)) {
          const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  };
  var dateTimeFromMatches = function(matches) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }
    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }
    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }
    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }
    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }
    const vals = Object.keys(matches).reduce((r, k) => {
      const f = toField(k);
      if (f) {
        r[f] = matches[k];
      }
      return r;
    }, {});
    return [vals, zone, specificOffset];
  };
  var getDummyDateTime = function() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  };
  var maybeExpandMacroToken = function(token, locale) {
    if (token.literal) {
      return token;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);
    if (tokens == null || tokens.includes(undefined)) {
      return token;
    }
    return tokens;
  };
  var expandMacroTokens = function(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
  };
  var explainFromTokens = function(locale, input6, format) {
    const parser = new TokenParser(locale, format);
    return parser.explainFromTokens(input6);
  };
  var parseFromTokens = function(locale, input6, format) {
    const {
      result,
      zone,
      specificOffset,
      invalidReason
    } = explainFromTokens(locale, input6, format);
    return [result, zone, specificOffset, invalidReason];
  };
  var formatOptsToTokens = function(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
  };
  var unsupportedZone = function(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  };
  var possiblyCachedWeekData = function(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  };
  var possiblyCachedLocalWeekData = function(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
    }
    return dt.localWeekData;
  };
  var clone = function(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({
      ...current,
      ...alts,
      old: current
    });
  };
  var fixOffset = function(localTS, o, tz) {
    let utcGuess = localTS - o * 60 * 1000;
    const o2 = tz.offset(utcGuess);
    if (o === o2) {
      return [utcGuess, o];
    }
    utcGuess -= (o2 - o) * 60 * 1000;
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
  };
  var tsToObj = function(ts, offset2) {
    ts += offset2 * 60 * 1000;
    const d = new Date(ts);
    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
      hour: d.getUTCHours(),
      minute: d.getUTCMinutes(),
      second: d.getUTCSeconds(),
      millisecond: d.getUTCMilliseconds()
    };
  };
  var objToTS = function(obj, offset2, zone) {
    return fixOffset(objToLocalTS(obj), offset2, zone);
  };
  var adjustTime = function(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c);
    let [ts, o] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o = inst.zone.offset(ts);
    }
    return {
      ts,
      o
    };
  };
  var parseDataToDateTime = function(parsed, parsedZone, opts, format, text, specificOffset) {
    const {
      setZone,
      zone
    } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
    }
  };
  var toTechFormat = function(dt, format, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format) : null;
  };
  var toISODate = function(o, extended) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c = "";
    if (longFormat && o.c.year >= 0)
      c += "+";
    c += padStart(o.c.year, longFormat ? 6 : 4);
    if (extended) {
      c += "-";
      c += padStart(o.c.month);
      c += "-";
      c += padStart(o.c.day);
    } else {
      c += padStart(o.c.month);
      c += padStart(o.c.day);
    }
    return c;
  };
  var toISOTime = function(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c = padStart(o.c.hour);
    if (extended) {
      c += ":";
      c += padStart(o.c.minute);
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c += ":";
      }
    } else {
      c += padStart(o.c.minute);
    }
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += padStart(o.c.second);
      if (o.c.millisecond !== 0 || !suppressMilliseconds) {
        c += ".";
        c += padStart(o.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c += "Z";
      } else if (o.o < 0) {
        c += "-";
        c += padStart(Math.trunc(-o.o / 60));
        c += ":";
        c += padStart(Math.trunc(-o.o % 60));
      } else {
        c += "+";
        c += padStart(Math.trunc(o.o / 60));
        c += ":";
        c += padStart(Math.trunc(o.o % 60));
      }
    }
    if (extendedZone) {
      c += "[" + o.zone.ianaName + "]";
    }
    return c;
  };
  var normalizeUnit = function(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  };
  var normalizeUnitWithLocalWeeks = function(unit) {
    switch (unit.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit);
    }
  };
  var guessOffsetForZone = function(zone) {
    if (!zoneOffsetGuessCache[zone]) {
      if (zoneOffsetTs === undefined) {
        zoneOffsetTs = Settings.now();
      }
      zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
    }
    return zoneOffsetGuessCache[zone];
  };
  var quickDT = function(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    }
    const loc = Locale.fromObject(opts);
    let ts, o;
    if (!isUndefined(obj.year)) {
      for (const u2 of orderedUnits) {
        if (isUndefined(obj[u2])) {
          obj[u2] = defaultUnitValues[u2];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = guessOffsetForZone(zone);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = Settings.now();
    }
    return new DateTime({
      ts,
      zone,
      loc,
      o
    });
  };
  var diffRelative = function(start, end, opts) {
    const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else
          return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  };
  var lastOpts = function(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  };
  var friendlyDateTime = function(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class LuxonError extends Error {
  }

  class InvalidDateTimeError extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  }

  class InvalidIntervalError extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  }

  class InvalidDurationError extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  }

  class ConflictingSpecificationError extends LuxonError {
  }

  class InvalidUnitError extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  }

  class InvalidArgumentError extends LuxonError {
  }

  class ZoneIsAbstractError extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  }
  var n = "numeric";
  var s = "short";
  var l = "long";
  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };
  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
  };
  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };
  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };
  var TIME_SIMPLE = {
    hour: n,
    minute: n
  };
  var TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };
  var TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
  };
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
  };
  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };

  class Zone {
    get type() {
      throw new ZoneIsAbstractError;
    }
    get name() {
      throw new ZoneIsAbstractError;
    }
    get ianaName() {
      return this.name;
    }
    get isUniversal() {
      throw new ZoneIsAbstractError;
    }
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError;
    }
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError;
    }
    offset(ts) {
      throw new ZoneIsAbstractError;
    }
    equals(otherZone) {
      throw new ZoneIsAbstractError;
    }
    get isValid() {
      throw new ZoneIsAbstractError;
    }
  }
  var singleton$1 = null;

  class SystemZone extends Zone {
    static get instance() {
      if (singleton$1 === null) {
        singleton$1 = new SystemZone;
      }
      return singleton$1;
    }
    get type() {
      return "system";
    }
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    equals(otherZone) {
      return otherZone.type === "system";
    }
    get isValid() {
      return true;
    }
  }
  var dtfCache = {};
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  var ianaZoneCache = {};

  class IANAZone extends Zone {
    static create(name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new IANAZone(name);
      }
      return ianaZoneCache[name];
    }
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    static isValidSpecifier(s2) {
      return this.isValidZone(s2);
    }
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", {
          timeZone: zone
        }).format();
        return true;
      } catch (e) {
        return false;
      }
    }
    constructor(name) {
      super();
      this.zoneName = name;
      this.valid = IANAZone.isValidZone(name);
    }
    get type() {
      return "iana";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      const date = new Date(ts);
      if (isNaN(date))
        return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day2, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day: day2,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0
      });
      let asTS = +date;
      const over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return (asUTC - asTS) / (60 * 1000);
    }
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    get isValid() {
      return this.valid;
    }
  }
  var intlLFCache = {};
  var intlDTCache = {};
  var intlNumCache = {};
  var intlRelCache = {};
  var sysLocaleCache = null;
  var weekInfoCache = {};

  class PolyNumberFormatter {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const {
        padTo,
        floor,
        ...otherOpts
      } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = {
          useGrouping: false,
          ...opts
        };
        if (opts.padTo > 0)
          intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  }

  class PolyDateFormatter {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = undefined;
      let z = undefined;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
            minutes: dt.offset
          });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({
          minutes: dt.offset
        });
        this.originalZone = dt.zone;
      }
      const intlOpts = {
        ...this.opts
      };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({
          value
        }) => value).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }

  class PolyRelFormatter {
    constructor(intl, isEnglish, opts) {
      this.opts = {
        style: "long",
        ...opts
      };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  }
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };

  class Locale {
    static fromOpts(opts) {
      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
    }
    static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({
      locale,
      numberingSystem,
      outputCalendar,
      weekSettings
    } = {}) {
      return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = {
        format: {},
        standalone: {}
      };
      this.monthsCache = {
        format: {},
        standalone: {}
      };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: true
      });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: false
      });
    }
    months(length, format = false) {
      return listStuff(this, length, months, () => {
        const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length];
      });
    }
    weekdays(length, format = false) {
      return listStuff(this, length, weekdays, () => {
        const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
        }
        return this.weekdaysCache[formatStr][length];
      });
    }
    meridiems() {
      return listStuff(this, undefined, () => meridiems, () => {
        if (!this.meridiemCache) {
          const intl = {
            hour: "numeric",
            hourCycle: "h12"
          };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
        }
        return this.meridiemCache;
      });
    }
    eras(length) {
      return listStuff(this, length, eras, () => {
        const intl = {
          era: length
        };
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
        }
        return this.eraCache[length];
      });
    }
    extract(dt, intlOpts, field3) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field3);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
    toString() {
      return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
    }
  }
  var singleton = null;

  class FixedOffsetZone extends Zone {
    static get utcInstance() {
      if (singleton === null) {
        singleton = new FixedOffsetZone(0);
      }
      return singleton;
    }
    static instance(offset2) {
      return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
    }
    static parseSpecifier(s2) {
      if (s2) {
        const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }
    constructor(offset2) {
      super();
      this.fixed = offset2;
    }
    get type() {
      return "fixed";
    }
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    offsetName() {
      return this.name;
    }
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }
    get isUniversal() {
      return true;
    }
    offset() {
      return this.fixed;
    }
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    get isValid() {
      return true;
    }
  }

  class InvalidZone extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    get type() {
      return "invalid";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName() {
      return null;
    }
    formatOffset() {
      return "";
    }
    offset() {
      return NaN;
    }
    equals() {
      return false;
    }
    get isValid() {
      return false;
    }
  }
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  var digitRegexCache = {};
  var now = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;

  class Settings {
    static get now() {
      return now;
    }
    static set now(n2) {
      now = n2;
    }
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    static get defaultLocale() {
      return defaultLocale;
    }
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    static set throwOnInvalid(t) {
      throwOnInvalid = t;
    }
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
      DateTime.resetCache();
      resetDigitRegexCache();
    }
  }

  class Invalid {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  }
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };

  class Formatter {
    static create(locale, opts = {}) {
      return new Formatter(locale, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0;i < fmt.length; i++) {
        const c = fmt.charAt(i);
        if (c === "'") {
          if (currentFull.length > 0) {
            splits.push({
              literal: bracketed || /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c;
        } else if (c === current) {
          currentFull += c;
        } else {
          if (currentFull.length > 0) {
            splits.push({
              literal: /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          currentFull = c;
          current = c;
        }
      }
      if (currentFull.length > 0) {
        splits.push({
          literal: bracketed || /^\s+$/.test(currentFull),
          val: currentFull
        });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }
    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n2, p = 0) {
      if (this.opts.forceSimple) {
        return padStart(n2, p);
      }
      const opts = {
        ...this.opts
      };
      if (p > 0) {
        opts.padTo = p;
      }
      return this.loc.numberFormatter(opts).format(n2);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"), maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era"), tokenToString = (token) => {
        switch (token) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            return formatOffset2({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            return formatOffset2({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter ? string({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
      return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, {
        literal,
        val
      }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
      return stringifyTokens(tokens, tokenToString(collapsed));
    }
  }
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}\$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var INVALID$2 = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
  var reverseUnits = orderedUnits$1.slice(0).reverse();

  class Duration {
    constructor(config) {
      const accurate = config.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config.matrix) {
        matrix = config.matrix;
      }
      this.values = config.values;
      this.loc = config.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    static fromMillis(count, opts) {
      return Duration.fromObject({
        milliseconds: count
      }, opts);
    }
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
      }
      return new Duration({
        values: normalizeObject(obj, Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return Duration.fromMillis(durationLike);
      } else if (Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
      }
    }
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new Duration({
          invalid
        });
      }
    }
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    static isDuration(o) {
      return o && o.isLuxonDuration || false;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
    }
    toHuman(opts = {}) {
      if (!this.isValid)
        return INVALID$2;
      const l2 = orderedUnits$1.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({
          style: "unit",
          unitDisplay: "long",
          ...opts,
          unit: unit.slice(0, -1)
        }).format(val);
      }).filter((n2) => n2);
      return this.loc.listFormatter({
        type: "conjunction",
        style: opts.listStyle || "narrow",
        ...opts
      }).format(l2);
    }
    toObject() {
      if (!this.isValid)
        return {};
      return {
        ...this.values
      };
    }
    toISO() {
      if (!this.isValid)
        return null;
      let s2 = "P";
      if (this.years !== 0)
        s2 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0)
        s2 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0)
        s2 += this.weeks + "W";
      if (this.days !== 0)
        s2 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s2 += "T";
      if (this.hours !== 0)
        s2 += this.hours + "H";
      if (this.minutes !== 0)
        s2 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s2 += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
      if (s2 === "P")
        s2 += "T0S";
      return s2;
    }
    toISOTime(opts = {}) {
      if (!this.isValid)
        return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 86400000)
        return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, {
        zone: "UTC"
      });
      return dateTime.toISOTime(opts);
    }
    toJSON() {
      return this.toISO();
    }
    toString() {
      return this.toISO();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    toMillis() {
      if (!this.isValid)
        return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    valueOf() {
      return this.toMillis();
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration), result = {};
      for (const k of orderedUnits$1) {
        if (hasOwnProperty3(dur.values, k) || hasOwnProperty3(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    mapUnits(fn) {
      if (!this.isValid)
        return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber(fn(this.values[k], k));
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    get(unit) {
      return this[Duration.normalizeUnit(unit)];
    }
    set(values4) {
      if (!this.isValid)
        return this;
      const mixed = {
        ...this.values,
        ...normalizeObject(values4, Duration.normalizeUnit)
      };
      return clone$1(this, {
        values: mixed
      });
    }
    reconfigure({
      locale,
      numberingSystem,
      conversionAccuracy,
      matrix
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem
      });
      const opts = {
        loc,
        matrix,
        conversionAccuracy
      };
      return clone$1(this, opts);
    }
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    normalize() {
      if (!this.isValid)
        return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone$1(this, {
        values: vals
      }, true);
    }
    rescale() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone$1(this, {
        values: vals
      }, true);
    }
    shiftTo(...units) {
      if (!this.isValid)
        return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u2) => Duration.normalizeUnit(u2));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits$1) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1000 - i * 1000) / 1000;
        } else if (isNumber(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone$1(this, {
        values: built
      }, true);
    }
    shiftToAll() {
      if (!this.isValid)
        return this;
      return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
    }
    negate() {
      if (!this.isValid)
        return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone$1(this, {
        values: negated
      }, true);
    }
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === undefined || v1 === 0)
          return v2 === undefined || v2 === 0;
        return v1 === v2;
      }
      for (const u2 of orderedUnits$1) {
        if (!eq(this.values[u2], other.values[u2])) {
          return false;
        }
      }
      return true;
    }
  }
  var INVALID$1 = "Invalid Interval";

  class Interval {
    constructor(config) {
      this.s = config.start;
      this.e = config.end;
      this.invalid = config.invalid || null;
      this.isLuxonInterval = true;
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new Interval({
          invalid
        });
      }
    }
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    static after(start, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
      return Interval.fromDateTimes(dt, dt.plus(dur));
    }
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return Interval.fromDateTimes(dt.minus(dur), dt);
    }
    static fromISO(text, opts) {
      const [s2, e] = (text || "").split("/", 2);
      if (s2 && e) {
        let start, startIsValid;
        try {
          start = DateTime.fromISO(s2, opts);
          startIsValid = start.isValid;
        } catch (e2) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e, opts);
          endIsValid = end.isValid;
        } catch (e2) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return Interval.fromDateTimes(start, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e, opts);
          if (dur.isValid) {
            return Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s2, opts);
          if (dur.isValid) {
            return Interval.before(end, dur);
          }
        }
      }
      return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    static isInterval(o) {
      return o && o.isLuxonInterval || false;
    }
    get start() {
      return this.isValid ? this.s : null;
    }
    get end() {
      return this.isValid ? this.e : null;
    }
    get isValid() {
      return this.invalidReason === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    count(unit = "milliseconds", opts) {
      if (!this.isValid)
        return NaN;
      const start = this.start.startOf(unit, opts);
      let end;
      if (opts != null && opts.useLocaleWeeks) {
        end = this.end.reconfigure({
          locale: start.locale
        });
      } else {
        end = this.end;
      }
      end = end.startOf(unit, opts);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    isAfter(dateTime) {
      if (!this.isValid)
        return false;
      return this.s > dateTime;
    }
    isBefore(dateTime) {
      if (!this.isValid)
        return false;
      return this.e <= dateTime;
    }
    contains(dateTime) {
      if (!this.isValid)
        return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    set({
      start,
      end
    } = {}) {
      if (!this.isValid)
        return this;
      return Interval.fromDateTimes(start || this.s, end || this.e);
    }
    splitAt(...dateTimes) {
      if (!this.isValid)
        return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
      let {
        s: s2
      } = this, i = 0;
      while (s2 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s2, next));
        s2 = next;
        i += 1;
      }
      return results;
    }
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let {
        s: s2
      } = this, idx = 1, next;
      const results = [];
      while (s2 < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s2, next));
        s2 = next;
        idx += 1;
      }
      return results;
    }
    divideEqually(numberOfParts) {
      if (!this.isValid)
        return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    abutsStart(other) {
      if (!this.isValid)
        return false;
      return +this.e === +other.s;
    }
    abutsEnd(other) {
      if (!this.isValid)
        return false;
      return +other.e === +this.s;
    }
    engulfs(other) {
      if (!this.isValid)
        return false;
      return this.s <= other.s && this.e >= other.e;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    intersection(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
      if (s2 >= e) {
        return null;
      } else {
        return Interval.fromDateTimes(s2, e);
      }
    }
    union(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
      return Interval.fromDateTimes(s2, e);
    }
    static merge(intervals) {
      const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      }, [[], null]);
      if (final) {
        found.push(final);
      }
      return found;
    }
    static xor(intervals) {
      let start = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start = i.time;
        } else {
          if (start && +start !== +i.time) {
            results.push(Interval.fromDateTimes(start, i.time));
          }
          start = null;
        }
      }
      return Interval.merge(results);
    }
    difference(...intervals) {
      return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    toString() {
      if (!this.isValid)
        return INVALID$1;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
    }
    toISO(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    toISODate() {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    toISOTime(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    toFormat(dateFormat, {
      separator = " \u2013 "
    } = {}) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    mapEndpoints(mapFn) {
      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  }

  class Info {
    static hasDST(zone = Settings.defaultZone) {
      const proto2 = DateTime.now().setZone(zone).set({
        month: 12
      });
      return !zone.isUniversal && proto2.offset !== proto2.set({
        month: 6
      }).offset;
    }
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    static normalizeZone(input6) {
      return normalizeZone(input6, Settings.defaultZone);
    }
    static getStartOfWeek({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getStartOfWeek();
    }
    static getMinimumDaysInFirstWeek({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
    }
    static getWeekendWeekdays({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getWeekendDays().slice();
    }
    static months(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }
    static monthsFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }
    static weekdays(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }
    static weekdaysFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }
    static meridiems({
      locale = null
    } = {}) {
      return Locale.create(locale).meridiems();
    }
    static eras(length = "short", {
      locale = null
    } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }
    static features() {
      return {
        relative: hasRelative(),
        localeWeek: hasLocaleWeekInfo()
      };
    }
  }
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  var dummyDateTimeCache = null;

  class TokenParser {
    constructor(locale, format) {
      this.locale = locale;
      this.format = format;
      this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
      this.units = this.tokens.map((t) => unitForToken(t, locale));
      this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
      if (!this.disqualifyingUnit) {
        const [regexString, handlers] = buildRegex(this.units);
        this.regex = RegExp(regexString, "i");
        this.handlers = handlers;
      }
    }
    explainFromTokens(input6) {
      if (!this.isValid) {
        return {
          input: input6,
          tokens: this.tokens,
          invalidReason: this.invalidReason
        };
      } else {
        const [rawMatches, matches] = match(input6, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
        if (hasOwnProperty3(matches, "a") && hasOwnProperty3(matches, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }
        return {
          input: input6,
          tokens: this.tokens,
          regex: this.regex,
          rawMatches,
          matches,
          result,
          zone,
          specificOffset
        };
      }
    }
    get isValid() {
      return !this.disqualifyingUnit;
    }
    get invalidReason() {
      return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
    }
  }
  var INVALID = "Invalid DateTime";
  var MAX_DATE = 8640000000000000;
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  var zoneOffsetTs;
  var zoneOffsetGuessCache = {};

  class DateTime {
    constructor(config) {
      const zone = config.zone || Settings.defaultZone;
      let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
      let c = null, o = null;
      if (!invalid) {
        const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
        if (unchanged) {
          [c, o] = [config.old.c, config.old.o];
        } else {
          const ot = isNumber(config.o) && !config.old ? config.o : zone.offset(this.ts);
          c = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
          c = invalid ? null : c;
          o = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c;
      this.o = o;
      this.isLuxonDateTime = true;
    }
    static now() {
      return new DateTime({});
    }
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day2, hour, minute, second, millisecond] = args;
      return quickDT({
        year,
        month,
        day: day2,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day2, hour, minute, second, millisecond] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({
        year,
        month,
        day: day2,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static fromJSDate(date, options = {}) {
      const ts = isDate(date) ? date.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return DateTime.invalid("Timestamp out of range");
      } else {
        return new DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new DateTime({
          ts: seconds * 1000,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const {
        minDaysInFirstWeek,
        startOfWeek
      } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u2 of units) {
        const v = normalized[u2];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u2] = defaultValues[u2];
        } else {
          normalized[u2] = objNow[u2];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
      }
      if (!inst.isValid) {
        return DateTime.invalid(inst.invalid);
      }
      return inst;
    }
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    static fromString(text, fmt, opts = {}) {
      return DateTime.fromFormat(text, fmt, opts);
    }
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new DateTime({
          invalid
        });
      }
    }
    static isDateTime(o) {
      return o && o.isLuxonDateTime || false;
    }
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
    }
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t) => t.val).join("");
    }
    static resetCache() {
      zoneOffsetTs = undefined;
      zoneOffsetGuessCache = {};
    }
    get(unit) {
      return this[unit];
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    get zone() {
      return this._zone;
    }
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    get monthShort() {
      return this.isValid ? Info.months("short", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get monthLong() {
      return this.isValid ? Info.months("long", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1,
          day: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 86400000;
      const minuteMs = 60000;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c12 = tsToObj(ts1, o1);
      const c2 = tsToObj(ts2, o2);
      if (c12.hour === c2.hour && c12.minute === c2.minute && c12.second === c2.second && c12.millisecond === c2.millisecond) {
        return [clone(this, {
          ts: ts1
        }), clone(this, {
          ts: ts2
        })];
      }
      return [this];
    }
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
    }
    resolvedLocaleOptions(opts = {}) {
      const {
        locale,
        numberingSystem,
        calendar
      } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
      return {
        locale,
        numberingSystem,
        outputCalendar: calendar
      };
    }
    toUTC(offset2 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset2), opts);
    }
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    setZone(zone, {
      keepLocalTime = false,
      keepCalendarTime = false
    } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone(this, {
          ts: newTS,
          zone
        });
      }
    }
    reconfigure({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem,
        outputCalendar
      });
      return clone(this, {
        loc
      });
    }
    setLocale(locale) {
      return this.reconfigure({
        locale
      });
    }
    set(values4) {
      if (!this.isValid)
        return this;
      const normalized = normalizeObject(values4, normalizeUnitWithLocalWeeks);
      const {
        minDaysInFirstWeek,
        startOfWeek
      } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian({
          ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek),
          ...normalized
        }, minDaysInFirstWeek, startOfWeek);
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({
          ...gregorianToOrdinal(this.c),
          ...normalized
        });
      } else {
        mixed = {
          ...this.toObject(),
          ...normalized
        };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone(this, {
        ts,
        o
      });
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return clone(this, adjustTime(this, dur));
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone(this, adjustTime(this, dur));
    }
    startOf(unit, {
      useLocaleWeeks = false
    } = {}) {
      if (!this.isValid)
        return this;
      const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        case "quarters":
        case "months":
          o.day = 1;
        case "weeks":
        case "days":
          o.hour = 0;
        case "hours":
          o.minute = 0;
        case "minutes":
          o.second = 0;
        case "seconds":
          o.millisecond = 0;
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const {
            weekday
          } = this;
          if (weekday < startOfWeek) {
            o.weekNumber = this.weekNumber - 1;
          }
          o.weekday = startOfWeek;
        } else {
          o.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }
      return this.set(o);
    }
    endOf(unit, opts) {
      return this.isValid ? this.plus({
        [unit]: 1
      }).startOf(unit, opts).minus(1) : this;
    }
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
    }
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format === "extended";
      let c = toISODate(this, ext);
      c += "T";
      c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c;
    }
    toISODate({
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format === "extended");
    }
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c = includePrefix ? "T" : "";
      return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    }
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    toSQLTime({
      includeOffset = true,
      includeZone = false,
      includeOffsetSpace = true
    } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    toString() {
      return this.isValid ? this.toISO() : INVALID;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    valueOf() {
      return this.toMillis();
    }
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    toSeconds() {
      return this.isValid ? this.ts / 1000 : NaN;
    }
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1000) : NaN;
    }
    toJSON() {
      return this.toISO();
    }
    toBSON() {
      return this.toJSDate();
    }
    toObject(opts = {}) {
      if (!this.isValid)
        return {};
      const base18 = {
        ...this.c
      };
      if (opts.includeConfig) {
        base18.outputCalendar = this.outputCalendar;
        base18.numberingSystem = this.loc.numberingSystem;
        base18.locale = this.loc.locale;
      }
      return base18;
    }
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = {
        locale: this.locale,
        numberingSystem: this.numberingSystem,
        ...opts
      };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(DateTime.now(), unit, opts);
    }
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    hasSame(otherDateTime, unit, opts) {
      if (!this.isValid)
        return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, {
        keepLocalTime: true
      });
      return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
    }
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    toRelative(options = {}) {
      if (!this.isValid)
        return null;
      const base18 = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), padding = options.padding ? this < base18 ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = undefined;
      }
      return diffRelative(base18, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    toRelativeCalendar(options = {}) {
      if (!this.isValid)
        return null;
      return diffRelative(options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    static min(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    static max(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    static fromFormatExplain(text, fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    static fromStringExplain(text, fmt, options = {}) {
      return DateTime.fromFormatExplain(text, fmt, options);
    }
    static buildFormatParser(fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return new TokenParser(localeToUse, fmt);
    }
    static fromFormatParser(text, formatParser, opts = {}) {
      if (isUndefined(text) || isUndefined(formatParser)) {
        throw new InvalidArgumentError("fromFormatParser requires an input string and a format parser");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      if (!localeToUse.equals(formatParser.locale)) {
        throw new InvalidArgumentError(`fromFormatParser called with a locale of ${localeToUse}, ` + `but the format parser was created for ${formatParser.locale}`);
      }
      const {
        result,
        zone,
        specificOffset,
        invalidReason
      } = formatParser.explainFromTokens(text);
      if (invalidReason) {
        return DateTime.invalid(invalidReason);
      } else {
        return parseDataToDateTime(result, zone, opts, `format ${formatParser.format}`, text, specificOffset);
      }
    }
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    static get DATE_MED() {
      return DATE_MED;
    }
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    static get DATE_FULL() {
      return DATE_FULL;
    }
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }
  var VERSION = "3.5.0";
  exports.DateTime = DateTime;
  exports.Duration = Duration;
  exports.FixedOffsetZone = FixedOffsetZone;
  exports.IANAZone = IANAZone;
  exports.Info = Info;
  exports.Interval = Interval;
  exports.InvalidZone = InvalidZone;
  exports.Settings = Settings;
  exports.SystemZone = SystemZone;
  exports.VERSION = VERSION;
  exports.Zone = Zone;
});

// ../../node_modules/cron-parser/lib/date.js
var require_date = __commonJS((exports, module) => {
  var CronDate = function(timestamp, tz) {
    var dateOpts = { zone: tz };
    if (!timestamp) {
      this._date = luxon.DateTime.local();
    } else if (timestamp instanceof CronDate) {
      this._date = timestamp._date;
    } else if (timestamp instanceof Date) {
      this._date = luxon.DateTime.fromJSDate(timestamp, dateOpts);
    } else if (typeof timestamp === "number") {
      this._date = luxon.DateTime.fromMillis(timestamp, dateOpts);
    } else if (typeof timestamp === "string") {
      this._date = luxon.DateTime.fromISO(timestamp, dateOpts);
      this._date.isValid || (this._date = luxon.DateTime.fromRFC2822(timestamp, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromSQL(timestamp, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromFormat(timestamp, "EEE, d MMM yyyy HH:mm:ss", dateOpts));
    }
    if (!this._date || !this._date.isValid) {
      throw new Error("CronDate: unhandled timestamp: " + JSON.stringify(timestamp));
    }
    if (tz && tz !== this._date.zoneName) {
      this._date = this._date.setZone(tz);
    }
  };
  var luxon = require_luxon();
  CronDate.prototype.addYear = function() {
    this._date = this._date.plus({ years: 1 });
  };
  CronDate.prototype.addMonth = function() {
    this._date = this._date.plus({ months: 1 }).startOf("month");
  };
  CronDate.prototype.addDay = function() {
    this._date = this._date.plus({ days: 1 }).startOf("day");
  };
  CronDate.prototype.addHour = function() {
    var prev = this._date;
    this._date = this._date.plus({ hours: 1 }).startOf("hour");
    if (this._date <= prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addMinute = function() {
    var prev = this._date;
    this._date = this._date.plus({ minutes: 1 }).startOf("minute");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addSecond = function() {
    var prev = this._date;
    this._date = this._date.plus({ seconds: 1 }).startOf("second");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractYear = function() {
    this._date = this._date.minus({ years: 1 });
  };
  CronDate.prototype.subtractMonth = function() {
    this._date = this._date.minus({ months: 1 }).endOf("month").startOf("second");
  };
  CronDate.prototype.subtractDay = function() {
    this._date = this._date.minus({ days: 1 }).endOf("day").startOf("second");
  };
  CronDate.prototype.subtractHour = function() {
    var prev = this._date;
    this._date = this._date.minus({ hours: 1 }).endOf("hour").startOf("second");
    if (this._date >= prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractMinute = function() {
    var prev = this._date;
    this._date = this._date.minus({ minutes: 1 }).endOf("minute").startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractSecond = function() {
    var prev = this._date;
    this._date = this._date.minus({ seconds: 1 }).startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.getDate = function() {
    return this._date.day;
  };
  CronDate.prototype.getFullYear = function() {
    return this._date.year;
  };
  CronDate.prototype.getDay = function() {
    var weekday = this._date.weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getMonth = function() {
    return this._date.month - 1;
  };
  CronDate.prototype.getHours = function() {
    return this._date.hour;
  };
  CronDate.prototype.getMinutes = function() {
    return this._date.minute;
  };
  CronDate.prototype.getSeconds = function() {
    return this._date.second;
  };
  CronDate.prototype.getMilliseconds = function() {
    return this._date.millisecond;
  };
  CronDate.prototype.getTime = function() {
    return this._date.valueOf();
  };
  CronDate.prototype.getUTCDate = function() {
    return this._getUTC().day;
  };
  CronDate.prototype.getUTCFullYear = function() {
    return this._getUTC().year;
  };
  CronDate.prototype.getUTCDay = function() {
    var weekday = this._getUTC().weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getUTCMonth = function() {
    return this._getUTC().month - 1;
  };
  CronDate.prototype.getUTCHours = function() {
    return this._getUTC().hour;
  };
  CronDate.prototype.getUTCMinutes = function() {
    return this._getUTC().minute;
  };
  CronDate.prototype.getUTCSeconds = function() {
    return this._getUTC().second;
  };
  CronDate.prototype.toISOString = function() {
    return this._date.toUTC().toISO();
  };
  CronDate.prototype.toJSON = function() {
    return this._date.toJSON();
  };
  CronDate.prototype.setDate = function(d) {
    this._date = this._date.set({ day: d });
  };
  CronDate.prototype.setFullYear = function(y) {
    this._date = this._date.set({ year: y });
  };
  CronDate.prototype.setDay = function(d) {
    this._date = this._date.set({ weekday: d });
  };
  CronDate.prototype.setMonth = function(m) {
    this._date = this._date.set({ month: m + 1 });
  };
  CronDate.prototype.setHours = function(h) {
    this._date = this._date.set({ hour: h });
  };
  CronDate.prototype.setMinutes = function(m) {
    this._date = this._date.set({ minute: m });
  };
  CronDate.prototype.setSeconds = function(s) {
    this._date = this._date.set({ second: s });
  };
  CronDate.prototype.setMilliseconds = function(s) {
    this._date = this._date.set({ millisecond: s });
  };
  CronDate.prototype._getUTC = function() {
    return this._date.toUTC();
  };
  CronDate.prototype.toString = function() {
    return this.toDate().toString();
  };
  CronDate.prototype.toDate = function() {
    return this._date.toJSDate();
  };
  CronDate.prototype.isLastDayOfMonth = function() {
    var newDate = this._date.plus({ days: 1 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  CronDate.prototype.isLastWeekdayOfMonth = function() {
    var newDate = this._date.plus({ days: 7 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  module.exports = CronDate;
});

// ../../node_modules/cron-parser/lib/field_compactor.js
var require_field_compactor = __commonJS((exports, module) => {
  var buildRange = function(item) {
    return {
      start: item,
      count: 1
    };
  };
  var completeRangeWithItem = function(range, item) {
    range.end = item;
    range.step = item - range.start;
    range.count = 2;
  };
  var finalizeCurrentRange = function(results, currentRange, currentItemRange) {
    if (currentRange) {
      if (currentRange.count === 2) {
        results.push(buildRange(currentRange.start));
        results.push(buildRange(currentRange.end));
      } else {
        results.push(currentRange);
      }
    }
    if (currentItemRange) {
      results.push(currentItemRange);
    }
  };
  var compactField = function(arr) {
    var results = [];
    var currentRange = undefined;
    for (var i = 0;i < arr.length; i++) {
      var currentItem = arr[i];
      if (typeof currentItem !== "number") {
        finalizeCurrentRange(results, currentRange, buildRange(currentItem));
        currentRange = undefined;
      } else if (!currentRange) {
        currentRange = buildRange(currentItem);
      } else if (currentRange.count === 1) {
        completeRangeWithItem(currentRange, currentItem);
      } else {
        if (currentRange.step === currentItem - currentRange.end) {
          currentRange.count++;
          currentRange.end = currentItem;
        } else if (currentRange.count === 2) {
          results.push(buildRange(currentRange.start));
          currentRange = buildRange(currentRange.end);
          completeRangeWithItem(currentRange, currentItem);
        } else {
          finalizeCurrentRange(results, currentRange);
          currentRange = buildRange(currentItem);
        }
      }
    }
    finalizeCurrentRange(results, currentRange);
    return results;
  };
  module.exports = compactField;
});

// ../../node_modules/cron-parser/lib/field_stringify.js
var require_field_stringify = __commonJS((exports, module) => {
  var stringifyField = function(arr, min, max) {
    var ranges = compactField(arr);
    if (ranges.length === 1) {
      var singleRange = ranges[0];
      var step = singleRange.step;
      if (step === 1 && singleRange.start === min && singleRange.end === max) {
        return "*";
      }
      if (step !== 1 && singleRange.start === min && singleRange.end === max - step + 1) {
        return "*/" + step;
      }
    }
    var result = [];
    for (var i = 0, l = ranges.length;i < l; ++i) {
      var range = ranges[i];
      if (range.count === 1) {
        result.push(range.start);
        continue;
      }
      var step = range.step;
      if (range.step === 1) {
        result.push(range.start + "-" + range.end);
        continue;
      }
      var multiplier = range.start == 0 ? range.count - 1 : range.count;
      if (range.step * multiplier > range.end) {
        result = result.concat(Array.from({ length: range.end - range.start + 1 }).map(function(_, index) {
          var value = range.start + index;
          if ((value - range.start) % range.step === 0) {
            return value;
          }
          return null;
        }).filter(function(value) {
          return value != null;
        }));
      } else if (range.end === max - range.step + 1) {
        result.push(range.start + "/" + range.step);
      } else {
        result.push(range.start + "-" + range.end + "/" + range.step);
      }
    }
    return result.join(",");
  };
  var compactField = require_field_compactor();
  module.exports = stringifyField;
});

// ../../node_modules/cron-parser/lib/expression.js
var require_expression = __commonJS((exports, module) => {
  var CronExpression = function(fields2, options) {
    this._options = options;
    this._utc = options.utc || false;
    this._tz = this._utc ? "UTC" : options.tz;
    this._currentDate = new CronDate(options.currentDate, this._tz);
    this._startDate = options.startDate ? new CronDate(options.startDate, this._tz) : null;
    this._endDate = options.endDate ? new CronDate(options.endDate, this._tz) : null;
    this._isIterator = options.iterator || false;
    this._hasIterated = false;
    this._nthDayOfWeek = options.nthDayOfWeek || 0;
    this.fields = CronExpression._freezeFields(fields2);
  };
  var CronDate = require_date();
  var stringifyField = require_field_stringify();
  var LOOP_LIMIT = 1e4;
  CronExpression.map = ["second", "minute", "hour", "dayOfMonth", "month", "dayOfWeek"];
  CronExpression.predefined = {
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  CronExpression.constraints = [
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 23, chars: [] },
    { min: 1, max: 31, chars: ["L"] },
    { min: 1, max: 12, chars: [] },
    { min: 0, max: 7, chars: ["L"] }
  ];
  CronExpression.daysInMonth = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  CronExpression.aliases = {
    month: {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12
    },
    dayOfWeek: {
      sun: 0,
      mon: 1,
      tue: 2,
      wed: 3,
      thu: 4,
      fri: 5,
      sat: 6
    }
  };
  CronExpression.parseDefaults = ["0", "*", "*", "*", "*", "*"];
  CronExpression.standardValidCharacters = /^[,*\d/-]+$/;
  CronExpression.dayOfWeekValidCharacters = /^[?,*\dL#/-]+$/;
  CronExpression.dayOfMonthValidCharacters = /^[?,*\dL/-]+$/;
  CronExpression.validCharacters = {
    second: CronExpression.standardValidCharacters,
    minute: CronExpression.standardValidCharacters,
    hour: CronExpression.standardValidCharacters,
    dayOfMonth: CronExpression.dayOfMonthValidCharacters,
    month: CronExpression.standardValidCharacters,
    dayOfWeek: CronExpression.dayOfWeekValidCharacters
  };
  CronExpression._isValidConstraintChar = function _isValidConstraintChar(constraints, value) {
    if (typeof value !== "string") {
      return false;
    }
    return constraints.chars.some(function(char) {
      return value.indexOf(char) > -1;
    });
  };
  CronExpression._parseField = function _parseField(field3, value, constraints) {
    switch (field3) {
      case "month":
      case "dayOfWeek":
        var aliases = CronExpression.aliases[field3];
        value = value.replace(/[a-z]{3}/gi, function(match) {
          match = match.toLowerCase();
          if (typeof aliases[match] !== "undefined") {
            return aliases[match];
          } else {
            throw new Error('Validation error, cannot resolve alias "' + match + '"');
          }
        });
        break;
    }
    if (!CronExpression.validCharacters[field3].test(value)) {
      throw new Error("Invalid characters, got value: " + value);
    }
    if (value.indexOf("*") !== -1) {
      value = value.replace(/\*/g, constraints.min + "-" + constraints.max);
    } else if (value.indexOf("?") !== -1) {
      value = value.replace(/\?/g, constraints.min + "-" + constraints.max);
    }
    function parseSequence(val) {
      var stack = [];
      function handleResult(result) {
        if (result instanceof Array) {
          for (var i2 = 0, c2 = result.length;i2 < c2; i2++) {
            var value2 = result[i2];
            if (CronExpression._isValidConstraintChar(constraints, value2)) {
              stack.push(value2);
              continue;
            }
            if (typeof value2 !== "number" || Number.isNaN(value2) || value2 < constraints.min || value2 > constraints.max) {
              throw new Error("Constraint error, got value " + value2 + " expected range " + constraints.min + "-" + constraints.max);
            }
            stack.push(value2);
          }
        } else {
          if (CronExpression._isValidConstraintChar(constraints, result)) {
            stack.push(result);
            return;
          }
          var numResult = +result;
          if (Number.isNaN(numResult) || numResult < constraints.min || numResult > constraints.max) {
            throw new Error("Constraint error, got value " + result + " expected range " + constraints.min + "-" + constraints.max);
          }
          if (field3 === "dayOfWeek") {
            numResult = numResult % 7;
          }
          stack.push(numResult);
        }
      }
      var atoms = val.split(",");
      if (!atoms.every(function(atom) {
        return atom.length > 0;
      })) {
        throw new Error("Invalid list value format");
      }
      if (atoms.length > 1) {
        for (var i = 0, c = atoms.length;i < c; i++) {
          handleResult(parseRepeat(atoms[i]));
        }
      } else {
        handleResult(parseRepeat(val));
      }
      stack.sort(CronExpression._sortCompareFn);
      return stack;
    }
    function parseRepeat(val) {
      var repeatInterval = 1;
      var atoms = val.split("/");
      if (atoms.length > 2) {
        throw new Error("Invalid repeat: " + val);
      }
      if (atoms.length > 1) {
        if (atoms[0] == +atoms[0]) {
          atoms = [atoms[0] + "-" + constraints.max, atoms[1]];
        }
        return parseRange(atoms[0], atoms[atoms.length - 1]);
      }
      return parseRange(val, repeatInterval);
    }
    function parseRange(val, repeatInterval) {
      var stack = [];
      var atoms = val.split("-");
      if (atoms.length > 1) {
        if (atoms.length < 2) {
          return +val;
        }
        if (!atoms[0].length) {
          if (!atoms[1].length) {
            throw new Error("Invalid range: " + val);
          }
          return +val;
        }
        var min = +atoms[0];
        var max = +atoms[1];
        if (Number.isNaN(min) || Number.isNaN(max) || min < constraints.min || max > constraints.max) {
          throw new Error("Constraint error, got range " + min + "-" + max + " expected range " + constraints.min + "-" + constraints.max);
        } else if (min > max) {
          throw new Error("Invalid range: " + val);
        }
        var repeatIndex = +repeatInterval;
        if (Number.isNaN(repeatIndex) || repeatIndex <= 0) {
          throw new Error("Constraint error, cannot repeat at every " + repeatIndex + " time.");
        }
        if (field3 === "dayOfWeek" && max % 7 === 0) {
          stack.push(0);
        }
        for (var index = min, count = max;index <= count; index++) {
          var exists = stack.indexOf(index) !== -1;
          if (!exists && repeatIndex > 0 && repeatIndex % repeatInterval === 0) {
            repeatIndex = 1;
            stack.push(index);
          } else {
            repeatIndex++;
          }
        }
        return stack;
      }
      return Number.isNaN(+val) ? val : +val;
    }
    return parseSequence(value);
  };
  CronExpression._sortCompareFn = function(a, b) {
    var aIsNumber = typeof a === "number";
    var bIsNumber = typeof b === "number";
    if (aIsNumber && bIsNumber) {
      return a - b;
    }
    if (!aIsNumber && bIsNumber) {
      return 1;
    }
    if (aIsNumber && !bIsNumber) {
      return -1;
    }
    return a.localeCompare(b);
  };
  CronExpression._handleMaxDaysInMonth = function(mappedFields) {
    if (mappedFields.month.length === 1) {
      var daysInMonth = CronExpression.daysInMonth[mappedFields.month[0] - 1];
      if (mappedFields.dayOfMonth[0] > daysInMonth) {
        throw new Error("Invalid explicit day of month definition");
      }
      return mappedFields.dayOfMonth.filter(function(dayOfMonth) {
        return dayOfMonth === "L" ? true : dayOfMonth <= daysInMonth;
      }).sort(CronExpression._sortCompareFn);
    }
  };
  CronExpression._freezeFields = function(fields2) {
    for (var i = 0, c = CronExpression.map.length;i < c; ++i) {
      var field3 = CronExpression.map[i];
      var value = fields2[field3];
      fields2[field3] = Object.freeze(value);
    }
    return Object.freeze(fields2);
  };
  CronExpression.prototype._applyTimezoneShift = function(currentDate, dateMathVerb, method) {
    if (method === "Month" || method === "Day") {
      var prevTime = currentDate.getTime();
      currentDate[dateMathVerb + method]();
      var currTime = currentDate.getTime();
      if (prevTime === currTime) {
        if (currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
          currentDate.addHour();
        } else if (currentDate.getMinutes() === 59 && currentDate.getSeconds() === 59) {
          currentDate.subtractHour();
        }
      }
    } else {
      var previousHour = currentDate.getHours();
      currentDate[dateMathVerb + method]();
      var currentHour = currentDate.getHours();
      var diff = currentHour - previousHour;
      if (diff === 2) {
        if (this.fields.hour.length !== 24) {
          this._dstStart = currentHour;
        }
      } else if (diff === 0 && currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
        if (this.fields.hour.length !== 24) {
          this._dstEnd = currentHour;
        }
      }
    }
  };
  CronExpression.prototype._findSchedule = function _findSchedule(reverse) {
    function matchSchedule(value, sequence) {
      for (var i = 0, c = sequence.length;i < c; i++) {
        if (sequence[i] >= value) {
          return sequence[i] === value;
        }
      }
      return sequence[0] === value;
    }
    function isNthDayMatch(date, nthDayOfWeek) {
      if (nthDayOfWeek < 6) {
        if (date.getDate() < 8 && nthDayOfWeek === 1) {
          return true;
        }
        var offset = date.getDate() % 7 ? 1 : 0;
        var adjustedDate = date.getDate() - date.getDate() % 7;
        var occurrence = Math.floor(adjustedDate / 7) + offset;
        return occurrence === nthDayOfWeek;
      }
      return false;
    }
    function isLInExpressions(expressions) {
      return expressions.length > 0 && expressions.some(function(expression) {
        return typeof expression === "string" && expression.indexOf("L") >= 0;
      });
    }
    reverse = reverse || false;
    var dateMathVerb = reverse ? "subtract" : "add";
    var currentDate = new CronDate(this._currentDate, this._tz);
    var startDate = this._startDate;
    var endDate = this._endDate;
    var startTimestamp = currentDate.getTime();
    var stepCount = 0;
    function isLastWeekdayOfMonthMatch(expressions) {
      return expressions.some(function(expression) {
        if (!isLInExpressions([expression])) {
          return false;
        }
        var weekday = Number.parseInt(expression[0]) % 7;
        if (Number.isNaN(weekday)) {
          throw new Error("Invalid last weekday of the month expression: " + expression);
        }
        return currentDate.getDay() === weekday && currentDate.isLastWeekdayOfMonth();
      });
    }
    while (stepCount < LOOP_LIMIT) {
      stepCount++;
      if (reverse) {
        if (startDate && currentDate.getTime() - startDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      } else {
        if (endDate && endDate.getTime() - currentDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      }
      var dayOfMonthMatch = matchSchedule(currentDate.getDate(), this.fields.dayOfMonth);
      if (isLInExpressions(this.fields.dayOfMonth)) {
        dayOfMonthMatch = dayOfMonthMatch || currentDate.isLastDayOfMonth();
      }
      var dayOfWeekMatch = matchSchedule(currentDate.getDay(), this.fields.dayOfWeek);
      if (isLInExpressions(this.fields.dayOfWeek)) {
        dayOfWeekMatch = dayOfWeekMatch || isLastWeekdayOfMonthMatch(this.fields.dayOfWeek);
      }
      var isDayOfMonthWildcardMatch = this.fields.dayOfMonth.length >= CronExpression.daysInMonth[currentDate.getMonth()];
      var isDayOfWeekWildcardMatch = this.fields.dayOfWeek.length === CronExpression.constraints[5].max - CronExpression.constraints[5].min + 1;
      var currentHour = currentDate.getHours();
      if (!dayOfMonthMatch && (!dayOfWeekMatch || isDayOfWeekWildcardMatch)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!isDayOfMonthWildcardMatch && isDayOfWeekWildcardMatch && !dayOfMonthMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (isDayOfMonthWildcardMatch && !isDayOfWeekWildcardMatch && !dayOfWeekMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (this._nthDayOfWeek > 0 && !isNthDayMatch(currentDate, this._nthDayOfWeek)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!matchSchedule(currentDate.getMonth() + 1, this.fields.month)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Month");
        continue;
      }
      if (!matchSchedule(currentHour, this.fields.hour)) {
        if (this._dstStart !== currentHour) {
          this._dstStart = null;
          this._applyTimezoneShift(currentDate, dateMathVerb, "Hour");
          continue;
        } else if (!matchSchedule(currentHour - 1, this.fields.hour)) {
          currentDate[dateMathVerb + "Hour"]();
          continue;
        }
      } else if (this._dstEnd === currentHour) {
        if (!reverse) {
          this._dstEnd = null;
          this._applyTimezoneShift(currentDate, "add", "Hour");
          continue;
        }
      }
      if (!matchSchedule(currentDate.getMinutes(), this.fields.minute)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Minute");
        continue;
      }
      if (!matchSchedule(currentDate.getSeconds(), this.fields.second)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        continue;
      }
      if (startTimestamp === currentDate.getTime()) {
        if (dateMathVerb === "add" || currentDate.getMilliseconds() === 0) {
          this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        } else {
          currentDate.setMilliseconds(0);
        }
        continue;
      }
      break;
    }
    if (stepCount >= LOOP_LIMIT) {
      throw new Error("Invalid expression, loop limit exceeded");
    }
    this._currentDate = new CronDate(currentDate, this._tz);
    this._hasIterated = true;
    return currentDate;
  };
  CronExpression.prototype.next = function next() {
    var schedule = this._findSchedule();
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasNext()
      };
    }
    return schedule;
  };
  CronExpression.prototype.prev = function prev() {
    var schedule = this._findSchedule(true);
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasPrev()
      };
    }
    return schedule;
  };
  CronExpression.prototype.hasNext = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule();
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.hasPrev = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule(true);
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.iterate = function iterate(steps2, callback) {
    var dates = [];
    if (steps2 >= 0) {
      for (var i = 0, c = steps2;i < c; i++) {
        try {
          var item = this.next();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    } else {
      for (var i = 0, c = steps2;i > c; i--) {
        try {
          var item = this.prev();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    }
    return dates;
  };
  CronExpression.prototype.reset = function reset(newDate) {
    this._currentDate = new CronDate(newDate || this._options.currentDate);
  };
  CronExpression.prototype.stringify = function stringify(includeSeconds) {
    var resultArr = [];
    for (var i = includeSeconds ? 0 : 1, c = CronExpression.map.length;i < c; ++i) {
      var field3 = CronExpression.map[i];
      var value = this.fields[field3];
      var constraint = CronExpression.constraints[i];
      if (field3 === "dayOfMonth" && this.fields.month.length === 1) {
        constraint = { min: 1, max: CronExpression.daysInMonth[this.fields.month[0] - 1] };
      } else if (field3 === "dayOfWeek") {
        constraint = { min: 0, max: 6 };
        value = value[value.length - 1] === 7 ? value.slice(0, -1) : value;
      }
      resultArr.push(stringifyField(value, constraint.min, constraint.max));
    }
    return resultArr.join(" ");
  };
  CronExpression.parse = function parse(expression, options) {
    var self2 = this;
    if (typeof options === "function") {
      options = {};
    }
    function parse2(expression2, options2) {
      if (!options2) {
        options2 = {};
      }
      if (typeof options2.currentDate === "undefined") {
        options2.currentDate = new CronDate(undefined, self2._tz);
      }
      if (CronExpression.predefined[expression2]) {
        expression2 = CronExpression.predefined[expression2];
      }
      var fields2 = [];
      var atoms = (expression2 + "").trim().split(/\s+/);
      if (atoms.length > 6) {
        throw new Error("Invalid cron expression");
      }
      var start = CronExpression.map.length - atoms.length;
      for (var i = 0, c = CronExpression.map.length;i < c; ++i) {
        var field3 = CronExpression.map[i];
        var value = atoms[atoms.length > c ? i : i - start];
        if (i < start || !value) {
          fields2.push(CronExpression._parseField(field3, CronExpression.parseDefaults[i], CronExpression.constraints[i]));
        } else {
          var val = field3 === "dayOfWeek" ? parseNthDay(value) : value;
          fields2.push(CronExpression._parseField(field3, val, CronExpression.constraints[i]));
        }
      }
      var mappedFields = {};
      for (var i = 0, c = CronExpression.map.length;i < c; i++) {
        var key = CronExpression.map[i];
        mappedFields[key] = fields2[i];
      }
      var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
      mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
      return new CronExpression(mappedFields, options2);
      function parseNthDay(val2) {
        var atoms2 = val2.split("#");
        if (atoms2.length > 1) {
          var nthValue = +atoms2[atoms2.length - 1];
          if (/,/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `,` special characters are incompatible");
          }
          if (/\//.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `/` special characters are incompatible");
          }
          if (/-/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `-` special characters are incompatible");
          }
          if (atoms2.length > 2 || Number.isNaN(nthValue) || (nthValue < 1 || nthValue > 5)) {
            throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");
          }
          options2.nthDayOfWeek = nthValue;
          return atoms2[0];
        }
        return val2;
      }
    }
    return parse2(expression, options);
  };
  CronExpression.fieldsToExpression = function fieldsToExpression(fields2, options) {
    function validateConstraints(field4, values5, constraints) {
      if (!values5) {
        throw new Error("Validation error, Field " + field4 + " is missing");
      }
      if (values5.length === 0) {
        throw new Error("Validation error, Field " + field4 + " contains no values");
      }
      for (var i2 = 0, c2 = values5.length;i2 < c2; i2++) {
        var value = values5[i2];
        if (CronExpression._isValidConstraintChar(constraints, value)) {
          continue;
        }
        if (typeof value !== "number" || Number.isNaN(value) || value < constraints.min || value > constraints.max) {
          throw new Error("Constraint error, got value " + value + " expected range " + constraints.min + "-" + constraints.max);
        }
      }
    }
    var mappedFields = {};
    for (var i = 0, c = CronExpression.map.length;i < c; ++i) {
      var field3 = CronExpression.map[i];
      var values4 = fields2[field3];
      validateConstraints(field3, values4, CronExpression.constraints[i]);
      var copy = [];
      var j = -1;
      while (++j < values4.length) {
        copy[j] = values4[j];
      }
      values4 = copy.sort(CronExpression._sortCompareFn).filter(function(item, pos, ary) {
        return !pos || item !== ary[pos - 1];
      });
      if (values4.length !== copy.length) {
        throw new Error("Validation error, Field " + field3 + " contains duplicate values");
      }
      mappedFields[field3] = values4;
    }
    var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
    mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
    return new CronExpression(mappedFields, options || {});
  };
  module.exports = CronExpression;
});

// ../../node_modules/cron-parser/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var CronParser = function() {
  };
  var CronExpression = require_expression();
  CronParser._parseEntry = function _parseEntry(entry) {
    var atoms = entry.split(" ");
    if (atoms.length === 6) {
      return {
        interval: CronExpression.parse(entry)
      };
    } else if (atoms.length > 6) {
      return {
        interval: CronExpression.parse(atoms.slice(0, 6).join(" ")),
        command: atoms.slice(6, atoms.length)
      };
    } else {
      throw new Error("Invalid entry: " + entry);
    }
  };
  CronParser.parseExpression = function parseExpression(expression, options) {
    return CronExpression.parse(expression, options);
  };
  CronParser.fieldsToExpression = function fieldsToExpression(fields2, options) {
    return CronExpression.fieldsToExpression(fields2, options);
  };
  CronParser.parseString = function parseString(data) {
    var blocks = data.split("\n");
    var response = {
      variables: {},
      expressions: [],
      errors: {}
    };
    for (var i = 0, c = blocks.length;i < c; i++) {
      var block2 = blocks[i];
      var matches = null;
      var entry = block2.trim();
      if (entry.length > 0) {
        if (entry.match(/^#/)) {
          continue;
        } else if (matches = entry.match(/^(.*)=(.*)$/)) {
          response.variables[matches[1]] = matches[2];
        } else {
          var result = null;
          try {
            result = CronParser._parseEntry("0 " + entry);
            response.expressions.push(result.interval);
          } catch (err) {
            response.errors[entry] = err;
          }
        }
      }
    }
    return response;
  };
  module.exports = CronParser;
});

// ../../node_modules/pg-boss/src/timekeeper.js
var require_timekeeper = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var cronParser = require_parser2();
  var Attorney = require_attorney();
  var pMap = require_p_map();
  var queues = {
    CRON: "__pgboss__cron",
    SEND_IT: "__pgboss__send-it"
  };
  var events2 = {
    error: "error",
    schedule: "schedule"
  };

  class Timekeeper extends EventEmitter {
    constructor(db, config) {
      super();
      this.db = db;
      this.config = config;
      this.manager = config.manager;
      this.skewMonitorIntervalMs = config.clockMonitorIntervalSeconds * 1000;
      this.cronMonitorIntervalMs = config.cronMonitorIntervalSeconds * 1000;
      this.clockSkew = 0;
      this.events = events2;
      this.getTimeCommand = plans.getTime(config.schema);
      this.getSchedulesCommand = plans.getSchedules(config.schema);
      this.scheduleCommand = plans.schedule(config.schema);
      this.unscheduleCommand = plans.unschedule(config.schema);
      this.getCronTimeCommand = plans.getCronTime(config.schema);
      this.setCronTimeCommand = plans.setCronTime(config.schema);
      this.functions = [
        this.schedule,
        this.unschedule,
        this.getSchedules
      ];
      this.stopped = true;
    }
    async start() {
      if (this.config.archiveSeconds < 60 || this.config.archiveFailedSeconds < 60) {
        return;
      }
      await this.cacheClockSkew();
      await this.manager.work(queues.CRON, { newJobCheckIntervalSeconds: this.config.cronWorkerIntervalSeconds }, (job) => this.onCron(job));
      await this.manager.work(queues.SEND_IT, { newJobCheckIntervalSeconds: this.config.cronWorkerIntervalSeconds, teamSize: 50, teamConcurrency: 5 }, (job) => this.onSendIt(job));
      await this.checkSchedulesAsync();
      this.cronMonitorInterval = setInterval(async () => await this.monitorCron(), this.cronMonitorIntervalMs);
      this.skewMonitorInterval = setInterval(async () => await this.cacheClockSkew(), this.skewMonitorIntervalMs);
      this.stopped = false;
    }
    async stop() {
      if (this.stopped) {
        return;
      }
      this.stopped = true;
      await this.manager.offWork(queues.CRON);
      await this.manager.offWork(queues.SEND_IT);
      if (this.skewMonitorInterval) {
        clearInterval(this.skewMonitorInterval);
        this.skewMonitorInterval = null;
      }
      if (this.cronMonitorInterval) {
        clearInterval(this.cronMonitorInterval);
        this.cronMonitorInterval = null;
      }
    }
    async monitorCron() {
      try {
        if (this.config.__test__force_cron_monitoring_error) {
          throw new Error(this.config.__test__force_cron_monitoring_error);
        }
        const { secondsAgo } = await this.getCronTime();
        if (secondsAgo > 60) {
          await this.checkSchedulesAsync();
        }
      } catch (err) {
        this.emit(this.events.error, err);
      }
    }
    async cacheClockSkew() {
      let skew = 0;
      try {
        if (this.config.__test__force_clock_monitoring_error) {
          throw new Error(this.config.__test__force_clock_monitoring_error);
        }
        const { rows } = await this.db.executeSql(this.getTimeCommand);
        const local = Date.now();
        const dbTime = parseFloat(rows[0].time);
        skew = dbTime - local;
        const skewSeconds = Math.abs(skew) / 1000;
        if (skewSeconds >= 60 || this.config.__test__force_clock_skew_warning) {
          Attorney.warnClockSkew(`Instance clock is ${skewSeconds}s ${skew > 0 ? "slower" : "faster"} than database.`);
        }
      } catch (err) {
        this.emit(this.events.error, err);
      } finally {
        this.clockSkew = skew;
      }
    }
    async checkSchedulesAsync() {
      const opts = {
        retryLimit: 2,
        retentionSeconds: 60,
        onComplete: false
      };
      await this.manager.sendDebounced(queues.CRON, null, opts, 60);
    }
    async onCron() {
      if (this.stopped)
        return;
      try {
        if (this.config.__test__throw_clock_monitoring) {
          throw new Error(this.config.__test__throw_clock_monitoring);
        }
        const items = await this.getSchedules();
        const sending = items.filter((i) => this.shouldSendIt(i.cron, i.timezone));
        if (sending.length && !this.stopped) {
          await pMap(sending, (it) => this.send(it), { concurrency: 5 });
        }
        if (this.stopped)
          return;
        await this.setCronTime();
      } catch (err) {
        this.emit(this.events.error, err);
      }
      if (this.stopped)
        return;
      await this.checkSchedulesAsync();
    }
    shouldSendIt(cron, tz) {
      const interval = cronParser.parseExpression(cron, { tz });
      const prevTime = interval.prev();
      const databaseTime = Date.now() + this.clockSkew;
      const prevDiff = (databaseTime - prevTime.getTime()) / 1000;
      return prevDiff < 60;
    }
    async send(job) {
      const options = {
        singletonKey: job.name,
        singletonSeconds: 60,
        onComplete: false
      };
      await this.manager.send(queues.SEND_IT, job, options);
    }
    async onSendIt(job) {
      if (this.stopped)
        return;
      const { name, data, options } = job.data;
      await this.manager.send(name, data, options);
    }
    async getSchedules() {
      const { rows } = await this.db.executeSql(this.getSchedulesCommand);
      return rows;
    }
    async schedule(name, cron, data, options = {}) {
      const { tz = "UTC" } = options;
      cronParser.parseExpression(cron, { tz });
      Attorney.checkSendArgs([name, data, options], this.config);
      const values4 = [name, cron, tz, data, options];
      const result = await this.db.executeSql(this.scheduleCommand, values4);
      return result ? result.rowCount : null;
    }
    async unschedule(name) {
      const result = await this.db.executeSql(this.unscheduleCommand, [name]);
      return result ? result.rowCount : null;
    }
    async setCronTime() {
      await this.db.executeSql(this.setCronTimeCommand);
    }
    async getCronTime() {
      const { rows } = await this.db.executeSql(this.getCronTimeCommand);
      let { cron_on: cronOn, seconds_ago: secondsAgo } = rows[0];
      secondsAgo = secondsAgo !== null ? parseFloat(secondsAgo) : 61;
      return { cronOn, secondsAgo };
    }
  }
  module.exports = Timekeeper;
  module.exports.QUEUES = queues;
});

// ../../node_modules/pg-boss/src/manager.js
var require_manager = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var EventEmitter = import.meta.require("events");
  var delay = require_delay();
  var uuid = require_dist();
  var debounce = require_lodash();
  var { serializeError: stringify4 } = require_serialize_error();
  var Attorney = require_attorney();
  var Worker = require_worker();
  var Db = require_db();
  var pMap = require_p_map();
  var { QUEUES: BOSS_QUEUES } = require_boss();
  var { QUEUES: TIMEKEEPER_QUEUES } = require_timekeeper();
  var INTERNAL_QUEUES = Object.values(BOSS_QUEUES).concat(Object.values(TIMEKEEPER_QUEUES)).reduce((acc, i) => ({ ...acc, [i]: i }), {});
  var plans = require_plans();
  var { COMPLETION_JOB_PREFIX, SINGLETON_QUEUE_KEY } = plans;
  var WIP_EVENT_INTERVAL = 2000;
  var WIP_DEBOUNCE_OPTIONS = { leading: true, trailing: true, maxWait: WIP_EVENT_INTERVAL };
  var events2 = {
    error: "error",
    wip: "wip"
  };
  var resolveWithinSeconds = async (promise, seconds) => {
    const timeout = Math.max(1, seconds) * 1000;
    const reject2 = delay.reject(timeout, { value: new Error(`handler execution exceeded ${timeout}ms`) });
    let result;
    try {
      result = await Promise.race([promise, reject2]);
    } finally {
      try {
        reject2.clear();
      } catch {
      }
    }
    return result;
  };

  class Manager extends EventEmitter {
    constructor(db, config) {
      super();
      this.config = config;
      this.db = db;
      this.events = events2;
      this.workers = new Map;
      this.nextJobCommand = plans.fetchNextJob(config.schema);
      this.insertJobCommand = plans.insertJob(config.schema);
      this.insertJobsCommand = plans.insertJobs(config.schema);
      this.completeJobsCommand = plans.completeJobs(config.schema);
      this.cancelJobsCommand = plans.cancelJobs(config.schema);
      this.resumeJobsCommand = plans.resumeJobs(config.schema);
      this.failJobsCommand = plans.failJobs(config.schema);
      this.getJobByIdCommand = plans.getJobById(config.schema);
      this.getArchivedJobByIdCommand = plans.getArchivedJobById(config.schema);
      this.subscribeCommand = plans.subscribe(config.schema);
      this.unsubscribeCommand = plans.unsubscribe(config.schema);
      this.getQueuesForEventCommand = plans.getQueuesForEvent(config.schema);
      this.functions = [
        this.complete,
        this.cancel,
        this.resume,
        this.fail,
        this.fetch,
        this.fetchCompleted,
        this.work,
        this.offWork,
        this.notifyWorker,
        this.onComplete,
        this.offComplete,
        this.publish,
        this.subscribe,
        this.unsubscribe,
        this.insert,
        this.send,
        this.sendDebounced,
        this.sendThrottled,
        this.sendOnce,
        this.sendAfter,
        this.sendSingleton,
        this.deleteQueue,
        this.deleteAllQueues,
        this.clearStorage,
        this.getQueueSize,
        this.getJobById
      ];
      this.emitWipThrottled = debounce(() => this.emit(events2.wip, this.getWipData()), WIP_EVENT_INTERVAL, WIP_DEBOUNCE_OPTIONS);
    }
    start() {
      this.stopping = false;
    }
    async stop() {
      this.stopping = true;
      for (const sub of this.workers.values()) {
        if (!INTERNAL_QUEUES[sub.name]) {
          await this.offWork(sub.name);
        }
      }
    }
    async work(name, ...args) {
      const { options, callback } = Attorney.checkWorkArgs(name, args, this.config);
      return await this.watch(name, options, callback);
    }
    async onComplete(name, ...args) {
      const { options, callback } = Attorney.checkWorkArgs(name, args, this.config);
      return await this.watch(COMPLETION_JOB_PREFIX + name, options, callback);
    }
    addWorker(worker) {
      this.workers.set(worker.id, worker);
    }
    removeWorker(worker) {
      this.workers.delete(worker.id);
    }
    getWorkers() {
      return Array.from(this.workers.values());
    }
    emitWip(name) {
      if (!INTERNAL_QUEUES[name]) {
        this.emitWipThrottled();
      }
    }
    getWipData(options = {}) {
      const { includeInternal = false } = options;
      const data = this.getWorkers().map(({
        id,
        name,
        options: options2,
        state,
        jobs,
        createdOn,
        lastFetchedOn,
        lastJobStartedOn,
        lastJobEndedOn,
        lastError,
        lastErrorOn
      }) => ({
        id,
        name,
        options: options2,
        state,
        count: jobs.length,
        createdOn,
        lastFetchedOn,
        lastJobStartedOn,
        lastJobEndedOn,
        lastError,
        lastErrorOn
      })).filter((i) => i.count > 0 && (!INTERNAL_QUEUES[i.name] || includeInternal));
      return data;
    }
    async watch(name, options, callback) {
      if (this.stopping) {
        throw new Error("Workers are disabled. pg-boss is stopping.");
      }
      const {
        newJobCheckInterval: interval = this.config.newJobCheckInterval,
        batchSize,
        teamSize = 1,
        teamConcurrency = 1,
        teamRefill: refill = false,
        includeMetadata = false,
        enforceSingletonQueueActiveLimit = false
      } = options;
      const id = uuid.v4();
      let queueSize = 0;
      let refillTeamPromise;
      let resolveRefillTeam;
      const createTeamRefillPromise = () => {
        refillTeamPromise = new Promise((resolve) => {
          resolveRefillTeam = resolve;
        });
      };
      createTeamRefillPromise();
      const onRefill = () => {
        queueSize--;
        resolveRefillTeam();
        createTeamRefillPromise();
      };
      const fetch6 = () => this.fetch(name, batchSize || teamSize - queueSize, { includeMetadata, enforceSingletonQueueActiveLimit });
      const onFetch = async (jobs) => {
        if (this.config.__test__throw_worker) {
          throw new Error("__test__throw_worker");
        }
        this.emitWip(name);
        if (batchSize) {
          const maxExpiration = jobs.reduce((acc, i) => Math.max(acc, i.expire_in_seconds), 0);
          await resolveWithinSeconds(Promise.all([callback(jobs)]), maxExpiration).then(() => this.complete(jobs.map((job) => job.id))).catch((err) => this.fail(jobs.map((job) => job.id), err));
        } else {
          if (refill) {
            queueSize += jobs.length || 1;
          }
          const allTeamPromise = pMap(jobs, (job) => resolveWithinSeconds(callback(job), job.expire_in_seconds).then((result) => this.complete(job.id, result)).catch((err) => this.fail(job.id, err)).then(() => refill ? onRefill() : null), { concurrency: teamConcurrency }).catch(() => {
          });
          if (refill) {
            if (queueSize < teamSize) {
              return;
            } else {
              await refillTeamPromise;
            }
          } else {
            await allTeamPromise;
          }
        }
        this.emitWip(name);
      };
      const onError = (error8) => {
        this.emit(events2.error, { ...error8, message: error8.message, stack: error8.stack, queue: name, worker: id });
      };
      const worker = new Worker({ id, name, options, interval, fetch: fetch6, onFetch, onError });
      this.addWorker(worker);
      worker.start();
      return id;
    }
    async offWork(value) {
      assert(value, "Missing required argument");
      const query3 = typeof value === "string" ? { filter: (i) => i.name === value } : typeof value === "object" && value.id ? { filter: (i) => i.id === value.id } : null;
      assert(query3, "Invalid argument. Expected string or object: { id }");
      const workers = this.getWorkers().filter((i) => query3.filter(i) && !i.stopping && !i.stopped);
      if (workers.length === 0) {
        return;
      }
      for (const worker of workers) {
        worker.stop();
      }
      setImmediate(async () => {
        while (!workers.every((w) => w.stopped)) {
          await delay(1000);
        }
        for (const worker of workers) {
          this.removeWorker(worker);
        }
      });
    }
    notifyWorker(workerId) {
      if (this.workers.has(workerId)) {
        this.workers.get(workerId).notify();
      }
    }
    async subscribe(event, name) {
      assert(event, "Missing required argument");
      assert(name, "Missing required argument");
      return await this.db.executeSql(this.subscribeCommand, [event, name]);
    }
    async unsubscribe(event, name) {
      assert(event, "Missing required argument");
      assert(name, "Missing required argument");
      return await this.db.executeSql(this.unsubscribeCommand, [event, name]);
    }
    async publish(event, ...args) {
      assert(event, "Missing required argument");
      const result = await this.db.executeSql(this.getQueuesForEventCommand, [event]);
      if (!result || result.rowCount === 0) {
        return [];
      }
      return await Promise.all(result.rows.map(({ name }) => this.send(name, ...args)));
    }
    async offComplete(value) {
      if (typeof value === "string") {
        value = COMPLETION_JOB_PREFIX + value;
      }
      return await this.offWork(value);
    }
    async send(...args) {
      const { name, data, options } = Attorney.checkSendArgs(args, this.config);
      return await this.createJob(name, data, options);
    }
    async sendOnce(name, data, options, key) {
      options = options ? { ...options } : {};
      options.singletonKey = key || name;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendSingleton(name, data, options) {
      options = options ? { ...options } : {};
      options.singletonKey = SINGLETON_QUEUE_KEY;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendAfter(name, data, options, after) {
      options = options ? { ...options } : {};
      options.startAfter = after;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendThrottled(name, data, options, seconds, key) {
      options = options ? { ...options } : {};
      options.singletonSeconds = seconds;
      options.singletonNextSlot = false;
      options.singletonKey = key;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendDebounced(name, data, options, seconds, key) {
      options = options ? { ...options } : {};
      options.singletonSeconds = seconds;
      options.singletonNextSlot = true;
      options.singletonKey = key;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async createJob(name, data, options, singletonOffset = 0) {
      const {
        db: wrapper,
        expireIn,
        priority,
        startAfter,
        keepUntil,
        singletonKey = null,
        singletonSeconds,
        retryBackoff,
        retryLimit,
        retryDelay,
        onComplete
      } = options;
      const id = uuid[this.config.uuid]();
      const values4 = [
        id,
        name,
        priority,
        retryLimit,
        startAfter,
        expireIn,
        data,
        singletonKey,
        singletonSeconds,
        singletonOffset,
        retryDelay,
        retryBackoff,
        keepUntil,
        onComplete
      ];
      const db = wrapper || this.db;
      const result = await db.executeSql(this.insertJobCommand, values4);
      if (result && result.rowCount === 1) {
        return result.rows[0].id;
      }
      if (!options.singletonNextSlot) {
        return null;
      }
      options.startAfter = this.getDebounceStartAfter(singletonSeconds, this.timekeeper.clockSkew);
      options.singletonNextSlot = false;
      singletonOffset = singletonSeconds;
      return await this.createJob(name, data, options, singletonOffset);
    }
    async insert(jobs, options = {}) {
      const { db: wrapper } = options;
      const db = wrapper || this.db;
      const checkedJobs = Attorney.checkInsertArgs(jobs);
      const data = JSON.stringify(checkedJobs);
      return await db.executeSql(this.insertJobsCommand, [data]);
    }
    getDebounceStartAfter(singletonSeconds, clockOffset) {
      const debounceInterval = singletonSeconds * 1000;
      const now = Date.now() + clockOffset;
      const slot = Math.floor(now / debounceInterval) * debounceInterval;
      let startAfter = singletonSeconds - Math.floor((now - slot) / 1000) || 1;
      if (singletonSeconds > 1) {
        startAfter++;
      }
      return startAfter;
    }
    async fetch(name, batchSize, options = {}) {
      const values4 = Attorney.checkFetchArgs(name, batchSize, options);
      const db = options.db || this.db;
      const preparedStatement = this.nextJobCommand(options.includeMetadata || false, options.enforceSingletonQueueActiveLimit || false);
      const statementValues = [values4.name, batchSize || 1];
      let result;
      if (options.enforceSingletonQueueActiveLimit && !options.db) {
        const fetchQuery = preparedStatement.replace("$1", Db.quotePostgresStr(statementValues[0])).replace("$2", statementValues[1].toString());
        const [_begin, _setLocal, fetchResult, _commit] = await db.executeSql([
          "BEGIN",
          "SET LOCAL jit = OFF",
          fetchQuery,
          "COMMIT"
        ].join(";\n"));
        result = fetchResult;
      } else {
        result = await db.executeSql(preparedStatement, statementValues);
      }
      if (!result || result.rows.length === 0) {
        return null;
      }
      return result.rows.length === 1 && !batchSize ? result.rows[0] : result.rows;
    }
    async fetchCompleted(name, batchSize, options = {}) {
      return await this.fetch(COMPLETION_JOB_PREFIX + name, batchSize, options);
    }
    mapCompletionIdArg(id, funcName) {
      const errorMessage = `${funcName}() requires an id`;
      assert(id, errorMessage);
      const ids = Array.isArray(id) ? id : [id];
      assert(ids.length, errorMessage);
      return ids;
    }
    mapCompletionDataArg(data) {
      if (data === null || typeof data === "undefined" || typeof data === "function") {
        return null;
      }
      const result = typeof data === "object" && !Array.isArray(data) ? data : { value: data };
      return stringify4(result);
    }
    mapCompletionResponse(ids, result) {
      return {
        jobs: ids,
        requested: ids.length,
        updated: result && result.rows ? parseInt(result.rows[0].count) : 0
      };
    }
    async complete(id, data, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "complete");
      const result = await db.executeSql(this.completeJobsCommand, [ids, this.mapCompletionDataArg(data)]);
      return this.mapCompletionResponse(ids, result);
    }
    async fail(id, data, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "fail");
      const result = await db.executeSql(this.failJobsCommand, [ids, this.mapCompletionDataArg(data)]);
      return this.mapCompletionResponse(ids, result);
    }
    async cancel(id, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "cancel");
      const result = await db.executeSql(this.cancelJobsCommand, [ids]);
      return this.mapCompletionResponse(ids, result);
    }
    async resume(id, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "resume");
      const result = await db.executeSql(this.resumeJobsCommand, [ids]);
      return this.mapCompletionResponse(ids, result);
    }
    async deleteQueue(queue, options) {
      assert(queue, "Missing queue name argument");
      const sql = plans.deleteQueue(this.config.schema, options);
      const result = await this.db.executeSql(sql, [queue]);
      return result ? result.rowCount : null;
    }
    async deleteAllQueues(options) {
      const sql = plans.deleteAllQueues(this.config.schema, options);
      const result = await this.db.executeSql(sql);
      return result ? result.rowCount : null;
    }
    async clearStorage() {
      const sql = plans.clearStorage(this.config.schema);
      await this.db.executeSql(sql);
    }
    async getQueueSize(queue, options) {
      assert(queue, "Missing queue name argument");
      const sql = plans.getQueueSize(this.config.schema, options);
      const result = await this.db.executeSql(sql, [queue]);
      return result ? parseFloat(result.rows[0].count) : null;
    }
    async getJobById(id, options = {}) {
      const db = options.db || this.db;
      const result1 = await db.executeSql(this.getJobByIdCommand, [id]);
      if (result1 && result1.rows && result1.rows.length === 1) {
        return result1.rows[0];
      }
      const result2 = await db.executeSql(this.getArchivedJobByIdCommand, [id]);
      if (result2 && result2.rows && result2.rows.length === 1) {
        return result2.rows[0];
      }
      return null;
    }
  }
  module.exports = Manager;
});

// ../../node_modules/pg-boss/src/index.js
var require_src = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var Attorney = require_attorney();
  var Contractor = require_contractor();
  var Manager = require_manager();
  var Timekeeper = require_timekeeper();
  var Boss = require_boss();
  var Db = require_db();
  var delay = require_delay();
  var events2 = {
    error: "error",
    stopped: "stopped"
  };

  class PgBoss extends EventEmitter {
    static getConstructionPlans(schema3) {
      return Contractor.constructionPlans(schema3);
    }
    static getMigrationPlans(schema3, version2) {
      return Contractor.migrationPlans(schema3, version2);
    }
    static getRollbackPlans(schema3, version2) {
      return Contractor.rollbackPlans(schema3, version2);
    }
    constructor(value) {
      const config = Attorney.getConfig(value);
      super();
      const db = getDb(config);
      if (db.isOurs) {
        promoteEvent.call(this, db, "error");
      }
      const manager2 = new Manager(db, config);
      Object.keys(manager2.events).forEach((event) => promoteEvent.call(this, manager2, manager2.events[event]));
      manager2.functions.forEach((func) => promoteFunction.call(this, manager2, func));
      const bossConfig = { ...config, manager: manager2 };
      const boss = new Boss(db, bossConfig);
      Object.keys(boss.events).forEach((event) => promoteEvent.call(this, boss, boss.events[event]));
      boss.functions.forEach((func) => promoteFunction.call(this, boss, func));
      const timekeeper = new Timekeeper(db, bossConfig);
      Object.keys(timekeeper.events).forEach((event) => promoteEvent.call(this, timekeeper, timekeeper.events[event]));
      timekeeper.functions.forEach((func) => promoteFunction.call(this, timekeeper, func));
      manager2.timekeeper = timekeeper;
      this.stoppingOn = null;
      this.stopped = true;
      this.config = config;
      this.db = db;
      this.boss = boss;
      this.contractor = new Contractor(db, config);
      this.manager = manager2;
      this.timekeeper = timekeeper;
      function getDb(config2) {
        if (config2.db) {
          return config2.db;
        }
        const db2 = new Db(config2);
        db2.isOurs = true;
        return db2;
      }
      function promoteFunction(obj, func) {
        this[func.name] = (...args) => {
          const shouldRun = !this.started || !((func.name === "work" || func.name === "onComplete") && (this.stopped || this.stoppingOn));
          if (shouldRun) {
            return func.apply(obj, args);
          } else {
            const state = this.stoppingOn ? "stopping" : this.stopped ? "stopped" : !this.started ? "not started" : "started";
            return Promise.reject(new Error(`pg-boss is ${state}.`));
          }
        };
      }
      function promoteEvent(emitter, event) {
        emitter.on(event, (arg) => this.emit(event, arg));
      }
    }
    async start() {
      if (!this.stopped) {
        return this;
      }
      if (this.db.isOurs && !this.db.opened) {
        await this.db.open();
      }
      await this.contractor.start();
      this.stopped = false;
      this.started = true;
      this.manager.start();
      if (!this.config.noSupervisor) {
        await this.boss.supervise();
      }
      if (!this.config.noScheduling) {
        await this.timekeeper.start();
      }
      return this;
    }
    async stop(options = {}) {
      if (this.stoppingOn) {
        return;
      }
      if (this.stopped) {
        this.emit(events2.stopped);
      }
      let { destroy = false, graceful = true, timeout = 30000 } = options;
      timeout = Math.max(timeout, 1000);
      this.stoppingOn = Date.now();
      await this.manager.stop();
      await this.timekeeper.stop();
      const shutdown = async () => {
        this.stopped = true;
        this.stoppingOn = null;
        if (this.db.isOurs && this.db.opened && destroy) {
          await this.db.close();
        }
        this.emit(events2.stopped);
      };
      if (!graceful) {
        await this.boss.stop();
        await shutdown();
        return;
      }
      setImmediate(async () => {
        let closing = false;
        try {
          while (Date.now() - this.stoppingOn < timeout) {
            if (this.manager.getWipData({ includeInternal: closing }).length === 0) {
              if (closing) {
                break;
              }
              closing = true;
              await this.boss.stop();
            }
            await delay(1000);
          }
          await this.boss.stop();
          await shutdown();
        } catch (err) {
          this.emit(events2.error, err);
        }
      });
    }
  }
  module.exports = PgBoss;
  module.exports.states = plans.states;
});

// ../../node_modules/handlebars/dist/cjs/handlebars/utils.js
var require_utils5 = __commonJS((exports) => {
  var escapeChar = function(chr) {
    return escape2[chr];
  };
  var extend = function(obj) {
    for (var i = 1;i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }
    return obj;
  };
  var indexOf = function(array, value) {
    for (var i = 0, len = array.length;i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var escapeExpression = function(string) {
    if (typeof string !== "string") {
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return "";
      } else if (!string) {
        return string + "";
      }
      string = "" + string;
    }
    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  };
  var isEmpty = function(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  };
  var createFrame = function(object5) {
    var frame = extend({}, object5);
    frame._parent = object5;
    return frame;
  };
  var blockParams = function(params3, ids) {
    params3.path = ids;
    return params3;
  };
  var appendContextPath = function(contextPath, id) {
    return (contextPath ? contextPath + "." : "") + id;
  };
  exports.__esModule = true;
  exports.extend = extend;
  exports.indexOf = indexOf;
  exports.escapeExpression = escapeExpression;
  exports.isEmpty = isEmpty;
  exports.createFrame = createFrame;
  exports.blockParams = blockParams;
  exports.appendContextPath = appendContextPath;
  var escape2 = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;",
    "=": "&#x3D;"
  };
  var badChars = /[&<>"'`=]/g;
  var possible = /[&<>"'`=]/;
  var toString = Object.prototype.toString;
  exports.toString = toString;
  var isFunction = function isFunction(value) {
    return typeof value === "function";
  };
  if (isFunction(/x/)) {
    exports.isFunction = isFunction = function(value) {
      return typeof value === "function" && toString.call(value) === "[object Function]";
    };
  }
  exports.isFunction = isFunction;
  var isArray = Array.isArray || function(value) {
    return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
  };
  exports.isArray = isArray;
});

// ../../node_modules/handlebars/dist/cjs/handlebars/exception.js
var require_exception = __commonJS((exports, module) => {
  var Exception = function(message, node3) {
    var loc = node3 && node3.loc, line = undefined, endLineNumber = undefined, column = undefined, endColumn = undefined;
    if (loc) {
      line = loc.start.line;
      endLineNumber = loc.end.line;
      column = loc.start.column;
      endColumn = loc.end.column;
      message += " - " + line + ":" + column;
    }
    var tmp = Error.prototype.constructor.call(this, message);
    for (var idx = 0;idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }
    try {
      if (loc) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber;
        if (Object.defineProperty) {
          Object.defineProperty(this, "column", {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, "endColumn", {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
    }
  };
  exports.__esModule = true;
  var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  Exception.prototype = new Error;
  exports.default = Exception;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
var require_block_helper_missing = __commonJS((exports, module) => {
  exports.__esModule = true;
  var _utils = require_utils5();
  exports.default = function(instance) {
    instance.registerHelper("blockHelperMissing", function(context, options) {
      var { inverse, fn } = options;
      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (_utils.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }
          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
          options = { data };
        }
        return fn(context, options);
      }
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
var require_each = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  exports.__esModule = true;
  var _utils = require_utils5();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports.default = function(instance) {
    instance.registerHelper("each", function(context, options) {
      if (!options) {
        throw new _exception2["default"]("Must pass iterator to #each");
      }
      var { fn, inverse } = options, i = 0, ret = "", data = undefined, contextPath = undefined;
      if (options.data && options.ids) {
        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
      }
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }
      if (options.data) {
        data = _utils.createFrame(options.data);
      }
      function execIteration(field3, index, last) {
        if (data) {
          data.key = field3;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;
          if (contextPath) {
            data.contextPath = contextPath + field3;
          }
        }
        ret = ret + fn(context[field3], {
          data,
          blockParams: _utils.blockParams([context[field3], field3], [contextPath + field3, null])
        });
      }
      if (context && typeof context === "object") {
        if (_utils.isArray(context)) {
          for (var j = context.length;i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
          var newContext = [];
          var iterator = context[Symbol.iterator]();
          for (var it = iterator.next();!it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (var j = context.length;i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function() {
            var priorKey = undefined;
            Object.keys(context).forEach(function(key) {
              if (priorKey !== undefined) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            });
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }
      if (i === 0) {
        ret = inverse(this);
      }
      return ret;
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
var require_helper_missing = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  exports.__esModule = true;
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports.default = function(instance) {
    instance.registerHelper("helperMissing", function() {
      if (arguments.length === 1) {
        return;
      } else {
        throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
var require_if = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  exports.__esModule = true;
  var _utils = require_utils5();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports.default = function(instance) {
    instance.registerHelper("if", function(conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2["default"]("#if requires exactly one argument");
      }
      if (_utils.isFunction(conditional)) {
        conditional = conditional.call(this);
      }
      if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });
    instance.registerHelper("unless", function(conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2["default"]("#unless requires exactly one argument");
      }
      return instance.helpers["if"].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
var require_log = __commonJS((exports, module) => {
  exports.__esModule = true;
  exports.default = function(instance) {
    instance.registerHelper("log", function() {
      var args = [undefined], options = arguments[arguments.length - 1];
      for (var i = 0;i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }
      var level = 1;
      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }
      args[0] = level;
      instance.log.apply(instance, args);
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
var require_lookup = __commonJS((exports, module) => {
  exports.__esModule = true;
  exports.default = function(instance) {
    instance.registerHelper("lookup", function(obj, field3, options) {
      if (!obj) {
        return obj;
      }
      return options.lookupProperty(obj, field3);
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
var require_with = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  exports.__esModule = true;
  var _utils = require_utils5();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  exports.default = function(instance) {
    instance.registerHelper("with", function(context, options) {
      if (arguments.length != 2) {
        throw new _exception2["default"]("#with requires exactly one argument");
      }
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }
      var fn = options.fn;
      if (!_utils.isEmpty(context)) {
        var data = options.data;
        if (options.data && options.ids) {
          data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
        }
        return fn(context, {
          data,
          blockParams: _utils.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/helpers.js
var require_helpers = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var registerDefaultHelpers = function(instance) {
    _helpersBlockHelperMissing2["default"](instance);
    _helpersEach2["default"](instance);
    _helpersHelperMissing2["default"](instance);
    _helpersIf2["default"](instance);
    _helpersLog2["default"](instance);
    _helpersLookup2["default"](instance);
    _helpersWith2["default"](instance);
  };
  var moveHelperToHooks = function(instance, helperName, keepHelper) {
    if (instance.helpers[helperName]) {
      instance.hooks[helperName] = instance.helpers[helperName];
      if (!keepHelper) {
        delete instance.helpers[helperName];
      }
    }
  };
  exports.__esModule = true;
  exports.registerDefaultHelpers = registerDefaultHelpers;
  exports.moveHelperToHooks = moveHelperToHooks;
  var _helpersBlockHelperMissing = require_block_helper_missing();
  var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
  var _helpersEach = require_each();
  var _helpersEach2 = _interopRequireDefault(_helpersEach);
  var _helpersHelperMissing = require_helper_missing();
  var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
  var _helpersIf = require_if();
  var _helpersIf2 = _interopRequireDefault(_helpersIf);
  var _helpersLog = require_log();
  var _helpersLog2 = _interopRequireDefault(_helpersLog);
  var _helpersLookup = require_lookup();
  var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
  var _helpersWith = require_with();
  var _helpersWith2 = _interopRequireDefault(_helpersWith);
});

// ../../node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
var require_inline = __commonJS((exports, module) => {
  exports.__esModule = true;
  var _utils = require_utils5();
  exports.default = function(instance) {
    instance.registerDecorator("inline", function(fn, props, container, options) {
      var ret = fn;
      if (!props.partials) {
        props.partials = {};
        ret = function(context, options2) {
          var original = container.partials;
          container.partials = _utils.extend({}, original, props.partials);
          var ret2 = fn(context, options2);
          container.partials = original;
          return ret2;
        };
      }
      props.partials[options.args[0]] = options.fn;
      return ret;
    });
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/decorators.js
var require_decorators = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var registerDefaultDecorators = function(instance) {
    _decoratorsInline2["default"](instance);
  };
  exports.__esModule = true;
  exports.registerDefaultDecorators = registerDefaultDecorators;
  var _decoratorsInline = require_inline();
  var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
});

// ../../node_modules/handlebars/dist/cjs/handlebars/logger.js
var require_logger = __commonJS((exports, module) => {
  exports.__esModule = true;
  var _utils = require_utils5();
  var logger2 = {
    methodMap: ["debug", "info", "warn", "error"],
    level: "info",
    lookupLevel: function lookupLevel(level) {
      if (typeof level === "string") {
        var levelMap = _utils.indexOf(logger2.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }
      return level;
    },
    log: function log(level) {
      level = logger2.lookupLevel(level);
      if (typeof console !== "undefined" && logger2.lookupLevel(logger2.level) <= level) {
        var method = logger2.methodMap[level];
        if (!console[method]) {
          method = "log";
        }
        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }
        console[method].apply(console, message);
      }
    }
  };
  exports.default = logger2;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
var require_create_new_lookup_object = __commonJS((exports) => {
  var createNewLookupObject = function() {
    for (var _len = arguments.length, sources = Array(_len), _key = 0;_key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    return _utils.extend.apply(undefined, [Object.create(null)].concat(sources));
  };
  exports.__esModule = true;
  exports.createNewLookupObject = createNewLookupObject;
  var _utils = require_utils5();
});

// ../../node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
var require_proto_access = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createProtoAccessControl = function(runtimeOptions) {
    var defaultMethodWhiteList = Object.create(null);
    defaultMethodWhiteList["constructor"] = false;
    defaultMethodWhiteList["__defineGetter__"] = false;
    defaultMethodWhiteList["__defineSetter__"] = false;
    defaultMethodWhiteList["__lookupGetter__"] = false;
    var defaultPropertyWhiteList = Object.create(null);
    defaultPropertyWhiteList["__proto__"] = false;
    return {
      properties: {
        whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
        defaultValue: runtimeOptions.allowProtoPropertiesByDefault
      },
      methods: {
        whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
        defaultValue: runtimeOptions.allowProtoMethodsByDefault
      }
    };
  };
  var resultIsAllowed = function(result, protoAccessControl, propertyName) {
    if (typeof result === "function") {
      return checkWhiteList(protoAccessControl.methods, propertyName);
    } else {
      return checkWhiteList(protoAccessControl.properties, propertyName);
    }
  };
  var checkWhiteList = function(protoAccessControlForType, propertyName) {
    if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
      return protoAccessControlForType.whitelist[propertyName] === true;
    }
    if (protoAccessControlForType.defaultValue !== undefined) {
      return protoAccessControlForType.defaultValue;
    }
    logUnexpecedPropertyAccessOnce(propertyName);
    return false;
  };
  var logUnexpecedPropertyAccessOnce = function(propertyName) {
    if (loggedProperties[propertyName] !== true) {
      loggedProperties[propertyName] = true;
      _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
    }
  };
  var resetLoggedProperties = function() {
    Object.keys(loggedProperties).forEach(function(propertyName) {
      delete loggedProperties[propertyName];
    });
  };
  exports.__esModule = true;
  exports.createProtoAccessControl = createProtoAccessControl;
  exports.resultIsAllowed = resultIsAllowed;
  exports.resetLoggedProperties = resetLoggedProperties;
  var _createNewLookupObject = require_create_new_lookup_object();
  var _logger = require_logger();
  var _logger2 = _interopRequireDefault(_logger);
  var loggedProperties = Object.create(null);
});

// ../../node_modules/handlebars/dist/cjs/handlebars/base.js
var require_base = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var HandlebarsEnvironment = function(helpers2, partials, decorators) {
    this.helpers = helpers2 || {};
    this.partials = partials || {};
    this.decorators = decorators || {};
    _helpers.registerDefaultHelpers(this);
    _decorators.registerDefaultDecorators(this);
  };
  exports.__esModule = true;
  exports.HandlebarsEnvironment = HandlebarsEnvironment;
  var _utils = require_utils5();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _helpers = require_helpers();
  var _decorators = require_decorators();
  var _logger = require_logger();
  var _logger2 = _interopRequireDefault(_logger);
  var _internalProtoAccess = require_proto_access();
  var VERSION = "4.7.8";
  exports.VERSION = VERSION;
  var COMPILER_REVISION = 8;
  exports.COMPILER_REVISION = COMPILER_REVISION;
  var LAST_COMPATIBLE_COMPILER_REVISION = 7;
  exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: "<= 1.0.rc.2",
    2: "== 1.0.0-rc.3",
    3: "== 1.0.0-rc.4",
    4: "== 1.x.x",
    5: "== 2.0.0-alpha.x",
    6: ">= 2.0.0-beta.1",
    7: ">= 4.0.0 <4.3.0",
    8: ">= 4.3.0"
  };
  exports.REVISION_CHANGES = REVISION_CHANGES;
  var objectType = "[object Object]";
  HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,
    logger: _logger2["default"],
    log: _logger2["default"].log,
    registerHelper: function registerHelper(name, fn) {
      if (_utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2["default"]("Arg not supported with multiple helpers");
        }
        _utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function unregisterHelper(name) {
      delete this.helpers[name];
    },
    registerPartial: function registerPartial(name, partial) {
      if (_utils.toString.call(name) === objectType) {
        _utils.extend(this.partials, name);
      } else {
        if (typeof partial === "undefined") {
          throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
        }
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function unregisterPartial(name) {
      delete this.partials[name];
    },
    registerDecorator: function registerDecorator(name, fn) {
      if (_utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2["default"]("Arg not supported with multiple decorators");
        }
        _utils.extend(this.decorators, name);
      } else {
        this.decorators[name] = fn;
      }
    },
    unregisterDecorator: function unregisterDecorator(name) {
      delete this.decorators[name];
    },
    resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
      _internalProtoAccess.resetLoggedProperties();
    }
  };
  var log = _logger2["default"].log;
  exports.log = log;
  exports.createFrame = _utils.createFrame;
  exports.logger = _logger2["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/safe-string.js
var require_safe_string = __commonJS((exports, module) => {
  var SafeString = function(string) {
    this.string = string;
  };
  exports.__esModule = true;
  SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
    return "" + this.string;
  };
  exports.default = SafeString;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
var require_wrapHelper = __commonJS((exports) => {
  var wrapHelper = function(helper, transformOptionsFn) {
    if (typeof helper !== "function") {
      return helper;
    }
    var wrapper = function wrapper() {
      var options = arguments[arguments.length - 1];
      arguments[arguments.length - 1] = transformOptionsFn(options);
      return helper.apply(this, arguments);
    };
    return wrapper;
  };
  exports.__esModule = true;
  exports.wrapHelper = wrapHelper;
});

// ../../node_modules/handlebars/dist/cjs/handlebars/runtime.js
var require_runtime = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _interopRequireWildcard = function(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  };
  var checkRevision = function(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
    if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
      return;
    }
    if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
    } else {
      throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
    }
  };
  var template = function(templateSpec, env4) {
    if (!env4) {
      throw new _exception2["default"]("No environment passed to template");
    }
    if (!templateSpec || !templateSpec.main) {
      throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
    }
    templateSpec.main.decorator = templateSpec.main_d;
    env4.VM.checkRevision(templateSpec.compiler);
    var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
    function invokePartialWrapper(partial, context, options) {
      if (options.hash) {
        context = Utils.extend({}, context, options.hash);
        if (options.ids) {
          options.ids[0] = true;
        }
      }
      partial = env4.VM.resolvePartial.call(this, partial, context, options);
      var extendedOptions = Utils.extend({}, options, {
        hooks: this.hooks,
        protoAccessControl: this.protoAccessControl
      });
      var result = env4.VM.invokePartial.call(this, partial, context, extendedOptions);
      if (result == null && env4.compile) {
        options.partials[options.name] = env4.compile(partial, templateSpec.compilerOptions, env4);
        result = options.partials[options.name](context, extendedOptions);
      }
      if (result != null) {
        if (options.indent) {
          var lines = result.split("\n");
          for (var i = 0, l = lines.length;i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }
            lines[i] = options.indent + lines[i];
          }
          result = lines.join("\n");
        }
        return result;
      } else {
        throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
      }
    }
    var container = {
      strict: function strict(obj, name, loc) {
        if (!obj || !(name in obj)) {
          throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
            loc
          });
        }
        return container.lookupProperty(obj, name);
      },
      lookupProperty: function lookupProperty(parent, propertyName) {
        var result = parent[propertyName];
        if (result == null) {
          return result;
        }
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return result;
        }
        if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
          return result;
        }
        return;
      },
      lookup: function lookup(depths, name) {
        var len = depths.length;
        for (var i = 0;i < len; i++) {
          var result = depths[i] && container.lookupProperty(depths[i], name);
          if (result != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function lambda(current, context) {
        return typeof current === "function" ? current.call(context) : current;
      },
      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,
      fn: function fn(i) {
        var ret2 = templateSpec[i];
        ret2.decorator = templateSpec[i + "_d"];
        return ret2;
      },
      programs: [],
      program: function program(i, data, declaredBlockParams, blockParams, depths) {
        var programWrapper = this.programs[i], fn = this.fn(i);
        if (data || depths || blockParams || declaredBlockParams) {
          programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = wrapProgram(this, i, fn);
        }
        return programWrapper;
      },
      data: function data(value, depth) {
        while (value && depth--) {
          value = value._parent;
        }
        return value;
      },
      mergeIfNeeded: function mergeIfNeeded(param, common2) {
        var obj = param || common2;
        if (param && common2 && param !== common2) {
          obj = Utils.extend({}, common2, param);
        }
        return obj;
      },
      nullContext: Object.seal({}),
      noop: env4.VM.noop,
      compilerInfo: templateSpec.compiler
    };
    function ret(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var data = options.data;
      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths = undefined, blockParams = templateSpec.useBlockParams ? [] : undefined;
      if (templateSpec.useDepths) {
        if (options.depths) {
          depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
        } else {
          depths = [context];
        }
      }
      function main(context2) {
        return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
      }
      main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
      return main(context, options);
    }
    ret.isTop = true;
    ret._setup = function(options) {
      if (!options.partial) {
        var mergedHelpers = Utils.extend({}, env4.helpers, options.helpers);
        wrapHelpersToPassLookupProperty(mergedHelpers, container);
        container.helpers = mergedHelpers;
        if (templateSpec.usePartial) {
          container.partials = container.mergeIfNeeded(options.partials, env4.partials);
        }
        if (templateSpec.usePartial || templateSpec.useDecorators) {
          container.decorators = Utils.extend({}, env4.decorators, options.decorators);
        }
        container.hooks = {};
        container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
        var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
        _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
        _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
      } else {
        container.protoAccessControl = options.protoAccessControl;
        container.helpers = options.helpers;
        container.partials = options.partials;
        container.decorators = options.decorators;
        container.hooks = options.hooks;
      }
    };
    ret._child = function(i, data, blockParams, depths) {
      if (templateSpec.useBlockParams && !blockParams) {
        throw new _exception2["default"]("must pass block params");
      }
      if (templateSpec.useDepths && !depths) {
        throw new _exception2["default"]("must pass parent depths");
      }
      return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    };
    return ret;
  };
  var wrapProgram = function(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    function prog(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var currentDepths = depths;
      if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
        currentDepths = [context].concat(depths);
      }
      return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    }
    prog = executeDecorators(fn, prog, container, depths, data, blockParams);
    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    prog.blockParams = declaredBlockParams || 0;
    return prog;
  };
  var resolvePartial = function(partial, context, options) {
    if (!partial) {
      if (options.name === "@partial-block") {
        partial = options.data["partial-block"];
      } else {
        partial = options.partials[options.name];
      }
    } else if (!partial.call && !options.name) {
      options.name = partial;
      partial = options.partials[partial];
    }
    return partial;
  };
  var invokePartial = function(partial, context, options) {
    var currentPartialBlock = options.data && options.data["partial-block"];
    options.partial = true;
    if (options.ids) {
      options.data.contextPath = options.ids[0] || options.data.contextPath;
    }
    var partialBlock = undefined;
    if (options.fn && options.fn !== noop2) {
      (function() {
        options.data = _base.createFrame(options.data);
        var fn = options.fn;
        partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
          var options2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          options2.data = _base.createFrame(options2.data);
          options2.data["partial-block"] = currentPartialBlock;
          return fn(context2, options2);
        };
        if (fn.partials) {
          options.partials = Utils.extend({}, options.partials, fn.partials);
        }
      })();
    }
    if (partial === undefined && partialBlock) {
      partial = partialBlock;
    }
    if (partial === undefined) {
      throw new _exception2["default"]("The partial " + options.name + " could not be found");
    } else if (partial instanceof Function) {
      return partial(context, options);
    }
  };
  var noop2 = function() {
    return "";
  };
  var initData = function(context, data) {
    if (!data || !("root" in data)) {
      data = data ? _base.createFrame(data) : {};
      data.root = context;
    }
    return data;
  };
  var executeDecorators = function(fn, prog, container, depths, data, blockParams) {
    if (fn.decorator) {
      var props = {};
      prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
      Utils.extend(prog, props);
    }
    return prog;
  };
  var wrapHelpersToPassLookupProperty = function(mergedHelpers, container) {
    Object.keys(mergedHelpers).forEach(function(helperName) {
      var helper = mergedHelpers[helperName];
      mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
    });
  };
  var passLookupPropertyOption = function(helper, container) {
    var lookupProperty = container.lookupProperty;
    return _internalWrapHelper.wrapHelper(helper, function(options) {
      return Utils.extend({ lookupProperty }, options);
    });
  };
  exports.__esModule = true;
  exports.checkRevision = checkRevision;
  exports.template = template;
  exports.wrapProgram = wrapProgram;
  exports.resolvePartial = resolvePartial;
  exports.invokePartial = invokePartial;
  exports.noop = noop2;
  var _utils = require_utils5();
  var Utils = _interopRequireWildcard(_utils);
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _base = require_base();
  var _helpers = require_helpers();
  var _internalWrapHelper = require_wrapHelper();
  var _internalProtoAccess = require_proto_access();
});

// ../../node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
var require_no_conflict = __commonJS((exports, module) => {
  exports.__esModule = true;
  exports.default = function(Handlebars) {
    (function() {
      if (typeof globalThis === "object")
        return;
      Object.prototype.__defineGetter__("__magic__", function() {
        return this;
      });
      __magic__.globalThis = __magic__;
      delete Object.prototype.__magic__;
    })();
    var $Handlebars = globalThis.Handlebars;
    Handlebars.noConflict = function() {
      if (globalThis.Handlebars === Handlebars) {
        globalThis.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars.runtime.js
var require_handlebars_runtime = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _interopRequireWildcard = function(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  };
  var create = function() {
    var hb = new base18.HandlebarsEnvironment;
    Utils.extend(hb, base18);
    hb.SafeString = _handlebarsSafeString2["default"];
    hb.Exception = _handlebarsException2["default"];
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;
    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };
    return hb;
  };
  exports.__esModule = true;
  var _handlebarsBase = require_base();
  var base18 = _interopRequireWildcard(_handlebarsBase);
  var _handlebarsSafeString = require_safe_string();
  var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
  var _handlebarsException = require_exception();
  var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
  var _handlebarsUtils = require_utils5();
  var Utils = _interopRequireWildcard(_handlebarsUtils);
  var _handlebarsRuntime = require_runtime();
  var runtime = _interopRequireWildcard(_handlebarsRuntime);
  var _handlebarsNoConflict = require_no_conflict();
  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
  var inst = create();
  inst.create = create;
  _handlebarsNoConflict2["default"](inst);
  inst["default"] = inst;
  exports.default = inst;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
var require_ast = __commonJS((exports, module) => {
  exports.__esModule = true;
  var AST = {
    helpers: {
      helperExpression: function helperExpression(node3) {
        return node3.type === "SubExpression" || (node3.type === "MustacheStatement" || node3.type === "BlockStatement") && !!(node3.params && node3.params.length || node3.hash);
      },
      scopedId: function scopedId(path) {
        return /^\.|this\b/.test(path.original);
      },
      simpleId: function simpleId(path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  };
  exports.default = AST;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
var require_parser3 = __commonJS((exports, module) => {
  exports.__esModule = true;
  var handlebars = function() {
    var parser = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 },
      terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$2, _$) {
        var $0 = $$2.length - 1;
        switch (yystate) {
          case 1:
            return $$2[$0 - 1];
            break;
          case 2:
            this.$ = yy.prepareProgram($$2[$0]);
            break;
          case 3:
            this.$ = $$2[$0];
            break;
          case 4:
            this.$ = $$2[$0];
            break;
          case 5:
            this.$ = $$2[$0];
            break;
          case 6:
            this.$ = $$2[$0];
            break;
          case 7:
            this.$ = $$2[$0];
            break;
          case 8:
            this.$ = $$2[$0];
            break;
          case 9:
            this.$ = {
              type: "CommentStatement",
              value: yy.stripComment($$2[$0]),
              strip: yy.stripFlags($$2[$0], $$2[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 10:
            this.$ = {
              type: "ContentStatement",
              original: $$2[$0],
              value: $$2[$0],
              loc: yy.locInfo(this._$)
            };
            break;
          case 11:
            this.$ = yy.prepareRawBlock($$2[$0 - 2], $$2[$0 - 1], $$2[$0], this._$);
            break;
          case 12:
            this.$ = { path: $$2[$0 - 3], params: $$2[$0 - 2], hash: $$2[$0 - 1] };
            break;
          case 13:
            this.$ = yy.prepareBlock($$2[$0 - 3], $$2[$0 - 2], $$2[$0 - 1], $$2[$0], false, this._$);
            break;
          case 14:
            this.$ = yy.prepareBlock($$2[$0 - 3], $$2[$0 - 2], $$2[$0 - 1], $$2[$0], true, this._$);
            break;
          case 15:
            this.$ = { open: $$2[$0 - 5], path: $$2[$0 - 4], params: $$2[$0 - 3], hash: $$2[$0 - 2], blockParams: $$2[$0 - 1], strip: yy.stripFlags($$2[$0 - 5], $$2[$0]) };
            break;
          case 16:
            this.$ = { path: $$2[$0 - 4], params: $$2[$0 - 3], hash: $$2[$0 - 2], blockParams: $$2[$0 - 1], strip: yy.stripFlags($$2[$0 - 5], $$2[$0]) };
            break;
          case 17:
            this.$ = { path: $$2[$0 - 4], params: $$2[$0 - 3], hash: $$2[$0 - 2], blockParams: $$2[$0 - 1], strip: yy.stripFlags($$2[$0 - 5], $$2[$0]) };
            break;
          case 18:
            this.$ = { strip: yy.stripFlags($$2[$0 - 1], $$2[$0 - 1]), program: $$2[$0] };
            break;
          case 19:
            var inverse = yy.prepareBlock($$2[$0 - 2], $$2[$0 - 1], $$2[$0], $$2[$0], false, this._$), program = yy.prepareProgram([inverse], $$2[$0 - 1].loc);
            program.chained = true;
            this.$ = { strip: $$2[$0 - 2].strip, program, chain: true };
            break;
          case 20:
            this.$ = $$2[$0];
            break;
          case 21:
            this.$ = { path: $$2[$0 - 1], strip: yy.stripFlags($$2[$0 - 2], $$2[$0]) };
            break;
          case 22:
            this.$ = yy.prepareMustache($$2[$0 - 3], $$2[$0 - 2], $$2[$0 - 1], $$2[$0 - 4], yy.stripFlags($$2[$0 - 4], $$2[$0]), this._$);
            break;
          case 23:
            this.$ = yy.prepareMustache($$2[$0 - 3], $$2[$0 - 2], $$2[$0 - 1], $$2[$0 - 4], yy.stripFlags($$2[$0 - 4], $$2[$0]), this._$);
            break;
          case 24:
            this.$ = {
              type: "PartialStatement",
              name: $$2[$0 - 3],
              params: $$2[$0 - 2],
              hash: $$2[$0 - 1],
              indent: "",
              strip: yy.stripFlags($$2[$0 - 4], $$2[$0]),
              loc: yy.locInfo(this._$)
            };
            break;
          case 25:
            this.$ = yy.preparePartialBlock($$2[$0 - 2], $$2[$0 - 1], $$2[$0], this._$);
            break;
          case 26:
            this.$ = { path: $$2[$0 - 3], params: $$2[$0 - 2], hash: $$2[$0 - 1], strip: yy.stripFlags($$2[$0 - 4], $$2[$0]) };
            break;
          case 27:
            this.$ = $$2[$0];
            break;
          case 28:
            this.$ = $$2[$0];
            break;
          case 29:
            this.$ = {
              type: "SubExpression",
              path: $$2[$0 - 3],
              params: $$2[$0 - 2],
              hash: $$2[$0 - 1],
              loc: yy.locInfo(this._$)
            };
            break;
          case 30:
            this.$ = { type: "Hash", pairs: $$2[$0], loc: yy.locInfo(this._$) };
            break;
          case 31:
            this.$ = { type: "HashPair", key: yy.id($$2[$0 - 2]), value: $$2[$0], loc: yy.locInfo(this._$) };
            break;
          case 32:
            this.$ = yy.id($$2[$0 - 1]);
            break;
          case 33:
            this.$ = $$2[$0];
            break;
          case 34:
            this.$ = $$2[$0];
            break;
          case 35:
            this.$ = { type: "StringLiteral", value: $$2[$0], original: $$2[$0], loc: yy.locInfo(this._$) };
            break;
          case 36:
            this.$ = { type: "NumberLiteral", value: Number($$2[$0]), original: Number($$2[$0]), loc: yy.locInfo(this._$) };
            break;
          case 37:
            this.$ = { type: "BooleanLiteral", value: $$2[$0] === "true", original: $$2[$0] === "true", loc: yy.locInfo(this._$) };
            break;
          case 38:
            this.$ = { type: "UndefinedLiteral", original: undefined, value: undefined, loc: yy.locInfo(this._$) };
            break;
          case 39:
            this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
            break;
          case 40:
            this.$ = $$2[$0];
            break;
          case 41:
            this.$ = $$2[$0];
            break;
          case 42:
            this.$ = yy.preparePath(true, $$2[$0], this._$);
            break;
          case 43:
            this.$ = yy.preparePath(false, $$2[$0], this._$);
            break;
          case 44:
            $$2[$0 - 2].push({ part: yy.id($$2[$0]), original: $$2[$0], separator: $$2[$0 - 1] });
            this.$ = $$2[$0 - 2];
            break;
          case 45:
            this.$ = [{ part: yy.id($$2[$0]), original: $$2[$0] }];
            break;
          case 46:
            this.$ = [];
            break;
          case 47:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 48:
            this.$ = [];
            break;
          case 49:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 50:
            this.$ = [];
            break;
          case 51:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 58:
            this.$ = [];
            break;
          case 59:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 64:
            this.$ = [];
            break;
          case 65:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 70:
            this.$ = [];
            break;
          case 71:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 78:
            this.$ = [];
            break;
          case 79:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 82:
            this.$ = [];
            break;
          case 83:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 86:
            this.$ = [];
            break;
          case 87:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 90:
            this.$ = [];
            break;
          case 91:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 94:
            this.$ = [];
            break;
          case 95:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 98:
            this.$ = [$$2[$0]];
            break;
          case 99:
            $$2[$0 - 1].push($$2[$0]);
            break;
          case 100:
            this.$ = [$$2[$0]];
            break;
          case 101:
            $$2[$0 - 1].push($$2[$0]);
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
      defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
      parseError: function parseError(str, hash) {
        throw new Error(str);
      },
      parse: function parse(input6) {
        var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
        this.lexer.setInput(input6);
        this.lexer.yy = this.yy;
        this.yy.lexer = this.lexer;
        this.yy.parser = this;
        if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
        var yyloc = this.lexer.yylloc;
        lstack.push(yyloc);
        var ranges = this.lexer.options && this.lexer.options.ranges;
        if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
        function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
        }
        function lex() {
          var token;
          token = self2.lexer.lex() || 1;
          if (typeof token !== "number") {
            token = self2.symbols_[token] || token;
          }
          return token;
        }
        var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            if (!recovering) {
              expected = [];
              for (p in table[state])
                if (this.terminals_[p] && p > 2) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
              if (this.lexer.showPosition) {
                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
              } else {
                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
              }
              this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
            }
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer2 = function() {
      var lexer3 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function setInput(input6) {
          this._input = input6;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
          if (this.options.ranges)
            this.yylloc.range = [0, 0];
          this.offset = 0;
          return this;
        },
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges)
            this.yylloc.range[1]++;
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1)
            this.yylineno -= lines.length - 1;
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
        },
        more: function more() {
          this._more = true;
          return this;
        },
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function upcomingInput() {
          var next = this.match;
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }
          return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        next: function next() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input)
            this.done = true;
          var token, match, tempMatch, index, col, lines;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0;i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (!this.options.flex)
                break;
            }
          }
          if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines)
              this.yylineno += lines.length;
            this.yylloc = {
              first_line: this.yylloc.last_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.last_column,
              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
            };
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
              this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
            if (this.done && this._input)
              this.done = false;
            if (token)
              return token;
            else
              return;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (typeof r !== "undefined") {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          return this.conditionStack.pop();
        },
        _currentRules: function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        },
        topState: function topState() {
          return this.conditionStack[this.conditionStack.length - 2];
        },
        pushState: function begin(condition) {
          this.begin(condition);
        }
      };
      lexer3.options = {};
      lexer3.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        function strip(start, end) {
          return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
        }
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            if (yy_.yytext.slice(-2) === "\\\\") {
              strip(0, 1);
              this.begin("mu");
            } else if (yy_.yytext.slice(-1) === "\\") {
              strip(0, 1);
              this.begin("emu");
            } else {
              this.begin("mu");
            }
            if (yy_.yytext)
              return 15;
            break;
          case 1:
            return 15;
            break;
          case 2:
            this.popState();
            return 15;
            break;
          case 3:
            this.begin("raw");
            return 15;
            break;
          case 4:
            this.popState();
            if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
              return 15;
            } else {
              strip(5, 9);
              return "END_RAW_BLOCK";
            }
            break;
          case 5:
            return 15;
            break;
          case 6:
            this.popState();
            return 14;
            break;
          case 7:
            return 65;
            break;
          case 8:
            return 68;
            break;
          case 9:
            return 19;
            break;
          case 10:
            this.popState();
            this.begin("raw");
            return 23;
            break;
          case 11:
            return 55;
            break;
          case 12:
            return 60;
            break;
          case 13:
            return 29;
            break;
          case 14:
            return 47;
            break;
          case 15:
            this.popState();
            return 44;
            break;
          case 16:
            this.popState();
            return 44;
            break;
          case 17:
            return 34;
            break;
          case 18:
            return 39;
            break;
          case 19:
            return 51;
            break;
          case 20:
            return 48;
            break;
          case 21:
            this.unput(yy_.yytext);
            this.popState();
            this.begin("com");
            break;
          case 22:
            this.popState();
            return 14;
            break;
          case 23:
            return 48;
            break;
          case 24:
            return 73;
            break;
          case 25:
            return 72;
            break;
          case 26:
            return 72;
            break;
          case 27:
            return 87;
            break;
          case 28:
            break;
          case 29:
            this.popState();
            return 54;
            break;
          case 30:
            this.popState();
            return 33;
            break;
          case 31:
            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
            return 80;
            break;
          case 32:
            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
            return 80;
            break;
          case 33:
            return 85;
            break;
          case 34:
            return 82;
            break;
          case 35:
            return 82;
            break;
          case 36:
            return 83;
            break;
          case 37:
            return 84;
            break;
          case 38:
            return 81;
            break;
          case 39:
            return 75;
            break;
          case 40:
            return 77;
            break;
          case 41:
            return 72;
            break;
          case 42:
            yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
            return 72;
            break;
          case 43:
            return "INVALID";
            break;
          case 44:
            return 5;
            break;
        }
      };
      lexer3.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
      lexer3.conditions = { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [6], inclusive: false }, raw: { rules: [3, 4, 5], inclusive: false }, INITIAL: { rules: [0, 1, 44], inclusive: true } };
      return lexer3;
    }();
    parser.lexer = lexer2;
    function Parser2() {
      this.yy = {};
    }
    Parser2.prototype = parser;
    parser.Parser = Parser2;
    return new Parser2;
  }();
  exports.default = handlebars;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
var require_visitor = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var Visitor = function() {
    this.parents = [];
  };
  var visitSubExpression = function(mustache) {
    this.acceptRequired(mustache, "path");
    this.acceptArray(mustache.params);
    this.acceptKey(mustache, "hash");
  };
  var visitBlock = function(block2) {
    visitSubExpression.call(this, block2);
    this.acceptKey(block2, "program");
    this.acceptKey(block2, "inverse");
  };
  var visitPartial = function(partial) {
    this.acceptRequired(partial, "name");
    this.acceptArray(partial.params);
    this.acceptKey(partial, "hash");
  };
  exports.__esModule = true;
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,
    acceptKey: function acceptKey(node3, name) {
      var value = this.accept(node3[name]);
      if (this.mutating) {
        if (value && !Visitor.prototype[value.type]) {
          throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node3.type);
        }
        node3[name] = value;
      }
    },
    acceptRequired: function acceptRequired(node3, name) {
      this.acceptKey(node3, name);
      if (!node3[name]) {
        throw new _exception2["default"](node3.type + " requires " + name);
      }
    },
    acceptArray: function acceptArray(array) {
      for (var i = 0, l = array.length;i < l; i++) {
        this.acceptKey(array, i);
        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },
    accept: function accept(object5) {
      if (!object5) {
        return;
      }
      if (!this[object5.type]) {
        throw new _exception2["default"]("Unknown type: " + object5.type, object5);
      }
      if (this.current) {
        this.parents.unshift(this.current);
      }
      this.current = object5;
      var ret = this[object5.type](object5);
      this.current = this.parents.shift();
      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object5;
      }
    },
    Program: function Program(program) {
      this.acceptArray(program.body);
    },
    MustacheStatement: visitSubExpression,
    Decorator: visitSubExpression,
    BlockStatement: visitBlock,
    DecoratorBlock: visitBlock,
    PartialStatement: visitPartial,
    PartialBlockStatement: function PartialBlockStatement(partial) {
      visitPartial.call(this, partial);
      this.acceptKey(partial, "program");
    },
    ContentStatement: function ContentStatement() {
    },
    CommentStatement: function CommentStatement() {
    },
    SubExpression: visitSubExpression,
    PathExpression: function PathExpression() {
    },
    StringLiteral: function StringLiteral() {
    },
    NumberLiteral: function NumberLiteral() {
    },
    BooleanLiteral: function BooleanLiteral() {
    },
    UndefinedLiteral: function UndefinedLiteral() {
    },
    NullLiteral: function NullLiteral() {
    },
    Hash: function Hash(hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function HashPair(pair) {
      this.acceptRequired(pair, "value");
    }
  };
  exports.default = Visitor;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
var require_whitespace_control = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var WhitespaceControl = function() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    this.options = options;
  };
  var isPrevWhitespace = function(body, i, isRoot) {
    if (i === undefined) {
      i = body.length;
    }
    var prev = body[i - 1], sibling = body[i - 2];
    if (!prev) {
      return isRoot;
    }
    if (prev.type === "ContentStatement") {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  };
  var isNextWhitespace = function(body, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }
    var next = body[i + 1], sibling = body[i + 2];
    if (!next) {
      return isRoot;
    }
    if (next.type === "ContentStatement") {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  };
  var omitRight = function(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];
    if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
    current.rightStripped = current.value !== original;
  };
  var omitLeft = function(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];
    if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
      return;
    }
    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  };
  exports.__esModule = true;
  var _visitor = require_visitor();
  var _visitor2 = _interopRequireDefault(_visitor);
  WhitespaceControl.prototype = new _visitor2["default"];
  WhitespaceControl.prototype.Program = function(program) {
    var doStandalone = !this.options.ignoreStandalone;
    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;
    var body = program.body;
    for (var i = 0, l = body.length;i < l; i++) {
      var current = body[i], strip = this.accept(current);
      if (!strip) {
        continue;
      }
      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
      if (strip.close) {
        omitRight(body, i, true);
      }
      if (strip.open) {
        omitLeft(body, i, true);
      }
      if (doStandalone && inlineStandalone) {
        omitRight(body, i);
        if (omitLeft(body, i)) {
          if (current.type === "PartialStatement") {
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }
      if (doStandalone && openStandalone) {
        omitRight((current.program || current.inverse).body);
        omitLeft(body, i);
      }
      if (doStandalone && closeStandalone) {
        omitRight(body, i);
        omitLeft((current.inverse || current.program).body);
      }
    }
    return program;
  };
  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block2) {
    this.accept(block2.program);
    this.accept(block2.inverse);
    var program = block2.program || block2.inverse, inverse = block2.program && block2.inverse, firstInverse = inverse, lastInverse = inverse;
    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program;
      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }
    var strip = {
      open: block2.openStrip.open,
      close: block2.closeStrip.close,
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };
    if (block2.openStrip.close) {
      omitRight(program.body, null, true);
    }
    if (inverse) {
      var inverseStrip = block2.inverseStrip;
      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }
      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }
      if (block2.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      }
      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block2.closeStrip.open) {
      omitLeft(program.body, null, true);
    }
    return strip;
  };
  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
    return mustache.strip;
  };
  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node3) {
    var strip = node3.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };
  exports.default = WhitespaceControl;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
var require_helpers2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validateClose = function(open, close) {
    close = close.path ? close.path.original : close;
    if (open.path.original !== close) {
      var errorNode = { loc: open.path.loc };
      throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
    }
  };
  var SourceLocation = function(source2, locInfo) {
    this.source = source2;
    this.start = {
      line: locInfo.first_line,
      column: locInfo.first_column
    };
    this.end = {
      line: locInfo.last_line,
      column: locInfo.last_column
    };
  };
  var id = function(token) {
    if (/^\[.*\]$/.test(token)) {
      return token.substring(1, token.length - 1);
    } else {
      return token;
    }
  };
  var stripFlags = function(open, close) {
    return {
      open: open.charAt(2) === "~",
      close: close.charAt(close.length - 3) === "~"
    };
  };
  var stripComment = function(comment) {
    return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
  };
  var preparePath = function(data, parts, loc) {
    loc = this.locInfo(loc);
    var original = data ? "@" : "", dig = [], depth = 0;
    for (var i = 0, l = parts.length;i < l; i++) {
      var part = parts[i].part, isLiteral = parts[i].original !== part;
      original += (parts[i].separator || "") + part;
      if (!isLiteral && (part === ".." || part === "." || part === "this")) {
        if (dig.length > 0) {
          throw new _exception2["default"]("Invalid path: " + original, { loc });
        } else if (part === "..") {
          depth++;
        }
      } else {
        dig.push(part);
      }
    }
    return {
      type: "PathExpression",
      data,
      depth,
      parts: dig,
      original,
      loc
    };
  };
  var prepareMustache = function(path, params3, hash, open, strip, locInfo) {
    var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
    var decorator = /\*/.test(open);
    return {
      type: decorator ? "Decorator" : "MustacheStatement",
      path,
      params: params3,
      hash,
      escaped,
      strip,
      loc: this.locInfo(locInfo)
    };
  };
  var prepareRawBlock = function(openRawBlock, contents, close, locInfo) {
    validateClose(openRawBlock, close);
    locInfo = this.locInfo(locInfo);
    var program = {
      type: "Program",
      body: contents,
      strip: {},
      loc: locInfo
    };
    return {
      type: "BlockStatement",
      path: openRawBlock.path,
      params: openRawBlock.params,
      hash: openRawBlock.hash,
      program,
      openStrip: {},
      inverseStrip: {},
      closeStrip: {},
      loc: locInfo
    };
  };
  var prepareBlock = function(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
    if (close && close.path) {
      validateClose(openBlock, close);
    }
    var decorator = /\*/.test(openBlock.open);
    program.blockParams = openBlock.blockParams;
    var inverse = undefined, inverseStrip = undefined;
    if (inverseAndProgram) {
      if (decorator) {
        throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
      }
      if (inverseAndProgram.chain) {
        inverseAndProgram.program.body[0].closeStrip = close.strip;
      }
      inverseStrip = inverseAndProgram.strip;
      inverse = inverseAndProgram.program;
    }
    if (inverted) {
      inverted = inverse;
      inverse = program;
      program = inverted;
    }
    return {
      type: decorator ? "DecoratorBlock" : "BlockStatement",
      path: openBlock.path,
      params: openBlock.params,
      hash: openBlock.hash,
      program,
      inverse,
      openStrip: openBlock.strip,
      inverseStrip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  };
  var prepareProgram = function(statements, loc) {
    if (!loc && statements.length) {
      var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
      if (firstLoc && lastLoc) {
        loc = {
          source: firstLoc.source,
          start: {
            line: firstLoc.start.line,
            column: firstLoc.start.column
          },
          end: {
            line: lastLoc.end.line,
            column: lastLoc.end.column
          }
        };
      }
    }
    return {
      type: "Program",
      body: statements,
      strip: {},
      loc
    };
  };
  var preparePartialBlock = function(open, program, close, locInfo) {
    validateClose(open, close);
    return {
      type: "PartialBlockStatement",
      name: open.path,
      params: open.params,
      hash: open.hash,
      program,
      openStrip: open.strip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  };
  exports.__esModule = true;
  exports.SourceLocation = SourceLocation;
  exports.id = id;
  exports.stripFlags = stripFlags;
  exports.stripComment = stripComment;
  exports.preparePath = preparePath;
  exports.prepareMustache = prepareMustache;
  exports.prepareRawBlock = prepareRawBlock;
  exports.prepareBlock = prepareBlock;
  exports.prepareProgram = prepareProgram;
  exports.preparePartialBlock = preparePartialBlock;
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
var require_base2 = __commonJS((exports) => {
  var _interopRequireWildcard = function(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj["default"] = obj;
      return newObj;
    }
  };
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parseWithoutProcessing = function(input6, options) {
    if (input6.type === "Program") {
      return input6;
    }
    _parser2["default"].yy = yy;
    yy.locInfo = function(locInfo) {
      return new yy.SourceLocation(options && options.srcName, locInfo);
    };
    var ast8 = _parser2["default"].parse(input6);
    return ast8;
  };
  var parse2 = function(input6, options) {
    var ast8 = parseWithoutProcessing(input6, options);
    var strip = new _whitespaceControl2["default"](options);
    return strip.accept(ast8);
  };
  exports.__esModule = true;
  exports.parseWithoutProcessing = parseWithoutProcessing;
  exports.parse = parse2;
  var _parser = require_parser3();
  var _parser2 = _interopRequireDefault(_parser);
  var _whitespaceControl = require_whitespace_control();
  var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
  var _helpers = require_helpers2();
  var Helpers = _interopRequireWildcard(_helpers);
  var _utils = require_utils5();
  exports.parser = _parser2["default"];
  var yy = {};
  _utils.extend(yy, Helpers);
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
var require_compiler = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var Compiler = function() {
  };
  var precompile = function(input6, options, env4) {
    if (input6 == null || typeof input6 !== "string" && input6.type !== "Program") {
      throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input6);
    }
    options = options || {};
    if (!("data" in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }
    var ast8 = env4.parse(input6, options), environment = new env4.Compiler().compile(ast8, options);
    return new env4.JavaScriptCompiler().compile(environment, options);
  };
  var compile = function(input6, options, env4) {
    if (options === undefined)
      options = {};
    if (input6 == null || typeof input6 !== "string" && input6.type !== "Program") {
      throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input6);
    }
    options = _utils.extend({}, options);
    if (!("data" in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }
    var compiled = undefined;
    function compileInput() {
      var ast8 = env4.parse(input6, options), environment = new env4.Compiler().compile(ast8, options), templateSpec = new env4.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env4.template(templateSpec);
    }
    function ret(context, execOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, execOptions);
    }
    ret._setup = function(setupOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._setup(setupOptions);
    };
    ret._child = function(i, data, blockParams, depths) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._child(i, data, blockParams, depths);
    };
    return ret;
  };
  var argEquals = function(a, b) {
    if (a === b) {
      return true;
    }
    if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
      for (var i = 0;i < a.length; i++) {
        if (!argEquals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  };
  var transformLiteralToPath = function(sexpr) {
    if (!sexpr.path.parts) {
      var literal = sexpr.path;
      sexpr.path = {
        type: "PathExpression",
        data: false,
        depth: 0,
        parts: [literal.original + ""],
        original: literal.original + "",
        loc: literal.loc
      };
    }
  };
  exports.__esModule = true;
  exports.Compiler = Compiler;
  exports.precompile = precompile;
  exports.compile = compile;
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _utils = require_utils5();
  var _ast = require_ast();
  var _ast2 = _interopRequireDefault(_ast);
  var slice = [].slice;
  Compiler.prototype = {
    compiler: Compiler,
    equals: function equals(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }
      for (var i = 0;i < len; i++) {
        var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
          return false;
        }
      }
      len = this.children.length;
      for (var i = 0;i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }
      return true;
    },
    guid: 0,
    compile: function compile(program, options) {
      this.sourceNode = [];
      this.opcodes = [];
      this.children = [];
      this.options = options;
      this.stringParams = options.stringParams;
      this.trackIds = options.trackIds;
      options.blockParams = options.blockParams || [];
      options.knownHelpers = _utils.extend(Object.create(null), {
        helperMissing: true,
        blockHelperMissing: true,
        each: true,
        if: true,
        unless: true,
        with: true,
        log: true,
        lookup: true
      }, options.knownHelpers);
      return this.accept(program);
    },
    compileProgram: function compileProgram(program) {
      var childCompiler = new this.compiler, result = childCompiler.compile(program, this.options), guid = this.guid++;
      this.usePartial = this.usePartial || result.usePartial;
      this.children[guid] = result;
      this.useDepths = this.useDepths || result.useDepths;
      return guid;
    },
    accept: function accept(node3) {
      if (!this[node3.type]) {
        throw new _exception2["default"]("Unknown type: " + node3.type, node3);
      }
      this.sourceNode.unshift(node3);
      var ret = this[node3.type](node3);
      this.sourceNode.shift();
      return ret;
    },
    Program: function Program(program) {
      this.options.blockParams.unshift(program.blockParams);
      var body = program.body, bodyLength = body.length;
      for (var i = 0;i < bodyLength; i++) {
        this.accept(body[i]);
      }
      this.options.blockParams.shift();
      this.isSimple = bodyLength === 1;
      this.blockParams = program.blockParams ? program.blockParams.length : 0;
      return this;
    },
    BlockStatement: function BlockStatement(block2) {
      transformLiteralToPath(block2);
      var { program, inverse } = block2;
      program = program && this.compileProgram(program);
      inverse = inverse && this.compileProgram(inverse);
      var type2 = this.classifySexpr(block2);
      if (type2 === "helper") {
        this.helperSexpr(block2, program, inverse);
      } else if (type2 === "simple") {
        this.simpleSexpr(block2);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        this.opcode("emptyHash");
        this.opcode("blockValue", block2.path.original);
      } else {
        this.ambiguousSexpr(block2, program, inverse);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        this.opcode("emptyHash");
        this.opcode("ambiguousBlockValue");
      }
      this.opcode("append");
    },
    DecoratorBlock: function DecoratorBlock(decorator) {
      var program = decorator.program && this.compileProgram(decorator.program);
      var params3 = this.setupFullMustacheParams(decorator, program, undefined), path = decorator.path;
      this.useDecorators = true;
      this.opcode("registerDecorator", params3.length, path.original);
    },
    PartialStatement: function PartialStatement(partial) {
      this.usePartial = true;
      var program = partial.program;
      if (program) {
        program = this.compileProgram(partial.program);
      }
      var params3 = partial.params;
      if (params3.length > 1) {
        throw new _exception2["default"]("Unsupported number of partial arguments: " + params3.length, partial);
      } else if (!params3.length) {
        if (this.options.explicitPartialContext) {
          this.opcode("pushLiteral", "undefined");
        } else {
          params3.push({ type: "PathExpression", parts: [], depth: 0 });
        }
      }
      var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
      if (isDynamic) {
        this.accept(partial.name);
      }
      this.setupFullMustacheParams(partial, program, undefined, true);
      var indent2 = partial.indent || "";
      if (this.options.preventIndent && indent2) {
        this.opcode("appendContent", indent2);
        indent2 = "";
      }
      this.opcode("invokePartial", isDynamic, partialName, indent2);
      this.opcode("append");
    },
    PartialBlockStatement: function PartialBlockStatement(partialBlock) {
      this.PartialStatement(partialBlock);
    },
    MustacheStatement: function MustacheStatement(mustache) {
      this.SubExpression(mustache);
      if (mustache.escaped && !this.options.noEscape) {
        this.opcode("appendEscaped");
      } else {
        this.opcode("append");
      }
    },
    Decorator: function Decorator(decorator) {
      this.DecoratorBlock(decorator);
    },
    ContentStatement: function ContentStatement(content) {
      if (content.value) {
        this.opcode("appendContent", content.value);
      }
    },
    CommentStatement: function CommentStatement() {
    },
    SubExpression: function SubExpression(sexpr) {
      transformLiteralToPath(sexpr);
      var type2 = this.classifySexpr(sexpr);
      if (type2 === "simple") {
        this.simpleSexpr(sexpr);
      } else if (type2 === "helper") {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },
    ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
      var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
      this.opcode("getContext", path.depth);
      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);
      path.strict = true;
      this.accept(path);
      this.opcode("invokeAmbiguous", name, isBlock);
    },
    simpleSexpr: function simpleSexpr(sexpr) {
      var path = sexpr.path;
      path.strict = true;
      this.accept(path);
      this.opcode("resolvePossibleLambda");
    },
    helperSexpr: function helperSexpr(sexpr, program, inverse) {
      var params3 = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
      if (this.options.knownHelpers[name]) {
        this.opcode("invokeKnownHelper", params3.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
      } else {
        path.strict = true;
        path.falsy = true;
        this.accept(path);
        this.opcode("invokeHelper", params3.length, path.original, _ast2["default"].helpers.simpleId(path));
      }
    },
    PathExpression: function PathExpression(path) {
      this.addDepth(path.depth);
      this.opcode("getContext", path.depth);
      var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
      if (blockParamId) {
        this.opcode("lookupBlockParam", blockParamId, path.parts);
      } else if (!name) {
        this.opcode("pushContext");
      } else if (path.data) {
        this.options.data = true;
        this.opcode("lookupData", path.depth, path.parts, path.strict);
      } else {
        this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
      }
    },
    StringLiteral: function StringLiteral(string) {
      this.opcode("pushString", string.value);
    },
    NumberLiteral: function NumberLiteral(number) {
      this.opcode("pushLiteral", number.value);
    },
    BooleanLiteral: function BooleanLiteral(bool) {
      this.opcode("pushLiteral", bool.value);
    },
    UndefinedLiteral: function UndefinedLiteral() {
      this.opcode("pushLiteral", "undefined");
    },
    NullLiteral: function NullLiteral() {
      this.opcode("pushLiteral", "null");
    },
    Hash: function Hash(hash) {
      var pairs = hash.pairs, i = 0, l = pairs.length;
      this.opcode("pushHash");
      for (;i < l; i++) {
        this.pushParam(pairs[i].value);
      }
      while (i--) {
        this.opcode("assignToHash", pairs[i].key);
      }
      this.opcode("popHash");
    },
    opcode: function opcode(name) {
      this.opcodes.push({
        opcode: name,
        args: slice.call(arguments, 1),
        loc: this.sourceNode[0].loc
      });
    },
    addDepth: function addDepth(depth) {
      if (!depth) {
        return;
      }
      this.useDepths = true;
    },
    classifySexpr: function classifySexpr(sexpr) {
      var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
      var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
      var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
      var isEligible = !isBlockParam && (isHelper || isSimple);
      if (isEligible && !isHelper) {
        var _name = sexpr.path.parts[0], options = this.options;
        if (options.knownHelpers[_name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }
      if (isHelper) {
        return "helper";
      } else if (isEligible) {
        return "ambiguous";
      } else {
        return "simple";
      }
    },
    pushParams: function pushParams(params3) {
      for (var i = 0, l = params3.length;i < l; i++) {
        this.pushParam(params3[i]);
      }
    },
    pushParam: function pushParam(val) {
      var value = val.value != null ? val.value : val.original || "";
      if (this.stringParams) {
        if (value.replace) {
          value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
        }
        if (val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode("getContext", val.depth || 0);
        this.opcode("pushStringParam", value, val.type);
        if (val.type === "SubExpression") {
          this.accept(val);
        }
      } else {
        if (this.trackIds) {
          var blockParamIndex = undefined;
          if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
            blockParamIndex = this.blockParamIndex(val.parts[0]);
          }
          if (blockParamIndex) {
            var blockParamChild = val.parts.slice(1).join(".");
            this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
          } else {
            value = val.original || value;
            if (value.replace) {
              value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
            }
            this.opcode("pushId", val.type, value);
          }
        }
        this.accept(val);
      }
    },
    setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
      var params3 = sexpr.params;
      this.pushParams(params3);
      this.opcode("pushProgram", program);
      this.opcode("pushProgram", inverse);
      if (sexpr.hash) {
        this.accept(sexpr.hash);
      } else {
        this.opcode("emptyHash", omitEmpty);
      }
      return params3;
    },
    blockParamIndex: function blockParamIndex(name) {
      for (var depth = 0, len = this.options.blockParams.length;depth < len; depth++) {
        var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
        if (blockParams && param >= 0) {
          return [depth, param];
        }
      }
    }
  };
});

// ../../node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// ../../node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var toVLQSigned = function(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  };
  var fromVLQSigned = function(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  };
  var base642 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base642.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base642.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// ../../node_modules/source-map/lib/util.js
var require_util = __commonJS((exports) => {
  var getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  };
  var urlParse = function(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  };
  var urlGenerate = function(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  };
  var normalize = function(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  };
  var join3 = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  };
  var relative = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var identity2 = function(s) {
    return s;
  };
  var toSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  };
  var fromSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  };
  var isProtoString = function(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  };
  var compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var strcmp = function(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  };
  var compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var parseSourceMapInput = function(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  };
  var computeSourceURL = function(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join3(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  };
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  exports.urlParse = urlParse;
  exports.urlGenerate = urlGenerate;
  exports.normalize = normalize;
  exports.join = join3;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  exports.toSetString = supportsNullProto ? identity2 : toSetString;
  exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
  exports.compareByOriginalPositions = compareByOriginalPositions;
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  exports.parseSourceMapInput = parseSourceMapInput;
  exports.computeSourceURL = computeSourceURL;
});

// ../../node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var ArraySet = function() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  };
  var util2 = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet;
    for (var i = 0, len = aArray.length;i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// ../../node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var generatedPositionAfter = function(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  };
  var MappingList = function() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  };
  var util2 = require_util();
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util2.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// ../../node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var SourceMapGenerator = function(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util2.getArg(aArgs, "file", null);
    this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  };
  var base64VLQ = require_base64_vlq();
  var util2 = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util2.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util2.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util2.getArg(aArgs, "generated");
    var original = util2.getArg(aArgs, "original", null);
    var source2 = util2.getArg(aArgs, "source", null);
    var name = util2.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source2, name);
    }
    if (source2 != null) {
      source2 = String(source2);
      if (!this._sources.has(source2)) {
        this._sources.add(source2);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source2,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source2 = aSourceFile;
    if (this._sourceRoot != null) {
      source2 = util2.relative(this._sourceRoot, source2);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util2.toSetString(source2)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util2.toSetString(source2)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util2.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util2.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util2.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source2 = mapping.source;
      if (source2 != null && !newSources.has(source2)) {
        newSources.add(source2);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util2.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length;i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source2) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source2 = util2.relative(aSourceRoot, source2);
      }
      var key = util2.toSetString(source2);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map3 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map3.file = this._file;
    }
    if (this._sourceRoot != null) {
      map3.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map3.sourcesContent = this._generateSourcesContent(map3.sources, map3.sourceRoot);
    }
    return map3;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// ../../node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
  var recursiveSearch = function(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  };
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// ../../node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
  var swap = function(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  };
  var randomIntInRange = function(low, high) {
    return Math.round(low + Math.random() * (high - low));
  };
  var doQuickSort = function(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p;j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  };
  exports.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// ../../node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
  var SourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util2.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  };
  var BasicSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap, "version");
    var sources = util2.getArg(sourceMap, "sources");
    var names = util2.getArg(sourceMap, "names", []);
    var sourceRoot = util2.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util2.getArg(sourceMap, "sourcesContent", null);
    var mappings = util2.getArg(sourceMap, "mappings");
    var file = util2.getArg(sourceMap, "file", null);
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    if (sourceRoot) {
      sourceRoot = util2.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util2.normalize).map(function(source2) {
      return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source2) ? util2.relative(sourceRoot, source2) : source2;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  };
  var Mapping = function() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  };
  var IndexedSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap, "version");
    var sections = util2.getArg(sourceMap, "sections");
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    this._sources = new ArraySet;
    this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util2.getArg(s, "offset");
      var offsetLine = util2.getArg(offset, "line");
      var offsetColumn = util2.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
      };
    });
  };
  var util2 = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source2 = mapping.source === null ? null : this._sources.at(mapping.source);
      source2 = util2.computeSourceURL(sourceRoot, source2, this._sourceMapURL);
      return {
        source: source2,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util2.getArg(aArgs, "line");
    var needle = {
      source: util2.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util2.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util2.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0;i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length;i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util2.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping;
        mapping.generatedLine = generatedLine;
        for (end = index;end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util2.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util2.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0;index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util2.compareByGeneratedPositionsDeflated, util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source2 = util2.getArg(mapping, "source", null);
        if (source2 !== null) {
          source2 = this._sources.at(source2);
          source2 = util2.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL);
        }
        var name = util2.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source2,
          line: util2.getArg(mapping, "originalLine", null),
          column: util2.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source2 = util2.getArg(aArgs, "source");
    source2 = this._findSourceIndex(source2);
    if (source2 < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source: source2,
      originalLine: util2.getArg(aArgs, "line"),
      originalColumn: util2.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util2.compareByOriginalPositions, util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util2.getArg(mapping, "generatedLine", null),
          column: util2.getArg(mapping, "generatedColumn", null),
          lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0;i < this._sections.length; i++) {
        for (var j = 0;j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0;j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source2 = section.consumer._sources.at(mapping.source);
        source2 = util2.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL);
        this._sources.add(source2);
        source2 = this._sources.indexOf(source2);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source: source2,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util2.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// ../../node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports) => {
  var SourceNode = function(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  };
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util2 = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node3 = new SourceNode;
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node3.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node3.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node3.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util2.join(aRelativePath, sourceFile);
        }
        node3.setSourceContent(sourceFile, content);
      }
    });
    return node3;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node3.add(code);
      } else {
        var source2 = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
        node3.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source2, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1;i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length;i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0;i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length;i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length;i < len; i++) {
      aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map3 = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map3.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map3.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length;idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map3.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map3.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map: map3 };
  };
  exports.SourceNode = SourceNode;
});

// ../../node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports.SourceNode = require_source_node().SourceNode;
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
var require_code_gen = __commonJS((exports, module) => {
  var castChunk = function(chunk, codeGen, loc) {
    if (_utils.isArray(chunk)) {
      var ret = [];
      for (var i = 0, len = chunk.length;i < len; i++) {
        ret.push(codeGen.wrap(chunk[i], loc));
      }
      return ret;
    } else if (typeof chunk === "boolean" || typeof chunk === "number") {
      return chunk + "";
    }
    return chunk;
  };
  var CodeGen = function(srcFile) {
    this.srcFile = srcFile;
    this.source = [];
  };
  exports.__esModule = true;
  var _utils = require_utils5();
  var SourceNode = undefined;
  try {
    if (typeof define !== "function" || !define.amd) {
      SourceMap = require_source_map();
      SourceNode = SourceMap.SourceNode;
    }
  } catch (err) {
  }
  var SourceMap;
  if (!SourceNode) {
    SourceNode = function(line, column, srcFile, chunks) {
      this.src = "";
      if (chunks) {
        this.add(chunks);
      }
    };
    SourceNode.prototype = {
      add: function add(chunks) {
        if (_utils.isArray(chunks)) {
          chunks = chunks.join("");
        }
        this.src += chunks;
      },
      prepend: function prepend(chunks) {
        if (_utils.isArray(chunks)) {
          chunks = chunks.join("");
        }
        this.src = chunks + this.src;
      },
      toStringWithSourceMap: function toStringWithSourceMap() {
        return { code: this.toString() };
      },
      toString: function toString() {
        return this.src;
      }
    };
  }
  CodeGen.prototype = {
    isEmpty: function isEmpty() {
      return !this.source.length;
    },
    prepend: function prepend(source2, loc) {
      this.source.unshift(this.wrap(source2, loc));
    },
    push: function push(source2, loc) {
      this.source.push(this.wrap(source2, loc));
    },
    merge: function merge() {
      var source2 = this.empty();
      this.each(function(line) {
        source2.add(["  ", line, "\n"]);
      });
      return source2;
    },
    each: function each(iter) {
      for (var i = 0, len = this.source.length;i < len; i++) {
        iter(this.source[i]);
      }
    },
    empty: function empty() {
      var loc = this.currentLocation || { start: {} };
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    },
    wrap: function wrap(chunk) {
      var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];
      if (chunk instanceof SourceNode) {
        return chunk;
      }
      chunk = castChunk(chunk, this, loc);
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    },
    functionCall: function functionCall(fn, type2, params3) {
      params3 = this.generateList(params3);
      return this.wrap([fn, type2 ? "." + type2 + "(" : "(", params3, ")"]);
    },
    quotedString: function quotedString(str) {
      return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
    },
    objectLiteral: function objectLiteral(obj) {
      var _this = this;
      var pairs = [];
      Object.keys(obj).forEach(function(key) {
        var value = castChunk(obj[key], _this);
        if (value !== "undefined") {
          pairs.push([_this.quotedString(key), ":", value]);
        }
      });
      var ret = this.generateList(pairs);
      ret.prepend("{");
      ret.add("}");
      return ret;
    },
    generateList: function generateList(entries) {
      var ret = this.empty();
      for (var i = 0, len = entries.length;i < len; i++) {
        if (i) {
          ret.add(",");
        }
        ret.add(castChunk(entries[i], this));
      }
      return ret;
    },
    generateArray: function generateArray(entries) {
      var ret = this.generateList(entries);
      ret.prepend("[");
      ret.add("]");
      return ret;
    }
  };
  exports.default = CodeGen;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
var require_javascript_compiler = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var Literal = function(value) {
    this.value = value;
  };
  var JavaScriptCompiler = function() {
  };
  var strictLookup = function(requireTerminal, compiler, parts, i, type2) {
    var stack = compiler.popStack(), len = parts.length;
    if (requireTerminal) {
      len--;
    }
    for (;i < len; i++) {
      stack = compiler.nameLookup(stack, parts[i], type2);
    }
    if (requireTerminal) {
      return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
    } else {
      return stack;
    }
  };
  exports.__esModule = true;
  var _base = require_base();
  var _exception = require_exception();
  var _exception2 = _interopRequireDefault(_exception);
  var _utils = require_utils5();
  var _codeGen = require_code_gen();
  var _codeGen2 = _interopRequireDefault(_codeGen);
  JavaScriptCompiler.prototype = {
    nameLookup: function nameLookup(parent, name) {
      return this.internalNameLookup(parent, name);
    },
    depthedLookup: function depthedLookup(name) {
      return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
    },
    compilerInfo: function compilerInfo() {
      var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
      return [revision, versions];
    },
    appendToBuffer: function appendToBuffer(source2, location3, explicit) {
      if (!_utils.isArray(source2)) {
        source2 = [source2];
      }
      source2 = this.source.wrap(source2, location3);
      if (this.environment.isSimple) {
        return ["return ", source2, ";"];
      } else if (explicit) {
        return ["buffer += ", source2, ";"];
      } else {
        source2.appendToBuffer = true;
        return source2;
      }
    },
    initializeBuffer: function initializeBuffer() {
      return this.quotedString("");
    },
    internalNameLookup: function internalNameLookup(parent, name) {
      this.lookupPropertyFunctionIsUsed = true;
      return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
    },
    lookupPropertyFunctionIsUsed: false,
    compile: function compile(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;
      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        decorators: [],
        programs: [],
        environments: []
      };
      this.preamble();
      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];
      this.blockParams = [];
      this.compileChildren(environment, options);
      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
      this.useBlockParams = this.useBlockParams || environment.useBlockParams;
      var opcodes = environment.opcodes, opcode = undefined, firstLoc = undefined, i = undefined, l = undefined;
      for (i = 0, l = opcodes.length;i < l; i++) {
        opcode = opcodes[i];
        this.source.currentLocation = opcode.loc;
        firstLoc = firstLoc || opcode.loc;
        this[opcode.opcode].apply(this, opcode.args);
      }
      this.source.currentLocation = firstLoc;
      this.pushSource("");
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new _exception2["default"]("Compile completed with content left on stack");
      }
      if (!this.decorators.isEmpty()) {
        this.useDecorators = true;
        this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
        this.decorators.push("return fn;");
        if (asObject) {
          this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
        } else {
          this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
          this.decorators.push("}\n");
          this.decorators = this.decorators.merge();
        }
      } else {
        this.decorators = undefined;
      }
      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };
        if (this.decorators) {
          ret.main_d = this.decorators;
          ret.useDecorators = true;
        }
        var _context = this.context;
        var programs = _context.programs;
        var decorators = _context.decorators;
        for (i = 0, l = programs.length;i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
            if (decorators[i]) {
              ret[i + "_d"] = decorators[i];
              ret.useDecorators = true;
            }
          }
        }
        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.useBlockParams) {
          ret.useBlockParams = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }
        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);
          this.source.currentLocation = { start: { line: 1, column: 0 } };
          ret = this.objectLiteral(ret);
          if (options.srcName) {
            ret = ret.toStringWithSourceMap({ file: options.destName });
            ret.map = ret.map && ret.map.toString();
          } else {
            ret = ret.toString();
          }
        } else {
          ret.compilerOptions = this.options;
        }
        return ret;
      } else {
        return fn;
      }
    },
    preamble: function preamble() {
      this.lastContext = 0;
      this.source = new _codeGen2["default"](this.options.srcName);
      this.decorators = new _codeGen2["default"](this.options.srcName);
    },
    createFunctionContext: function createFunctionContext(asObject) {
      var _this = this;
      var varDeclarations = "";
      var locals = this.stackVars.concat(this.registers.list);
      if (locals.length > 0) {
        varDeclarations += ", " + locals.join(", ");
      }
      var aliasCount = 0;
      Object.keys(this.aliases).forEach(function(alias) {
        var node3 = _this.aliases[alias];
        if (node3.children && node3.referenceCount > 1) {
          varDeclarations += ", alias" + ++aliasCount + "=" + alias;
          node3.children[0] = "alias" + aliasCount;
        }
      });
      if (this.lookupPropertyFunctionIsUsed) {
        varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
      }
      var params3 = ["container", "depth0", "helpers", "partials", "data"];
      if (this.useBlockParams || this.useDepths) {
        params3.push("blockParams");
      }
      if (this.useDepths) {
        params3.push("depths");
      }
      var source2 = this.mergeSource(varDeclarations);
      if (asObject) {
        params3.push(source2);
        return Function.apply(this, params3);
      } else {
        return this.source.wrap(["function(", params3.join(","), ") {\n  ", source2, "}"]);
      }
    },
    mergeSource: function mergeSource(varDeclarations) {
      var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = undefined, sourceSeen = undefined, bufferStart = undefined, bufferEnd = undefined;
      this.source.each(function(line) {
        if (line.appendToBuffer) {
          if (bufferStart) {
            line.prepend("  + ");
          } else {
            bufferStart = line;
          }
          bufferEnd = line;
        } else {
          if (bufferStart) {
            if (!sourceSeen) {
              appendFirst = true;
            } else {
              bufferStart.prepend("buffer += ");
            }
            bufferEnd.add(";");
            bufferStart = bufferEnd = undefined;
          }
          sourceSeen = true;
          if (!isSimple) {
            appendOnly = false;
          }
        }
      });
      if (appendOnly) {
        if (bufferStart) {
          bufferStart.prepend("return ");
          bufferEnd.add(";");
        } else if (!sourceSeen) {
          this.source.push('return "";');
        }
      } else {
        varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
        if (bufferStart) {
          bufferStart.prepend("return buffer + ");
          bufferEnd.add(";");
        } else {
          this.source.push("return buffer;");
        }
      }
      if (varDeclarations) {
        this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
      }
      return this.source.merge();
    },
    lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
      return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
    },
    blockValue: function blockValue(name) {
      var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params3 = [this.contextName(0)];
      this.setupHelperArgs(name, 0, params3);
      var blockName = this.popStack();
      params3.splice(1, 0, blockName);
      this.push(this.source.functionCall(blockHelperMissing, "call", params3));
    },
    ambiguousBlockValue: function ambiguousBlockValue() {
      var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params3 = [this.contextName(0)];
      this.setupHelperArgs("", 0, params3, true);
      this.flushInline();
      var current = this.topStack();
      params3.splice(1, 0, current);
      this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params3), "}"]);
    },
    appendContent: function appendContent(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      } else {
        this.pendingLocation = this.source.currentLocation;
      }
      this.pendingContent = content;
    },
    append: function append() {
      if (this.isInline()) {
        this.replaceStack(function(current) {
          return [" != null ? ", current, ' : ""'];
        });
        this.pushSource(this.appendToBuffer(this.popStack()));
      } else {
        var local = this.popStack();
        this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, undefined, true), " }"]);
        if (this.environment.isSimple) {
          this.pushSource(["else { ", this.appendToBuffer("''", undefined, true), " }"]);
        }
      }
    },
    appendEscaped: function appendEscaped() {
      this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
    },
    getContext: function getContext(depth) {
      this.lastContext = depth;
    },
    pushContext: function pushContext() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },
    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
      var i = 0;
      if (!scoped && this.options.compat && !this.lastContext) {
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }
      this.resolvePath("context", parts, i, falsy, strict);
    },
    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
      this.useBlockParams = true;
      this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
      this.resolvePath("context", parts, 1);
    },
    lookupData: function lookupData(depth, parts, strict) {
      if (!depth) {
        this.pushStackLiteral("data");
      } else {
        this.pushStackLiteral("container.data(data, " + depth + ")");
      }
      this.resolvePath("data", parts, 0, true, strict);
    },
    resolvePath: function resolvePath(type2, parts, i, falsy, strict) {
      var _this2 = this;
      if (this.options.strict || this.options.assumeObjects) {
        this.push(strictLookup(this.options.strict && strict, this, parts, i, type2));
        return;
      }
      var len = parts.length;
      for (;i < len; i++) {
        this.replaceStack(function(current) {
          var lookup = _this2.nameLookup(current, parts[i], type2);
          if (!falsy) {
            return [" != null ? ", lookup, " : ", current];
          } else {
            return [" && ", lookup];
          }
        });
      }
    },
    resolvePossibleLambda: function resolvePossibleLambda() {
      this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
    },
    pushStringParam: function pushStringParam(string, type2) {
      this.pushContext();
      this.pushString(type2);
      if (type2 !== "SubExpression") {
        if (typeof string === "string") {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },
    emptyHash: function emptyHash(omitEmpty) {
      if (this.trackIds) {
        this.push("{}");
      }
      if (this.stringParams) {
        this.push("{}");
        this.push("{}");
      }
      this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
    },
    pushHash: function pushHash() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = { values: {}, types: [], contexts: [], ids: [] };
    },
    popHash: function popHash() {
      var hash = this.hash;
      this.hash = this.hashes.pop();
      if (this.trackIds) {
        this.push(this.objectLiteral(hash.ids));
      }
      if (this.stringParams) {
        this.push(this.objectLiteral(hash.contexts));
        this.push(this.objectLiteral(hash.types));
      }
      this.push(this.objectLiteral(hash.values));
    },
    pushString: function pushString(string) {
      this.pushStackLiteral(this.quotedString(string));
    },
    pushLiteral: function pushLiteral(value) {
      this.pushStackLiteral(value);
    },
    pushProgram: function pushProgram(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },
    registerDecorator: function registerDecorator(paramSize, name) {
      var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
      this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
    },
    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
      var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
      var possibleFunctionCalls = [];
      if (isSimple) {
        possibleFunctionCalls.push(helper.name);
      }
      possibleFunctionCalls.push(nonHelper);
      if (!this.options.strict) {
        possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
      }
      var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
      var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
      this.push(functionCall);
    },
    itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
      var result = [];
      result.push(items[0]);
      for (var i = 1;i < items.length; i++) {
        result.push(separator, items[i]);
      }
      return result;
    },
    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(this.source.functionCall(helper.name, "call", helper.callParams));
    },
    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
      this.useRegister("helper");
      var nonHelper = this.popStack();
      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);
      var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
      var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
      if (!this.options.strict) {
        lookup[0] = "(helper = ";
        lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
      }
      this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
    },
    invokePartial: function invokePartial(isDynamic, name, indent2) {
      var params3 = [], options = this.setupParams(name, 1, params3);
      if (isDynamic) {
        name = this.popStack();
        delete options.name;
      }
      if (indent2) {
        options.indent = JSON.stringify(indent2);
      }
      options.helpers = "helpers";
      options.partials = "partials";
      options.decorators = "container.decorators";
      if (!isDynamic) {
        params3.unshift(this.nameLookup("partials", name, "partial"));
      } else {
        params3.unshift(name);
      }
      if (this.options.compat) {
        options.depths = "depths";
      }
      options = this.objectLiteral(options);
      params3.push(options);
      this.push(this.source.functionCall("container.invokePartial", "", params3));
    },
    assignToHash: function assignToHash(key) {
      var value = this.popStack(), context = undefined, type2 = undefined, id = undefined;
      if (this.trackIds) {
        id = this.popStack();
      }
      if (this.stringParams) {
        type2 = this.popStack();
        context = this.popStack();
      }
      var hash = this.hash;
      if (context) {
        hash.contexts[key] = context;
      }
      if (type2) {
        hash.types[key] = type2;
      }
      if (id) {
        hash.ids[key] = id;
      }
      hash.values[key] = value;
    },
    pushId: function pushId(type2, name, child) {
      if (type2 === "BlockParam") {
        this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
      } else if (type2 === "PathExpression") {
        this.pushString(name);
      } else if (type2 === "SubExpression") {
        this.pushStackLiteral("true");
      } else {
        this.pushStackLiteral("null");
      }
    },
    compiler: JavaScriptCompiler,
    compileChildren: function compileChildren(environment, options) {
      var children = environment.children, child = undefined, compiler = undefined;
      for (var i = 0, l = children.length;i < l; i++) {
        child = children[i];
        compiler = new this.compiler;
        var existing = this.matchExistingProgram(child);
        if (existing == null) {
          this.context.programs.push("");
          var index = this.context.programs.length;
          child.index = index;
          child.name = "program" + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.decorators[index] = compiler.decorators;
          this.context.environments[index] = child;
          this.useDepths = this.useDepths || compiler.useDepths;
          this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          child.useDepths = this.useDepths;
          child.useBlockParams = this.useBlockParams;
        } else {
          child.index = existing.index;
          child.name = "program" + existing.index;
          this.useDepths = this.useDepths || existing.useDepths;
          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
        }
      }
    },
    matchExistingProgram: function matchExistingProgram(child) {
      for (var i = 0, len = this.context.environments.length;i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return environment;
        }
      }
    },
    programExpression: function programExpression(guid) {
      var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
      if (this.useBlockParams || this.useDepths) {
        programParams.push("blockParams");
      }
      if (this.useDepths) {
        programParams.push("depths");
      }
      return "container.program(" + programParams.join(", ") + ")";
    },
    useRegister: function useRegister(name) {
      if (!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },
    push: function push(expr) {
      if (!(expr instanceof Literal)) {
        expr = this.source.wrap(expr);
      }
      this.inlineStack.push(expr);
      return expr;
    },
    pushStackLiteral: function pushStackLiteral(item) {
      this.push(new Literal(item));
    },
    pushSource: function pushSource(source2) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
        this.pendingContent = undefined;
      }
      if (source2) {
        this.source.push(source2);
      }
    },
    replaceStack: function replaceStack(callback) {
      var prefix = ["("], stack = undefined, createdStack = undefined, usedLiteral = undefined;
      if (!this.isInline()) {
        throw new _exception2["default"]("replaceStack on non-inline");
      }
      var top = this.popStack(true);
      if (top instanceof Literal) {
        stack = [top.value];
        prefix = ["(", stack];
        usedLiteral = true;
      } else {
        createdStack = true;
        var _name = this.incrStack();
        prefix = ["((", this.push(_name), " = ", top, ")"];
        stack = this.topStack();
      }
      var item = callback.call(this, stack);
      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push(prefix.concat(item, ")"));
    },
    incrStack: function incrStack() {
      this.stackSlot++;
      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push("stack" + this.stackSlot);
      }
      return this.topStackName();
    },
    topStackName: function topStackName() {
      return "stack" + this.stackSlot;
    },
    flushInline: function flushInline() {
      var inlineStack = this.inlineStack;
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length;i < len; i++) {
        var entry = inlineStack[i];
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          var stack = this.incrStack();
          this.pushSource([stack, " = ", entry, ";"]);
          this.compileStack.push(stack);
        }
      }
    },
    isInline: function isInline() {
      return this.inlineStack.length;
    },
    popStack: function popStack(wrapped) {
      var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline) {
          if (!this.stackSlot) {
            throw new _exception2["default"]("Invalid stack pop");
          }
          this.stackSlot--;
        }
        return item;
      }
    },
    topStack: function topStack() {
      var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },
    contextName: function contextName(context) {
      if (this.useDepths && context) {
        return "depths[" + context + "]";
      } else {
        return "depth" + context;
      }
    },
    quotedString: function quotedString(str) {
      return this.source.quotedString(str);
    },
    objectLiteral: function objectLiteral(obj) {
      return this.source.objectLiteral(obj);
    },
    aliasable: function aliasable(name) {
      var ret = this.aliases[name];
      if (ret) {
        ret.referenceCount++;
        return ret;
      }
      ret = this.aliases[name] = this.source.wrap(name);
      ret.aliasable = true;
      ret.referenceCount = 1;
      return ret;
    },
    setupHelper: function setupHelper(paramSize, name, blockHelper) {
      var params3 = [], paramsInit = this.setupHelperArgs(name, paramSize, params3, blockHelper);
      var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
      return {
        params: params3,
        paramsInit,
        name: foundHelper,
        callParams: [callContext].concat(params3)
      };
    },
    setupParams: function setupParams(helper, paramSize, params3) {
      var options = {}, contexts = [], types25 = [], ids = [], objectArgs = !params3, param = undefined;
      if (objectArgs) {
        params3 = [];
      }
      options.name = this.quotedString(helper);
      options.hash = this.popStack();
      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }
      var inverse = this.popStack(), program = this.popStack();
      if (program || inverse) {
        options.fn = program || "container.noop";
        options.inverse = inverse || "container.noop";
      }
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params3[i] = param;
        if (this.trackIds) {
          ids[i] = this.popStack();
        }
        if (this.stringParams) {
          types25[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }
      if (objectArgs) {
        options.args = this.source.generateArray(params3);
      }
      if (this.trackIds) {
        options.ids = this.source.generateArray(ids);
      }
      if (this.stringParams) {
        options.types = this.source.generateArray(types25);
        options.contexts = this.source.generateArray(contexts);
      }
      if (this.options.data) {
        options.data = "data";
      }
      if (this.useBlockParams) {
        options.blockParams = "blockParams";
      }
      return options;
    },
    setupHelperArgs: function setupHelperArgs(helper, paramSize, params3, useRegister) {
      var options = this.setupParams(helper, paramSize, params3);
      options.loc = JSON.stringify(this.source.currentLocation);
      options = this.objectLiteral(options);
      if (useRegister) {
        this.useRegister("options");
        params3.push("options");
        return ["options=", options];
      } else if (params3) {
        params3.push(options);
        return "";
      } else {
        return options;
      }
    }
  };
  (function() {
    var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
    for (var i = 0, l = reservedWords.length;i < l; i++) {
      compilerWords[reservedWords[i]] = true;
    }
  })();
  JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };
  exports.default = JavaScriptCompiler;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars.js
var require_handlebars = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var create = function() {
    var hb = _create();
    hb.compile = function(input6, options) {
      return _handlebarsCompilerCompiler.compile(input6, options, hb);
    };
    hb.precompile = function(input6, options) {
      return _handlebarsCompilerCompiler.precompile(input6, options, hb);
    };
    hb.AST = _handlebarsCompilerAst2["default"];
    hb.Compiler = _handlebarsCompilerCompiler.Compiler;
    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
    hb.Parser = _handlebarsCompilerBase.parser;
    hb.parse = _handlebarsCompilerBase.parse;
    hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
    return hb;
  };
  exports.__esModule = true;
  var _handlebarsRuntime = require_handlebars_runtime();
  var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
  var _handlebarsCompilerAst = require_ast();
  var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
  var _handlebarsCompilerBase = require_base2();
  var _handlebarsCompilerCompiler = require_compiler();
  var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
  var _handlebarsCompilerVisitor = require_visitor();
  var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
  var _handlebarsNoConflict = require_no_conflict();
  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
  var _create = _handlebarsRuntime2["default"].create;
  var inst = create();
  inst.create = create;
  _handlebarsNoConflict2["default"](inst);
  inst.Visitor = _handlebarsCompilerVisitor2["default"];
  inst["default"] = inst;
  exports.default = inst;
  module.exports = exports["default"];
});

// ../../node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
var require_printer = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var print2 = function(ast8) {
    return new PrintVisitor().accept(ast8);
  };
  var PrintVisitor = function() {
    this.padding = 0;
  };
  exports.__esModule = true;
  exports.print = print2;
  exports.PrintVisitor = PrintVisitor;
  var _visitor = require_visitor();
  var _visitor2 = _interopRequireDefault(_visitor);
  PrintVisitor.prototype = new _visitor2["default"];
  PrintVisitor.prototype.pad = function(string) {
    var out = "";
    for (var i = 0, l = this.padding;i < l; i++) {
      out += "  ";
    }
    out += string + "\n";
    return out;
  };
  PrintVisitor.prototype.Program = function(program) {
    var out = "", body = program.body, i = undefined, l = undefined;
    if (program.blockParams) {
      var blockParams = "BLOCK PARAMS: [";
      for (i = 0, l = program.blockParams.length;i < l; i++) {
        blockParams += " " + program.blockParams[i];
      }
      blockParams += " ]";
      out += this.pad(blockParams);
    }
    for (i = 0, l = body.length;i < l; i++) {
      out += this.accept(body[i]);
    }
    this.padding--;
    return out;
  };
  PrintVisitor.prototype.MustacheStatement = function(mustache) {
    return this.pad("{{ " + this.SubExpression(mustache) + " }}");
  };
  PrintVisitor.prototype.Decorator = function(mustache) {
    return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
  };
  PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block2) {
    var out = "";
    out += this.pad((block2.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
    this.padding++;
    out += this.pad(this.SubExpression(block2));
    if (block2.program) {
      out += this.pad("PROGRAM:");
      this.padding++;
      out += this.accept(block2.program);
      this.padding--;
    }
    if (block2.inverse) {
      if (block2.program) {
        this.padding++;
      }
      out += this.pad("{{^}}");
      this.padding++;
      out += this.accept(block2.inverse);
      this.padding--;
      if (block2.program) {
        this.padding--;
      }
    }
    this.padding--;
    return out;
  };
  PrintVisitor.prototype.PartialStatement = function(partial) {
    var content = "PARTIAL:" + partial.name.original;
    if (partial.params[0]) {
      content += " " + this.accept(partial.params[0]);
    }
    if (partial.hash) {
      content += " " + this.accept(partial.hash);
    }
    return this.pad("{{> " + content + " }}");
  };
  PrintVisitor.prototype.PartialBlockStatement = function(partial) {
    var content = "PARTIAL BLOCK:" + partial.name.original;
    if (partial.params[0]) {
      content += " " + this.accept(partial.params[0]);
    }
    if (partial.hash) {
      content += " " + this.accept(partial.hash);
    }
    content += " " + this.pad("PROGRAM:");
    this.padding++;
    content += this.accept(partial.program);
    this.padding--;
    return this.pad("{{> " + content + " }}");
  };
  PrintVisitor.prototype.ContentStatement = function(content) {
    return this.pad("CONTENT[ '" + content.value + "' ]");
  };
  PrintVisitor.prototype.CommentStatement = function(comment) {
    return this.pad("{{! '" + comment.value + "' }}");
  };
  PrintVisitor.prototype.SubExpression = function(sexpr) {
    var params3 = sexpr.params, paramStrings = [], hash = undefined;
    for (var i = 0, l = params3.length;i < l; i++) {
      paramStrings.push(this.accept(params3[i]));
    }
    params3 = "[" + paramStrings.join(", ") + "]";
    hash = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
    return this.accept(sexpr.path) + " " + params3 + hash;
  };
  PrintVisitor.prototype.PathExpression = function(id) {
    var path = id.parts.join("/");
    return (id.data ? "@" : "") + "PATH:" + path;
  };
  PrintVisitor.prototype.StringLiteral = function(string) {
    return '"' + string.value + '"';
  };
  PrintVisitor.prototype.NumberLiteral = function(number) {
    return "NUMBER{" + number.value + "}";
  };
  PrintVisitor.prototype.BooleanLiteral = function(bool) {
    return "BOOLEAN{" + bool.value + "}";
  };
  PrintVisitor.prototype.UndefinedLiteral = function() {
    return "UNDEFINED";
  };
  PrintVisitor.prototype.NullLiteral = function() {
    return "NULL";
  };
  PrintVisitor.prototype.Hash = function(hash) {
    var pairs = hash.pairs, joinedPairs = [];
    for (var i = 0, l = pairs.length;i < l; i++) {
      joinedPairs.push(this.accept(pairs[i]));
    }
    return "HASH{" + joinedPairs.join(", ") + "}";
  };
  PrintVisitor.prototype.HashPair = function(pair) {
    return pair.key + "=" + this.accept(pair.value);
  };
});

// ../../node_modules/handlebars/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  var extension = function(module2, filename) {
    var fs = import.meta.require("fs");
    var templateString = fs.readFileSync(filename, "utf8");
    module2.exports = handlebars.compile(templateString);
  };
  var handlebars = require_handlebars()["default"];
  var printer11 = require_printer();
  handlebars.PrintVisitor = printer11.PrintVisitor;
  handlebars.print = printer11.print;
  module.exports = handlebars;
  if (typeof import.meta.require !== "undefined" && import.meta.require.extensions) {
    import.meta.require.extensions[".handlebars"] = extension;
    import.meta.require.extensions[".hbs"] = extension;
  }
});

// ../../node_modules/handlebars-async-helpers/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "handlebars-async-helpers",
    version: "1.0.6",
    description: "Adding async function support to handlebars helpers",
    main: "index.js",
    scripts: {
      test: "mocha --ui bdd --recursive --timeout 15000"
    },
    repository: "https://github.com/gastonrobledo/handlebars-async-helpers",
    author: "Gaston Robledo",
    license: "MIT",
    peerDependencies: {
      handlebars: "4.7.6"
    },
    devDependencies: {
      handlebars: "^4.7.6",
      eslint: "^8.9.0",
      "eslint-config-airbnb": "^19.0.4",
      "eslint-config-standard": "^12.0.0",
      "eslint-plugin-import": "^2.14.0",
      "eslint-plugin-node": "^8.0.0",
      "eslint-plugin-promise": "^4.0.1",
      "eslint-plugin-standard": "^4.0.0",
      mocha: "^9.2.0",
      should: "^13.2.3"
    }
  };
});

// ../../node_modules/handlebars-async-helpers/utils.js
var require_utils6 = __commonJS((exports, module) => {
  var blockParams = function(params3, ids) {
    params3.path = ids;
    return params3;
  };
  var extend = function(obj) {
    for (let i = 1;i < arguments.length; i++) {
      for (const key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }
    return obj;
  };
  var appendContextPath = function(contextPath, id) {
    return (contextPath ? `${contextPath}.` : "") + id;
  };
  var createFrame = function(object5) {
    const frame = extend({}, object5);
    frame._parent = object5;
    return frame;
  };
  var isEmpty = function(value) {
    if (!value && value !== 0) {
      return true;
    }
    if (Array.isArray(value) && value.length === 0) {
      return true;
    }
    return false;
  };
  var isPromise5 = function(value) {
    return typeof value === "object" && value !== null && typeof value.then === "function";
  };
  module.exports = {
    blockParams,
    extend,
    appendContextPath,
    createFrame,
    isEmpty,
    isPromise: isPromise5
  };
});

// ../../node_modules/handlebars-async-helpers/helpers/each.js
var require_each2 = __commonJS((exports, module) => {
  var {
    appendContextPath,
    createFrame,
    blockParams,
    isPromise: isPromise5
  } = require_utils6();
  var { Readable } = import.meta.require("stream");
  module.exports = (handlebars) => {
    handlebars.registerHelper("each", async function(context, options) {
      if (!options) {
        throw new Error("Must pass iterator to #each");
      }
      let { fn } = options, { inverse } = options, i = 0, ret = [], data, contextPath;
      if (options.data && options.ids) {
        contextPath = `${appendContextPath(options.data.contextPath, options.ids[0])}.`;
      }
      if (typeof context === "function") {
        context = context.call(this);
      }
      if (options.data) {
        data = createFrame(options.data);
      }
      async function execIteration(field3, index, last) {
        if (data) {
          data.key = field3;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;
          if (contextPath) {
            data.contextPath = contextPath + field3;
          }
        }
        ret.push(await fn(context[field3], {
          data,
          blockParams: blockParams([context[field3], field3], [contextPath + field3, null])
        }));
      }
      if (context && typeof context === "object") {
        if (isPromise5(context)) {
          context = await context;
        }
        if (Array.isArray(context)) {
          for (let j = context.length;i < j; i++) {
            if (i in context) {
              await execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (global.Symbol && context[global.Symbol.iterator]) {
          const newContext = [], iterator = context[global.Symbol.iterator]();
          for (let it = iterator.next();!it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (let j = context.length;i < j; i++) {
            await execIteration(i, i, i === context.length - 1);
          }
        } else if (context instanceof Readable) {
          const newContext = [];
          await new Promise((resolve, reject2) => {
            context.on("data", (item) => {
              newContext.push(item);
            }).on("end", async () => {
              context = newContext;
              for (let j = context.length;i < j; i++) {
                await execIteration(i, i, i === context.length - 1);
              }
              resolve();
            }).once("error", (e) => reject2(e));
          });
        } else {
          let priorKey;
          for (const key of Object.keys(context)) {
            if (priorKey !== undefined) {
              await execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
          if (priorKey !== undefined) {
            await execIteration(priorKey, i - 1, true);
          }
        }
      }
      if (i === 0) {
        ret = inverse(this);
      }
      return ret.join("");
    });
  };
});

// ../../node_modules/handlebars-async-helpers/helpers/if.js
var require_if2 = __commonJS((exports, module) => {
  var { isPromise: isPromise5, isEmpty } = require_utils6();
  module.exports = (handlebars) => {
    handlebars.registerHelper("if", async function(conditional, options) {
      if (arguments.length !== 2) {
        throw new Error("#if requires exactly one argument");
      }
      if (typeof conditional === "function") {
        conditional = conditional.call(this);
      } else if (isPromise5(conditional)) {
        conditional = await conditional;
      }
      if (!options.hash.includeZero && !conditional || isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });
    handlebars.registerHelper("unless", function(conditional, options) {
      if (arguments.length !== 2) {
        throw new Error("#unless requires exactly one argument");
      }
      return handlebars.helpers["if"].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };
});

// ../../node_modules/handlebars-async-helpers/helpers/with.js
var require_with2 = __commonJS((exports, module) => {
  var { isPromise: isPromise5, isEmpty, createFrame, appendContextPath, blockParams } = require_utils6();
  module.exports = (handlebars) => {
    handlebars.registerHelper("with", async function(context, options) {
      if (arguments.length !== 2) {
        throw new Error("#with requires exactly one argument");
      }
      if (typeof context === "function") {
        context = context.call(this);
      } else if (isPromise5(context)) {
        context = await context;
      }
      const { fn } = options;
      if (!isEmpty(context)) {
        let { data } = options;
        if (options.data && options.ids) {
          data = createFrame(options.data);
          data.contextPath = appendContextPath(options.data.contextPath, options.ids[0]);
        }
        return fn(context, {
          data,
          blockParams: blockParams([context], [data && data.contextPath])
        });
      }
      return options.inverse(this);
    });
  };
});

// ../../node_modules/handlebars-async-helpers/helpers/index.js
var require_helpers3 = __commonJS((exports, module) => {
  module.exports = {
    registerCoreHelpers: (handlebars) => {
      require_each2()(handlebars);
      require_if2()(handlebars);
      require_with2()(handlebars);
    }
  };
});

// ../../node_modules/handlebars-async-helpers/index.js
var require_handlebars_async_helpers = __commonJS((exports, module) => {
  var asyncHelpers = function(hbs) {
    const handlebars = hbs.create(), asyncCompiler = class extends hbs.JavaScriptCompiler {
      constructor() {
        super();
        this.compiler = asyncCompiler;
      }
      mergeSource(varDeclarations) {
        const sources = super.mergeSource(varDeclarations);
        sources.prepend("return (async () => {");
        sources.add(" })()");
        return sources;
      }
      appendToBuffer(source2, location3, explicit) {
        if (!Array.isArray(source2)) {
          source2 = [source2];
        }
        source2 = this.source.wrap(source2, location3);
        if (this.environment.isSimple) {
          return ["return await ", source2, ";"];
        }
        if (explicit) {
          return ["buffer += await ", source2, ";"];
        }
        source2.appendToBuffer = true;
        source2.prepend("await ");
        return source2;
      }
    };
    handlebars.JavaScriptCompiler = asyncCompiler;
    const _compile = handlebars.compile, _template = handlebars.VM.template, _escapeExpression = handlebars.escapeExpression, escapeExpression = function(value) {
      if (isPromise5(value)) {
        return value.then((v) => _escapeExpression(v));
      }
      return _escapeExpression(value);
    };
    function lookupProperty(containerLookupProperty) {
      return function(parent, propertyName) {
        if (isPromise5(parent)) {
          return parent.then((p) => containerLookupProperty(p, propertyName));
        }
        return containerLookupProperty(parent, propertyName);
      };
    }
    handlebars.template = function(spec) {
      spec.main_d = (prog, props, container, depth, data, blockParams, depths) => async (context) => {
        container.escapeExpression = escapeExpression;
        container.lookupProperty = lookupProperty(container.lookupProperty);
        const v = spec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
        return v;
      };
      return _template(spec, handlebars);
    };
    handlebars.compile = function(template, options) {
      const compiled = _compile.apply(handlebars, [template, { ...options }]);
      return function(context, execOptions) {
        context = context || {};
        return compiled.call(handlebars, context, execOptions);
      };
    };
    handlebars.ASYNC_VERSION = app.version;
    registerCoreHelpers(handlebars);
    return handlebars;
  };
  var app = require_package();
  var { registerCoreHelpers } = require_helpers3();
  var isPromise5 = (obj) => !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  module.exports = asyncHelpers;
});

// ../../node_modules/he/he.js
var require_he = __commonJS((exports, module) => {
  /*! https://mths.be/he v1.2.0 by @mathias | MIT license */
  (function(root6) {
    var freeExports = typeof exports == "object" && exports;
    var freeModule = typeof module == "object" && module && exports == freeExports && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root6 = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "\t": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", _: "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "\'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", undefined: null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", $: "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\uD835\uDCB6": "ascr", "\uD835\uDD52": "aopf", "\uD835\uDD1E": "afr", "\uD835\uDD38": "Aopf", "\uD835\uDD04": "Afr", "\uD835\uDC9C": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\uD835\uDCB7": "bscr", "\uD835\uDD53": "bopf", "\uD835\uDD1F": "bfr", "\uD835\uDD39": "Bopf", "\u212C": "Bscr", "\uD835\uDD05": "Bfr", "\uD835\uDD20": "cfr", "\uD835\uDCB8": "cscr", "\uD835\uDD54": "copf", "\u212D": "Cfr", "\uD835\uDC9E": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\uD835\uDD21": "dfr", "\u2146": "dd", "\uD835\uDD55": "dopf", "\uD835\uDCB9": "dscr", "\uD835\uDC9F": "Dscr", "\uD835\uDD07": "Dfr", "\u2145": "DD", "\uD835\uDD3B": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\uD835\uDD22": "efr", "\uD835\uDD56": "eopf", "\u2130": "Escr", "\uD835\uDD08": "Efr", "\uD835\uDD3C": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\uD835\uDD23": "ffr", "\uD835\uDD57": "fopf", "\uD835\uDCBB": "fscr", "\uD835\uDD09": "Ffr", "\uD835\uDD3D": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", fj: "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\uD835\uDD58": "gopf", "\uD835\uDD24": "gfr", "\uD835\uDCA2": "Gscr", "\uD835\uDD3E": "Gopf", "\uD835\uDD0A": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\uD835\uDD25": "hfr", "\u210E": "planckh", "\uD835\uDCBD": "hscr", "\uD835\uDD59": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\uD835\uDD5A": "iopf", "\uD835\uDD26": "ifr", "\uD835\uDCBE": "iscr", "\u2148": "ii", "\uD835\uDD40": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\uD835\uDCBF": "jscr", "\uD835\uDD5B": "jopf", "\uD835\uDD27": "jfr", "\uD835\uDCA5": "Jscr", "\uD835\uDD0D": "Jfr", "\uD835\uDD41": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\uD835\uDD5C": "kopf", "\uD835\uDCC0": "kscr", "\uD835\uDD28": "kfr", "\uD835\uDCA6": "Kscr", "\uD835\uDD42": "Kopf", "\uD835\uDD0E": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\uD835\uDD29": "lfr", "\uD835\uDCC1": "lscr", "\u2113": "ell", "\uD835\uDD5D": "lopf", "\u2112": "Lscr", "\uD835\uDD0F": "Lfr", "\uD835\uDD43": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\uD835\uDD2A": "mfr", "\uD835\uDD5E": "mopf", "\uD835\uDCC2": "mscr", "\uD835\uDD10": "Mfr", "\uD835\uDD44": "Mopf", "\u2133": "Mscr", "\uD835\uDD2B": "nfr", "\uD835\uDD5F": "nopf", "\uD835\uDCC3": "nscr", "\u2115": "Nopf", "\uD835\uDCA9": "Nscr", "\uD835\uDD11": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\uD835\uDD60": "oopf", "\uD835\uDD2C": "ofr", "\u2134": "oscr", "\uD835\uDCAA": "Oscr", "\uD835\uDD12": "Ofr", "\uD835\uDD46": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\uD835\uDD2D": "pfr", "\uD835\uDCC5": "pscr", "\uD835\uDD61": "popf", "\u2119": "Popf", "\uD835\uDD13": "Pfr", "\uD835\uDCAB": "Pscr", "\uD835\uDD62": "qopf", "\uD835\uDD2E": "qfr", "\uD835\uDCC6": "qscr", "\uD835\uDCAC": "Qscr", "\uD835\uDD14": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\uD835\uDD2F": "rfr", "\uD835\uDD63": "ropf", "\uD835\uDCC7": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\uD835\uDD64": "sopf", "\uD835\uDCC8": "sscr", "\uD835\uDD30": "sfr", "\uD835\uDD4A": "Sopf", "\uD835\uDD16": "Sfr", "\uD835\uDCAE": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\uD835\uDD31": "tfr", "\uD835\uDCC9": "tscr", "\uD835\uDD65": "topf", "\uD835\uDCAF": "Tscr", "\uD835\uDD17": "Tfr", "\uD835\uDD4B": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\uD835\uDCCA": "uscr", "\uD835\uDD66": "uopf", "\uD835\uDD32": "ufr", "\uD835\uDD4C": "Uopf", "\uD835\uDD18": "Ufr", "\uD835\uDCB0": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\uD835\uDD33": "vfr", "\uD835\uDD67": "vopf", "\uD835\uDCCB": "vscr", "\uD835\uDD19": "Vfr", "\uD835\uDD4D": "Vopf", "\uD835\uDCB1": "Vscr", "\uD835\uDD68": "wopf", "\uD835\uDCCC": "wscr", "\uD835\uDD34": "wfr", "\uD835\uDCB2": "Wscr", "\uD835\uDD4E": "Wopf", "\uD835\uDD1A": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\uD835\uDD35": "xfr", "\uD835\uDCCD": "xscr", "\uD835\uDD69": "xopf", "\uD835\uDD4F": "Xopf", "\uD835\uDD1B": "Xfr", "\uD835\uDCB3": "Xscr", "\uD835\uDD36": "yfr", "\uD835\uDCCE": "yscr", "\uD835\uDD6A": "yopf", "\uD835\uDCB4": "Yscr", "\uD835\uDD1C": "Yfr", "\uD835\uDD50": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\uD835\uDCCF": "zscr", "\uD835\uDD37": "zfr", "\uD835\uDD6B": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\uD835\uDCB5": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
      '"': "&quot;",
      "&": "&amp;",
      "\'": "&#x27;",
      "<": "&lt;",
      ">": "&gt;",
      "`": "&#x60;"
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
    var decodeMap = { aacute: "\xE1", Aacute: "\xC1", abreve: "\u0103", Abreve: "\u0102", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", acy: "\u0430", Acy: "\u0410", aelig: "\xE6", AElig: "\xC6", af: "\u2061", afr: "\uD835\uDD1E", Afr: "\uD835\uDD04", agrave: "\xE0", Agrave: "\xC0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", Alpha: "\u0391", amacr: "\u0101", Amacr: "\u0100", amalg: "\u2A3F", amp: "&", AMP: "&", and: "\u2227", And: "\u2A53", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", Aogon: "\u0104", aopf: "\uD835\uDD52", Aopf: "\uD835\uDD38", ap: "\u2248", apacir: "\u2A6F", ape: "\u224A", apE: "\u2A70", apid: "\u224B", apos: "\'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", Aring: "\xC5", ascr: "\uD835\uDCB6", Ascr: "\uD835\uDC9C", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\xC4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", Bcy: "\u0411", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", beta: "\u03B2", Beta: "\u0392", beth: "\u2136", between: "\u226C", bfr: "\uD835\uDD1F", Bfr: "\uD835\uDD05", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bNot: "\u2AED", bopf: "\uD835\uDD53", Bopf: "\uD835\uDD39", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxhD: "\u2565", boxHd: "\u2564", boxHD: "\u2566", boxhu: "\u2534", boxhU: "\u2568", boxHu: "\u2567", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\uD835\uDCB7", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpe: "\u224F", bumpE: "\u2AAE", bumpeq: "\u224F", Bumpeq: "\u224E", cacute: "\u0107", Cacute: "\u0106", cap: "\u2229", Cap: "\u22D2", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", ccaron: "\u010D", Ccaron: "\u010C", ccedil: "\xE7", Ccedil: "\xC7", ccirc: "\u0109", Ccirc: "\u0108", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", Cdot: "\u010A", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\uD835\uDD20", Cfr: "\u212D", chcy: "\u0447", CHcy: "\u0427", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", Chi: "\u03A7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cire: "\u2257", cirE: "\u29C3", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", colone: "\u2254", Colone: "\u2A74", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\uD835\uDD54", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", cscr: "\uD835\uDCB8", Cscr: "\uD835\uDC9E", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", Cup: "\u22D3", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", dArr: "\u21D3", Darr: "\u21A1", dash: "\u2010", dashv: "\u22A3", Dashv: "\u2AE4", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", Dcaron: "\u010E", dcy: "\u0434", Dcy: "\u0414", dd: "\u2146", DD: "\u2145", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", delta: "\u03B4", Delta: "\u0394", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", Dfr: "\uD835\uDD07", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", DJcy: "\u0402", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", Dopf: "\uD835\uDD3B", dot: "\u02D9", Dot: "\xA8", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", downarrow: "\u2193", Downarrow: "\u21D3", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", Dscr: "\uD835\uDC9F", dscy: "\u0455", DScy: "\u0405", dsol: "\u29F6", dstrok: "\u0111", Dstrok: "\u0110", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", DZcy: "\u040F", dzigrarr: "\u27FF", eacute: "\xE9", Eacute: "\xC9", easter: "\u2A6E", ecaron: "\u011B", Ecaron: "\u011A", ecir: "\u2256", ecirc: "\xEA", Ecirc: "\xCA", ecolon: "\u2255", ecy: "\u044D", Ecy: "\u042D", eDDot: "\u2A77", edot: "\u0117", eDot: "\u2251", Edot: "\u0116", ee: "\u2147", efDot: "\u2252", efr: "\uD835\uDD22", Efr: "\uD835\uDD08", eg: "\u2A9A", egrave: "\xE8", Egrave: "\xC8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", Emacr: "\u0112", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", eng: "\u014B", ENG: "\u014A", ensp: "\u2002", eogon: "\u0119", Eogon: "\u0118", eopf: "\uD835\uDD56", Eopf: "\uD835\uDD3C", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", Epsilon: "\u0395", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", esim: "\u2242", Esim: "\u2A73", eta: "\u03B7", Eta: "\u0397", eth: "\xF0", ETH: "\xD0", euml: "\xEB", Euml: "\xCB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", Fcy: "\u0424", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", Ffr: "\uD835\uDD09", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", Fopf: "\uD835\uDD3D", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\uD835\uDCBB", Fscr: "\u2131", gacute: "\u01F5", gamma: "\u03B3", Gamma: "\u0393", gammad: "\u03DD", Gammad: "\u03DC", gap: "\u2A86", gbreve: "\u011F", Gbreve: "\u011E", Gcedil: "\u0122", gcirc: "\u011D", Gcirc: "\u011C", gcy: "\u0433", Gcy: "\u0413", gdot: "\u0121", Gdot: "\u0120", ge: "\u2265", gE: "\u2267", gel: "\u22DB", gEl: "\u2A8C", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", Gfr: "\uD835\uDD0A", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", GJcy: "\u0403", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\uD835\uDD58", Gopf: "\uD835\uDD3E", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", gscr: "\u210A", Gscr: "\uD835\uDCA2", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", Gt: "\u226B", GT: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", HARDcy: "\u042A", harr: "\u2194", hArr: "\u21D4", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", hcirc: "\u0125", Hcirc: "\u0124", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\uD835\uDD59", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\uD835\uDCBD", Hscr: "\u210B", hslash: "\u210F", hstrok: "\u0127", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", Iacute: "\xCD", ic: "\u2063", icirc: "\xEE", Icirc: "\xCE", icy: "\u0438", Icy: "\u0418", Idot: "\u0130", iecy: "\u0435", IEcy: "\u0415", iexcl: "\xA1", iff: "\u21D4", ifr: "\uD835\uDD26", Ifr: "\u2111", igrave: "\xEC", Igrave: "\xCC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", IJlig: "\u0132", Im: "\u2111", imacr: "\u012B", Imacr: "\u012A", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", Int: "\u222C", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", iocy: "\u0451", IOcy: "\u0401", iogon: "\u012F", Iogon: "\u012E", iopf: "\uD835\uDD5A", Iopf: "\uD835\uDD40", iota: "\u03B9", Iota: "\u0399", iprod: "\u2A3C", iquest: "\xBF", iscr: "\uD835\uDCBE", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", Itilde: "\u0128", iukcy: "\u0456", Iukcy: "\u0406", iuml: "\xEF", Iuml: "\xCF", jcirc: "\u0135", Jcirc: "\u0134", jcy: "\u0439", Jcy: "\u0419", jfr: "\uD835\uDD27", Jfr: "\uD835\uDD0D", jmath: "\u0237", jopf: "\uD835\uDD5B", Jopf: "\uD835\uDD41", jscr: "\uD835\uDCBF", Jscr: "\uD835\uDCA5", jsercy: "\u0458", Jsercy: "\u0408", jukcy: "\u0454", Jukcy: "\u0404", kappa: "\u03BA", Kappa: "\u039A", kappav: "\u03F0", kcedil: "\u0137", Kcedil: "\u0136", kcy: "\u043A", Kcy: "\u041A", kfr: "\uD835\uDD28", Kfr: "\uD835\uDD0E", kgreen: "\u0138", khcy: "\u0445", KHcy: "\u0425", kjcy: "\u045C", KJcy: "\u040C", kopf: "\uD835\uDD5C", Kopf: "\uD835\uDD42", kscr: "\uD835\uDCC0", Kscr: "\uD835\uDCA6", lAarr: "\u21DA", lacute: "\u013A", Lacute: "\u0139", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", Lambda: "\u039B", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larr: "\u2190", lArr: "\u21D0", Larr: "\u219E", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", lAtail: "\u291B", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", Lcaron: "\u013D", lcedil: "\u013C", Lcedil: "\u013B", lceil: "\u2308", lcub: "{", lcy: "\u043B", Lcy: "\u041B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", leftarrow: "\u2190", Leftarrow: "\u21D0", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", Leftrightarrow: "\u21D4", LeftRightArrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", leg: "\u22DA", lEg: "\u2A8B", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\uD835\uDD29", Lfr: "\uD835\uDD0F", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", LJcy: "\u0409", ll: "\u226A", Ll: "\u22D8", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", Lmidot: "\u013F", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", Longleftarrow: "\u27F8", LongLeftArrow: "\u27F5", longleftrightarrow: "\u27F7", Longleftrightarrow: "\u27FA", LongLeftRightArrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", Longrightarrow: "\u27F9", LongRightArrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", Lopf: "\uD835\uDD43", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", Lstrok: "\u0141", lt: "<", Lt: "\u226A", LT: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", Map: "\u2905", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", Mcy: "\u041C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", mfr: "\uD835\uDD2A", Mfr: "\uD835\uDD10", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\uD835\uDD5E", Mopf: "\uD835\uDD44", mp: "\u2213", mscr: "\uD835\uDCC2", Mscr: "\u2133", mstpos: "\u223E", mu: "\u03BC", Mu: "\u039C", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", nacute: "\u0144", Nacute: "\u0143", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", Ncaron: "\u0147", ncedil: "\u0146", Ncedil: "\u0145", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", Ncy: "\u041D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", nfr: "\uD835\uDD2B", Nfr: "\uD835\uDD11", nge: "\u2271", ngE: "\u2267\u0338", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", ngt: "\u226F", nGt: "\u226B\u20D2", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", NJcy: "\u040A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nle: "\u2270", nlE: "\u2266\u0338", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nlt: "\u226E", nLt: "\u226A\u20D2", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\uD835\uDD5F", Nopf: "\u2115", not: "\xAC", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\uD835\uDCC3", Nscr: "\uD835\uDCA9", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsube: "\u2288", nsubE: "\u2AC5\u0338", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupe: "\u2289", nsupE: "\u2AC6\u0338", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntilde: "\xF1", Ntilde: "\xD1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", Nu: "\u039D", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", oacute: "\xF3", Oacute: "\xD3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", Ocirc: "\xD4", ocy: "\u043E", Ocy: "\u041E", odash: "\u229D", odblac: "\u0151", Odblac: "\u0150", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", OElig: "\u0152", ofcir: "\u29BF", ofr: "\uD835\uDD2C", Ofr: "\uD835\uDD12", ogon: "\u02DB", ograve: "\xF2", Ograve: "\xD2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", Omacr: "\u014C", omega: "\u03C9", Omega: "\u03A9", omicron: "\u03BF", Omicron: "\u039F", omid: "\u29B6", ominus: "\u2296", oopf: "\uD835\uDD60", Oopf: "\uD835\uDD46", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", or: "\u2228", Or: "\u2A54", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", oscr: "\u2134", Oscr: "\uD835\uDCAA", oslash: "\xF8", Oslash: "\xD8", osol: "\u2298", otilde: "\xF5", Otilde: "\xD5", otimes: "\u2297", Otimes: "\u2A37", otimesas: "\u2A36", ouml: "\xF6", Ouml: "\xD6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", pcy: "\u043F", Pcy: "\u041F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\uD835\uDD2D", Pfr: "\uD835\uDD13", phi: "\u03C6", Phi: "\u03A6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", Pi: "\u03A0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\uD835\uDD61", Popf: "\u2119", pound: "\xA3", pr: "\u227A", Pr: "\u2ABB", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prE: "\u2AB3", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\uD835\uDCC5", Pscr: "\uD835\uDCAB", psi: "\u03C8", Psi: "\u03A8", puncsp: "\u2008", qfr: "\uD835\uDD2E", Qfr: "\uD835\uDD14", qint: "\u2A0C", qopf: "\uD835\uDD62", Qopf: "\u211A", qprime: "\u2057", qscr: "\uD835\uDCC6", Qscr: "\uD835\uDCAC", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", racute: "\u0155", Racute: "\u0154", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rArr: "\u21D2", Rarr: "\u21A0", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", Rarrtl: "\u2916", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", Rcaron: "\u0158", rcedil: "\u0157", Rcedil: "\u0156", rceil: "\u2309", rcub: "}", rcy: "\u0440", Rcy: "\u0420", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\uD835\uDD2F", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", Rho: "\u03A1", rhov: "\u03F1", RightAngleBracket: "\u27E9", rightarrow: "\u2192", Rightarrow: "\u21D2", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\uD835\uDD63", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\uD835\uDCC7", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", Sacute: "\u015A", sbquo: "\u201A", sc: "\u227B", Sc: "\u2ABC", scap: "\u2AB8", scaron: "\u0161", Scaron: "\u0160", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", scedil: "\u015F", Scedil: "\u015E", scirc: "\u015D", Scirc: "\u015C", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", Scy: "\u0421", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\uD835\uDD30", Sfr: "\uD835\uDD16", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", SHCHcy: "\u0429", shcy: "\u0448", SHcy: "\u0428", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", sigma: "\u03C3", Sigma: "\u03A3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", SOFTcy: "\u042C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", Sopf: "\uD835\uDD4A", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\uD835\uDCC8", Sscr: "\uD835\uDCAE", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", Star: "\u22C6", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", sube: "\u2286", subE: "\u2AC5", subedot: "\u2AC3", submult: "\u2AC1", subne: "\u228A", subnE: "\u2ACB", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup: "\u2283", Sup: "\u22D1", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supE: "\u2AC6", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supne: "\u228B", supnE: "\u2ACC", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "\t", target: "\u2316", tau: "\u03C4", Tau: "\u03A4", tbrk: "\u23B4", tcaron: "\u0165", Tcaron: "\u0164", tcedil: "\u0163", Tcedil: "\u0162", tcy: "\u0442", Tcy: "\u0422", tdot: "\u20DB", telrec: "\u2315", tfr: "\uD835\uDD31", Tfr: "\uD835\uDD17", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", theta: "\u03B8", Theta: "\u0398", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", thorn: "\xFE", THORN: "\xDE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", Topf: "\uD835\uDD4B", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", Tscr: "\uD835\uDCAF", tscy: "\u0446", TScy: "\u0426", tshcy: "\u045B", TSHcy: "\u040B", tstrok: "\u0167", Tstrok: "\u0166", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uacute: "\xFA", Uacute: "\xDA", uarr: "\u2191", uArr: "\u21D1", Uarr: "\u219F", Uarrocir: "\u2949", ubrcy: "\u045E", Ubrcy: "\u040E", ubreve: "\u016D", Ubreve: "\u016C", ucirc: "\xFB", Ucirc: "\xDB", ucy: "\u0443", Ucy: "\u0423", udarr: "\u21C5", udblac: "\u0171", Udblac: "\u0170", udhar: "\u296E", ufisht: "\u297E", ufr: "\uD835\uDD32", Ufr: "\uD835\uDD18", ugrave: "\xF9", Ugrave: "\xD9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", Umacr: "\u016A", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", uogon: "\u0173", Uogon: "\u0172", uopf: "\uD835\uDD66", Uopf: "\uD835\uDD4C", uparrow: "\u2191", Uparrow: "\u21D1", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", Updownarrow: "\u21D5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", upsilon: "\u03C5", Upsilon: "\u03A5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", Uring: "\u016E", urtri: "\u25F9", uscr: "\uD835\uDCCA", Uscr: "\uD835\uDCB0", utdot: "\u22F0", utilde: "\u0169", Utilde: "\u0168", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uuml: "\xFC", Uuml: "\xDC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", vcy: "\u0432", Vcy: "\u0412", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", vee: "\u2228", Vee: "\u22C1", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", vfr: "\uD835\uDD33", Vfr: "\uD835\uDD19", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\uD835\uDD67", Vopf: "\uD835\uDD4D", vprop: "\u221D", vrtri: "\u22B3", vscr: "\uD835\uDCCB", Vscr: "\uD835\uDCB1", vsubne: "\u228A\uFE00", vsubnE: "\u2ACB\uFE00", vsupne: "\u228B\uFE00", vsupnE: "\u2ACC\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", wcirc: "\u0175", Wcirc: "\u0174", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", wfr: "\uD835\uDD34", Wfr: "\uD835\uDD1A", wopf: "\uD835\uDD68", Wopf: "\uD835\uDD4E", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\uD835\uDCCC", Wscr: "\uD835\uDCB2", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\uD835\uDD35", Xfr: "\uD835\uDD1B", xharr: "\u27F7", xhArr: "\u27FA", xi: "\u03BE", Xi: "\u039E", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\uD835\uDD69", Xopf: "\uD835\uDD4F", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", xscr: "\uD835\uDCCD", Xscr: "\uD835\uDCB3", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacute: "\xFD", Yacute: "\xDD", yacy: "\u044F", YAcy: "\u042F", ycirc: "\u0177", Ycirc: "\u0176", ycy: "\u044B", Ycy: "\u042B", yen: "\xA5", yfr: "\uD835\uDD36", Yfr: "\uD835\uDD1C", yicy: "\u0457", YIcy: "\u0407", yopf: "\uD835\uDD6A", Yopf: "\uD835\uDD50", yscr: "\uD835\uDCCE", Yscr: "\uD835\uDCB4", yucy: "\u044E", YUcy: "\u042E", yuml: "\xFF", Yuml: "\u0178", zacute: "\u017A", Zacute: "\u0179", zcaron: "\u017E", Zcaron: "\u017D", zcy: "\u0437", Zcy: "\u0417", zdot: "\u017C", Zdot: "\u017B", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", zeta: "\u03B6", Zeta: "\u0396", zfr: "\uD835\uDD37", Zfr: "\u2128", zhcy: "\u0436", ZHcy: "\u0416", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", Zopf: "\u2124", zscr: "\uD835\uDCCF", Zscr: "\uD835\uDCB5", zwj: "\u200D", zwnj: "\u200C" };
    var decodeMapLegacy = { aacute: "\xE1", Aacute: "\xC1", acirc: "\xE2", Acirc: "\xC2", acute: "\xB4", aelig: "\xE6", AElig: "\xC6", agrave: "\xE0", Agrave: "\xC0", amp: "&", AMP: "&", aring: "\xE5", Aring: "\xC5", atilde: "\xE3", Atilde: "\xC3", auml: "\xE4", Auml: "\xC4", brvbar: "\xA6", ccedil: "\xE7", Ccedil: "\xC7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", eacute: "\xE9", Eacute: "\xC9", ecirc: "\xEA", Ecirc: "\xCA", egrave: "\xE8", Egrave: "\xC8", eth: "\xF0", ETH: "\xD0", euml: "\xEB", Euml: "\xCB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", iacute: "\xED", Iacute: "\xCD", icirc: "\xEE", Icirc: "\xCE", iexcl: "\xA1", igrave: "\xEC", Igrave: "\xCC", iquest: "\xBF", iuml: "\xEF", Iuml: "\xCF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", ntilde: "\xF1", Ntilde: "\xD1", oacute: "\xF3", Oacute: "\xD3", ocirc: "\xF4", Ocirc: "\xD4", ograve: "\xF2", Ograve: "\xD2", ordf: "\xAA", ordm: "\xBA", oslash: "\xF8", Oslash: "\xD8", otilde: "\xF5", Otilde: "\xD5", ouml: "\xF6", Ouml: "\xD6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", thorn: "\xFE", THORN: "\xDE", times: "\xD7", uacute: "\xFA", Uacute: "\xDA", ucirc: "\xFB", Ucirc: "\xDB", ugrave: "\xF9", Ugrave: "\xD9", uml: "\xA8", uuml: "\xFC", Uuml: "\xDC", yacute: "\xFD", Yacute: "\xDD", yen: "\xA5", yuml: "\xFF" };
    var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
    var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
    var stringFromCharCode = String.fromCharCode;
    var object5 = {};
    var hasOwnProperty3 = object5.hasOwnProperty;
    var has = function(object6, propertyName) {
      return hasOwnProperty3.call(object6, propertyName);
    };
    var contains = function(array, value) {
      var index = -1;
      var length = array.length;
      while (++index < length) {
        if (array[index] == value) {
          return true;
        }
      }
      return false;
    };
    var merge2 = function(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      var key2;
      for (key2 in defaults) {
        result[key2] = has(options, key2) ? options[key2] : defaults[key2];
      }
      return result;
    };
    var codePointToSymbol = function(codePoint, strict) {
      var output2 = "";
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        if (strict) {
          parseError("character reference outside the permissible Unicode range");
        }
        return "\uFFFD";
      }
      if (has(decodeMapNumeric, codePoint)) {
        if (strict) {
          parseError("disallowed character reference");
        }
        return decodeMapNumeric[codePoint];
      }
      if (strict && contains(invalidReferenceCodePoints, codePoint)) {
        parseError("disallowed character reference");
      }
      if (codePoint > 65535) {
        codePoint -= 65536;
        output2 += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output2 += stringFromCharCode(codePoint);
      return output2;
    };
    var hexEscape = function(codePoint) {
      return "&#x" + codePoint.toString(16).toUpperCase() + ";";
    };
    var decEscape = function(codePoint) {
      return "&#" + codePoint + ";";
    };
    var parseError = function(message) {
      throw Error("Parse error: " + message);
    };
    var encode = function(string, options) {
      options = merge2(options, encode.options);
      var strict = options.strict;
      if (strict && regexInvalidRawCodePoint.test(string)) {
        parseError("forbidden code point");
      }
      var encodeEverything = options.encodeEverything;
      var useNamedReferences = options.useNamedReferences;
      var allowUnsafeSymbols = options.allowUnsafeSymbols;
      var escapeCodePoint = options.decimal ? decEscape : hexEscape;
      var escapeBmpSymbol = function(symbol) {
        return escapeCodePoint(symbol.charCodeAt(0));
      };
      if (encodeEverything) {
        string = string.replace(regexAsciiWhitelist, function(symbol) {
          if (useNamedReferences && has(encodeMap, symbol)) {
            return "&" + encodeMap[symbol] + ";";
          }
          return escapeBmpSymbol(symbol);
        });
        if (useNamedReferences) {
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
        }
        if (useNamedReferences) {
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        }
      } else if (useNamedReferences) {
        if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        }
        string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
        string = string.replace(regexEncodeNonAscii, function(string2) {
          return "&" + encodeMap[string2] + ";";
        });
      } else if (!allowUnsafeSymbols) {
        string = string.replace(regexEscape, escapeBmpSymbol);
      }
      return string.replace(regexAstralSymbols, function($0) {
        var high = $0.charCodeAt(0);
        var low = $0.charCodeAt(1);
        var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
        return escapeCodePoint(codePoint);
      }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
      allowUnsafeSymbols: false,
      encodeEverything: false,
      strict: false,
      useNamedReferences: false,
      decimal: false
    };
    var decode = function(html, options) {
      options = merge2(options, decode.options);
      var strict = options.strict;
      if (strict && regexInvalidEntity.test(html)) {
        parseError("malformed character reference");
      }
      return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $62, $7, $8) {
        var codePoint;
        var semicolon;
        var decDigits;
        var hexDigits;
        var reference;
        var next;
        if ($1) {
          reference = $1;
          return decodeMap[reference];
        }
        if ($2) {
          reference = $2;
          next = $3;
          if (next && options.isAttributeValue) {
            if (strict && next == "=") {
              parseError("`&` did not start a character reference");
            }
            return $0;
          } else {
            if (strict) {
              parseError("named character reference was not terminated by a semicolon");
            }
            return decodeMapLegacy[reference] + (next || "");
          }
        }
        if ($4) {
          decDigits = $4;
          semicolon = $5;
          if (strict && !semicolon) {
            parseError("character reference was not terminated by a semicolon");
          }
          codePoint = parseInt(decDigits, 10);
          return codePointToSymbol(codePoint, strict);
        }
        if ($62) {
          hexDigits = $62;
          semicolon = $7;
          if (strict && !semicolon) {
            parseError("character reference was not terminated by a semicolon");
          }
          codePoint = parseInt(hexDigits, 16);
          return codePointToSymbol(codePoint, strict);
        }
        if (strict) {
          parseError("named character reference was not terminated by a semicolon");
        }
        return $0;
      });
    };
    decode.options = {
      isAttributeValue: false,
      strict: false
    };
    var escape2 = function(string) {
      return string.replace(regexEscape, function($0) {
        return escapeMap[$0];
      });
    };
    var he = {
      version: "1.2.0",
      encode,
      decode,
      escape: escape2,
      unescape: decode
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      define(function() {
        return he;
      });
    } else if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = he;
      } else {
        for (var key in he) {
          has(he, key) && (freeExports[key] = he[key]);
        }
      }
    } else {
      root6.he = he;
    }
  })(exports);
});

// ../../node_modules/node-html-parser/dist/nodes/node.js
var require_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var he_1 = require_he();
  var Node = function() {
    function Node2(parentNode, range) {
      if (parentNode === undefined) {
        parentNode = null;
      }
      this.parentNode = parentNode;
      this.childNodes = [];
      Object.defineProperty(this, "range", {
        enumerable: false,
        writable: true,
        configurable: true,
        value: range !== null && range !== undefined ? range : [-1, -1]
      });
    }
    Node2.prototype.remove = function() {
      var _this = this;
      if (this.parentNode) {
        var children = this.parentNode.childNodes;
        this.parentNode.childNodes = children.filter(function(child) {
          return _this !== child;
        });
        this.parentNode = null;
      }
      return this;
    };
    Object.defineProperty(Node2.prototype, "innerText", {
      get: function() {
        return this.rawText;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "textContent", {
      get: function() {
        return (0, he_1.decode)(this.rawText);
      },
      set: function(val) {
        this.rawText = (0, he_1.encode)(val);
      },
      enumerable: false,
      configurable: true
    });
    return Node2;
  }();
  exports.default = Node;
});

// ../../node_modules/node-html-parser/dist/nodes/type.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var NodeType;
  (function(NodeType2) {
    NodeType2[NodeType2["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
    NodeType2[NodeType2["TEXT_NODE"] = 3] = "TEXT_NODE";
    NodeType2[NodeType2["COMMENT_NODE"] = 8] = "COMMENT_NODE";
  })(NodeType || (NodeType = {}));
  exports.default = NodeType;
});

// ../../node_modules/node-html-parser/dist/nodes/comment.js
var require_comment = __commonJS((exports) => {
  var __extends2 = exports && exports.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_1 = __importDefault(require_node());
  var type_1 = __importDefault(require_type());
  var CommentNode = function(_super) {
    __extends2(CommentNode2, _super);
    function CommentNode2(rawText, parentNode, range, rawTagName) {
      if (parentNode === undefined) {
        parentNode = null;
      }
      if (rawTagName === undefined) {
        rawTagName = "!--";
      }
      var _this = _super.call(this, parentNode, range) || this;
      _this.rawText = rawText;
      _this.rawTagName = rawTagName;
      _this.nodeType = type_1.default.COMMENT_NODE;
      return _this;
    }
    CommentNode2.prototype.clone = function() {
      return new CommentNode2(this.rawText, null, undefined, this.rawTagName);
    };
    Object.defineProperty(CommentNode2.prototype, "text", {
      get: function() {
        return this.rawText;
      },
      enumerable: false,
      configurable: true
    });
    CommentNode2.prototype.toString = function() {
      return "<!--".concat(this.rawText, "-->");
    };
    return CommentNode2;
  }(node_1.default);
  exports.default = CommentNode;
});

// ../../node_modules/domelementtype/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var isTag = function(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = undefined;
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType = exports.ElementType || (exports.ElementType = {}));
  exports.isTag = isTag;
  exports.Root = ElementType.Root;
  exports.Text = ElementType.Text;
  exports.Directive = ElementType.Directive;
  exports.Comment = ElementType.Comment;
  exports.Script = ElementType.Script;
  exports.Style = ElementType.Style;
  exports.Tag = ElementType.Tag;
  exports.CDATA = ElementType.CDATA;
  exports.Doctype = ElementType.Doctype;
});

// ../../node_modules/domhandler/lib/node.js
var require_node2 = __commonJS((exports) => {
  var isTag = function(node3) {
    return (0, domelementtype_1.isTag)(node3);
  };
  var isCDATA = function(node3) {
    return node3.type === domelementtype_1.ElementType.CDATA;
  };
  var isText = function(node3) {
    return node3.type === domelementtype_1.ElementType.Text;
  };
  var isComment = function(node3) {
    return node3.type === domelementtype_1.ElementType.Comment;
  };
  var isDirective2 = function(node3) {
    return node3.type === domelementtype_1.ElementType.Directive;
  };
  var isDocument = function(node3) {
    return node3.type === domelementtype_1.ElementType.Root;
  };
  var hasChildren = function(node3) {
    return Object.prototype.hasOwnProperty.call(node3, "children");
  };
  var cloneNode = function(node3, recursive) {
    if (recursive === undefined) {
      recursive = false;
    }
    var result;
    if (isText(node3)) {
      result = new Text(node3.data);
    } else if (isComment(node3)) {
      result = new Comment(node3.data);
    } else if (isTag(node3)) {
      var children = recursive ? cloneChildren(node3.children) : [];
      var clone_1 = new Element(node3.name, __assign({}, node3.attribs), children);
      children.forEach(function(child) {
        return child.parent = clone_1;
      });
      if (node3.namespace != null) {
        clone_1.namespace = node3.namespace;
      }
      if (node3["x-attribsNamespace"]) {
        clone_1["x-attribsNamespace"] = __assign({}, node3["x-attribsNamespace"]);
      }
      if (node3["x-attribsPrefix"]) {
        clone_1["x-attribsPrefix"] = __assign({}, node3["x-attribsPrefix"]);
      }
      result = clone_1;
    } else if (isCDATA(node3)) {
      var children = recursive ? cloneChildren(node3.children) : [];
      var clone_2 = new CDATA(children);
      children.forEach(function(child) {
        return child.parent = clone_2;
      });
      result = clone_2;
    } else if (isDocument(node3)) {
      var children = recursive ? cloneChildren(node3.children) : [];
      var clone_3 = new Document(children);
      children.forEach(function(child) {
        return child.parent = clone_3;
      });
      if (node3["x-mode"]) {
        clone_3["x-mode"] = node3["x-mode"];
      }
      result = clone_3;
    } else if (isDirective2(node3)) {
      var instruction = new ProcessingInstruction(node3.name, node3.data);
      if (node3["x-name"] != null) {
        instruction["x-name"] = node3["x-name"];
        instruction["x-publicId"] = node3["x-publicId"];
        instruction["x-systemId"] = node3["x-systemId"];
      }
      result = instruction;
    } else {
      throw new Error("Not implemented yet: ".concat(node3.type));
    }
    result.startIndex = node3.startIndex;
    result.endIndex = node3.endIndex;
    if (node3.sourceCodeLocation != null) {
      result.sourceCodeLocation = node3.sourceCodeLocation;
    }
    return result;
  };
  var cloneChildren = function(childs) {
    var children = childs.map(function(child) {
      return cloneNode(child, true);
    });
    for (var i = 1;i < children.length; i++) {
      children[i].prev = children[i - 1];
      children[i - 1].next = children[i];
    }
    return children;
  };
  var __extends2 = exports && exports.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = undefined;
  var domelementtype_1 = require_lib6();
  var Node = function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === undefined) {
        recursive = false;
      }
      return cloneNode(this, recursive);
    };
    return Node2;
  }();
  exports.Node = Node;
  var DataNode = function(_super) {
    __extends2(DataNode2, _super);
    function DataNode2(data) {
      var _this = _super.call(this) || this;
      _this.data = data;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      get: function() {
        return this.data;
      },
      set: function(data) {
        this.data = data;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node);
  exports.DataNode = DataNode;
  var Text = function(_super) {
    __extends2(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode);
  exports.Text = Text;
  var Comment = function(_super) {
    __extends2(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode);
  exports.Comment = Comment;
  var ProcessingInstruction = function(_super) {
    __extends2(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name, data) {
      var _this = _super.call(this, data) || this;
      _this.name = name;
      _this.type = domelementtype_1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode);
  exports.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = function(_super) {
    __extends2(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node);
  exports.NodeWithChildren = NodeWithChildren;
  var CDATA = function(_super) {
    __extends2(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren);
  exports.CDATA = CDATA;
  var Document = function(_super) {
    __extends2(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren);
  exports.Document = Document;
  var Element = function(_super) {
    __extends2(Element2, _super);
    function Element2(name, attribs, children, type2) {
      if (children === undefined) {
        children = [];
      }
      if (type2 === undefined) {
        type2 = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name;
      _this.attribs = attribs;
      _this.type = type2;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      get: function() {
        return this.name;
      },
      set: function(name) {
        this.name = name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name) {
          var _a, _b;
          return {
            name,
            value: _this.attribs[name],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === undefined ? undefined : _a[name],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren);
  exports.Element = Element;
  exports.isTag = isTag;
  exports.isCDATA = isCDATA;
  exports.isText = isText;
  exports.isComment = isComment;
  exports.isDirective = isDirective2;
  exports.isDocument = isDocument;
  exports.hasChildren = hasChildren;
  exports.cloneNode = cloneNode;
});

// ../../node_modules/domhandler/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomHandler = undefined;
  var domelementtype_1 = require_lib6();
  var node_js_1 = require_node2();
  __exportStar(require_node2(), exports);
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = function() {
    function DomHandler2(callback, options, elementCB) {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
      if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      if (typeof callback === "object") {
        options = callback;
        callback = undefined;
      }
      this.callback = callback !== null && callback !== undefined ? callback : null;
      this.options = options !== null && options !== undefined ? options : defaultOpts;
      this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
    }
    DomHandler2.prototype.onparserinit = function(parser) {
      this.parser = parser;
    };
    DomHandler2.prototype.onreset = function() {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
    };
    DomHandler2.prototype.onend = function() {
      if (this.done)
        return;
      this.done = true;
      this.parser = null;
      this.handleCallback(null);
    };
    DomHandler2.prototype.onerror = function(error8) {
      this.handleCallback(error8);
    };
    DomHandler2.prototype.onclosetag = function() {
      this.lastNode = null;
      var elem = this.tagStack.pop();
      if (this.options.withEndIndices) {
        elem.endIndex = this.parser.endIndex;
      }
      if (this.elementCB)
        this.elementCB(elem);
    };
    DomHandler2.prototype.onopentag = function(name, attribs) {
      var type2 = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
      var element = new node_js_1.Element(name, attribs, undefined, type2);
      this.addNode(element);
      this.tagStack.push(element);
    };
    DomHandler2.prototype.ontext = function(data) {
      var lastNode = this.lastNode;
      if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
        lastNode.data += data;
        if (this.options.withEndIndices) {
          lastNode.endIndex = this.parser.endIndex;
        }
      } else {
        var node3 = new node_js_1.Text(data);
        this.addNode(node3);
        this.lastNode = node3;
      }
    };
    DomHandler2.prototype.oncomment = function(data) {
      if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
        this.lastNode.data += data;
        return;
      }
      var node3 = new node_js_1.Comment(data);
      this.addNode(node3);
      this.lastNode = node3;
    };
    DomHandler2.prototype.oncommentend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.oncdatastart = function() {
      var text = new node_js_1.Text("");
      var node3 = new node_js_1.CDATA([text]);
      this.addNode(node3);
      text.parent = node3;
      this.lastNode = text;
    };
    DomHandler2.prototype.oncdataend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.onprocessinginstruction = function(name, data) {
      var node3 = new node_js_1.ProcessingInstruction(name, data);
      this.addNode(node3);
    };
    DomHandler2.prototype.handleCallback = function(error8) {
      if (typeof this.callback === "function") {
        this.callback(error8, this.dom);
      } else if (error8) {
        throw error8;
      }
    };
    DomHandler2.prototype.addNode = function(node3) {
      var parent = this.tagStack[this.tagStack.length - 1];
      var previousSibling = parent.children[parent.children.length - 1];
      if (this.options.withStartIndices) {
        node3.startIndex = this.parser.startIndex;
      }
      if (this.options.withEndIndices) {
        node3.endIndex = this.parser.endIndex;
      }
      parent.children.push(node3);
      if (previousSibling) {
        node3.prev = previousSibling;
        previousSibling.next = node3;
      }
      node3.parent = parent;
      this.lastNode = null;
    };
    return DomHandler2;
  }();
  exports.DomHandler = DomHandler;
  exports.default = DomHandler;
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
    return c.charCodeAt(0);
  }));
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
    return c.charCodeAt(0);
  }));
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports) => {
  var replaceCodePoint = function(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
  };
  var decodeCodePoint = function(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.replaceCodePoint = exports.fromCodePoint = undefined;
  var decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
    var output2 = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output2 += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output2 += String.fromCharCode(codePoint);
    return output2;
  };
  exports.replaceCodePoint = replaceCodePoint;
  exports.default = decodeCodePoint;
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/decode.js
var require_decode = __commonJS((exports) => {
  var isNumber = function(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  };
  var isHexadecimalCharacter = function(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
  };
  var isAsciiAlphaNumeric = function(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
  };
  var isEntityInAttributeInvalidEnd = function(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  };
  var getDecoder = function(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(str, offset + 1);
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  };
  var determineBranch = function(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  };
  var decodeHTML = function(str, mode) {
    if (mode === undefined) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  };
  var decodeHTMLAttribute = function(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  };
  var decodeHTMLStrict = function(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  };
  var decodeXML = function(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = undefined;
  var decode_data_html_js_1 = __importDefault(require_decode_data_html());
  exports.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
  exports.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
  exports.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = require_decode_codepoint();
  Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
  var EntityDecoder = function() {
    function EntityDecoder2(decodeTree, emitCodePoint, errors17) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors17;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    EntityDecoder2.prototype.startEntity = function(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    };
    EntityDecoder2.prototype.write = function(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    };
    EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    };
    EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base18) {
      if (start !== end) {
        var digitCount = end - start;
        this.result = this.result * Math.pow(base18, digitCount) + parseInt(str.substr(start, digitCount), base18);
        this.consumed += digitCount;
      }
    };
    EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    };
    EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    };
    EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
      var _a;
      if (this.consumed <= expectedLength) {
        (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    };
    EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
      var decodeTree = this.decodeTree;
      var current = decodeTree[this.treeIndex];
      var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (;offset < str.length; offset++, this.excess++) {
        var char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    };
    EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
      var _a;
      var _b = this, result = _b.result, decodeTree = _b.decodeTree;
      var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a = this.errors) === null || _a === undefined || _a.missingSemicolonAfterCharacterReference();
      return this.consumed;
    };
    EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
      var decodeTree = this.decodeTree;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    };
    EntityDecoder2.prototype.end = function() {
      var _a;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    };
    return EntityDecoder2;
  }();
  exports.EntityDecoder = EntityDecoder;
  exports.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  exports.decodeHTML = decodeHTML;
  exports.decodeHTMLAttribute = decodeHTMLAttribute;
  exports.decodeHTMLStrict = decodeHTMLStrict;
  exports.decodeXML = decodeXML;
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS((exports) => {
  var restoreDiff = function(arr) {
    for (var i = 1;i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/escape.js
var require_escape = __commonJS((exports) => {
  var encodeXML = function(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== undefined) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  };
  var getEscaper = function(regex, map3) {
    return function escape(data) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        result += map3.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = undefined;
  exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports.getCodePoint = String.prototype.codePointAt != null ? function(str, index) {
    return str.codePointAt(index);
  } : function(c, index) {
    return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
  };
  exports.encodeXML = encodeXML;
  exports.escape = encodeXML;
  exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/encode.js
var require_encode = __commonJS((exports) => {
  var encodeHTML = function(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
  };
  var encodeNonAsciiHTML = function(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
  };
  var encodeHTMLTrieRe = function(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = regExp.exec(str)) !== null) {
      var i = match.index;
      ret += str.substring(lastIdx, i);
      var char = str.charCodeAt(i);
      var next = encode_html_js_1.default.get(char);
      if (typeof next === "object") {
        if (i + 1 < str.length) {
          var nextChar = str.charCodeAt(i + 1);
          var value = typeof next.n === "number" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);
          if (value !== undefined) {
            ret += value;
            lastIdx = regExp.lastIndex += 1;
            continue;
          }
        }
        next = next.v;
      }
      if (next !== undefined) {
        ret += next;
        lastIdx = i + 1;
      } else {
        var cp = (0, escape_js_1.getCodePoint)(str, i);
        ret += "&#x".concat(cp.toString(16), ";");
        lastIdx = regExp.lastIndex += Number(cp !== char);
      }
    }
    return ret + str.substr(lastIdx);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeNonAsciiHTML = exports.encodeHTML = undefined;
  var encode_html_js_1 = __importDefault(require_encode_html());
  var escape_js_1 = require_escape();
  var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  exports.encodeHTML = encodeHTML;
  exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/index.js
var require_lib8 = __commonJS((exports) => {
  var decode = function(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options === "object" ? options.mode : undefined;
      return (0, decode_js_1.decodeHTML)(data, mode);
    }
    return (0, decode_js_1.decodeXML)(data);
  };
  var decodeStrict = function(data, options) {
    var _a;
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== undefined || (opts.mode = decode_js_1.DecodingMode.Strict);
    return decode(data, opts);
  };
  var encode = function(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data);
      }
      return (0, encode_js_1.encodeHTML)(data);
    }
    return (0, escape_js_1.encodeXML)(data);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = undefined;
  var decode_js_1 = require_decode();
  var encode_js_1 = require_encode();
  var escape_js_1 = require_escape();
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
  exports.decode = decode;
  exports.decodeStrict = decodeStrict;
  exports.encode = encode;
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = require_encode();
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = require_decode();
  Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
});

// ../../node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attributeNames = exports.elementNames = undefined;
  exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
  exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
});

// ../../node_modules/dom-serializer/lib/index.js
var require_lib9 = __commonJS((exports) => {
  var replaceQuotes = function(value) {
    return value.replace(/"/g, "&quot;");
  };
  var formatAttributes = function(attributes, opts) {
    var _a;
    if (!attributes)
      return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
    return Object.keys(attributes).map(function(key) {
      var _a2, _b;
      var value = (_a2 = attributes[key]) !== null && _a2 !== undefined ? _a2 : "";
      if (opts.xmlMode === "foreign") {
        key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return "".concat(key, "=\"").concat(encode(value), "\"");
    }).join(" ");
  };
  var render = function(node3, options) {
    if (options === undefined) {
      options = {};
    }
    var nodes = "length" in node3 ? node3 : [node3];
    var output2 = "";
    for (var i = 0;i < nodes.length; i++) {
      output2 += renderNode(nodes[i], options);
    }
    return output2;
  };
  var renderNode = function(node3, options) {
    switch (node3.type) {
      case ElementType.Root:
        return render(node3.children, options);
      case ElementType.Doctype:
      case ElementType.Directive:
        return renderDirective(node3);
      case ElementType.Comment:
        return renderComment(node3);
      case ElementType.CDATA:
        return renderCdata(node3);
      case ElementType.Script:
      case ElementType.Style:
      case ElementType.Tag:
        return renderTag(node3, options);
      case ElementType.Text:
        return renderText(node3, options);
    }
  };
  var renderTag = function(elem, opts) {
    var _a;
    if (opts.xmlMode === "foreign") {
      elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== undefined ? _a : elem.name;
      if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: false });
      }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
      tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
      if (!opts.xmlMode)
        tag += " ";
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children.length > 0) {
        tag += render(elem.children, opts);
      }
      if (opts.xmlMode || !singleTag.has(elem.name)) {
        tag += "</".concat(elem.name, ">");
      }
    }
    return tag;
  };
  var renderDirective = function(elem) {
    return "<".concat(elem.data, ">");
  };
  var renderText = function(elem, opts) {
    var _a;
    var data = elem.data || "";
    if (((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
      data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
    }
    return data;
  };
  var renderCdata = function(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
  };
  var renderComment = function(elem) {
    return "<!--".concat(elem.data, "-->");
  };
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.render = undefined;
  var ElementType = __importStar(require_lib6());
  var entities_1 = require_lib8();
  var foreignNames_js_1 = require_foreignNames();
  var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  exports.render = render;
  exports.default = render;
  var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var foreignElements = new Set(["svg", "math"]);
});

// ../../node_modules/domutils/lib/stringify.js
var require_stringify3 = __commonJS((exports) => {
  var getOuterHTML = function(node3, options) {
    return (0, dom_serializer_1.default)(node3, options);
  };
  var getInnerHTML = function(node3, options) {
    return (0, domhandler_1.hasChildren)(node3) ? node3.children.map(function(node4) {
      return getOuterHTML(node4, options);
    }).join("") : "";
  };
  var getText = function(node3) {
    if (Array.isArray(node3))
      return node3.map(getText).join("");
    if ((0, domhandler_1.isTag)(node3))
      return node3.name === "br" ? "\n" : getText(node3.children);
    if ((0, domhandler_1.isCDATA)(node3))
      return getText(node3.children);
    if ((0, domhandler_1.isText)(node3))
      return node3.data;
    return "";
  };
  var textContent = function(node3) {
    if (Array.isArray(node3))
      return node3.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node3) && !(0, domhandler_1.isComment)(node3)) {
      return textContent(node3.children);
    }
    if ((0, domhandler_1.isText)(node3))
      return node3.data;
    return "";
  };
  var innerText = function(node3) {
    if (Array.isArray(node3))
      return node3.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node3) && (node3.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node3))) {
      return innerText(node3.children);
    }
    if ((0, domhandler_1.isText)(node3))
      return node3.data;
    return "";
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = undefined;
  var domhandler_1 = require_lib7();
  var dom_serializer_1 = __importDefault(require_lib9());
  var domelementtype_1 = require_lib6();
  exports.getOuterHTML = getOuterHTML;
  exports.getInnerHTML = getInnerHTML;
  exports.getText = getText;
  exports.textContent = textContent;
  exports.innerText = innerText;
});

// ../../node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
  var getChildren = function(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
  };
  var getParent = function(elem) {
    return elem.parent || null;
  };
  var getSiblings = function(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
      return getChildren(parent);
    var siblings = [elem];
    var { prev, next } = elem;
    while (prev != null) {
      siblings.unshift(prev);
      _a = prev, prev = _a.prev;
    }
    while (next != null) {
      siblings.push(next);
      _b = next, next = _b.next;
    }
    return siblings;
  };
  var getAttributeValue = function(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === undefined ? undefined : _a[name];
  };
  var hasAttrib = function(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
  };
  var getName = function(elem) {
    return elem.name;
  };
  var nextElementSibling = function(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
      _a = next, next = _a.next;
    return next;
  };
  var prevElementSibling = function(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
      _a = prev, prev = _a.prev;
    return prev;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = undefined;
  var domhandler_1 = require_lib7();
  exports.getChildren = getChildren;
  exports.getParent = getParent;
  exports.getSiblings = getSiblings;
  exports.getAttributeValue = getAttributeValue;
  exports.hasAttrib = hasAttrib;
  exports.getName = getName;
  exports.nextElementSibling = nextElementSibling;
  exports.prevElementSibling = prevElementSibling;
});

// ../../node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
  var removeElement = function(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      var childsIndex = childs.lastIndexOf(elem);
      if (childsIndex >= 0) {
        childs.splice(childsIndex, 1);
      }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
  };
  var replaceElement = function(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
      elem.parent = null;
    }
  };
  var appendChild = function(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
      var sibling = parent.children[parent.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
    } else {
      child.prev = null;
    }
  };
  var append = function(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  var prependChild = function(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
      var sibling = parent.children[1];
      sibling.prev = child;
      child.next = sibling;
    } else {
      child.next = null;
    }
  };
  var prepend = function(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = undefined;
  exports.removeElement = removeElement;
  exports.replaceElement = replaceElement;
  exports.appendChild = appendChild;
  exports.append = append;
  exports.prependChild = prependChild;
  exports.prepend = prepend;
});

// ../../node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports) => {
  var filter2 = function(test, node3, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return find(test, Array.isArray(node3) ? node3 : [node3], recurse, limit);
  };
  var find = function(test, nodes, recurse, limit) {
    var result = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (indexStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (test(elem)) {
        result.push(elem);
        if (--limit <= 0)
          return result;
      }
      if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  };
  var findOneChild = function(test, nodes) {
    return nodes.find(test);
  };
  var findOne = function(test, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    var elem = null;
    for (var i = 0;i < nodes.length && !elem; i++) {
      var node3 = nodes[i];
      if (!(0, domhandler_1.isTag)(node3)) {
        continue;
      } else if (test(node3)) {
        elem = node3;
      } else if (recurse && node3.children.length > 0) {
        elem = findOne(test, node3.children, true);
      }
    }
    return elem;
  };
  var existsOne = function(test, nodes) {
    return nodes.some(function(checked) {
      return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
    });
  };
  var findAll = function(test, nodes) {
    var result = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (nodeStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (!(0, domhandler_1.isTag)(elem))
        continue;
      if (test(elem))
        result.push(elem);
      if (elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = undefined;
  var domhandler_1 = require_lib7();
  exports.filter = filter2;
  exports.find = find;
  exports.findOneChild = findOneChild;
  exports.findOne = findOne;
  exports.existsOne = existsOne;
  exports.findAll = findAll;
});

// ../../node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS((exports) => {
  var getAttribCheck = function(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
  };
  var combineFuncs = function(a, b) {
    return function(elem) {
      return a(elem) || b(elem);
    };
  };
  var compileTest = function(options) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  };
  var testElement = function(options, node3) {
    var test = compileTest(options);
    return test ? test(node3) : true;
  };
  var getElements = function(options, nodes, recurse, limit) {
    if (limit === undefined) {
      limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
  };
  var getElementById = function(id, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (!Array.isArray(nodes))
      nodes = [nodes];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
  };
  var getElementsByTagName = function(tagName, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
  };
  var getElementsByTagType = function(type2, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_type"](type2), nodes, recurse, limit);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = undefined;
  var domhandler_1 = require_lib7();
  var querying_js_1 = require_querying();
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return domhandler_1.isTag;
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.name === name;
      };
    },
    tag_type: function(type2) {
      if (typeof type2 === "function") {
        return function(elem) {
          return type2(elem.type);
        };
      }
      return function(elem) {
        return elem.type === type2;
      };
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && data(elem.data);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && elem.data === data;
      };
    }
  };
  exports.testElement = testElement;
  exports.getElements = getElements;
  exports.getElementById = getElementById;
  exports.getElementsByTagName = getElementsByTagName;
  exports.getElementsByTagType = getElementsByTagType;
});

// ../../node_modules/domutils/lib/helpers.js
var require_helpers4 = __commonJS((exports) => {
  var removeSubsets = function(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node3 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node3, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node3.parent;ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  };
  var compareDocumentPosition = function(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  };
  var uniqueSort = function(nodes) {
    nodes = nodes.filter(function(node3, i, arr) {
      return !arr.includes(node3, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = undefined;
  var domhandler_1 = require_lib7();
  exports.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
  exports.compareDocumentPosition = compareDocumentPosition;
  exports.uniqueSort = uniqueSort;
});

// ../../node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS((exports) => {
  var getFeed = function(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
  };
  var getAtomFeed = function(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
      type: "atom",
      items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
        var _a2;
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "id", children);
        addConditionally(entry, "title", "title", children);
        var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === undefined ? undefined : _a2.attribs["href"];
        if (href2) {
          entry.link = href2;
        }
        var description3 = fetch6("summary", children) || fetch6("content", children);
        if (description3) {
          entry.description = description3;
        }
        var pubDate = fetch6("updated", children);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === undefined ? undefined : _a.attribs["href"];
    if (href) {
      feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch6("updated", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
  };
  var getRssFeed = function(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === undefined ? undefined : _a.children) !== null && _b !== undefined ? _b : [];
    var feed = {
      type: feedRoot.name.substr(0, 3),
      id: "",
      items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "guid", children);
        addConditionally(entry, "title", "title", children);
        addConditionally(entry, "link", "link", children);
        addConditionally(entry, "description", "description", children);
        var pubDate = fetch6("pubDate", children) || fetch6("dc:date", children);
        if (pubDate)
          entry.pubDate = new Date(pubDate);
        return entry;
      })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch6("lastBuildDate", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
  };
  var getMediaElements = function(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
      var attribs = elem.attribs;
      var media = {
        medium: attribs["medium"],
        isDefault: !!attribs["isDefault"]
      };
      for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;_i < MEDIA_KEYS_STRING_1.length; _i++) {
        var attrib = MEDIA_KEYS_STRING_1[_i];
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;_a < MEDIA_KEYS_INT_1.length; _a++) {
        var attrib = MEDIA_KEYS_INT_1[_a];
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs["expression"]) {
        media.expression = attribs["expression"];
      }
      return media;
    });
  };
  var getOneElement = function(tagName, node3) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node3, true, 1)[0];
  };
  var fetch6 = function(tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
  };
  var addConditionally = function(obj, prop, tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    var val = fetch6(tagName, where, recurse);
    if (val)
      obj[prop] = val;
  };
  var isValidFeed = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFeed = undefined;
  var stringify_js_1 = require_stringify3();
  var legacy_js_1 = require_legacy();
  exports.getFeed = getFeed;
  var MEDIA_KEYS_STRING = ["url", "type", "lang"];
  var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
});

// ../../node_modules/domutils/lib/index.js
var require_lib10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = undefined;
  __exportStar(require_stringify3(), exports);
  __exportStar(require_traversal(), exports);
  __exportStar(require_manipulation(), exports);
  __exportStar(require_querying(), exports);
  __exportStar(require_legacy(), exports);
  __exportStar(require_helpers4(), exports);
  __exportStar(require_feeds(), exports);
  var domhandler_1 = require_lib7();
  Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
    return domhandler_1.isTag;
  } });
  Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
    return domhandler_1.isCDATA;
  } });
  Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
    return domhandler_1.isText;
  } });
  Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
    return domhandler_1.isComment;
  } });
  Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
    return domhandler_1.isDocument;
  } });
  Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
    return domhandler_1.hasChildren;
  } });
});

// ../../node_modules/boolbase/index.js
var require_boolbase = __commonJS((exports, module) => {
  module.exports = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };
});

// ../../node_modules/css-what/lib/commonjs/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeAction = exports.IgnoreCaseMode = exports.SelectorType = undefined;
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2["Attribute"] = "attribute";
    SelectorType2["Pseudo"] = "pseudo";
    SelectorType2["PseudoElement"] = "pseudo-element";
    SelectorType2["Tag"] = "tag";
    SelectorType2["Universal"] = "universal";
    SelectorType2["Adjacent"] = "adjacent";
    SelectorType2["Child"] = "child";
    SelectorType2["Descendant"] = "descendant";
    SelectorType2["Parent"] = "parent";
    SelectorType2["Sibling"] = "sibling";
    SelectorType2["ColumnCombinator"] = "column-combinator";
  })(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
  exports.IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: true,
    CaseSensitive: false
  };
  var AttributeAction;
  (function(AttributeAction2) {
    AttributeAction2["Any"] = "any";
    AttributeAction2["Element"] = "element";
    AttributeAction2["End"] = "end";
    AttributeAction2["Equals"] = "equals";
    AttributeAction2["Exists"] = "exists";
    AttributeAction2["Hyphen"] = "hyphen";
    AttributeAction2["Not"] = "not";
    AttributeAction2["Start"] = "start";
  })(AttributeAction = exports.AttributeAction || (exports.AttributeAction = {}));
});

// ../../node_modules/css-what/lib/commonjs/parse.js
var require_parse3 = __commonJS((exports) => {
  var isTraversal = function(selector) {
    switch (selector.type) {
      case types_1.SelectorType.Adjacent:
      case types_1.SelectorType.Child:
      case types_1.SelectorType.Descendant:
      case types_1.SelectorType.Parent:
      case types_1.SelectorType.Sibling:
      case types_1.SelectorType.ColumnCombinator:
        return true;
      default:
        return false;
    }
  };
  var funescape = function(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 65536;
    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
  };
  var unescapeCSS = function(str) {
    return str.replace(reEscape, funescape);
  };
  var isQuote = function(c) {
    return c === 39 || c === 34;
  };
  var isWhitespace = function(c) {
    return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
  };
  var parse2 = function(selector) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "".concat(selector), 0);
    if (endIndex < selector.length) {
      throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
    }
    return subselects;
  };
  var parseSelector = function(subselects, selector, selectorIndex) {
    var tokens = [];
    function getName(offset) {
      var match = selector.slice(selectorIndex + offset).match(reName);
      if (!match) {
        throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
      }
      var name = match[0];
      selectorIndex += offset + name.length;
      return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
      selectorIndex += offset;
      while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
        selectorIndex++;
      }
    }
    function readValueWithParenthesis() {
      selectorIndex += 1;
      var start = selectorIndex;
      var counter = 1;
      for (;counter > 0 && selectorIndex < selector.length; selectorIndex++) {
        if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
          counter++;
        } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
          counter--;
        }
      }
      if (counter) {
        throw new Error("Parenthesis not matched");
      }
      return unescapeCSS(selector.slice(start, selectorIndex - 1));
    }
    function isEscaped(pos) {
      var slashCount = 0;
      while (selector.charCodeAt(--pos) === 92)
        slashCount++;
      return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
      if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
        throw new Error("Did not expect successive traversals.");
      }
    }
    function addTraversal(type2) {
      if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
        tokens[tokens.length - 1].type = type2;
        return;
      }
      ensureNotTraversal();
      tokens.push({ type: type2 });
    }
    function addSpecialAttribute(name, action2) {
      tokens.push({
        type: types_1.SelectorType.Attribute,
        name,
        action: action2,
        value: getName(1),
        namespace: null,
        ignoreCase: "quirks"
      });
    }
    function finalizeSubselector() {
      if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
        tokens.pop();
      }
      if (tokens.length === 0) {
        throw new Error("Empty sub-selector");
      }
      subselects.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
      return selectorIndex;
    }
    loop:
      while (selectorIndex < selector.length) {
        var firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
          case 32:
          case 9:
          case 10:
          case 12:
          case 13: {
            if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
              ensureNotTraversal();
              tokens.push({ type: types_1.SelectorType.Descendant });
            }
            stripWhitespace(1);
            break;
          }
          case 62: {
            addTraversal(types_1.SelectorType.Child);
            stripWhitespace(1);
            break;
          }
          case 60: {
            addTraversal(types_1.SelectorType.Parent);
            stripWhitespace(1);
            break;
          }
          case 126: {
            addTraversal(types_1.SelectorType.Sibling);
            stripWhitespace(1);
            break;
          }
          case 43: {
            addTraversal(types_1.SelectorType.Adjacent);
            stripWhitespace(1);
            break;
          }
          case 46: {
            addSpecialAttribute("class", types_1.AttributeAction.Element);
            break;
          }
          case 35: {
            addSpecialAttribute("id", types_1.AttributeAction.Equals);
            break;
          }
          case 91: {
            stripWhitespace(1);
            var name_1 = undefined;
            var namespace = null;
            if (selector.charCodeAt(selectorIndex) === 124) {
              name_1 = getName(1);
            } else if (selector.startsWith("*|", selectorIndex)) {
              namespace = "*";
              name_1 = getName(2);
            } else {
              name_1 = getName(0);
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                namespace = name_1;
                name_1 = getName(1);
              }
            }
            stripWhitespace(0);
            var action = types_1.AttributeAction.Exists;
            var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
            if (possibleAction) {
              action = possibleAction;
              if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                throw new Error("Expected `=`");
              }
              stripWhitespace(2);
            } else if (selector.charCodeAt(selectorIndex) === 61) {
              action = types_1.AttributeAction.Equals;
              stripWhitespace(1);
            }
            var value = "";
            var ignoreCase = null;
            if (action !== "exists") {
              if (isQuote(selector.charCodeAt(selectorIndex))) {
                var quote = selector.charCodeAt(selectorIndex);
                var sectionEnd = selectorIndex + 1;
                while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                  sectionEnd += 1;
                }
                if (selector.charCodeAt(sectionEnd) !== quote) {
                  throw new Error("Attribute value didn't end");
                }
                value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                selectorIndex = sectionEnd + 1;
              } else {
                var valueStart = selectorIndex;
                while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                  selectorIndex += 1;
                }
                value = unescapeCSS(selector.slice(valueStart, selectorIndex));
              }
              stripWhitespace(0);
              var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
              if (forceIgnore === 115) {
                ignoreCase = false;
                stripWhitespace(1);
              } else if (forceIgnore === 105) {
                ignoreCase = true;
                stripWhitespace(1);
              }
            }
            if (selector.charCodeAt(selectorIndex) !== 93) {
              throw new Error("Attribute selector didn't terminate");
            }
            selectorIndex += 1;
            var attributeSelector = {
              type: types_1.SelectorType.Attribute,
              name: name_1,
              action,
              value,
              namespace,
              ignoreCase
            };
            tokens.push(attributeSelector);
            break;
          }
          case 58: {
            if (selector.charCodeAt(selectorIndex + 1) === 58) {
              tokens.push({
                type: types_1.SelectorType.PseudoElement,
                name: getName(2).toLowerCase(),
                data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
              });
              continue;
            }
            var name_2 = getName(1).toLowerCase();
            var data = null;
            if (selector.charCodeAt(selectorIndex) === 40) {
              if (unpackPseudos.has(name_2)) {
                if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                  throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                }
                data = [];
                selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                if (selector.charCodeAt(selectorIndex) !== 41) {
                  throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                }
                selectorIndex += 1;
              } else {
                data = readValueWithParenthesis();
                if (stripQuotesFromPseudos.has(name_2)) {
                  var quot = data.charCodeAt(0);
                  if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                    data = data.slice(1, -1);
                  }
                }
                data = unescapeCSS(data);
              }
            }
            tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
            break;
          }
          case 44: {
            finalizeSubselector();
            tokens = [];
            stripWhitespace(1);
            break;
          }
          default: {
            if (selector.startsWith("/*", selectorIndex)) {
              var endIndex = selector.indexOf("*/", selectorIndex + 2);
              if (endIndex < 0) {
                throw new Error("Comment was not terminated");
              }
              selectorIndex = endIndex + 2;
              if (tokens.length === 0) {
                stripWhitespace(0);
              }
              break;
            }
            var namespace = null;
            var name_3 = undefined;
            if (firstChar === 42) {
              selectorIndex += 1;
              name_3 = "*";
            } else if (firstChar === 124) {
              name_3 = "";
              if (selector.charCodeAt(selectorIndex + 1) === 124) {
                addTraversal(types_1.SelectorType.ColumnCombinator);
                stripWhitespace(2);
                break;
              }
            } else if (reName.test(selector.slice(selectorIndex))) {
              name_3 = getName(0);
            } else {
              break loop;
            }
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
              namespace = name_3;
              if (selector.charCodeAt(selectorIndex + 1) === 42) {
                name_3 = "*";
                selectorIndex += 2;
              } else {
                name_3 = getName(1);
              }
            }
            tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
          }
        }
      }
    finalizeSubselector();
    return selectorIndex;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = exports.isTraversal = undefined;
  var types_1 = require_types();
  var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
  var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
  var actionTypes = new Map([
    [126, types_1.AttributeAction.Element],
    [94, types_1.AttributeAction.Start],
    [36, types_1.AttributeAction.End],
    [42, types_1.AttributeAction.Any],
    [33, types_1.AttributeAction.Not],
    [124, types_1.AttributeAction.Hyphen]
  ]);
  var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context"
  ]);
  exports.isTraversal = isTraversal;
  var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
  exports.parse = parse2;
});

// ../../node_modules/css-what/lib/commonjs/stringify.js
var require_stringify4 = __commonJS((exports) => {
  var stringify4 = function(selector) {
    return selector.map(function(token) {
      return token.map(stringifyToken).join("");
    }).join(", ");
  };
  var stringifyToken = function(token, index, arr) {
    switch (token.type) {
      case types_1.SelectorType.Child:
        return index === 0 ? "> " : " > ";
      case types_1.SelectorType.Parent:
        return index === 0 ? "< " : " < ";
      case types_1.SelectorType.Sibling:
        return index === 0 ? "~ " : " ~ ";
      case types_1.SelectorType.Adjacent:
        return index === 0 ? "+ " : " + ";
      case types_1.SelectorType.Descendant:
        return " ";
      case types_1.SelectorType.ColumnCombinator:
        return index === 0 ? "|| " : " || ";
      case types_1.SelectorType.Universal:
        return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
      case types_1.SelectorType.Tag:
        return getNamespacedName(token);
      case types_1.SelectorType.PseudoElement:
        return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
      case types_1.SelectorType.Pseudo:
        return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify4(token.data), ")"));
      case types_1.SelectorType.Attribute: {
        if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
          return "#".concat(escapeName(token.value, charsToEscapeInName));
        }
        if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
          return ".".concat(escapeName(token.value, charsToEscapeInName));
        }
        var name_1 = getNamespacedName(token);
        if (token.action === types_1.AttributeAction.Exists) {
          return "[".concat(name_1, "]");
        }
        return "[".concat(name_1).concat(getActionValue(token.action), "=\"").concat(escapeName(token.value, charsToEscapeInAttributeValue), "\"").concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
      }
    }
  };
  var getActionValue = function(action) {
    switch (action) {
      case types_1.AttributeAction.Equals:
        return "";
      case types_1.AttributeAction.Element:
        return "~";
      case types_1.AttributeAction.Start:
        return "^";
      case types_1.AttributeAction.End:
        return "$";
      case types_1.AttributeAction.Any:
        return "*";
      case types_1.AttributeAction.Not:
        return "!";
      case types_1.AttributeAction.Hyphen:
        return "|";
      case types_1.AttributeAction.Exists:
        throw new Error("Shouldn't be here");
    }
  };
  var getNamespacedName = function(token) {
    return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
  };
  var getNamespace = function(namespace) {
    return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
  };
  var escapeName = function(str, charsToEscape) {
    var lastIdx = 0;
    var ret = "";
    for (var i = 0;i < str.length; i++) {
      if (charsToEscape.has(str.charCodeAt(i))) {
        ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
        lastIdx = i + 1;
      }
    }
    return ret.length > 0 ? ret + str.slice(lastIdx) : str;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringify = undefined;
  var types_1 = require_types();
  var attribValChars = ["\\", '"'];
  var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
  var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
    return c.charCodeAt(0);
  }));
  var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
    return c.charCodeAt(0);
  }));
  var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    "."
  ], false).map(function(c) {
    return c.charCodeAt(0);
  }));
  exports.stringify = stringify4;
});

// ../../node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringify = exports.parse = exports.isTraversal = undefined;
  __exportStar(require_types(), exports);
  var parse_1 = require_parse3();
  Object.defineProperty(exports, "isTraversal", { enumerable: true, get: function() {
    return parse_1.isTraversal;
  } });
  Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
    return parse_1.parse;
  } });
  var stringify_1 = require_stringify4();
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return stringify_1.stringify;
  } });
});

// ../../node_modules/css-select/lib/sort.js
var require_sort = __commonJS((exports) => {
  var isTraversal = function(token) {
    return !procedure.has(token.type);
  };
  var sortByProcedure = function(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1;i < arr.length; i++) {
      var procNew = procs[i];
      if (procNew < 0)
        continue;
      for (var j = i - 1;j >= 0 && procNew < procs[j]; j--) {
        var token = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = token;
        procs[j + 1] = procs[j];
        procs[j] = procNew;
      }
    }
  };
  var getProcedure = function(token) {
    var _a, _b;
    var proc = (_a = procedure.get(token.type)) !== null && _a !== undefined ? _a : -1;
    if (token.type === css_what_1.SelectorType.Attribute) {
      proc = (_b = attributes.get(token.action)) !== null && _b !== undefined ? _b : 4;
      if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
        proc = 9;
      }
      if (token.ignoreCase) {
        proc >>= 1;
      }
    } else if (token.type === css_what_1.SelectorType.Pseudo) {
      if (!token.data) {
        proc = 3;
      } else if (token.name === "has" || token.name === "contains") {
        proc = 0;
      } else if (Array.isArray(token.data)) {
        proc = Math.min.apply(Math, token.data.map(function(d) {
          return Math.min.apply(Math, d.map(getProcedure));
        }));
        if (proc < 0) {
          proc = 0;
        }
      } else {
        proc = 2;
      }
    }
    return proc;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTraversal = undefined;
  var css_what_1 = require_commonjs();
  var procedure = new Map([
    [css_what_1.SelectorType.Universal, 50],
    [css_what_1.SelectorType.Tag, 30],
    [css_what_1.SelectorType.Attribute, 1],
    [css_what_1.SelectorType.Pseudo, 0]
  ]);
  exports.isTraversal = isTraversal;
  var attributes = new Map([
    [css_what_1.AttributeAction.Exists, 10],
    [css_what_1.AttributeAction.Equals, 8],
    [css_what_1.AttributeAction.Not, 7],
    [css_what_1.AttributeAction.Start, 6],
    [css_what_1.AttributeAction.End, 6],
    [css_what_1.AttributeAction.Any, 5]
  ]);
  exports.default = sortByProcedure;
});

// ../../node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS((exports) => {
  var escapeRegex = function(value) {
    return value.replace(reChars, "\\$&");
  };
  var shouldIgnoreCase = function(selector, options) {
    return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attributeRules = undefined;
  var boolbase_1 = __importDefault(require_boolbase());
  var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
  var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink"
  ]);
  exports.attributeRules = {
    equals: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
        };
      }
      return function(elem) {
        return adapter.getAttributeValue(elem, name) === value && next(elem);
      };
    },
    hyphen: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      var len = value.length;
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function hyphenIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
        };
      }
      return function hyphen(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
      };
    },
    element: function(next, data, options) {
      var adapter = options.adapter;
      var { name, value } = data;
      if (/\s/.test(value)) {
        return boolbase_1.default.falseFunc;
      }
      var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
      return function element(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
      };
    },
    exists: function(next, _a, _b) {
      var name = _a.name;
      var adapter = _b.adapter;
      return function(elem) {
        return adapter.hasAttrib(elem, name) && next(elem);
      };
    },
    start: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      var len = value.length;
      if (len === 0) {
        return boolbase_1.default.falseFunc;
      }
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
        };
      }
      return function(elem) {
        var _a;
        return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.startsWith(value)) && next(elem);
      };
    },
    end: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      var len = -value.length;
      if (len === 0) {
        return boolbase_1.default.falseFunc;
      }
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var _a;
          return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.substr(len).toLowerCase()) === value && next(elem);
        };
      }
      return function(elem) {
        var _a;
        return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.endsWith(value)) && next(elem);
      };
    },
    any: function(next, data, options) {
      var adapter = options.adapter;
      var { name, value } = data;
      if (value === "") {
        return boolbase_1.default.falseFunc;
      }
      if (shouldIgnoreCase(data, options)) {
        var regex_1 = new RegExp(escapeRegex(value), "i");
        return function anyIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
        };
      }
      return function(elem) {
        var _a;
        return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.includes(value)) && next(elem);
      };
    },
    not: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      if (value === "") {
        return function(elem) {
          return !!adapter.getAttributeValue(elem, name) && next(elem);
        };
      } else if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
        };
      }
      return function(elem) {
        return adapter.getAttributeValue(elem, name) !== value && next(elem);
      };
    }
  };
});

// ../../node_modules/nth-check/lib/parse.js
var require_parse4 = __commonJS((exports) => {
  var parse2 = function(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
      return [2, 0];
    } else if (formula === "odd") {
      return [2, 1];
    }
    var idx = 0;
    var a = 0;
    var sign = readSign();
    var number = readNumber2();
    if (idx < formula.length && formula.charAt(idx) === "n") {
      idx++;
      a = sign * (number !== null && number !== undefined ? number : 1);
      skipWhitespace();
      if (idx < formula.length) {
        sign = readSign();
        skipWhitespace();
        number = readNumber2();
      } else {
        sign = number = 0;
      }
    }
    if (number === null || idx < formula.length) {
      throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
    }
    return [a, sign * number];
    function readSign() {
      if (formula.charAt(idx) === "-") {
        idx++;
        return -1;
      }
      if (formula.charAt(idx) === "+") {
        idx++;
      }
      return 1;
    }
    function readNumber2() {
      var start = idx;
      var value = 0;
      while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
        value = value * 10 + (formula.charCodeAt(idx) - ZERO);
        idx++;
      }
      return idx === start ? null : value;
    }
    function skipWhitespace() {
      while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
        idx++;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = undefined;
  var whitespace = new Set([9, 10, 12, 13, 32]);
  var ZERO = "0".charCodeAt(0);
  var NINE = "9".charCodeAt(0);
  exports.parse = parse2;
});

// ../../node_modules/nth-check/lib/compile.js
var require_compile = __commonJS((exports) => {
  var compile = function(parsed) {
    var a = parsed[0];
    var b = parsed[1] - 1;
    if (b < 0 && a <= 0)
      return boolbase_1.default.falseFunc;
    if (a === -1)
      return function(index) {
        return index <= b;
      };
    if (a === 0)
      return function(index) {
        return index === b;
      };
    if (a === 1)
      return b < 0 ? boolbase_1.default.trueFunc : function(index) {
        return index >= b;
      };
    var absA = Math.abs(a);
    var bMod = (b % absA + absA) % absA;
    return a > 1 ? function(index) {
      return index >= b && index % absA === bMod;
    } : function(index) {
      return index <= b && index % absA === bMod;
    };
  };
  var generate = function(parsed) {
    var a = parsed[0];
    var b = parsed[1] - 1;
    var n = 0;
    if (a < 0) {
      var aPos_1 = -a;
      var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
      return function() {
        var val = minValue_1 + aPos_1 * n++;
        return val > b ? null : val;
      };
    }
    if (a === 0)
      return b < 0 ? function() {
        return null;
      } : function() {
        return n++ === 0 ? b : null;
      };
    if (b < 0) {
      b += a * Math.ceil(-b / a);
    }
    return function() {
      return a * n++ + b;
    };
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = exports.compile = undefined;
  var boolbase_1 = __importDefault(require_boolbase());
  exports.compile = compile;
  exports.generate = generate;
});

// ../../node_modules/nth-check/lib/index.js
var require_lib11 = __commonJS((exports) => {
  var nthCheck = function(formula) {
    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
  };
  var sequence = function(formula) {
    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequence = exports.generate = exports.compile = exports.parse = undefined;
  var parse_js_1 = require_parse4();
  Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
    return parse_js_1.parse;
  } });
  var compile_js_1 = require_compile();
  Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
    return compile_js_1.compile;
  } });
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return compile_js_1.generate;
  } });
  exports.default = nthCheck;
  exports.sequence = sequence;
});

// ../../node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS((exports) => {
  var getChildFunc = function(next, adapter) {
    return function(elem) {
      var parent = adapter.getParent(elem);
      return parent != null && adapter.isTag(parent) && next(elem);
    };
  };
  var dynamicStatePseudo = function(name) {
    return function dynamicPseudo(next, _rule, _a) {
      var adapter = _a.adapter;
      var func = adapter[name];
      if (typeof func !== "function") {
        return boolbase_1.default.falseFunc;
      }
      return function active(elem) {
        return func(elem) && next(elem);
      };
    };
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filters = undefined;
  var nth_check_1 = __importDefault(require_lib11());
  var boolbase_1 = __importDefault(require_boolbase());
  exports.filters = {
    contains: function(next, text, _a) {
      var adapter = _a.adapter;
      return function contains(elem) {
        return next(elem) && adapter.getText(elem).includes(text);
      };
    },
    icontains: function(next, text, _a) {
      var adapter = _a.adapter;
      var itext = text.toLowerCase();
      return function icontains(elem) {
        return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
      };
    },
    "nth-child": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthChild(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0;i < siblings.length; i++) {
          if (equals(elem, siblings[i]))
            break;
          if (adapter.isTag(siblings[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-child": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastChild(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings.length - 1;i >= 0; i--) {
          if (equals(elem, siblings[i]))
            break;
          if (adapter.isTag(siblings[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-of-type": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthOfType(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0;i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-of-type": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastOfType(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings.length - 1;i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    root: function(next, _rule, _a) {
      var adapter = _a.adapter;
      return function(elem) {
        var parent = adapter.getParent(elem);
        return (parent == null || !adapter.isTag(parent)) && next(elem);
      };
    },
    scope: function(next, rule, options, context) {
      var equals = options.equals;
      if (!context || context.length === 0) {
        return exports.filters["root"](next, rule, options);
      }
      if (context.length === 1) {
        return function(elem) {
          return equals(context[0], elem) && next(elem);
        };
      }
      return function(elem) {
        return context.includes(elem) && next(elem);
      };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive")
  };
});

// ../../node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS((exports) => {
  var verifyPseudoArgs = function(func, name, subselect, argIndex) {
    if (subselect === null) {
      if (func.length > argIndex) {
        throw new Error("Pseudo-class :".concat(name, " requires an argument"));
      }
    } else if (func.length === argIndex) {
      throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyPseudoArgs = exports.pseudos = undefined;
  exports.pseudos = {
    empty: function(elem, _a) {
      var adapter = _a.adapter;
      return !adapter.getChildren(elem).some(function(elem2) {
        return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
      });
    },
    "first-child": function(elem, _a) {
      var { adapter, equals } = _a;
      if (adapter.prevElementSibling) {
        return adapter.prevElementSibling(elem) == null;
      }
      var firstChild = adapter.getSiblings(elem).find(function(elem2) {
        return adapter.isTag(elem2);
      });
      return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function(elem, _a) {
      var { adapter, equals } = _a;
      var siblings = adapter.getSiblings(elem);
      for (var i = siblings.length - 1;i >= 0; i--) {
        if (equals(elem, siblings[i]))
          return true;
        if (adapter.isTag(siblings[i]))
          break;
      }
      return false;
    },
    "first-of-type": function(elem, _a) {
      var { adapter, equals } = _a;
      var siblings = adapter.getSiblings(elem);
      var elemName = adapter.getName(elem);
      for (var i = 0;i < siblings.length; i++) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          return true;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
          break;
        }
      }
      return false;
    },
    "last-of-type": function(elem, _a) {
      var { adapter, equals } = _a;
      var siblings = adapter.getSiblings(elem);
      var elemName = adapter.getName(elem);
      for (var i = siblings.length - 1;i >= 0; i--) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          return true;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
          break;
        }
      }
      return false;
    },
    "only-of-type": function(elem, _a) {
      var { adapter, equals } = _a;
      var elemName = adapter.getName(elem);
      return adapter.getSiblings(elem).every(function(sibling) {
        return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
      });
    },
    "only-child": function(elem, _a) {
      var { adapter, equals } = _a;
      return adapter.getSiblings(elem).every(function(sibling) {
        return equals(elem, sibling) || !adapter.isTag(sibling);
      });
    }
  };
  exports.verifyPseudoArgs = verifyPseudoArgs;
});

// ../../node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aliases = undefined;
  exports.aliases = {
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])"
  };
});

// ../../node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS((exports) => {
  var ensureIsTag = function(next, adapter) {
    if (next === boolbase_1.default.falseFunc)
      return boolbase_1.default.falseFunc;
    return function(elem) {
      return adapter.isTag(elem) && next(elem);
    };
  };
  var getNextSiblings = function(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
      return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
      return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
  };
  var copyOptions = function(options) {
    return {
      xmlMode: !!options.xmlMode,
      lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
      lowerCaseTags: !!options.lowerCaseTags,
      quirksMode: !!options.quirksMode,
      cacheResults: !!options.cacheResults,
      pseudos: options.pseudos,
      adapter: options.adapter,
      equals: options.equals
    };
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = undefined;
  var boolbase_1 = __importDefault(require_boolbase());
  var sort_js_1 = require_sort();
  exports.PLACEHOLDER_ELEMENT = {};
  exports.ensureIsTag = ensureIsTag;
  exports.getNextSiblings = getNextSiblings;
  var is = function(next, token, options, context, compileToken) {
    var func = compileToken(token, copyOptions(options), context);
    return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
      return func(elem) && next(elem);
    };
  };
  exports.subselects = {
    is,
    matches: is,
    where: is,
    not: function(next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
        return !func(elem) && next(elem);
      };
    },
    has: function(next, subselect, options, _context, compileToken) {
      var adapter = options.adapter;
      var opts = copyOptions(options);
      opts.relativeSelector = true;
      var context = subselect.some(function(s) {
        return s.some(sort_js_1.isTraversal);
      }) ? [exports.PLACEHOLDER_ELEMENT] : undefined;
      var compiled = compileToken(subselect, opts, context);
      if (compiled === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      var hasElement = ensureIsTag(compiled, adapter);
      if (context && compiled !== boolbase_1.default.trueFunc) {
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === undefined ? false : _a;
        return function(elem) {
          if (!next(elem))
            return false;
          context[0] = elem;
          var childs = adapter.getChildren(elem);
          var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
          return adapter.existsOne(hasElement, nextElements);
        };
      }
      return function(elem) {
        return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
      };
    }
  };
});

// ../../node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS((exports) => {
  var compilePseudoSelector = function(next, selector, options, context, compileToken) {
    var _a;
    var { name, data } = selector;
    if (Array.isArray(data)) {
      if (!(name in subselects_js_1.subselects)) {
        throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
      }
      return subselects_js_1.subselects[name](next, data, options, context, compileToken);
    }
    var userPseudo = (_a = options.pseudos) === null || _a === undefined ? undefined : _a[name];
    var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
    if (typeof stringPseudo === "string") {
      if (data != null) {
        throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
      }
      var alias = (0, css_what_1.parse)(stringPseudo);
      return subselects_js_1.subselects["is"](next, alias, options, context, compileToken);
    }
    if (typeof userPseudo === "function") {
      (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
      return function(elem) {
        return userPseudo(elem, data) && next(elem);
      };
    }
    if (name in filters_js_1.filters) {
      return filters_js_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_js_1.pseudos) {
      var pseudo_1 = pseudos_js_1.pseudos[name];
      (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
      return function(elem) {
        return pseudo_1(elem, options, data) && next(elem);
      };
    }
    throw new Error("Unknown pseudo-class :".concat(name));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = undefined;
  var css_what_1 = require_commonjs();
  var filters_js_1 = require_filters();
  Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
    return filters_js_1.filters;
  } });
  var pseudos_js_1 = require_pseudos();
  Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
    return pseudos_js_1.pseudos;
  } });
  var aliases_js_1 = require_aliases();
  Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
    return aliases_js_1.aliases;
  } });
  var subselects_js_1 = require_subselects();
  exports.compilePseudoSelector = compilePseudoSelector;
});

// ../../node_modules/css-select/lib/general.js
var require_general = __commonJS((exports) => {
  var getElementParent = function(node3, adapter) {
    var parent = adapter.getParent(node3);
    if (parent && adapter.isTag(parent)) {
      return parent;
    }
    return null;
  };
  var compileGeneralSelector = function(next, selector, options, context, compileToken) {
    var { adapter, equals } = options;
    switch (selector.type) {
      case css_what_1.SelectorType.PseudoElement: {
        throw new Error("Pseudo-elements are not supported by css-select");
      }
      case css_what_1.SelectorType.ColumnCombinator: {
        throw new Error("Column combinators are not yet supported by css-select");
      }
      case css_what_1.SelectorType.Attribute: {
        if (selector.namespace != null) {
          throw new Error("Namespaced attributes are not yet supported by css-select");
        }
        if (!options.xmlMode || options.lowerCaseAttributeNames) {
          selector.name = selector.name.toLowerCase();
        }
        return attributes_js_1.attributeRules[selector.action](next, selector, options);
      }
      case css_what_1.SelectorType.Pseudo: {
        return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);
      }
      case css_what_1.SelectorType.Tag: {
        if (selector.namespace != null) {
          throw new Error("Namespaced tag names are not yet supported by css-select");
        }
        var name_1 = selector.name;
        if (!options.xmlMode || options.lowerCaseTags) {
          name_1 = name_1.toLowerCase();
        }
        return function tag(elem) {
          return adapter.getName(elem) === name_1 && next(elem);
        };
      }
      case css_what_1.SelectorType.Descendant: {
        if (options.cacheResults === false || typeof WeakSet === "undefined") {
          return function descendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (next(current)) {
                return true;
              }
            }
            return false;
          };
        }
        var isFalseCache_1 = new WeakSet;
        return function cachedDescendant(elem) {
          var current = elem;
          while (current = getElementParent(current, adapter)) {
            if (!isFalseCache_1.has(current)) {
              if (adapter.isTag(current) && next(current)) {
                return true;
              }
              isFalseCache_1.add(current);
            }
          }
          return false;
        };
      }
      case "_flexibleDescendant": {
        return function flexibleDescendant(elem) {
          var current = elem;
          do {
            if (next(current))
              return true;
          } while (current = getElementParent(current, adapter));
          return false;
        };
      }
      case css_what_1.SelectorType.Parent: {
        return function parent(elem) {
          return adapter.getChildren(elem).some(function(elem2) {
            return adapter.isTag(elem2) && next(elem2);
          });
        };
      }
      case css_what_1.SelectorType.Child: {
        return function child(elem) {
          var parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(parent);
        };
      }
      case css_what_1.SelectorType.Sibling: {
        return function sibling(elem) {
          var siblings = adapter.getSiblings(elem);
          for (var i = 0;i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && next(currentSibling)) {
              return true;
            }
          }
          return false;
        };
      }
      case css_what_1.SelectorType.Adjacent: {
        if (adapter.prevElementSibling) {
          return function adjacent(elem) {
            var previous = adapter.prevElementSibling(elem);
            return previous != null && next(previous);
          };
        }
        return function adjacent(elem) {
          var siblings = adapter.getSiblings(elem);
          var lastElement;
          for (var i = 0;i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling)) {
              lastElement = currentSibling;
            }
          }
          return !!lastElement && next(lastElement);
        };
      }
      case css_what_1.SelectorType.Universal: {
        if (selector.namespace != null && selector.namespace !== "*") {
          throw new Error("Namespaced universal selectors are not yet supported by css-select");
        }
        return next;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compileGeneralSelector = undefined;
  var attributes_js_1 = require_attributes();
  var index_js_1 = require_pseudo_selectors();
  var css_what_1 = require_commonjs();
  exports.compileGeneralSelector = compileGeneralSelector;
});

// ../../node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS((exports) => {
  var compile = function(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
  };
  var compileUnsafe = function(selector, options, context) {
    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
    return compileToken(token, options, context);
  };
  var includesScopePseudo = function(t) {
    return t.type === css_what_1.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data) {
      return data.some(includesScopePseudo);
    }));
  };
  var absolutize = function(token, _a, context) {
    var adapter = _a.adapter;
    var hasContext = !!(context === null || context === undefined ? undefined : context.every(function(e) {
      var parent = adapter.isTag(e) && adapter.getParent(e);
      return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
    }));
    for (var _i = 0, token_1 = token;_i < token_1.length; _i++) {
      var t = token_1[_i];
      if (t.length > 0 && (0, sort_js_1.isTraversal)(t[0]) && t[0].type !== css_what_1.SelectorType.Descendant) {
      } else if (hasContext && !t.some(includesScopePseudo)) {
        t.unshift(DESCENDANT_TOKEN);
      } else {
        continue;
      }
      t.unshift(SCOPE_TOKEN);
    }
  };
  var compileToken = function(token, options, context) {
    var _a;
    token.forEach(sort_js_1.default);
    context = (_a = options.context) !== null && _a !== undefined ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    if (options.relativeSelector !== false) {
      absolutize(token, options, finalContext);
    } else if (token.some(function(t) {
      return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
    })) {
      throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
    }
    var shouldTestNextSiblings = false;
    var query3 = token.map(function(rules) {
      if (rules.length >= 2) {
        var first = rules[0], second = rules[1];
        if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {
        } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
          rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
        } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
          shouldTestNextSiblings = true;
        }
      }
      return compileRules(rules, options, finalContext);
    }).reduce(reduceRules, boolbase_1.default.falseFunc);
    query3.shouldTestNextSiblings = shouldTestNextSiblings;
    return query3;
  };
  var compileRules = function(rules, options, context) {
    var _a;
    return rules.reduce(function(previous, rule) {
      return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== undefined ? _a : boolbase_1.default.trueFunc);
  };
  var reduceRules = function(a, b) {
    if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
      return a;
    }
    if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
      return b;
    }
    return function combine(elem) {
      return a(elem) || b(elem);
    };
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compileToken = exports.compileUnsafe = exports.compile = undefined;
  var css_what_1 = require_commonjs();
  var boolbase_1 = __importDefault(require_boolbase());
  var sort_js_1 = __importStar(require_sort());
  var general_js_1 = require_general();
  var subselects_js_1 = require_subselects();
  exports.compile = compile;
  exports.compileUnsafe = compileUnsafe;
  var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
  var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant"
  };
  var SCOPE_TOKEN = {
    type: css_what_1.SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  exports.compileToken = compileToken;
});

// ../../node_modules/css-select/lib/index.js
var require_lib12 = __commonJS((exports) => {
  var convertOptionFormats = function(options) {
    var _a, _b, _c, _d;
    var opts = options !== null && options !== undefined ? options : defaultOptions;
    (_a = opts.adapter) !== null && _a !== undefined || (opts.adapter = DomUtils);
    (_b = opts.equals) !== null && _b !== undefined || (opts.equals = (_d = (_c = opts.adapter) === null || _c === undefined ? undefined : _c.equals) !== null && _d !== undefined ? _d : defaultEquals);
    return opts;
  };
  var wrapCompile = function(func) {
    return function addAdapter(selector, options, context) {
      var opts = convertOptionFormats(options);
      return func(selector, opts, context);
    };
  };
  var getSelectorFunc = function(searchFunc) {
    return function select(query3, elements, options) {
      var opts = convertOptionFormats(options);
      if (typeof query3 !== "function") {
        query3 = (0, compile_js_1.compileUnsafe)(query3, opts, elements);
      }
      var filteredElements = prepareContext(elements, opts.adapter, query3.shouldTestNextSiblings);
      return searchFunc(query3, filteredElements, opts);
    };
  };
  var prepareContext = function(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === undefined) {
      shouldTestNextSiblings = false;
    }
    if (shouldTestNextSiblings) {
      elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
  };
  var appendNextSiblings = function(elem, adapter) {
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i = 0;i < elemsLength; i++) {
      var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);
      elems.push.apply(elems, nextSiblings);
    }
    return elems;
  };
  var is = function(elem, query3, options) {
    var opts = convertOptionFormats(options);
    return (typeof query3 === "function" ? query3 : (0, compile_js_1.compile)(query3, opts))(elem);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = undefined;
  var DomUtils = __importStar(require_lib10());
  var boolbase_1 = __importDefault(require_boolbase());
  var compile_js_1 = require_compile2();
  var subselects_js_1 = require_subselects();
  var defaultEquals = function(a, b) {
    return a === b;
  };
  var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals
  };
  exports.compile = wrapCompile(compile_js_1.compile);
  exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
  exports._compileToken = wrapCompile(compile_js_1.compileToken);
  exports.prepareContext = prepareContext;
  exports.selectAll = getSelectorFunc(function(query3, elems, options) {
    return query3 === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query3, elems);
  });
  exports.selectOne = getSelectorFunc(function(query3, elems, options) {
    return query3 === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query3, elems);
  });
  exports.is = is;
  exports.default = exports.selectAll;
  var index_js_1 = require_pseudo_selectors();
  Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
    return index_js_1.filters;
  } });
  Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
    return index_js_1.pseudos;
  } });
  Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
    return index_js_1.aliases;
  } });
});

// ../../node_modules/node-html-parser/dist/back.js
var require_back = __commonJS((exports) => {
  var arr_back = function(arr) {
    return arr[arr.length - 1];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = arr_back;
});

// ../../node_modules/node-html-parser/dist/matcher.js
var require_matcher = __commonJS((exports) => {
  var isTag = function(node3) {
    return node3 && node3.nodeType === type_1.default.ELEMENT_NODE;
  };
  var getAttributeValue = function(elem, name) {
    return isTag(elem) ? elem.getAttribute(name) : undefined;
  };
  var getName = function(elem) {
    return (elem && elem.rawTagName || "").toLowerCase();
  };
  var getChildren = function(node3) {
    return node3 && node3.childNodes;
  };
  var getParent = function(node3) {
    return node3 ? node3.parentNode : null;
  };
  var getText = function(node3) {
    return node3.text;
  };
  var removeSubsets = function(nodes) {
    var idx = nodes.length;
    var node3;
    var ancestor;
    var replace;
    while (--idx > -1) {
      node3 = ancestor = nodes[idx];
      nodes[idx] = null;
      replace = true;
      while (ancestor) {
        if (nodes.indexOf(ancestor) > -1) {
          replace = false;
          nodes.splice(idx, 1);
          break;
        }
        ancestor = getParent(ancestor);
      }
      if (replace) {
        nodes[idx] = node3;
      }
    }
    return nodes;
  };
  var existsOne = function(test, elems) {
    return elems.some(function(elem) {
      return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;
    });
  };
  var getSiblings = function(node3) {
    var parent = getParent(node3);
    return parent ? getChildren(parent) : [];
  };
  var hasAttrib = function(elem, name) {
    return getAttributeValue(elem, name) !== undefined;
  };
  var findOne = function(test, elems) {
    var elem = null;
    for (var i = 0, l = elems === null || elems === undefined ? undefined : elems.length;i < l && !elem; i++) {
      var el = elems[i];
      if (test(el)) {
        elem = el;
      } else {
        var childs = getChildren(el);
        if (childs && childs.length > 0) {
          elem = findOne(test, childs);
        }
      }
    }
    return elem;
  };
  var findAll = function(test, nodes) {
    var result = [];
    for (var i = 0, j = nodes.length;i < j; i++) {
      if (!isTag(nodes[i]))
        continue;
      if (test(nodes[i]))
        result.push(nodes[i]);
      var childs = getChildren(nodes[i]);
      if (childs)
        result = result.concat(findAll(test, childs));
    }
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var type_1 = __importDefault(require_type());
  exports.default = {
    isTag,
    getAttributeValue,
    getName,
    getChildren,
    getParent,
    getText,
    removeSubsets,
    existsOne,
    getSiblings,
    hasAttrib,
    findOne,
    findAll
  };
});

// ../../node_modules/node-html-parser/dist/void-tag.js
var require_void_tag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var VoidTag = function() {
    function VoidTag2(addClosingSlash, tags) {
      if (addClosingSlash === undefined) {
        addClosingSlash = false;
      }
      this.addClosingSlash = addClosingSlash;
      if (Array.isArray(tags)) {
        this.voidTags = tags.reduce(function(set, tag) {
          return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
        }, new Set);
      } else {
        this.voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"].reduce(function(set, tag) {
          return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
        }, new Set);
      }
    }
    VoidTag2.prototype.formatNode = function(tag, attrs, innerHTML) {
      var addClosingSlash = this.addClosingSlash;
      var closingSpace = addClosingSlash && attrs && !attrs.endsWith(" ") ? " " : "";
      var closingSlash = addClosingSlash ? "".concat(closingSpace, "/") : "";
      return this.isVoidElement(tag.toLowerCase()) ? "<".concat(tag).concat(attrs).concat(closingSlash, ">") : "<".concat(tag).concat(attrs, ">").concat(innerHTML, "</").concat(tag, ">");
    };
    VoidTag2.prototype.isVoidElement = function(tag) {
      return this.voidTags.has(tag);
    };
    return VoidTag2;
  }();
  exports.default = VoidTag;
});

// ../../node_modules/node-html-parser/dist/nodes/text.js
var require_text = __commonJS((exports) => {
  var trimText = function(text) {
    var i = 0;
    var startPos;
    var endPos;
    while (i >= 0 && i < text.length) {
      if (/\S/.test(text[i])) {
        if (startPos === undefined) {
          startPos = i;
          i = text.length;
        } else {
          endPos = i;
          i = undefined;
        }
      }
      if (startPos === undefined)
        i++;
      else
        i--;
    }
    if (startPos === undefined)
      startPos = 0;
    if (endPos === undefined)
      endPos = text.length - 1;
    var hasLeadingSpace = startPos > 0 && /[^\S\r\n]/.test(text[startPos - 1]);
    var hasTrailingSpace = endPos < text.length - 1 && /[^\S\r\n]/.test(text[endPos + 1]);
    return (hasLeadingSpace ? " " : "") + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? " " : "");
  };
  var __extends2 = exports && exports.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var he_1 = require_he();
  var node_1 = __importDefault(require_node());
  var type_1 = __importDefault(require_type());
  var TextNode = function(_super) {
    __extends2(TextNode2, _super);
    function TextNode2(rawText, parentNode, range) {
      if (parentNode === undefined) {
        parentNode = null;
      }
      var _this = _super.call(this, parentNode, range) || this;
      _this.nodeType = type_1.default.TEXT_NODE;
      _this.rawTagName = "";
      _this._rawText = rawText;
      return _this;
    }
    TextNode2.prototype.clone = function() {
      return new TextNode2(this._rawText, null);
    };
    Object.defineProperty(TextNode2.prototype, "rawText", {
      get: function() {
        return this._rawText;
      },
      set: function(text) {
        this._rawText = text;
        this._trimmedRawText = undefined;
        this._trimmedText = undefined;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextNode2.prototype, "trimmedRawText", {
      get: function() {
        if (this._trimmedRawText !== undefined)
          return this._trimmedRawText;
        this._trimmedRawText = trimText(this.rawText);
        return this._trimmedRawText;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextNode2.prototype, "trimmedText", {
      get: function() {
        if (this._trimmedText !== undefined)
          return this._trimmedText;
        this._trimmedText = trimText(this.text);
        return this._trimmedText;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextNode2.prototype, "text", {
      get: function() {
        return (0, he_1.decode)(this.rawText);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextNode2.prototype, "isWhitespace", {
      get: function() {
        return /^(\s|&nbsp;)*$/.test(this.rawText);
      },
      enumerable: false,
      configurable: true
    });
    TextNode2.prototype.toString = function() {
      return this.rawText;
    };
    return TextNode2;
  }(node_1.default);
  exports.default = TextNode;
});

// ../../node_modules/node-html-parser/dist/nodes/html.js
var require_html = __commonJS((exports) => {
  var decode = function(val) {
    return JSON.parse(JSON.stringify(he_1.default.decode(val)));
  };
  var addToKBlockElement = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var addToSet = function(array) {
      for (var index = 0;index < array.length; index++) {
        var element = array[index];
        kBlockElements.add(element);
        kBlockElements.add(element.toUpperCase());
      }
    };
    for (var _a = 0, args_1 = args;_a < args_1.length; _a++) {
      var arg = args_1[_a];
      addToSet(arg);
    }
  };
  var base_parse = function(data, options) {
    var _a, _b;
    if (options === undefined) {
      options = {};
    }
    var voidTag = new void_tag_1.default((_a = options === null || options === undefined ? undefined : options.voidTag) === null || _a === undefined ? undefined : _a.closingSlash, (_b = options === null || options === undefined ? undefined : options.voidTag) === null || _b === undefined ? undefined : _b.tags);
    var elements = options.blockTextElements || {
      script: true,
      noscript: true,
      style: true,
      pre: true
    };
    var element_names = Object.keys(elements);
    var kBlockTextElements = element_names.map(function(it) {
      return new RegExp("^".concat(it, "$"), "i");
    });
    var kIgnoreElements = element_names.filter(function(it) {
      return Boolean(elements[it]);
    }).map(function(it) {
      return new RegExp("^".concat(it, "$"), "i");
    });
    function element_should_be_ignore(tag) {
      return kIgnoreElements.some(function(it) {
        return it.test(tag);
      });
    }
    function is_block_text_element(tag) {
      return kBlockTextElements.some(function(it) {
        return it.test(tag);
      });
    }
    var createRange = function(startPos, endPos) {
      return [startPos - frameFlagOffset, endPos - frameFlagOffset];
    };
    var root6 = new HTMLElement(null, {}, "", null, [0, data.length], voidTag, options);
    var currentParent = root6;
    var stack = [root6];
    var lastTextPos = -1;
    var noNestedTagIndex = undefined;
    var match;
    data = "<".concat(frameflag, ">").concat(data, "</").concat(frameflag, ">");
    var { lowerCaseTagName, fixNestedATags } = options;
    var dataEndPos = data.length - (frameflag.length + 2);
    var frameFlagOffset = frameflag.length + 2;
    while (match = kMarkupPattern.exec(data)) {
      var matchText = match[0], leadingSlash = match[1], tagName = match[2], attributes = match[3], closingSlash = match[4];
      var matchLength = matchText.length;
      var tagStartPos = kMarkupPattern.lastIndex - matchLength;
      var tagEndPos = kMarkupPattern.lastIndex;
      if (lastTextPos > -1) {
        if (lastTextPos + matchLength < tagEndPos) {
          var text = data.substring(lastTextPos, tagStartPos);
          currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));
        }
      }
      lastTextPos = kMarkupPattern.lastIndex;
      if (tagName === frameflag)
        continue;
      if (matchText[1] === "!") {
        if (options.comment) {
          var text = data.substring(tagStartPos + 4, tagEndPos - 3);
          currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));
        }
        continue;
      }
      if (lowerCaseTagName)
        tagName = tagName.toLowerCase();
      if (!leadingSlash) {
        var attrs = {};
        for (var attMatch = undefined;attMatch = kAttributePattern.exec(attributes); ) {
          var key = attMatch[1], val = attMatch[2];
          var isQuoted = val[0] === "'" || val[0] === "\"";
          attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;
        }
        var parentTagName = currentParent.rawTagName;
        if (!closingSlash && kElementsClosedByOpening[parentTagName]) {
          if (kElementsClosedByOpening[parentTagName][tagName]) {
            stack.pop();
            currentParent = (0, back_1.default)(stack);
          }
        }
        if (fixNestedATags && (tagName === "a" || tagName === "A")) {
          if (noNestedTagIndex !== undefined) {
            stack.splice(noNestedTagIndex);
            currentParent = (0, back_1.default)(stack);
          }
          noNestedTagIndex = stack.length;
        }
        var tagEndPos_1 = kMarkupPattern.lastIndex;
        var tagStartPos_1 = tagEndPos_1 - matchLength;
        currentParent = currentParent.appendChild(new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos_1, tagEndPos_1), voidTag, options));
        stack.push(currentParent);
        if (is_block_text_element(tagName)) {
          var closeMarkup = "</".concat(tagName, ">");
          var closeIndex = lowerCaseTagName ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);
          var textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;
          if (element_should_be_ignore(tagName)) {
            var text = data.substring(tagEndPos_1, textEndPos);
            if (text.length > 0 && /\S/.test(text)) {
              currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos_1, textEndPos)));
            }
          }
          if (closeIndex === -1) {
            lastTextPos = kMarkupPattern.lastIndex = data.length + 1;
          } else {
            lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;
            leadingSlash = "/";
          }
        }
      }
      if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {
        while (true) {
          if (noNestedTagIndex != null && (tagName === "a" || tagName === "A"))
            noNestedTagIndex = undefined;
          if (currentParent.rawTagName === tagName) {
            currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];
            stack.pop();
            currentParent = (0, back_1.default)(stack);
            break;
          } else {
            var parentTagName = currentParent.tagName;
            if (kElementsClosedByClosing[parentTagName]) {
              if (kElementsClosedByClosing[parentTagName][tagName]) {
                stack.pop();
                currentParent = (0, back_1.default)(stack);
                continue;
              }
            }
            break;
          }
        }
      }
    }
    return stack;
  };
  var parse2 = function(data, options) {
    if (options === undefined) {
      options = {};
    }
    var stack = base_parse(data, options);
    var root6 = stack[0];
    var _loop_1 = function() {
      var last = stack.pop();
      var oneBefore = (0, back_1.default)(stack);
      if (last.parentNode && last.parentNode.parentNode) {
        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {
          if (options.parseNoneClosedTags !== true) {
            oneBefore.removeChild(last);
            last.childNodes.forEach(function(child) {
              oneBefore.parentNode.appendChild(child);
            });
            stack.pop();
          }
        } else {
          if (options.parseNoneClosedTags !== true) {
            oneBefore.removeChild(last);
            last.childNodes.forEach(function(child) {
              oneBefore.appendChild(child);
            });
          }
        }
      } else {
      }
    };
    while (stack.length > 1) {
      _loop_1();
    }
    return root6;
  };
  var resetParent = function(nodes, parent) {
    return nodes.map(function(node3) {
      node3.parentNode = parent;
      return node3;
    });
  };
  var __extends2 = exports && exports.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = exports.base_parse = undefined;
  var css_select_1 = require_lib12();
  var he_1 = __importDefault(require_he());
  var back_1 = __importDefault(require_back());
  var matcher_1 = __importDefault(require_matcher());
  var void_tag_1 = __importDefault(require_void_tag());
  var comment_1 = __importDefault(require_comment());
  var node_1 = __importDefault(require_node());
  var text_1 = __importDefault(require_text());
  var type_1 = __importDefault(require_type());
  var Htags = ["h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup"];
  var Dtags = ["details", "dialog", "dd", "div", "dt"];
  var Ftags = ["fieldset", "figcaption", "figure", "footer", "form"];
  var tableTags = ["table", "td", "tr"];
  var htmlTags = ["address", "article", "aside", "blockquote", "br", "hr", "li", "main", "nav", "ol", "p", "pre", "section", "ul"];
  var kBlockElements = new Set;
  addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
  var DOMTokenList = function() {
    function DOMTokenList2(valuesInit, afterUpdate) {
      if (valuesInit === undefined) {
        valuesInit = [];
      }
      if (afterUpdate === undefined) {
        afterUpdate = function() {
          return null;
        };
      }
      this._set = new Set(valuesInit);
      this._afterUpdate = afterUpdate;
    }
    DOMTokenList2.prototype._validate = function(c) {
      if (/\s/.test(c)) {
        throw new Error("DOMException in DOMTokenList.add: The token '".concat(c, "' contains HTML space characters, which are not valid in tokens."));
      }
    };
    DOMTokenList2.prototype.add = function(c) {
      this._validate(c);
      this._set.add(c);
      this._afterUpdate(this);
    };
    DOMTokenList2.prototype.replace = function(c12, c2) {
      this._validate(c2);
      this._set.delete(c12);
      this._set.add(c2);
      this._afterUpdate(this);
    };
    DOMTokenList2.prototype.remove = function(c) {
      this._set.delete(c) && this._afterUpdate(this);
    };
    DOMTokenList2.prototype.toggle = function(c) {
      this._validate(c);
      if (this._set.has(c))
        this._set.delete(c);
      else
        this._set.add(c);
      this._afterUpdate(this);
    };
    DOMTokenList2.prototype.contains = function(c) {
      return this._set.has(c);
    };
    Object.defineProperty(DOMTokenList2.prototype, "length", {
      get: function() {
        return this._set.size;
      },
      enumerable: false,
      configurable: true
    });
    DOMTokenList2.prototype.values = function() {
      return this._set.values();
    };
    Object.defineProperty(DOMTokenList2.prototype, "value", {
      get: function() {
        return Array.from(this._set.values());
      },
      enumerable: false,
      configurable: true
    });
    DOMTokenList2.prototype.toString = function() {
      return Array.from(this._set.values()).join(" ");
    };
    return DOMTokenList2;
  }();
  var HTMLElement = function(_super) {
    __extends2(HTMLElement2, _super);
    function HTMLElement2(tagName, keyAttrs, rawAttrs, parentNode, range, voidTag, _parseOptions) {
      if (rawAttrs === undefined) {
        rawAttrs = "";
      }
      if (parentNode === undefined) {
        parentNode = null;
      }
      if (voidTag === undefined) {
        voidTag = new void_tag_1.default;
      }
      if (_parseOptions === undefined) {
        _parseOptions = {};
      }
      var _this = _super.call(this, parentNode, range) || this;
      _this.rawAttrs = rawAttrs;
      _this.voidTag = voidTag;
      _this.nodeType = type_1.default.ELEMENT_NODE;
      _this.rawTagName = tagName;
      _this.rawAttrs = rawAttrs || "";
      _this.id = keyAttrs.id || "";
      _this.childNodes = [];
      _this._parseOptions = _parseOptions;
      _this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\s+/) : [], function(classList) {
        return _this.setAttribute("class", classList.toString());
      });
      if (keyAttrs.id) {
        if (!rawAttrs) {
          _this.rawAttrs = "id=\"".concat(keyAttrs.id, "\"");
        }
      }
      if (keyAttrs.class) {
        if (!rawAttrs) {
          var cls = "class=\"".concat(_this.classList.toString(), "\"");
          if (_this.rawAttrs) {
            _this.rawAttrs += " ".concat(cls);
          } else {
            _this.rawAttrs = cls;
          }
        }
      }
      return _this;
    }
    HTMLElement2.prototype.quoteAttribute = function(attr) {
      if (attr == null) {
        return "null";
      }
      return JSON.stringify(attr.replace(/"/g, "&quot;")).replace(/\\t/g, "\t").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\/g, "");
    };
    HTMLElement2.prototype.removeChild = function(node3) {
      this.childNodes = this.childNodes.filter(function(child) {
        return child !== node3;
      });
      return this;
    };
    HTMLElement2.prototype.exchangeChild = function(oldNode, newNode) {
      var children = this.childNodes;
      this.childNodes = children.map(function(child) {
        if (child === oldNode) {
          return newNode;
        }
        return child;
      });
      return this;
    };
    Object.defineProperty(HTMLElement2.prototype, "tagName", {
      get: function() {
        return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;
      },
      set: function(newname) {
        this.rawTagName = newname.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "localName", {
      get: function() {
        return this.rawTagName.toLowerCase();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "isVoidElement", {
      get: function() {
        return this.voidTag.isVoidElement(this.localName);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "rawText", {
      get: function() {
        if (/^br$/i.test(this.rawTagName)) {
          return "\n";
        }
        return this.childNodes.reduce(function(pre, cur) {
          return pre += cur.rawText;
        }, "");
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "textContent", {
      get: function() {
        return decode(this.rawText);
      },
      set: function(val) {
        var content = [new text_1.default(val, this)];
        this.childNodes = content;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "text", {
      get: function() {
        return decode(this.rawText);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "structuredText", {
      get: function() {
        var currentBlock = [];
        var blocks = [currentBlock];
        function dfs(node3) {
          if (node3.nodeType === type_1.default.ELEMENT_NODE) {
            if (kBlockElements.has(node3.rawTagName)) {
              if (currentBlock.length > 0) {
                blocks.push(currentBlock = []);
              }
              node3.childNodes.forEach(dfs);
              if (currentBlock.length > 0) {
                blocks.push(currentBlock = []);
              }
            } else {
              node3.childNodes.forEach(dfs);
            }
          } else if (node3.nodeType === type_1.default.TEXT_NODE) {
            if (node3.isWhitespace) {
              currentBlock.prependWhitespace = true;
            } else {
              var text = node3.trimmedText;
              if (currentBlock.prependWhitespace) {
                text = " ".concat(text);
                currentBlock.prependWhitespace = false;
              }
              currentBlock.push(text);
            }
          }
        }
        dfs(this);
        return blocks.map(function(block2) {
          return block2.join("").replace(/\s{2,}/g, " ");
        }).join("\n").replace(/\s+$/, "");
      },
      enumerable: false,
      configurable: true
    });
    HTMLElement2.prototype.toString = function() {
      var tag = this.rawTagName;
      if (tag) {
        var attrs = this.rawAttrs ? " ".concat(this.rawAttrs) : "";
        return this.voidTag.formatNode(tag, attrs, this.innerHTML);
      }
      return this.innerHTML;
    };
    Object.defineProperty(HTMLElement2.prototype, "innerHTML", {
      get: function() {
        return this.childNodes.map(function(child) {
          return child.toString();
        }).join("");
      },
      set: function(content) {
        var r = parse2(content, this._parseOptions);
        var nodes = r.childNodes.length ? r.childNodes : [new text_1.default(content, this)];
        resetParent(nodes, this);
        resetParent(this.childNodes, null);
        this.childNodes = nodes;
      },
      enumerable: false,
      configurable: true
    });
    HTMLElement2.prototype.set_content = function(content, options) {
      if (options === undefined) {
        options = {};
      }
      if (content instanceof node_1.default) {
        content = [content];
      } else if (typeof content == "string") {
        options = __assign(__assign({}, this._parseOptions), options);
        var r = parse2(content, options);
        content = r.childNodes.length ? r.childNodes : [new text_1.default(r.innerHTML, this)];
      }
      resetParent(this.childNodes, null);
      resetParent(content, this);
      this.childNodes = content;
      return this;
    };
    HTMLElement2.prototype.replaceWith = function() {
      var _this = this;
      var nodes = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
      }
      var parent = this.parentNode;
      var content = nodes.map(function(node3) {
        if (node3 instanceof node_1.default) {
          return [node3];
        } else if (typeof node3 == "string") {
          var r = parse2(node3, _this._parseOptions);
          return r.childNodes.length ? r.childNodes : [new text_1.default(node3, _this)];
        }
        return [];
      }).flat();
      var idx = parent.childNodes.findIndex(function(child) {
        return child === _this;
      });
      resetParent([this], null);
      parent.childNodes = __spreadArray(__spreadArray(__spreadArray([], parent.childNodes.slice(0, idx), true), resetParent(content, parent), true), parent.childNodes.slice(idx + 1), true);
      return this;
    };
    Object.defineProperty(HTMLElement2.prototype, "outerHTML", {
      get: function() {
        return this.toString();
      },
      enumerable: false,
      configurable: true
    });
    HTMLElement2.prototype.trimRight = function(pattern) {
      for (var i = 0;i < this.childNodes.length; i++) {
        var childNode = this.childNodes[i];
        if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
          childNode.trimRight(pattern);
        } else {
          var index = childNode.rawText.search(pattern);
          if (index > -1) {
            childNode.rawText = childNode.rawText.substr(0, index);
            this.childNodes.length = i + 1;
          }
        }
      }
      return this;
    };
    Object.defineProperty(HTMLElement2.prototype, "structure", {
      get: function() {
        var res = [];
        var indention = 0;
        function write(str) {
          res.push("  ".repeat(indention) + str);
        }
        function dfs(node3) {
          var idStr = node3.id ? "#".concat(node3.id) : "";
          var classStr = node3.classList.length ? ".".concat(node3.classList.value.join(".")) : "";
          write("".concat(node3.rawTagName).concat(idStr).concat(classStr));
          indention++;
          node3.childNodes.forEach(function(childNode) {
            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
              dfs(childNode);
            } else if (childNode.nodeType === type_1.default.TEXT_NODE) {
              if (!childNode.isWhitespace) {
                write("#text");
              }
            }
          });
          indention--;
        }
        dfs(this);
        return res.join("\n");
      },
      enumerable: false,
      configurable: true
    });
    HTMLElement2.prototype.removeWhitespace = function() {
      var _this = this;
      var o = 0;
      this.childNodes.forEach(function(node3) {
        if (node3.nodeType === type_1.default.TEXT_NODE) {
          if (node3.isWhitespace) {
            return;
          }
          node3.rawText = node3.trimmedRawText;
        } else if (node3.nodeType === type_1.default.ELEMENT_NODE) {
          node3.removeWhitespace();
        }
        _this.childNodes[o++] = node3;
      });
      this.childNodes.length = o;
      return this;
    };
    HTMLElement2.prototype.querySelectorAll = function(selector) {
      return (0, css_select_1.selectAll)(selector, this, {
        xmlMode: true,
        adapter: matcher_1.default
      });
    };
    HTMLElement2.prototype.querySelector = function(selector) {
      return (0, css_select_1.selectOne)(selector, this, {
        xmlMode: true,
        adapter: matcher_1.default
      });
    };
    HTMLElement2.prototype.getElementsByTagName = function(tagName) {
      var upperCasedTagName = tagName.toUpperCase();
      var re = [];
      var stack = [];
      var currentNodeReference = this;
      var index = 0;
      while (index !== undefined) {
        var child = undefined;
        do {
          child = currentNodeReference.childNodes[index++];
        } while (index < currentNodeReference.childNodes.length && child === undefined);
        if (child === undefined) {
          currentNodeReference = currentNodeReference.parentNode;
          index = stack.pop();
          continue;
        }
        if (child.nodeType === type_1.default.ELEMENT_NODE) {
          if (tagName === "*" || child.tagName === upperCasedTagName)
            re.push(child);
          if (child.childNodes.length > 0) {
            stack.push(index);
            currentNodeReference = child;
            index = 0;
          }
        }
      }
      return re;
    };
    HTMLElement2.prototype.getElementById = function(id) {
      var stack = [];
      var currentNodeReference = this;
      var index = 0;
      while (index !== undefined) {
        var child = undefined;
        do {
          child = currentNodeReference.childNodes[index++];
        } while (index < currentNodeReference.childNodes.length && child === undefined);
        if (child === undefined) {
          currentNodeReference = currentNodeReference.parentNode;
          index = stack.pop();
          continue;
        }
        if (child.nodeType === type_1.default.ELEMENT_NODE) {
          if (child.id === id) {
            return child;
          }
          if (child.childNodes.length > 0) {
            stack.push(index);
            currentNodeReference = child;
            index = 0;
          }
        }
      }
      return null;
    };
    HTMLElement2.prototype.closest = function(selector) {
      var mapChild = new Map;
      var el = this;
      var old = null;
      function findOne(test, elems) {
        var elem = null;
        for (var i = 0, l = elems.length;i < l && !elem; i++) {
          var el_1 = elems[i];
          if (test(el_1)) {
            elem = el_1;
          } else {
            var child = mapChild.get(el_1);
            if (child) {
              elem = findOne(test, [child]);
            }
          }
        }
        return elem;
      }
      while (el) {
        mapChild.set(el, old);
        old = el;
        el = el.parentNode;
      }
      el = this;
      while (el) {
        var e = (0, css_select_1.selectOne)(selector, el, {
          xmlMode: true,
          adapter: __assign(__assign({}, matcher_1.default), { getChildren: function(node3) {
            var child = mapChild.get(node3);
            return child && [child];
          }, getSiblings: function(node3) {
            return [node3];
          }, findOne, findAll: function() {
            return [];
          } })
        });
        if (e) {
          return e;
        }
        el = el.parentNode;
      }
      return null;
    };
    HTMLElement2.prototype.appendChild = function(node3) {
      node3.remove();
      this.childNodes.push(node3);
      node3.parentNode = this;
      return node3;
    };
    Object.defineProperty(HTMLElement2.prototype, "firstChild", {
      get: function() {
        return this.childNodes[0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "lastChild", {
      get: function() {
        return (0, back_1.default)(this.childNodes);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "attrs", {
      get: function() {
        if (this._attrs) {
          return this._attrs;
        }
        this._attrs = {};
        var attrs = this.rawAttributes;
        for (var key in attrs) {
          var val = attrs[key] || "";
          this._attrs[key.toLowerCase()] = decode(val);
        }
        return this._attrs;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "attributes", {
      get: function() {
        var ret_attrs = {};
        var attrs = this.rawAttributes;
        for (var key in attrs) {
          var val = attrs[key] || "";
          ret_attrs[key] = decode(val);
        }
        return ret_attrs;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "rawAttributes", {
      get: function() {
        if (this._rawAttrs) {
          return this._rawAttrs;
        }
        var attrs = {};
        if (this.rawAttrs) {
          var re = /([a-zA-Z()[\]#@$.?:][a-zA-Z0-9-_:()[\]#]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
          var match = undefined;
          while (match = re.exec(this.rawAttrs)) {
            var key = match[1];
            var val = match[2] || null;
            if (val && (val[0] === "'" || val[0] === "\""))
              val = val.slice(1, val.length - 1);
            attrs[key] = attrs[key] || val;
          }
        }
        this._rawAttrs = attrs;
        return attrs;
      },
      enumerable: false,
      configurable: true
    });
    HTMLElement2.prototype.removeAttribute = function(key) {
      var _this = this;
      var attrs = this.rawAttributes;
      delete attrs[key];
      if (this._attrs) {
        delete this._attrs[key];
      }
      this.rawAttrs = Object.keys(attrs).map(function(name) {
        var val = _this.quoteAttribute(attrs[name]);
        if (val === "null" || val === '""')
          return name;
        return "".concat(name, "=").concat(val);
      }).join(" ");
      if (key === "id") {
        this.id = "";
      }
      return this;
    };
    HTMLElement2.prototype.hasAttribute = function(key) {
      return key.toLowerCase() in this.attrs;
    };
    HTMLElement2.prototype.getAttribute = function(key) {
      return this.attrs[key.toLowerCase()];
    };
    HTMLElement2.prototype.setAttribute = function(key, value) {
      var _this = this;
      if (arguments.length < 2) {
        throw new Error("Failed to execute 'setAttribute' on 'Element'");
      }
      var k2 = key.toLowerCase();
      var attrs = this.rawAttributes;
      for (var k in attrs) {
        if (k.toLowerCase() === k2) {
          key = k;
          break;
        }
      }
      attrs[key] = String(value);
      if (this._attrs) {
        this._attrs[k2] = decode(attrs[key]);
      }
      this.rawAttrs = Object.keys(attrs).map(function(name) {
        var val = _this.quoteAttribute(attrs[name]);
        if (val === "null" || val === '""')
          return name;
        return "".concat(name, "=").concat(val);
      }).join(" ");
      if (key === "id") {
        this.id = value;
      }
      return this;
    };
    HTMLElement2.prototype.setAttributes = function(attributes) {
      var _this = this;
      if (this._attrs) {
        delete this._attrs;
      }
      if (this._rawAttrs) {
        delete this._rawAttrs;
      }
      this.rawAttrs = Object.keys(attributes).map(function(name) {
        var val = attributes[name];
        if (val === "null" || val === '""')
          return name;
        return "".concat(name, "=").concat(_this.quoteAttribute(String(val)));
      }).join(" ");
      return this;
    };
    HTMLElement2.prototype.insertAdjacentHTML = function(where, html) {
      var _a, _b, _c;
      var _this = this;
      if (arguments.length < 2) {
        throw new Error("2 arguments required");
      }
      var p = parse2(html, this._parseOptions);
      if (where === "afterend") {
        var idx = this.parentNode.childNodes.findIndex(function(child) {
          return child === _this;
        });
        resetParent(p.childNodes, this.parentNode);
        (_a = this.parentNode.childNodes).splice.apply(_a, __spreadArray([idx + 1, 0], p.childNodes, false));
      } else if (where === "afterbegin") {
        resetParent(p.childNodes, this);
        (_b = this.childNodes).unshift.apply(_b, p.childNodes);
      } else if (where === "beforeend") {
        p.childNodes.forEach(function(n) {
          _this.appendChild(n);
        });
      } else if (where === "beforebegin") {
        var idx = this.parentNode.childNodes.findIndex(function(child) {
          return child === _this;
        });
        resetParent(p.childNodes, this.parentNode);
        (_c = this.parentNode.childNodes).splice.apply(_c, __spreadArray([idx, 0], p.childNodes, false));
      } else {
        throw new Error("The value provided ('".concat(where, "') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'"));
      }
      return this;
    };
    Object.defineProperty(HTMLElement2.prototype, "nextSibling", {
      get: function() {
        if (this.parentNode) {
          var children = this.parentNode.childNodes;
          var i = 0;
          while (i < children.length) {
            var child = children[i++];
            if (this === child)
              return children[i] || null;
          }
          return null;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "nextElementSibling", {
      get: function() {
        if (this.parentNode) {
          var children = this.parentNode.childNodes;
          var i = 0;
          var find = false;
          while (i < children.length) {
            var child = children[i++];
            if (find) {
              if (child instanceof HTMLElement2) {
                return child || null;
              }
            } else if (this === child) {
              find = true;
            }
          }
          return null;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "previousSibling", {
      get: function() {
        if (this.parentNode) {
          var children = this.parentNode.childNodes;
          var i = children.length;
          while (i > 0) {
            var child = children[--i];
            if (this === child)
              return children[i - 1] || null;
          }
          return null;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "previousElementSibling", {
      get: function() {
        if (this.parentNode) {
          var children = this.parentNode.childNodes;
          var i = children.length;
          var find = false;
          while (i > 0) {
            var child = children[--i];
            if (find) {
              if (child instanceof HTMLElement2) {
                return child || null;
              }
            } else if (this === child) {
              find = true;
            }
          }
          return null;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLElement2.prototype, "classNames", {
      get: function() {
        return this.classList.toString();
      },
      enumerable: false,
      configurable: true
    });
    HTMLElement2.prototype.clone = function() {
      return parse2(this.toString(), this._parseOptions).firstChild;
    };
    return HTMLElement2;
  }(node_1.default);
  exports.default = HTMLElement;
  var kMarkupPattern = /<!--[\s\S]*?-->|<(\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\s+[^>]*?(?:(?:'[^']*')|(?:"[^"]*"))?)*)\s*(\/?)>/g;
  var kAttributePattern = /(?:^|\s)(id|class)\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+)/gi;
  var kElementsClosedByOpening = {
    li: { li: true, LI: true },
    LI: { li: true, LI: true },
    p: { p: true, div: true, P: true, DIV: true },
    P: { p: true, div: true, P: true, DIV: true },
    b: { div: true, DIV: true },
    B: { div: true, DIV: true },
    td: { td: true, th: true, TD: true, TH: true },
    TD: { td: true, th: true, TD: true, TH: true },
    th: { td: true, th: true, TD: true, TH: true },
    TH: { td: true, th: true, TD: true, TH: true },
    h1: { h1: true, H1: true },
    H1: { h1: true, H1: true },
    h2: { h2: true, H2: true },
    H2: { h2: true, H2: true },
    h3: { h3: true, H3: true },
    H3: { h3: true, H3: true },
    h4: { h4: true, H4: true },
    H4: { h4: true, H4: true },
    h5: { h5: true, H5: true },
    H5: { h5: true, H5: true },
    h6: { h6: true, H6: true },
    H6: { h6: true, H6: true }
  };
  var kElementsClosedByClosing = {
    li: { ul: true, ol: true, UL: true, OL: true },
    LI: { ul: true, ol: true, UL: true, OL: true },
    a: { div: true, DIV: true },
    A: { div: true, DIV: true },
    b: { div: true, DIV: true },
    B: { div: true, DIV: true },
    i: { div: true, DIV: true },
    I: { div: true, DIV: true },
    p: { div: true, DIV: true },
    P: { div: true, DIV: true },
    td: { tr: true, table: true, TR: true, TABLE: true },
    TD: { tr: true, table: true, TR: true, TABLE: true },
    th: { tr: true, table: true, TR: true, TABLE: true },
    TH: { tr: true, table: true, TR: true, TABLE: true }
  };
  var frameflag = "documentfragmentcontainer";
  exports.base_parse = base_parse;
  exports.parse = parse2;
});

// ../../node_modules/node-html-parser/dist/parse.js
var require_parse5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var html_1 = require_html();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return html_1.parse;
  } });
});

// ../../node_modules/node-html-parser/dist/valid.js
var require_valid = __commonJS((exports) => {
  var valid = function(data, options) {
    if (options === undefined) {
      options = {};
    }
    var stack = (0, html_1.base_parse)(data, options);
    return Boolean(stack.length === 1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var html_1 = require_html();
  exports.default = valid;
});

// ../../node_modules/node-html-parser/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var parse2 = function(data, options) {
    if (options === undefined) {
      options = {};
    }
    return (0, parse_1.default)(data, options);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeType = exports.TextNode = exports.Node = exports.valid = exports.CommentNode = exports.HTMLElement = exports.parse = undefined;
  var comment_1 = __importDefault(require_comment());
  exports.CommentNode = comment_1.default;
  var html_1 = __importDefault(require_html());
  exports.HTMLElement = html_1.default;
  var node_1 = __importDefault(require_node());
  exports.Node = node_1.default;
  var text_1 = __importDefault(require_text());
  exports.TextNode = text_1.default;
  var type_1 = __importDefault(require_type());
  exports.NodeType = type_1.default;
  var parse_1 = __importDefault(require_parse5());
  var valid_1 = __importDefault(require_valid());
  exports.valid = valid_1.default;
  exports.default = parse2;
  exports.parse = parse2;
  parse2.parse = parse_1.default;
  parse2.HTMLElement = html_1.default;
  parse2.CommentNode = comment_1.default;
  parse2.valid = valid_1.default;
  parse2.Node = node_1.default;
  parse2.TextNode = text_1.default;
  parse2.NodeType = type_1.default;
});

// ../../node_modules/elysia/dist/bun/index.js
var eW = Object.create;
var { defineProperty: S6, getPrototypeOf: $X, getOwnPropertyNames: YX } = Object;
var WX = Object.prototype.hasOwnProperty;
var Q1 = ($, Y, W) => {
  W = $ != null ? eW($X($)) : {};
  const X = Y || !$ || !$.__esModule ? S6(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of YX($))
    if (!WX.call(X, Z))
      S6(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var J0 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var b6 = J0((O7, a$) => {
  var s1 = function() {
  }, QX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, I6 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new QX(W, X || $, Z), J = V0 ? V0 + Y : Y;
    if (!$._events[J])
      $._events[J] = Q, $._eventsCount++;
    else if (!$._events[J].fn)
      $._events[J].push(Q);
    else
      $._events[J] = [$._events[J], Q];
    return $;
  }, K$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new s1;
    else
      delete $._events[Y];
  }, G0 = function() {
    this._events = new s1, this._eventsCount = 0;
  }, ZX = Object.prototype.hasOwnProperty, V0 = "~";
  if (Object.create) {
    if (s1.prototype = Object.create(null), !new s1().__proto__)
      V0 = false;
  }
  G0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (ZX.call(W, X))
        Y.push(V0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  G0.prototype.listeners = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, Q = X.length, J = new Array(Q);Z < Q; Z++)
      J[Z] = X[Z].fn;
    return J;
  };
  G0.prototype.listenerCount = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  G0.prototype.emit = function $(Y, W, X, Z, Q, J) {
    var z = V0 ? V0 + Y : Y;
    if (!this._events[z])
      return false;
    var U = this._events[z], D = arguments.length, B, j;
    if (U.fn) {
      if (U.once)
        this.removeListener(Y, U.fn, undefined, true);
      switch (D) {
        case 1:
          return U.fn.call(U.context), true;
        case 2:
          return U.fn.call(U.context, W), true;
        case 3:
          return U.fn.call(U.context, W, X), true;
        case 4:
          return U.fn.call(U.context, W, X, Z), true;
        case 5:
          return U.fn.call(U.context, W, X, Z, Q), true;
        case 6:
          return U.fn.call(U.context, W, X, Z, Q, J), true;
      }
      for (j = 1, B = new Array(D - 1);j < D; j++)
        B[j - 1] = arguments[j];
      U.fn.apply(U.context, B);
    } else {
      var b = U.length, S;
      for (j = 0;j < b; j++) {
        if (U[j].once)
          this.removeListener(Y, U[j].fn, undefined, true);
        switch (D) {
          case 1:
            U[j].fn.call(U[j].context);
            break;
          case 2:
            U[j].fn.call(U[j].context, W);
            break;
          case 3:
            U[j].fn.call(U[j].context, W, X);
            break;
          case 4:
            U[j].fn.call(U[j].context, W, X, Z);
            break;
          default:
            if (!B)
              for (S = 1, B = new Array(D - 1);S < D; S++)
                B[S - 1] = arguments[S];
            U[j].fn.apply(U[j].context, B);
        }
      }
    }
    return true;
  };
  G0.prototype.on = function $(Y, W, X) {
    return I6(this, Y, W, X, false);
  };
  G0.prototype.once = function $(Y, W, X) {
    return I6(this, Y, W, X, true);
  };
  G0.prototype.removeListener = function $(Y, W, X, Z) {
    var Q = V0 ? V0 + Y : Y;
    if (!this._events[Q])
      return this;
    if (!W)
      return K$(this, Q), this;
    var J = this._events[Q];
    if (J.fn) {
      if (J.fn === W && (!Z || J.once) && (!X || J.context === X))
        K$(this, Q);
    } else {
      for (var z = 0, U = [], D = J.length;z < D; z++)
        if (J[z].fn !== W || Z && !J[z].once || X && J[z].context !== X)
          U.push(J[z]);
      if (U.length)
        this._events[Q] = U.length === 1 ? U[0] : U;
      else
        K$(this, Q);
    }
    return this;
  };
  G0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = V0 ? V0 + Y : Y, this._events[W])
        K$(this, W);
    } else
      this._events = new s1, this._eventsCount = 0;
    return this;
  };
  G0.prototype.off = G0.prototype.removeListener;
  G0.prototype.addListener = G0.prototype.on;
  G0.prefixed = V0;
  G0.EventEmitter = G0;
  if (typeof a$ !== "undefined")
    a$.exports = G0;
});
var x0 = J0((d6) => {
  var JX = function($) {
    return j$($) && Symbol.asyncIterator in $;
  }, zX = function($) {
    return j$($) && Symbol.iterator in $;
  }, HX = function($) {
    return ArrayBuffer.isView($);
  }, qX = function($) {
    return $ instanceof Promise;
  }, MX = function($) {
    return $ instanceof Uint8Array;
  }, NX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, FX = function($, Y) {
    return Y in $;
  }, UX = function($) {
    return j$($) && f6($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, AX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E6 = function($) {
    return $ === undefined;
  }, V6 = function($) {
    return $ === null;
  }, x6 = function($) {
    return typeof $ === "boolean";
  }, e$ = function($) {
    return typeof $ === "number";
  }, BX = function($) {
    return e$($) && Number.isInteger($);
  }, k6 = function($) {
    return typeof $ === "bigint";
  }, g6 = function($) {
    return typeof $ === "string";
  }, f6 = function($) {
    return typeof $ === "function";
  }, T6 = function($) {
    return typeof $ === "symbol";
  }, DX = function($) {
    return k6($) || x6($) || V6($) || e$($) || g6($) || T6($) || E6($);
  };
  Object.defineProperty(d6, "__esModule", { value: true });
  d6.IsValueType = d6.IsSymbol = d6.IsFunction = d6.IsString = d6.IsBigInt = d6.IsInteger = d6.IsNumber = d6.IsBoolean = d6.IsNull = d6.IsUndefined = d6.IsArray = d6.IsObject = d6.IsPlainObject = d6.HasPropertyKey = d6.IsDate = d6.IsUint8Array = d6.IsPromise = d6.IsTypedArray = d6.IsIterator = d6.IsAsyncIterator = undefined;
  d6.IsAsyncIterator = JX;
  d6.IsIterator = zX;
  d6.IsTypedArray = HX;
  d6.IsPromise = qX;
  d6.IsUint8Array = MX;
  d6.IsDate = NX;
  d6.HasPropertyKey = FX;
  d6.IsPlainObject = UX;
  d6.IsObject = j$;
  d6.IsArray = AX;
  d6.IsUndefined = E6;
  d6.IsNull = V6;
  d6.IsBoolean = x6;
  d6.IsNumber = e$;
  d6.IsInteger = BX;
  d6.IsBigInt = k6;
  d6.IsString = g6;
  d6.IsFunction = f6;
  d6.IsSymbol = T6;
  d6.IsValueType = DX;
});
var f0 = J0((m6) => {
  Object.defineProperty(m6, "__esModule", { value: true });
  m6.Type = m6.JsonType = m6.JavaScriptTypeBuilder = m6.JsonTypeBuilder = m6.TypeBuilder = m6.TypeBuilderError = m6.TransformEncodeBuilder = m6.TransformDecodeBuilder = m6.TemplateLiteralDslParser = m6.TemplateLiteralGenerator = m6.TemplateLiteralGeneratorError = m6.TemplateLiteralFinite = m6.TemplateLiteralFiniteError = m6.TemplateLiteralParser = m6.TemplateLiteralParserError = m6.TemplateLiteralResolver = m6.TemplateLiteralPattern = m6.TemplateLiteralPatternError = m6.UnionResolver = m6.KeyArrayResolver = m6.KeyArrayResolverError = m6.KeyResolver = m6.ObjectMap = m6.Intrinsic = m6.IndexedAccessor = m6.TypeClone = m6.TypeExtends = m6.TypeExtendsResult = m6.TypeExtendsError = m6.ExtendsUndefined = m6.TypeGuard = m6.TypeGuardUnknownTypeError = m6.ValueGuard = m6.FormatRegistry = m6.TypeBoxError = m6.TypeRegistry = m6.PatternStringExact = m6.PatternNumberExact = m6.PatternBooleanExact = m6.PatternString = m6.PatternNumber = m6.PatternBoolean = m6.Kind = m6.Hint = m6.Optional = m6.Readonly = m6.Transform = undefined;
  m6.Transform = Symbol.for("TypeBox.Transform");
  m6.Readonly = Symbol.for("TypeBox.Readonly");
  m6.Optional = Symbol.for("TypeBox.Optional");
  m6.Hint = Symbol.for("TypeBox.Hint");
  m6.Kind = Symbol.for("TypeBox.Kind");
  m6.PatternBoolean = "(true|false)";
  m6.PatternNumber = "(0|[1-9][0-9]*)";
  m6.PatternString = "(.*)";
  m6.PatternBooleanExact = `^${m6.PatternBoolean}$`;
  m6.PatternNumberExact = `^${m6.PatternNumber}$`;
  m6.PatternStringExact = `^${m6.PatternString}$`;
  var $8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })($8 || (m6.TypeRegistry = $8 = {}));

  class $1 extends Error {
    constructor($) {
      super($);
    }
  }
  m6.TypeBoxError = $1;
  var v6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })(v6 || (m6.FormatRegistry = v6 = {}));
  var V;
  (function($) {
    function Y(D) {
      return Array.isArray(D);
    }
    $.IsArray = Y;
    function W(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = W;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function Q(D) {
      return typeof D === "number";
    }
    $.IsNumber = Q;
    function J(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = J;
    function z(D) {
      return typeof D === "string";
    }
    $.IsString = z;
    function U(D) {
      return D === undefined;
    }
    $.IsUndefined = U;
  })(V || (m6.ValueGuard = V = {}));

  class i6 extends $1 {
  }
  m6.TypeGuardUnknownTypeError = i6;
  var A;
  (function($) {
    function Y(M) {
      try {
        return new RegExp(M), true;
      } catch {
        return false;
      }
    }
    function W(M) {
      if (!V.IsString(M))
        return false;
      for (let l = 0;l < M.length; l++) {
        const S0 = M.charCodeAt(l);
        if (S0 >= 7 && S0 <= 13 || S0 === 27 || S0 === 127)
          return false;
      }
      return true;
    }
    function X(M) {
      return J(M) || X0(M);
    }
    function Z(M) {
      return V.IsUndefined(M) || V.IsBigInt(M);
    }
    function Q(M) {
      return V.IsUndefined(M) || V.IsNumber(M);
    }
    function J(M) {
      return V.IsUndefined(M) || V.IsBoolean(M);
    }
    function z(M) {
      return V.IsUndefined(M) || V.IsString(M);
    }
    function U(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M) && Y(M);
    }
    function D(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M);
    }
    function B(M) {
      return V.IsUndefined(M) || X0(M);
    }
    function j(M) {
      return _(M, "Any") && z(M.$id);
    }
    $.TAny = j;
    function b(M) {
      return _(M, "Array") && M.type === "array" && z(M.$id) && X0(M.items) && Q(M.minItems) && Q(M.maxItems) && J(M.uniqueItems) && B(M.contains) && Q(M.minContains) && Q(M.maxContains);
    }
    $.TArray = b;
    function S(M) {
      return _(M, "AsyncIterator") && M.type === "AsyncIterator" && z(M.$id) && X0(M.items);
    }
    $.TAsyncIterator = S;
    function N(M) {
      return _(M, "BigInt") && M.type === "bigint" && z(M.$id) && Z(M.exclusiveMaximum) && Z(M.exclusiveMinimum) && Z(M.maximum) && Z(M.minimum) && Z(M.multipleOf);
    }
    $.TBigInt = N;
    function O(M) {
      return _(M, "Boolean") && M.type === "boolean" && z(M.$id);
    }
    $.TBoolean = O;
    function P(M) {
      return _(M, "Constructor") && M.type === "Constructor" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TConstructor = P;
    function F(M) {
      return _(M, "Date") && M.type === "Date" && z(M.$id) && Q(M.exclusiveMaximumTimestamp) && Q(M.exclusiveMinimumTimestamp) && Q(M.maximumTimestamp) && Q(M.minimumTimestamp) && Q(M.multipleOfTimestamp);
    }
    $.TDate = F;
    function w(M) {
      return _(M, "Function") && M.type === "Function" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TFunction = w;
    function I(M) {
      return _(M, "Integer") && M.type === "integer" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TInteger = I;
    function G(M) {
      return _(M, "Intersect") && (V.IsString(M.type) && M.type !== "object" ? false : true) && V.IsArray(M.allOf) && M.allOf.every((l) => X0(l) && !w0(l)) && z(M.type) && (J(M.unevaluatedProperties) || B(M.unevaluatedProperties)) && z(M.$id);
    }
    $.TIntersect = G;
    function k(M) {
      return _(M, "Iterator") && M.type === "Iterator" && z(M.$id) && X0(M.items);
    }
    $.TIterator = k;
    function _(M, l) {
      return e(M) && M[m6.Kind] === l;
    }
    $.TKindOf = _;
    function e(M) {
      return V.IsObject(M) && m6.Kind in M && V.IsString(M[m6.Kind]);
    }
    $.TKind = e;
    function o(M) {
      return b0(M) && V.IsString(M.const);
    }
    $.TLiteralString = o;
    function r(M) {
      return b0(M) && V.IsNumber(M.const);
    }
    $.TLiteralNumber = r;
    function g0(M) {
      return b0(M) && V.IsBoolean(M.const);
    }
    $.TLiteralBoolean = g0;
    function b0(M) {
      return _(M, "Literal") && z(M.$id) && (V.IsBoolean(M.const) || V.IsNumber(M.const) || V.IsString(M.const));
    }
    $.TLiteral = b0;
    function E0(M) {
      return _(M, "Never") && V.IsObject(M.not) && Object.getOwnPropertyNames(M.not).length === 0;
    }
    $.TNever = E0;
    function H0(M) {
      return _(M, "Not") && X0(M.not);
    }
    $.TNot = H0;
    function z0(M) {
      return _(M, "Null") && M.type === "null" && z(M.$id);
    }
    $.TNull = z0;
    function u0(M) {
      return _(M, "Number") && M.type === "number" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TNumber = u0;
    function a0(M) {
      return _(M, "Object") && M.type === "object" && z(M.$id) && V.IsObject(M.properties) && X(M.additionalProperties) && Q(M.minProperties) && Q(M.maxProperties) && Object.entries(M.properties).every(([l, S0]) => W(l) && X0(S0));
    }
    $.TObject = a0;
    function v0(M) {
      return _(M, "Promise") && M.type === "Promise" && z(M.$id) && X0(M.item);
    }
    $.TPromise = v0;
    function R(M) {
      return _(M, "Record") && M.type === "object" && z(M.$id) && X(M.additionalProperties) && V.IsObject(M.patternProperties) && ((l) => {
        const S0 = Object.getOwnPropertyNames(l.patternProperties);
        return S0.length === 1 && Y(S0[0]) && V.IsObject(l.patternProperties) && X0(l.patternProperties[S0[0]]);
      })(M);
    }
    $.TRecord = R;
    function f(M) {
      return V.IsObject(M) && m6.Hint in M && M[m6.Hint] === "Recursive";
    }
    $.TRecursive = f;
    function i(M) {
      return _(M, "Ref") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TRef = i;
    function n(M) {
      return _(M, "String") && M.type === "string" && z(M.$id) && Q(M.minLength) && Q(M.maxLength) && U(M.pattern) && D(M.format);
    }
    $.TString = n;
    function q0(M) {
      return _(M, "Symbol") && M.type === "symbol" && z(M.$id);
    }
    $.TSymbol = q0;
    function B0(M) {
      return _(M, "TemplateLiteral") && M.type === "string" && V.IsString(M.pattern) && M.pattern[0] === "^" && M.pattern[M.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = B0;
    function D0(M) {
      return _(M, "This") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TThis = D0;
    function w0(M) {
      return V.IsObject(M) && m6.Transform in M;
    }
    $.TTransform = w0;
    function M0(M) {
      return _(M, "Tuple") && M.type === "array" && z(M.$id) && V.IsNumber(M.minItems) && V.IsNumber(M.maxItems) && M.minItems === M.maxItems && (V.IsUndefined(M.items) && V.IsUndefined(M.additionalItems) && M.minItems === 0 || V.IsArray(M.items) && M.items.every((l) => X0(l)));
    }
    $.TTuple = M0;
    function B1(M) {
      return _(M, "Undefined") && M.type === "undefined" && z(M.$id);
    }
    $.TUndefined = B1;
    function K(M) {
      return E(M) && M.anyOf.every((l) => o(l) || r(l));
    }
    $.TUnionLiteral = K;
    function E(M) {
      return _(M, "Union") && z(M.$id) && V.IsObject(M) && V.IsArray(M.anyOf) && M.anyOf.every((l) => X0(l));
    }
    $.TUnion = E;
    function L(M) {
      return _(M, "Uint8Array") && M.type === "Uint8Array" && z(M.$id) && Q(M.minByteLength) && Q(M.maxByteLength);
    }
    $.TUint8Array = L;
    function p(M) {
      return _(M, "Unknown") && z(M.$id);
    }
    $.TUnknown = p;
    function T(M) {
      return _(M, "Unsafe");
    }
    $.TUnsafe = T;
    function d(M) {
      return _(M, "Void") && M.type === "void" && z(M.$id);
    }
    $.TVoid = d;
    function W0(M) {
      return V.IsObject(M) && M[m6.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function j0(M) {
      return V.IsObject(M) && M[m6.Optional] === "Optional";
    }
    $.TOptional = j0;
    function X0(M) {
      return V.IsObject(M) && (j(M) || b(M) || O(M) || N(M) || S(M) || P(M) || F(M) || w(M) || I(M) || G(M) || k(M) || b0(M) || E0(M) || H0(M) || z0(M) || u0(M) || a0(M) || v0(M) || R(M) || i(M) || n(M) || q0(M) || B0(M) || D0(M) || M0(M) || B1(M) || E(M) || L(M) || p(M) || T(M) || d(M) || e(M) && $8.Has(M[m6.Kind]));
    }
    $.TSchema = X0;
  })(A || (m6.TypeGuard = A = {}));
  var p6;
  (function($) {
    function Y(W) {
      return W[m6.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[m6.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[m6.Kind] === "Undefined" ? true : W[m6.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(p6 || (m6.ExtendsUndefined = p6 = {}));

  class Z8 extends $1 {
  }
  m6.TypeExtendsError = Z8;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (m6.TypeExtendsResult = C = {}));
  var j1;
  (function($) {
    function Y(H) {
      return H === C.False ? H : C.True;
    }
    function W(H) {
      throw new Z8(H);
    }
    function X(H) {
      return A.TNever(H) || A.TIntersect(H) || A.TUnion(H) || A.TUnknown(H) || A.TAny(H);
    }
    function Z(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : W("StructuralRight");
    }
    function Q(H, q) {
      return C.True;
    }
    function J(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) && q.anyOf.some(($0) => A.TAny($0) || A.TUnknown($0)) ? C.True : A.TUnion(q) ? C.Union : A.TUnknown(q) ? C.True : A.TAny(q) ? C.True : C.Union;
    }
    function z(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) ? C.True : C.False;
    }
    function U(H, q) {
      return A.TObject(q) && B0(q) ? C.True : X(q) ? Z(H, q) : !A.TArray(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function D(H, q) {
      return X(q) ? Z(H, q) : !A.TAsyncIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function B(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBigInt(q) ? C.True : C.False;
    }
    function j(H, q) {
      return A.TLiteral(H) && V.IsBoolean(H.const) ? C.True : A.TBoolean(H) ? C.True : C.False;
    }
    function b(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBoolean(q) ? C.True : C.False;
    }
    function S(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TConstructor(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function N(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TDate(q) ? C.True : C.False;
    }
    function O(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TFunction(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function P(H, q) {
      return A.TLiteral(H) && V.IsNumber(H.const) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function F(H, q) {
      return A.TInteger(q) || A.TNumber(q) ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : C.False;
    }
    function w(H, q) {
      return q.allOf.every(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function I(H, q) {
      return H.allOf.some(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function G(H, q) {
      return X(q) ? Z(H, q) : !A.TIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function k(H, q) {
      return A.TLiteral(q) && q.const === H.const ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : C.False;
    }
    function _(H, q) {
      return C.False;
    }
    function e(H, q) {
      return C.True;
    }
    function o(H) {
      let [q, $0] = [H, 0];
      while (true) {
        if (!A.TNot(q))
          break;
        q = q.not, $0 += 1;
      }
      return $0 % 2 === 0 ? q : m6.Type.Unknown();
    }
    function r(H, q) {
      return A.TNot(H) ? Q0(o(H), q) : A.TNot(q) ? Q0(H, o(q)) : W("Invalid fallthrough for Not");
    }
    function g0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TNull(q) ? C.True : C.False;
    }
    function b0(H, q) {
      return A.TLiteralNumber(H) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function E0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TInteger(q) || A.TNumber(q) ? C.True : C.False;
    }
    function H0(H, q) {
      return Object.getOwnPropertyNames(H.properties).length === q;
    }
    function z0(H) {
      return B0(H);
    }
    function u0(H) {
      return H0(H, 0) || H0(H, 1) && "description" in H.properties && A.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (A.TString(H.properties.description.anyOf[0]) && A.TUndefined(H.properties.description.anyOf[1]) || A.TString(H.properties.description.anyOf[1]) && A.TUndefined(H.properties.description.anyOf[0]));
    }
    function a0(H) {
      return H0(H, 0);
    }
    function v0(H) {
      return H0(H, 0);
    }
    function R(H) {
      return H0(H, 0);
    }
    function f(H) {
      return H0(H, 0);
    }
    function i(H) {
      return B0(H);
    }
    function n(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && "length" in H.properties && Y(Q0(H.properties.length, q)) === C.True;
    }
    function q0(H) {
      return H0(H, 0);
    }
    function B0(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && "length" in H.properties && Y(Q0(H.properties.length, q)) === C.True;
    }
    function D0(H) {
      const q = m6.Type.Function([m6.Type.Any()], m6.Type.Any());
      return H0(H, 0) || H0(H, 1) && "then" in H.properties && Y(Q0(H.properties.then, q)) === C.True;
    }
    function w0(H, q) {
      return Q0(H, q) === C.False ? C.False : A.TOptional(H) && !A.TOptional(q) ? C.False : C.True;
    }
    function M0(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) || A.TLiteralString(H) && z0(q) || A.TLiteralNumber(H) && a0(q) || A.TLiteralBoolean(H) && v0(q) || A.TSymbol(H) && u0(q) || A.TBigInt(H) && R(q) || A.TString(H) && z0(q) || A.TSymbol(H) && u0(q) || A.TNumber(H) && a0(q) || A.TInteger(H) && a0(q) || A.TBoolean(H) && v0(q) || A.TUint8Array(H) && i(q) || A.TDate(H) && f(q) || A.TConstructor(H) && q0(q) || A.TFunction(H) && n(q) ? C.True : A.TRecord(H) && A.TString(E(H)) ? (() => {
        return q[m6.Hint] === "Record" ? C.True : C.False;
      })() : A.TRecord(H) && A.TNumber(E(H)) ? (() => {
        return H0(q, 0) ? C.True : C.False;
      })() : C.False;
    }
    function B1(H, q) {
      return X(q) ? Z(H, q) : A.TRecord(q) ? p(H, q) : !A.TObject(q) ? C.False : (() => {
        for (let $0 of Object.getOwnPropertyNames(q.properties)) {
          if (!($0 in H.properties))
            return C.False;
          if (w0(H.properties[$0], q.properties[$0]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function K(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && D0(q) ? C.True : !A.TPromise(q) ? C.False : Y(Q0(H.item, q.item));
    }
    function E(H) {
      return m6.PatternNumberExact in H.patternProperties ? m6.Type.Number() : (m6.PatternStringExact in H.patternProperties) ? m6.Type.String() : W("Unknown record key pattern");
    }
    function L(H) {
      return m6.PatternNumberExact in H.patternProperties ? H.patternProperties[m6.PatternNumberExact] : (m6.PatternStringExact in H.patternProperties) ? H.patternProperties[m6.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(H, q) {
      const [$0, h0] = [E(q), L(q)];
      return A.TLiteralString(H) && A.TNumber($0) && Y(Q0(H, h0)) === C.True ? C.True : A.TUint8Array(H) && A.TNumber($0) ? Q0(H, h0) : A.TString(H) && A.TNumber($0) ? Q0(H, h0) : A.TArray(H) && A.TNumber($0) ? Q0(H, h0) : A.TObject(H) ? (() => {
        for (let aW of Object.getOwnPropertyNames(H.properties))
          if (w0(h0, H.properties[aW]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function T(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TRecord(q) ? C.False : Q0(L(H), L(q));
    }
    function d(H, q) {
      return A.TLiteral(H) && V.IsString(H.const) ? C.True : A.TString(H) ? C.True : C.False;
    }
    function W0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? C.True : C.False;
    }
    function j0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TSymbol(q) ? C.True : C.False;
    }
    function X0(H, q) {
      return A.TTemplateLiteral(H) ? Q0(J1.Resolve(H), q) : A.TTemplateLiteral(q) ? Q0(H, J1.Resolve(q)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function M(H, q) {
      return A.TArray(q) && H.items !== undefined && H.items.every(($0) => Q0($0, q.items) === C.True);
    }
    function l(H, q) {
      return A.TNever(H) ? C.True : A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : C.False;
    }
    function S0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && B0(q) ? C.True : A.TArray(q) && M(H, q) ? C.True : !A.TTuple(q) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) || !V.IsUndefined(H.items) && V.IsUndefined(q.items) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) ? C.True : H.items.every(($0, h0) => Q0($0, q.items[h0]) === C.True) ? C.True : C.False;
    }
    function l$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TUint8Array(q) ? C.True : C.False;
    }
    function t$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TVoid(q) ? tW(H, q) : A.TUndefined(q) ? C.True : C.False;
    }
    function s$(H, q) {
      return q.anyOf.some(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function cW(H, q) {
      return H.anyOf.every(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function O6(H, q) {
      return C.True;
    }
    function lW(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TAny(q) ? Q(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : A.TArray(q) ? z(H, q) : A.TTuple(q) ? l(H, q) : A.TObject(q) ? M0(H, q) : A.TUnknown(q) ? C.True : C.False;
    }
    function tW(H, q) {
      return A.TUndefined(H) ? C.True : A.TUndefined(H) ? C.True : C.False;
    }
    function sW(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : A.TObject(q) ? M0(H, q) : A.TVoid(q) ? C.True : C.False;
    }
    function Q0(H, q) {
      return A.TTemplateLiteral(H) || A.TTemplateLiteral(q) ? X0(H, q) : A.TNot(H) || A.TNot(q) ? r(H, q) : A.TAny(H) ? J(H, q) : A.TArray(H) ? U(H, q) : A.TBigInt(H) ? B(H, q) : A.TBoolean(H) ? b(H, q) : A.TAsyncIterator(H) ? D(H, q) : A.TConstructor(H) ? S(H, q) : A.TDate(H) ? N(H, q) : A.TFunction(H) ? O(H, q) : A.TInteger(H) ? F(H, q) : A.TIntersect(H) ? I(H, q) : A.TIterator(H) ? G(H, q) : A.TLiteral(H) ? k(H, q) : A.TNever(H) ? e(H, q) : A.TNull(H) ? g0(H, q) : A.TNumber(H) ? E0(H, q) : A.TObject(H) ? B1(H, q) : A.TRecord(H) ? T(H, q) : A.TString(H) ? W0(H, q) : A.TSymbol(H) ? j0(H, q) : A.TTuple(H) ? S0(H, q) : A.TPromise(H) ? K(H, q) : A.TUint8Array(H) ? l$(H, q) : A.TUndefined(H) ? t$(H, q) : A.TUnion(H) ? cW(H, q) : A.TUnknown(H) ? lW(H, q) : A.TVoid(H) ? sW(H, q) : W(`Unknown left type operand '${H[m6.Kind]}'`);
    }
    function rW(H, q) {
      return Q0(H, q);
    }
    $.Extends = rW;
  })(j1 || (m6.TypeExtends = j1 = {}));
  var m;
  (function($) {
    function Y(J) {
      const z = Object.getOwnPropertyNames(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {}), U = Object.getOwnPropertySymbols(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {});
      return { ...z, ...U };
    }
    function W(J) {
      return J.map((z) => X(z));
    }
    function X(J) {
      return V.IsArray(J) ? W(J) : V.IsObject(J) ? Y(J) : J;
    }
    function Z(J) {
      return J.map((z) => Q(z));
    }
    $.Rest = Z;
    function Q(J, z = {}) {
      return { ...X(J), ...z };
    }
    $.Type = Q;
  })(m || (m6.TypeClone = m = {}));
  var Y8;
  (function($) {
    function Y(S) {
      return S.map((N) => {
        const { [m6.Optional]: O, ...P } = m.Type(N);
        return P;
      });
    }
    function W(S) {
      return S.every((N) => A.TOptional(N));
    }
    function X(S) {
      return S.some((N) => A.TOptional(N));
    }
    function Z(S) {
      return W(S.allOf) ? m6.Type.Optional(m6.Type.Intersect(Y(S.allOf))) : S;
    }
    function Q(S) {
      return X(S.anyOf) ? m6.Type.Optional(m6.Type.Union(Y(S.anyOf))) : S;
    }
    function J(S) {
      return S[m6.Kind] === "Intersect" ? Z(S) : S[m6.Kind] === "Union" ? Q(S) : S;
    }
    function z(S, N) {
      const O = S.allOf.reduce((P, F) => {
        const w = j(F, N);
        return w[m6.Kind] === "Never" ? P : [...P, w];
      }, []);
      return J(m6.Type.Intersect(O));
    }
    function U(S, N) {
      const O = S.anyOf.map((P) => j(P, N));
      return J(m6.Type.Union(O));
    }
    function D(S, N) {
      const O = S.properties[N];
      return V.IsUndefined(O) ? m6.Type.Never() : m6.Type.Union([O]);
    }
    function B(S, N) {
      const O = S.items;
      if (V.IsUndefined(O))
        return m6.Type.Never();
      const P = O[N];
      if (V.IsUndefined(P))
        return m6.Type.Never();
      return P;
    }
    function j(S, N) {
      return S[m6.Kind] === "Intersect" ? z(S, N) : S[m6.Kind] === "Union" ? U(S, N) : S[m6.Kind] === "Object" ? D(S, N) : S[m6.Kind] === "Tuple" ? B(S, N) : m6.Type.Never();
    }
    function b(S, N, O = {}) {
      const P = N.map((F) => j(S, F.toString()));
      return J(m6.Type.Union(P, O));
    }
    $.Resolve = b;
  })(Y8 || (m6.IndexedAccessor = Y8 = {}));
  var V1;
  (function($) {
    function Y(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toLowerCase()}${b}`;
    }
    function W(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toUpperCase()}${b}`;
    }
    function X(B) {
      return B.toUpperCase();
    }
    function Z(B) {
      return B.toLowerCase();
    }
    function Q(B, j) {
      const b = f1.ParseExact(B.pattern);
      if (!T1.Check(b))
        return { ...B, pattern: J(B.pattern, j) };
      const O = [...d1.Generate(b)].map((w) => m6.Type.Literal(w)), P = z(O, j), F = m6.Type.Union(P);
      return m6.Type.TemplateLiteral([F]);
    }
    function J(B, j) {
      return typeof B === "string" ? j === "Uncapitalize" ? Y(B) : j === "Capitalize" ? W(B) : j === "Uppercase" ? X(B) : j === "Lowercase" ? Z(B) : B : B.toString();
    }
    function z(B, j) {
      if (B.length === 0)
        return [];
      const [b, ...S] = B;
      return [D(b, j), ...z(S, j)];
    }
    function U(B, j) {
      return A.TTemplateLiteral(B) ? Q(B, j) : A.TUnion(B) ? m6.Type.Union(z(B.anyOf, j)) : A.TLiteral(B) ? m6.Type.Literal(J(B.const, j)) : B;
    }
    function D(B, j) {
      return U(B, j);
    }
    $.Map = D;
  })(V1 || (m6.Intrinsic = V1 = {}));
  var x1;
  (function($) {
    function Y(J, z) {
      return m6.Type.Intersect(J.allOf.map((U) => Z(U, z)), { ...J });
    }
    function W(J, z) {
      return m6.Type.Union(J.anyOf.map((U) => Z(U, z)), { ...J });
    }
    function X(J, z) {
      return z(J);
    }
    function Z(J, z) {
      return J[m6.Kind] === "Intersect" ? Y(J, z) : J[m6.Kind] === "Union" ? W(J, z) : J[m6.Kind] === "Object" ? X(J, z) : J;
    }
    function Q(J, z, U) {
      return { ...Z(m.Type(J), z), ...U };
    }
    $.Map = Q;
  })(x1 || (m6.ObjectMap = x1 = {}));
  var P$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function W(D, B) {
      return D.allOf.reduce((j, b) => [...j, ...J(b, B)], []);
    }
    function X(D, B) {
      const j = D.anyOf.map((b) => J(b, B));
      return [...j.reduce((b, S) => S.map((N) => j.every((O) => O.includes(N)) ? b.add(N) : b)[0], new Set)];
    }
    function Z(D, B) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function Q(D, B) {
      return B.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function J(D, B) {
      return A.TIntersect(D) ? W(D, B) : A.TUnion(D) ? X(D, B) : A.TObject(D) ? Z(D, B) : A.TRecord(D) ? Q(D, B) : [];
    }
    function z(D, B) {
      return [...new Set(J(D, B))];
    }
    $.ResolveKeys = z;
    function U(D) {
      return `^(${z(D, { includePatterns: true }).map((b) => `(${Y(b)})`).join("|")})$`;
    }
    $.ResolvePattern = U;
  })(P$ || (m6.KeyResolver = P$ = {}));

  class Q8 extends $1 {
  }
  m6.KeyArrayResolverError = Q8;
  var r1;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : A.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : A.TLiteral(W) ? [W.const] : A.TTemplateLiteral(W) ? (() => {
        const X = f1.ParseExact(W.pattern);
        if (!T1.Check(X))
          throw new Q8("Cannot resolve keys from infinite template expression");
        return [...d1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(r1 || (m6.KeyArrayResolver = r1 = {}));
  var W8;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m6.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return m6.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(W8 || (m6.UnionResolver = W8 = {}));

  class J8 extends $1 {
  }
  m6.TemplateLiteralPatternError = J8;
  var O$;
  (function($) {
    function Y(Q) {
      throw new J8(Q);
    }
    function W(Q) {
      return Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(Q, J) {
      return A.TTemplateLiteral(Q) ? Q.pattern.slice(1, Q.pattern.length - 1) : A.TUnion(Q) ? `(${Q.anyOf.map((z) => X(z, J)).join("|")})` : A.TNumber(Q) ? `${J}${m6.PatternNumber}` : A.TInteger(Q) ? `${J}${m6.PatternNumber}` : A.TBigInt(Q) ? `${J}${m6.PatternNumber}` : A.TString(Q) ? `${J}${m6.PatternString}` : A.TLiteral(Q) ? `${J}${W(Q.const.toString())}` : A.TBoolean(Q) ? `${J}${m6.PatternBoolean}` : Y(`Unexpected Kind '${Q[m6.Kind]}'`);
    }
    function Z(Q) {
      return `^${Q.map((J) => X(J, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m6.TemplateLiteralPattern = O$ = {}));
  var J1;
  (function($) {
    function Y(W) {
      const X = f1.ParseExact(W.pattern);
      if (!T1.Check(X))
        return m6.Type.String();
      const Z = [...d1.Generate(X)].map((Q) => m6.Type.Literal(Q));
      return m6.Type.Union(Z);
    }
    $.Resolve = Y;
  })(J1 || (m6.TemplateLiteralResolver = J1 = {}));

  class S$ extends $1 {
  }
  m6.TemplateLiteralParserError = S$;
  var f1;
  (function($) {
    function Y(S, N, O) {
      return S[N] === O && S.charCodeAt(N - 1) !== 92;
    }
    function W(S, N) {
      return Y(S, N, "(");
    }
    function X(S, N) {
      return Y(S, N, ")");
    }
    function Z(S, N) {
      return Y(S, N, "|");
    }
    function Q(S) {
      if (!(W(S, 0) && X(S, S.length - 1)))
        return false;
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (N === 0 && O !== S.length - 1)
          return false;
      }
      return true;
    }
    function J(S) {
      return S.slice(1, S.length - 1);
    }
    function z(S) {
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (Z(S, O) && N === 0)
          return true;
      }
      return false;
    }
    function U(S) {
      for (let N = 0;N < S.length; N++)
        if (W(S, N))
          return true;
      return false;
    }
    function D(S) {
      let [N, O] = [0, 0];
      const P = [];
      for (let w = 0;w < S.length; w++) {
        if (W(S, w))
          N += 1;
        if (X(S, w))
          N -= 1;
        if (Z(S, w) && N === 0) {
          const I = S.slice(O, w);
          if (I.length > 0)
            P.push(j(I));
          O = w + 1;
        }
      }
      const F = S.slice(O);
      if (F.length > 0)
        P.push(j(F));
      if (P.length === 0)
        return { type: "const", const: "" };
      if (P.length === 1)
        return P[0];
      return { type: "or", expr: P };
    }
    function B(S) {
      function N(F, w) {
        if (!W(F, w))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let I = 0;
        for (let G = w;G < F.length; G++) {
          if (W(F, G))
            I += 1;
          if (X(F, G))
            I -= 1;
          if (I === 0)
            return [w, G];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function O(F, w) {
        for (let I = w;I < F.length; I++)
          if (W(F, I))
            return [w, I];
        return [w, F.length];
      }
      const P = [];
      for (let F = 0;F < S.length; F++)
        if (W(S, F)) {
          const [w, I] = N(S, F), G = S.slice(w, I + 1);
          P.push(j(G)), F = I;
        } else {
          const [w, I] = O(S, F), G = S.slice(w, I);
          if (G.length > 0)
            P.push(j(G));
          F = I - 1;
        }
      return P.length === 0 ? { type: "const", const: "" } : P.length === 1 ? P[0] : { type: "and", expr: P };
    }
    function j(S) {
      return Q(S) ? j(J(S)) : z(S) ? D(S) : U(S) ? B(S) : { type: "const", const: S };
    }
    $.Parse = j;
    function b(S) {
      return j(S.slice(1, S.length - 1));
    }
    $.ParseExact = b;
  })(f1 || (m6.TemplateLiteralParser = f1 = {}));

  class z8 extends $1 {
  }
  m6.TemplateLiteralFiniteError = z8;
  var T1;
  (function($) {
    function Y(J) {
      throw new z8(J);
    }
    function W(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "0" && J.expr[1].type === "const" && J.expr[1].const === "[1-9][0-9]*";
    }
    function X(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "true" && J.expr[1].type === "const" && J.expr[1].const === "false";
    }
    function Z(J) {
      return J.type === "const" && J.const === ".*";
    }
    function Q(J) {
      return X(J) ? true : W(J) || Z(J) ? false : J.type === "and" ? J.expr.every((z) => Q(z)) : J.type === "or" ? J.expr.every((z) => Q(z)) : J.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = Q;
  })(T1 || (m6.TemplateLiteralFinite = T1 = {}));

  class H8 extends $1 {
  }
  m6.TemplateLiteralGeneratorError = H8;
  var d1;
  (function($) {
    function* Y(J) {
      if (J.length === 1)
        return yield* J[0];
      for (let z of J[0])
        for (let U of Y(J.slice(1)))
          yield `${z}${U}`;
    }
    function* W(J) {
      return yield* Y(J.expr.map((z) => [...Q(z)]));
    }
    function* X(J) {
      for (let z of J.expr)
        yield* Q(z);
    }
    function* Z(J) {
      return yield J.const;
    }
    function* Q(J) {
      return J.type === "and" ? yield* W(J) : J.type === "or" ? yield* X(J) : J.type === "const" ? yield* Z(J) : (() => {
        throw new H8("Unknown expression");
      })();
    }
    $.Generate = Q;
  })(d1 || (m6.TemplateLiteralGenerator = d1 = {}));
  var X8;
  (function($) {
    function* Y(Q) {
      const J = Q.trim().replace(/"|'/g, "");
      return J === "boolean" ? yield m6.Type.Boolean() : J === "number" ? yield m6.Type.Number() : J === "bigint" ? yield m6.Type.BigInt() : J === "string" ? yield m6.Type.String() : yield (() => {
        const z = J.split("|").map((U) => m6.Type.Literal(U.trim()));
        return z.length === 0 ? m6.Type.Never() : z.length === 1 ? z[0] : m6.Type.Union(z);
      })();
    }
    function* W(Q) {
      if (Q[1] !== "{") {
        const J = m6.Type.Literal("$"), z = X(Q.slice(1));
        return yield* [J, ...z];
      }
      for (let J = 2;J < Q.length; J++)
        if (Q[J] === "}") {
          const z = Y(Q.slice(2, J)), U = X(Q.slice(J + 1));
          return yield* [...z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function* X(Q) {
      for (let J = 0;J < Q.length; J++)
        if (Q[J] === "$") {
          const z = m6.Type.Literal(Q.slice(0, J)), U = W(Q.slice(J));
          return yield* [z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(X8 || (m6.TemplateLiteralDslParser = X8 = {}));

  class q8 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new M8(this.schema, $);
    }
  }
  m6.TransformDecodeBuilder = q8;

  class M8 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = m.Type(this.schema);
      return A.TTransform(Y) ? (() => {
        const Z = { Encode: (Q) => Y[m6.Transform].Encode($(Q)), Decode: (Q) => this.decode(Y[m6.Transform].Decode(Q)) };
        return { ...Y, [m6.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [m6.Transform]: W };
      })();
    }
  }
  m6.TransformEncodeBuilder = M8;
  var TX = 0;

  class N8 extends $1 {
  }
  m6.TypeBuilderError = N8;

  class F8 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new N8($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...Q } = W;
        return Q;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m6.TypeBuilder = F8;

  class L$ extends F8 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...m.Type($), [m6.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...m.Type($), [m6.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Array", type: "array", items: m.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = m6.Type.Intersect($, {}), Z = P$.ResolveKeys(W, { includePatterns: false }).reduce((Q, J) => ({ ...Q, [J]: m6.Type.Index(W, [J]) }), {});
      return m6.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const W = Object.getOwnPropertyNames($).filter((Q) => isNaN(Q)).map((Q) => $[Q]), Z = [...new Set(W)].map((Q) => m6.Type.Literal(Q));
      return this.Union(Z, { ...Y, [m6.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (j1.Extends($, Y)) {
        case C.Union:
          return this.Union([m.Type(W, Z), m.Type(X, Z)]);
        case C.True:
          return m.Type(W, Z);
        case C.False:
          return m.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Exclude(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Exclude($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) === C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? this.Never(W) : m.Type($, W);
    }
    Extract($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Extract(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Extract($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) !== C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? m.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return A.TArray($) && A.TNumber(Y) ? (() => {
        return m.Type($.items, W);
      })() : A.TTuple($) && A.TNumber(Y) ? (() => {
        const Z = (V.IsUndefined($.items) ? [] : $.items).map((Q) => m.Type(Q));
        return this.Union(Z, W);
      })() : (() => {
        const X = r1.Resolve(Y), Z = m.Type($);
        return Y8.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m6.Type.Never();
      if ($.length === 1)
        return m.Type($[0], Y);
      if ($.some((Q) => A.TTransform(Q)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((Q) => A.TObject(Q)), X = m.Rest($), Z = A.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: m.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || A.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return A.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === m6.PatternNumberExact ? this.Number(Y) : W === m6.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : A.TTuple($) ? (() => {
        const X = (V.IsUndefined($.items) ? [] : $.items).map((Z, Q) => m6.Type.Literal(Q.toString()));
        return this.Union(X, Y);
      })() : A.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = P$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m6.Kind]: "Not", not: m.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((z) => A.TOptional($[z])), Z = W.filter((z) => !X.includes(z)), Q = A.TSchema(Y.additionalProperties) ? { additionalProperties: m.Type(Y.additionalProperties) } : {}, J = W.reduce((z, U) => ({ ...z, [U]: m.Type($[U]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J, required: Z }) : this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J });
    }
    Omit($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(W.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return A.TTemplateLiteral($) ? (() => {
        const X = f1.ParseExact($.pattern);
        return T1.Check(X) ? this.Object([...d1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: m.Type(Y) }), {}), W) : this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: m.Type(Y) } });
      })() : A.TUnion($) ? (() => {
        const X = W8.Resolve($);
        if (A.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, J) => ({ ...Q, [J.const]: m.Type(Y) }), {});
          return this.Object(Z, { ...W, [m6.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : A.TLiteral($) ? (() => {
        return V.IsString($.const) || V.IsNumber($.const) ? this.Object({ [$.const]: m.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : A.TInteger($) || A.TNumber($) ? (() => {
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [m6.PatternNumberExact]: m.Type(Y) } });
      })() : A.TString($) ? (() => {
        const X = V.IsUndefined($.pattern) ? m6.PatternStringExact : $.pattern;
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [X]: m.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (V.IsUndefined(Y.$id))
        Y.$id = `T${TX++}`;
      const W = $({ [m6.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [m6.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (V.IsString($))
        return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $ });
      if (V.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(W.properties[Q], [m6.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return A.TTuple($) && !V.IsUndefined($.items) ? m.Rest($.items) : A.TIntersect($) ? m.Rest($.allOf) : A.TUnion($) ? m.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = V.IsString($) ? O$.Create(X8.Parse($)) : O$.Create($);
      return this.Create({ ...Y, [m6.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new q8($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], Q = m.Rest($), J = $.length > 0 ? { ...Y, [m6.Kind]: "Tuple", type: "array", items: Q, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [m6.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(J);
    }
    Uncapitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return A.TTemplateLiteral($) ? J1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(m.Type(W[0], Y));
        const X = m.Rest(W);
        return this.Create({ ...Y, [m6.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m6.Kind]: $[m6.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uppercase"), ...Y };
    }
  }
  m6.JsonTypeBuilder = L$;

  class U8 extends L$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "AsyncIterator", type: "AsyncIterator", items: m.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...W(Q)];
      })() : X;
      return A.TIntersect($) ? m6.Type.Intersect(W($.allOf)) : A.TUnion($) ? m6.Type.Union(W($.anyOf)) : A.TPromise($) ? this.Awaited($.item) : m.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Iterator", type: "Iterator", items: m.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Promise", type: "Promise", item: m.Type($) });
    }
    RegExp($, Y = {}) {
      const W = V.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m6.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m6.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Void", type: "void" });
    }
  }
  m6.JavaScriptTypeBuilder = U8;
  m6.JsonType = new L$;
  m6.Type = new U8;
});
var P8 = J0((n6) => {
  var w8 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[z1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(n6, "__esModule", { value: true });
  n6.DefaultErrorFunction = n6.TypeSystemPolicy = n6.TypeSystemErrorFunction = n6.TypeSystem = n6.TypeSystemDuplicateFormat = n6.TypeSystemDuplicateTypeKind = undefined;
  var C$ = x0(), y = $$(), z1 = f0();

  class K8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateTypeKind = K8;

  class j8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateFormat = j8;
  var u6;
  (function($) {
    function Y(X, Z) {
      if (z1.TypeRegistry.Has(X))
        throw new K8(X);
      return z1.TypeRegistry.Set(X, Z), (Q = {}) => z1.Type.Unsafe({ ...Q, [z1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (z1.FormatRegistry.Has(X))
        throw new j8(X);
      return z1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })(u6 || (n6.TypeSystem = u6 = {}));
  var h6;
  (function($) {
    let Y = w8;
    function W() {
      Y = w8;
    }
    $.Reset = W;
    function X(Q) {
      Y = Q;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(h6 || (n6.TypeSystemErrorFunction = h6 = {}));
  var o6;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(J, z) {
      return $.ExactOptionalPropertyTypes ? z in J : J[z] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      const z = (0, C$.IsObject)(J);
      return $.AllowArrayObject ? z : z && !(0, C$.IsArray)(J);
    }
    $.IsObjectLike = W;
    function X(J) {
      return W(J) && !(J instanceof Date) && !(J instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(J) {
      const z = (0, C$.IsNumber)(J);
      return $.AllowNaN ? z : z && Number.isFinite(J);
    }
    $.IsNumberLike = Z;
    function Q(J) {
      const z = (0, C$.IsUndefined)(J);
      return $.AllowNullVoid ? z || J === null : z;
    }
    $.IsVoidLike = Q;
  })(o6 || (n6.TypeSystemPolicy = o6 = {}));
  n6.DefaultErrorFunction = w8;
});
var D1 = J0((l6) => {
  var IZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new O8($);
    return Y[W];
  };
  Object.defineProperty(l6, "__esModule", { value: true });
  l6.Deref = l6.TypeDereferenceError = undefined;
  var CZ = f0();

  class O8 extends CZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l6.TypeDereferenceError = O8;
  l6.Deref = IZ;
});
var Y$ = J0((e6) => {
  function* EZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var VZ = function($) {
    R0(T0.Array);
    for (let Y of $)
      v1(Y);
  }, xZ = function($) {
    R0(T0.Boolean), R0($ ? 1 : 0);
  }, kZ = function($) {
    R0(T0.BigInt), r6.setBigInt64(0, $);
    for (let Y of a6)
      R0(Y);
  }, gZ = function($) {
    R0(T0.Date), v1($.getTime());
  }, fZ = function($) {
    R0(T0.Null);
  }, TZ = function($) {
    R0(T0.Number), r6.setFloat64(0, $);
    for (let Y of a6)
      R0(Y);
  }, dZ = function($) {
    R0(T0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      v1(Y), v1($[Y]);
  }, yZ = function($) {
    R0(T0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of EZ($.charCodeAt(Y)))
        R0(W);
  }, vZ = function($) {
    R0(T0.Symbol), v1($.description);
  }, pZ = function($) {
    R0(T0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      R0($[Y]);
  }, iZ = function($) {
    return R0(T0.Undefined);
  }, v1 = function($) {
    if ((0, o0.IsArray)($))
      return VZ($);
    if ((0, o0.IsBoolean)($))
      return xZ($);
    if ((0, o0.IsBigInt)($))
      return kZ($);
    if ((0, o0.IsDate)($))
      return gZ($);
    if ((0, o0.IsNull)($))
      return fZ($);
    if ((0, o0.IsNumber)($))
      return TZ($);
    if ((0, o0.IsPlainObject)($))
      return dZ($);
    if ((0, o0.IsString)($))
      return yZ($);
    if ((0, o0.IsSymbol)($))
      return vZ($);
    if ((0, o0.IsUint8Array)($))
      return pZ($);
    if ((0, o0.IsUndefined)($))
      return iZ($);
    throw new S8($);
  }, R0 = function($) {
    y1 = y1 ^ _Z[$], y1 = y1 * GZ % RZ;
  }, mZ = function($) {
    return y1 = BigInt("14695981039346656037"), v1($), y1;
  };
  Object.defineProperty(e6, "__esModule", { value: true });
  e6.Hash = e6.ByteMarker = e6.ValueHashError = undefined;
  var o0 = x0();

  class S8 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e6.ValueHashError = S8;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e6.ByteMarker = T0 = {}));
  var y1 = BigInt("14695981039346656037"), [GZ, RZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], _Z = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), s6 = new Float64Array(1), r6 = new DataView(s6.buffer), a6 = new Uint8Array(s6.buffer);
  e6.Hash = mZ;
});
var $$ = J0((WY) => {
  var t = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: p1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* nZ($, Y, W, X) {
  }
  function* cZ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Array, $, W, X);
    if (t($.minItems) && !(X.length >= $.minItems))
      yield g(x.ArrayMinItems, $, W, X);
    if (t($.maxItems) && !(X.length <= $.maxItems))
      yield g(x.ArrayMaxItems, $, W, X);
    for (let J = 0;J < X.length; J++)
      yield* L0($.items, Y, `${W}/${J}`, X[J]);
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let z of X) {
        const U = (0, oZ.Hash)(z);
        if (J.has(U))
          return false;
        else
          J.add(U);
      }
      return true;
    }())
      yield g(x.ArrayUniqueItems, $, W, X);
    if (!(t($.contains) || t($.minContains) || t($.maxContains)))
      return;
    const Z = t($.contains) ? $.contains : p0.Type.Never(), Q = X.reduce((J, z, U) => L0(Z, Y, `${W}${U}`, z).next().done === true ? J + 1 : J, 0);
    if (Q === 0)
      yield g(x.ArrayContains, $, W, X);
    if ((0, U0.IsNumber)($.minContains) && Q < $.minContains)
      yield g(x.ArrayMinContains, $, W, X);
    if ((0, U0.IsNumber)($.maxContains) && Q > $.maxContains)
      yield g(x.ArrayMaxContains, $, W, X);
  }
  function* lZ($, Y, W, X) {
    if (!(0, U0.IsAsyncIterator)(X))
      yield g(x.AsyncIterator, $, W, X);
  }
  function* tZ($, Y, W, X) {
    if (!(0, U0.IsBigInt)(X))
      return yield g(x.BigInt, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.BigIntExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.BigIntExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.BigIntMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.BigIntMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(x.BigIntMultipleOf, $, W, X);
  }
  function* sZ($, Y, W, X) {
    if (!(0, U0.IsBoolean)(X))
      yield g(x.Boolean, $, W, X);
  }
  function* rZ($, Y, W, X) {
    yield* L0($.returns, Y, W, X.prototype);
  }
  function* aZ($, Y, W, X) {
    if (!(0, U0.IsDate)(X))
      return yield g(x.Date, $, W, X);
    if (t($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(x.DateExclusiveMaximumTimestamp, $, W, X);
    if (t($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(x.DateExclusiveMinimumTimestamp, $, W, X);
    if (t($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(x.DateMaximumTimestamp, $, W, X);
    if (t($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(x.DateMinimumTimestamp, $, W, X);
    if (t($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(x.DateMultipleOfTimestamp, $, W, X);
  }
  function* eZ($, Y, W, X) {
    if (!(0, U0.IsFunction)(X))
      yield g(x.Function, $, W, X);
  }
  function* $Q($, Y, W, X) {
    if (!(0, U0.IsInteger)(X))
      return yield g(x.Integer, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.IntegerExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.IntegerExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.IntegerMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.IntegerMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.IntegerMultipleOf, $, W, X);
  }
  function* YQ($, Y, W, X) {
    for (let Z of $.allOf) {
      const Q = L0(Z, Y, W, X).next();
      if (!Q.done)
        yield g(x.Intersect, $, W, X), yield Q.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield g(x.IntersectUnevaluatedProperties, $, `${W}/${Q}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const J = L0($.unevaluatedProperties, Y, `${W}/${Q}`, X[Q]).next();
          if (!J.done)
            yield J.value;
        }
    }
  }
  function* WQ($, Y, W, X) {
    if (!(0, U0.IsIterator)(X))
      yield g(x.Iterator, $, W, X);
  }
  function* XQ($, Y, W, X) {
    if (X !== $.const)
      yield g(x.Literal, $, W, X);
  }
  function* ZQ($, Y, W, X) {
    yield g(x.Never, $, W, X);
  }
  function* QQ($, Y, W, X) {
    if (L0($.not, Y, W, X).next().done === true)
      yield g(x.Not, $, W, X);
  }
  function* JQ($, Y, W, X) {
    if (!(0, U0.IsNull)(X))
      yield g(x.Null, $, W, X);
  }
  function* zQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(x.Number, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.NumberExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.NumberExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.NumberMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.NumberMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.NumberMultipleOf, $, W, X);
  }
  function* HQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), J = Object.getOwnPropertyNames(X);
    for (let z of Z) {
      if (J.includes(z))
        continue;
      yield g(x.ObjectRequiredProperty, $.properties[z], `${W}/${z}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let z of J)
        if (!Q.includes(z))
          yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, X[z]);
    }
    if (typeof $.additionalProperties === "object")
      for (let z of J) {
        if (Q.includes(z))
          continue;
        yield* L0($.additionalProperties, Y, `${W}/${z}`, X[z]);
      }
    for (let z of Q) {
      const U = $.properties[z];
      if ($.required && $.required.includes(z)) {
        if (yield* L0(U, Y, `${W}/${z}`, X[z]), p0.ExtendsUndefined.Check($) && !(z in X))
          yield g(x.ObjectRequiredProperty, U, `${W}/${z}`, undefined);
      } else if (p1.TypeSystemPolicy.IsExactOptionalProperty(X, z))
        yield* L0(U, Y, `${W}/${z}`, X[z]);
    }
  }
  function* qQ($, Y, W, X) {
    if (!(0, U0.IsPromise)(X))
      yield g(x.Promise, $, W, X);
  }
  function* MQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const [Z, Q] = Object.entries($.patternProperties)[0], J = new RegExp(Z);
    for (let [z, U] of Object.entries(X))
      if (J.test(z))
        yield* L0(Q, Y, `${W}/${z}`, U);
    if (typeof $.additionalProperties === "object") {
      for (let [z, U] of Object.entries(X))
        if (!J.test(z))
          yield* L0($.additionalProperties, Y, `${W}/${z}`, U);
    }
    if ($.additionalProperties === false)
      for (let [z, U] of Object.entries(X)) {
        if (J.test(z))
          continue;
        return yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, U);
      }
  }
  function* NQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* FQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (t($.minLength) && !(X.length >= $.minLength))
      yield g(x.StringMinLength, $, W, X);
    if (t($.maxLength) && !(X.length <= $.maxLength))
      yield g(x.StringMaxLength, $, W, X);
    if ((0, U0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(x.StringPattern, $, W, X);
    }
    if ((0, U0.IsString)($.format)) {
      if (!p0.FormatRegistry.Has($.format))
        yield g(x.StringFormatUnknown, $, W, X);
      else if (!p0.FormatRegistry.Get($.format)(X))
        yield g(x.StringFormat, $, W, X);
    }
  }
  function* UQ($, Y, W, X) {
    if (!(0, U0.IsSymbol)(X))
      yield g(x.Symbol, $, W, X);
  }
  function* AQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(x.StringPattern, $, W, X);
  }
  function* BQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* DQ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(x.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(x.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* L0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* wQ($, Y, W, X) {
    if (!(0, U0.IsUndefined)(X))
      yield g(x.Undefined, $, W, X);
  }
  function* KQ($, Y, W, X) {
    let Z = 0;
    for (let Q of $.anyOf) {
      const J = [...L0(Q, Y, W, X)];
      if (J.length === 0)
        return;
      Z += J.length;
    }
    if (Z > 0)
      yield g(x.Union, $, W, X);
  }
  function* jQ($, Y, W, X) {
    if (!(0, U0.IsUint8Array)(X))
      return yield g(x.Uint8Array, $, W, X);
    if (t($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(x.Uint8ArrayMaxByteLength, $, W, X);
    if (t($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(x.Uint8ArrayMinByteLength, $, W, X);
  }
  function* PQ($, Y, W, X) {
  }
  function* OQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsVoidLike(X))
      yield g(x.Void, $, W, X);
  }
  function* SQ($, Y, W, X) {
    if (!p0.TypeRegistry.Get($[p0.Kind])($, X))
      yield g(x.Kind, $, W, X);
  }
  function* L0($, Y, W, X) {
    const Z = t($.$id) ? [...Y, $] : Y, Q = $;
    switch (Q[p0.Kind]) {
      case "Any":
        return yield* nZ(Q, Z, W, X);
      case "Array":
        return yield* cZ(Q, Z, W, X);
      case "AsyncIterator":
        return yield* lZ(Q, Z, W, X);
      case "BigInt":
        return yield* tZ(Q, Z, W, X);
      case "Boolean":
        return yield* sZ(Q, Z, W, X);
      case "Constructor":
        return yield* rZ(Q, Z, W, X);
      case "Date":
        return yield* aZ(Q, Z, W, X);
      case "Function":
        return yield* eZ(Q, Z, W, X);
      case "Integer":
        return yield* $Q(Q, Z, W, X);
      case "Intersect":
        return yield* YQ(Q, Z, W, X);
      case "Iterator":
        return yield* WQ(Q, Z, W, X);
      case "Literal":
        return yield* XQ(Q, Z, W, X);
      case "Never":
        return yield* ZQ(Q, Z, W, X);
      case "Not":
        return yield* QQ(Q, Z, W, X);
      case "Null":
        return yield* JQ(Q, Z, W, X);
      case "Number":
        return yield* zQ(Q, Z, W, X);
      case "Object":
        return yield* HQ(Q, Z, W, X);
      case "Promise":
        return yield* qQ(Q, Z, W, X);
      case "Record":
        return yield* MQ(Q, Z, W, X);
      case "Ref":
        return yield* NQ(Q, Z, W, X);
      case "String":
        return yield* FQ(Q, Z, W, X);
      case "Symbol":
        return yield* UQ(Q, Z, W, X);
      case "TemplateLiteral":
        return yield* AQ(Q, Z, W, X);
      case "This":
        return yield* BQ(Q, Z, W, X);
      case "Tuple":
        return yield* DQ(Q, Z, W, X);
      case "Undefined":
        return yield* wQ(Q, Z, W, X);
      case "Union":
        return yield* KQ(Q, Z, W, X);
      case "Uint8Array":
        return yield* jQ(Q, Z, W, X);
      case "Unknown":
        return yield* PQ(Q, Z, W, X);
      case "Void":
        return yield* OQ(Q, Z, W, X);
      default:
        if (!p0.TypeRegistry.Has(Q[p0.Kind]))
          throw new L8($);
        return yield* SQ(Q, Z, W, X);
    }
  }
  var LQ = function(...$) {
    const Y = $.length === 3 ? L0($[0], $[1], "", $[2]) : L0($[0], [], "", $[1]);
    return new C8(Y);
  };
  Object.defineProperty(WY, "__esModule", { value: true });
  WY.Errors = WY.ValueErrorIterator = WY.ValueErrorsUnknownTypeError = WY.ValueErrorType = undefined;
  var U0 = x0(), p1 = P8(), YY = D1(), oZ = Y$(), p0 = f0(), x;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(x || (WY.ValueErrorType = x = {}));

  class L8 extends p0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  WY.ValueErrorsUnknownTypeError = L8;

  class C8 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  WY.ValueErrorIterator = C8;
  WY.Errors = LQ;
});
var I$ = J0((O1) => {
  var GQ = O1 && O1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), RQ = O1 && O1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        GQ(Y, $, W);
  };
  Object.defineProperty(O1, "__esModule", { value: true });
  RQ($$(), O1);
});
var b$ = J0((QY) => {
  Object.defineProperty(QY, "__esModule", { value: true });
  QY.ValuePointer = QY.ValuePointerRootDeleteError = QY.ValuePointerRootSetError = undefined;

  class I8 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  QY.ValuePointerRootSetError = I8;

  class b8 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  QY.ValuePointerRootDeleteError = b8;
  var ZY;
  (function($) {
    function Y(z) {
      return z.indexOf("~") === -1 ? z : z.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(z) {
      if (z === "")
        return;
      let [U, D] = [0, 0];
      for (let B = 0;B < z.length; B++)
        if (z.charAt(B) === "/")
          if (B === 0)
            U = B + 1;
          else
            D = B, yield Y(z.slice(U, D)), U = B + 1;
        else
          D = B;
      yield Y(z.slice(U));
    }
    $.Format = W;
    function X(z, U, D) {
      if (U === "")
        throw new I8(z, U, D);
      let [B, j, b] = [null, z, ""];
      for (let S of W(U)) {
        if (j[S] === undefined)
          j[S] = {};
        B = j, j = j[S], b = S;
      }
      B[b] = D;
    }
    $.Set = X;
    function Z(z, U) {
      if (U === "")
        throw new b8(z, U);
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined || B[b] === null)
          return;
        D = B, B = B[b], j = b;
      }
      if (Array.isArray(D)) {
        const b = parseInt(j);
        D.splice(b, 1);
      } else
        delete D[j];
    }
    $.Delete = Z;
    function Q(z, U) {
      if (U === "")
        return true;
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined)
          return false;
        D = B, B = B[b], j = b;
      }
      return Object.getOwnPropertyNames(D).includes(j);
    }
    $.Has = Q;
    function J(z, U) {
      if (U === "")
        return z;
      let D = z;
      for (let B of W(U)) {
        if (D[B] === undefined)
          return;
        D = D[B];
      }
      return D;
    }
    $.Get = J;
  })(ZY || (QY.ValuePointer = ZY = {}));
});
var i1 = J0((zY) => {
  var VQ = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: G8($[X]) }), {});
  }, xQ = function($) {
    return $.map((Y) => G8(Y));
  }, kQ = function($) {
    return $.slice();
  }, gQ = function($) {
    return new Date($.toISOString());
  }, fQ = function($) {
    return $;
  }, G8 = function($) {
    if ((0, W$.IsArray)($))
      return xQ($);
    if ((0, W$.IsDate)($))
      return gQ($);
    if ((0, W$.IsPlainObject)($))
      return VQ($);
    if ((0, W$.IsTypedArray)($))
      return kQ($);
    if ((0, W$.IsValueType)($))
      return fQ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zY, "__esModule", { value: true });
  zY.Clone = undefined;
  var W$ = x0();
  zY.Clone = G8;
});
var V8 = J0((NY) => {
  var X$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, qY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, MY = function($) {
    return { type: "delete", path: $ };
  };
  function* TQ($, Y, W) {
    if (!(0, _0.IsPlainObject)(W))
      return yield X$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let Q of X) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && Z.includes(Q))
        yield X$(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if ((0, _0.IsUndefined)(Y[Q]) || (0, _0.IsUndefined)(W[Q]))
        continue;
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      yield* G$(`${$}/${String(Q)}`, Y[Q], W[Q]);
    }
    for (let Q of Z) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(Y[Q]))
        yield qY(`${$}/${String(Q)}`, W[Q]);
    }
    for (let Q of X.reverse()) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && !Z.includes(Q))
        yield MY(`${$}/${String(Q)}`);
    }
  }
  function* dQ($, Y, W) {
    if (!(0, _0.IsArray)(W))
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield qY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield MY(`${$}/${X}`);
    }
  }
  function* yQ($, Y, W) {
    if (!(0, _0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
  }
  function* vQ($, Y, W) {
    if (Y === W)
      return;
    yield X$($, W);
  }
  function* G$($, Y, W) {
    if ((0, _0.IsPlainObject)(Y))
      return yield* TQ($, Y, W);
    if ((0, _0.IsArray)(Y))
      return yield* dQ($, Y, W);
    if ((0, _0.IsTypedArray)(Y))
      return yield* yQ($, Y, W);
    if ((0, _0.IsValueType)(Y))
      return yield* vQ($, Y, W);
    throw new E8(Y);
  }
  var pQ = function($, Y) {
    return [...G$("", $, Y)];
  }, iQ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, mQ = function($) {
    return $.length === 0;
  }, uQ = function($, Y) {
    if (iQ(Y))
      return (0, _8.Clone)(Y[0].value);
    if (mQ(Y))
      return (0, _8.Clone)($);
    const W = (0, _8.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          R8.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(NY, "__esModule", { value: true });
  NY.Patch = NY.Diff = NY.ValueDeltaUnableToDiffUnknownValue = NY.ValueDeltaObjectWithSymbolKeyError = NY.Edit = NY.Delete = NY.Update = NY.Insert = undefined;
  var _0 = x0(), i0 = f0(), R8 = b$(), _8 = i1();
  NY.Insert = i0.Type.Object({ type: i0.Type.Literal("insert"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Update = i0.Type.Object({ type: i0.Type.Literal("update"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Delete = i0.Type.Object({ type: i0.Type.Literal("delete"), path: i0.Type.String() });
  NY.Edit = i0.Type.Union([NY.Insert, NY.Update, NY.Delete]);

  class m1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  NY.ValueDeltaObjectWithSymbolKeyError = m1;

  class E8 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  NY.ValueDeltaUnableToDiffUnknownValue = E8;
  NY.Diff = pQ;
  NY.Patch = uQ;
});
var jY = J0((wY) => {
  var lQ = function($, Y, W, X) {
    if (!(0, d0.IsPlainObject)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      const Z = Object.keys(W), Q = Object.keys(X);
      for (let J of Z)
        if (!Q.includes(J))
          delete W[J];
      for (let J of Q)
        if (!Z.includes(J))
          W[J] = null;
      for (let J of Q)
        f8($, `${Y}/${J}`, W[J], X[J]);
    }
  }, tQ = function($, Y, W, X) {
    if (!(0, d0.IsArray)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        f8($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, sQ = function($, Y, W, X) {
    if ((0, d0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
  }, rQ = function($, Y, W, X) {
    if (W === X)
      return;
    R$.ValuePointer.Set($, Y, X);
  }, f8 = function($, Y, W, X) {
    if ((0, d0.IsArray)(X))
      return tQ($, Y, W, X);
    if ((0, d0.IsTypedArray)(X))
      return sQ($, Y, W, X);
    if ((0, d0.IsPlainObject)(X))
      return lQ($, Y, W, X);
    if ((0, d0.IsValueType)(X))
      return rQ($, Y, W, X);
  }, DY = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, aQ = function($, Y) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(Y) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(Y);
  }, eQ = function($, Y) {
    if (DY($) || DY(Y))
      throw new g8;
    if (aQ($, Y))
      throw new k8;
    f8($, "", $, Y);
  };
  Object.defineProperty(wY, "__esModule", { value: true });
  wY.Mutate = wY.ValueMutateInvalidRootMutationError = wY.ValueMutateTypeMismatchError = undefined;
  var d0 = x0(), R$ = b$(), x8 = i1();

  class k8 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wY.ValueMutateTypeMismatchError = k8;

  class g8 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wY.ValueMutateInvalidRootMutationError = g8;
  wY.Mutate = eQ;
});
var SY = J0((PY) => {
  var W4 = function($, Y) {
    if (!(0, H1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => _$($[Z], Y[Z]));
  }, X4 = function($, Y) {
    return (0, H1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, Z4 = function($, Y) {
    if (!(0, H1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, Q4 = function($, Y) {
    if (!(0, H1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, J4 = function($, Y) {
    return $ === Y;
  }, _$ = function($, Y) {
    if ((0, H1.IsPlainObject)($))
      return W4($, Y);
    if ((0, H1.IsDate)($))
      return X4($, Y);
    if ((0, H1.IsTypedArray)($))
      return Q4($, Y);
    if ((0, H1.IsArray)($))
      return Z4($, Y);
    if ((0, H1.IsValueType)($))
      return J4($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PY, "__esModule", { value: true });
  PY.Equal = undefined;
  var H1 = x0();
  PY.Equal = _$;
});
var E$ = J0((q1) => {
  var z4 = q1 && q1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), H4 = q1 && q1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        z4(Y, $, W);
  };
  Object.defineProperty(q1, "__esModule", { value: true });
  q1.ValueErrorType = undefined;
  var q4 = $$();
  Object.defineProperty(q1, "ValueErrorType", { enumerable: true, get: function() {
    return q4.ValueErrorType;
  } });
  H4(P8(), q1);
});
var Q$ = J0((CY) => {
  var N4 = function($) {
    return $[C0.Kind] === "Any" || $[C0.Kind] === "Unknown";
  }, s = function($) {
    return $ !== undefined;
  }, F4 = function($, Y, W) {
    return true;
  }, U4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if (s($.minItems) && !(W.length >= $.minItems))
      return false;
    if (s($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((Q) => I0($.items, Y, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let J of W) {
        const z = (0, M4.Hash)(J);
        if (Q.has(z))
          return false;
        else
          Q.add(z);
      }
      return true;
    }())
      return false;
    if (!(s($.contains) || (0, A0.IsNumber)($.minContains) || (0, A0.IsNumber)($.maxContains)))
      return true;
    const X = s($.contains) ? $.contains : C0.Type.Never(), Z = W.reduce((Q, J) => I0(X, Y, J) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if ((0, A0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, A0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, A4 = function($, Y, W) {
    return (0, A0.IsAsyncIterator)(W);
  }, B4 = function($, Y, W) {
    if (!(0, A0.IsBigInt)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, D4 = function($, Y, W) {
    return (0, A0.IsBoolean)(W);
  }, w4 = function($, Y, W) {
    return I0($.returns, Y, W.prototype);
  }, K4 = function($, Y, W) {
    if (!(0, A0.IsDate)(W))
      return false;
    if (s($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (s($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (s($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (s($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (s($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, j4 = function($, Y, W) {
    return (0, A0.IsFunction)(W);
  }, P4 = function($, Y, W) {
    if (!(0, A0.IsInteger)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, O4 = function($, Y, W) {
    const X = $.allOf.every((Z) => I0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J));
      return X && Q;
    } else if (C0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J) || I0($.unevaluatedProperties, Y, W[J]));
      return X && Q;
    } else
      return X;
  }, S4 = function($, Y, W) {
    return (0, A0.IsIterator)(W);
  }, L4 = function($, Y, W) {
    return W === $.const;
  }, C4 = function($, Y, W) {
    return false;
  }, I4 = function($, Y, W) {
    return !I0($.not, Y, W);
  }, b4 = function($, Y, W) {
    return (0, A0.IsNull)(W);
  }, G4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, R4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!I0(Q, Y, W[Z]))
          return false;
        if ((C0.ExtendsUndefined.Check(Q) || N4(Q)) && !(Z in W))
          return false;
      } else if (Z$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !I0(Q, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((Q) => X.includes(Q) || I0($.additionalProperties, Y, W[Q]));
    else
      return true;
  }, _4 = function($, Y, W) {
    return (0, A0.IsPromise)(W);
  }, E4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X), J = Object.entries(W).every(([D, B]) => {
      return Q.test(D) ? I0(Z, Y, B) : true;
    }), z = typeof $.additionalProperties === "object" ? Object.entries(W).every(([D, B]) => {
      return !Q.test(D) ? I0($.additionalProperties, Y, B) : true;
    }) : true, U = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((D) => {
      return Q.test(D);
    }) : true;
    return J && z && U;
  }, V4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, x4 = function($, Y, W) {
    if (!(0, A0.IsString)(W))
      return false;
    if (s($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (s($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (s($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (s($.format)) {
      if (!C0.FormatRegistry.Has($.format))
        return false;
      return C0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, k4 = function($, Y, W) {
    return (0, A0.IsSymbol)(W);
  }, g4 = function($, Y, W) {
    return (0, A0.IsString)(W) && new RegExp($.pattern).test(W);
  }, f4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, T4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!I0($.items[X], Y, W[X]))
        return false;
    return true;
  }, d4 = function($, Y, W) {
    return (0, A0.IsUndefined)(W);
  }, y4 = function($, Y, W) {
    return $.anyOf.some((X) => I0(X, Y, W));
  }, v4 = function($, Y, W) {
    if (!(0, A0.IsUint8Array)(W))
      return false;
    if (s($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (s($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, p4 = function($, Y, W) {
    return true;
  }, i4 = function($, Y, W) {
    return Z$.TypeSystemPolicy.IsVoidLike(W);
  }, m4 = function($, Y, W) {
    if (!C0.TypeRegistry.Has($[C0.Kind]))
      return false;
    return C0.TypeRegistry.Get($[C0.Kind])($, W);
  }, I0 = function($, Y, W) {
    const X = s($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[C0.Kind]) {
      case "Any":
        return F4(Z, X, W);
      case "Array":
        return U4(Z, X, W);
      case "AsyncIterator":
        return A4(Z, X, W);
      case "BigInt":
        return B4(Z, X, W);
      case "Boolean":
        return D4(Z, X, W);
      case "Constructor":
        return w4(Z, X, W);
      case "Date":
        return K4(Z, X, W);
      case "Function":
        return j4(Z, X, W);
      case "Integer":
        return P4(Z, X, W);
      case "Intersect":
        return O4(Z, X, W);
      case "Iterator":
        return S4(Z, X, W);
      case "Literal":
        return L4(Z, X, W);
      case "Never":
        return C4(Z, X, W);
      case "Not":
        return I4(Z, X, W);
      case "Null":
        return b4(Z, X, W);
      case "Number":
        return G4(Z, X, W);
      case "Object":
        return R4(Z, X, W);
      case "Promise":
        return _4(Z, X, W);
      case "Record":
        return E4(Z, X, W);
      case "Ref":
        return V4(Z, X, W);
      case "String":
        return x4(Z, X, W);
      case "Symbol":
        return k4(Z, X, W);
      case "TemplateLiteral":
        return g4(Z, X, W);
      case "This":
        return f4(Z, X, W);
      case "Tuple":
        return T4(Z, X, W);
      case "Undefined":
        return d4(Z, X, W);
      case "Union":
        return y4(Z, X, W);
      case "Uint8Array":
        return v4(Z, X, W);
      case "Unknown":
        return p4(Z, X, W);
      case "Void":
        return i4(Z, X, W);
      default:
        if (!C0.TypeRegistry.Has(Z[C0.Kind]))
          throw new T8(Z);
        return m4(Z, X, W);
    }
  }, u4 = function(...$) {
    return $.length === 3 ? I0($[0], $[1], $[2]) : I0($[0], [], $[1]);
  };
  Object.defineProperty(CY, "__esModule", { value: true });
  CY.Check = CY.ValueCheckUnknownTypeError = undefined;
  var A0 = x0(), Z$ = E$(), LY = D1(), M4 = Y$(), C0 = f0();

  class T8 extends C0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CY.ValueCheckUnknownTypeError = T8;
  CY.Check = u4;
});
var u8 = J0((_Y) => {
  var n4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, c4 = function($, Y) {
    if ($.uniqueItems === true && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if ("contains" in $ && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return y0($.items, Y);
      });
    else
      return [];
  }, l4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, t4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, s4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, r4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = y0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, a4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, e4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, Y);
  }, $J = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, YJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const Q = y0(Z, Y);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!(0, o4.Check)($, Y, W))
        throw new p8($);
      return W;
    }
  }, WJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, XJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, ZJ = function($, Y) {
    throw new y8($);
  }, QJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new v8($);
  }, JJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, zJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, HJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return W.has(Z) ? { ...X, [Z]: y0(Q, Y) } : { ...X };
      }, {});
    }
  }, qJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, Y));
  }, MJ = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === k0.PatternStringExact || W === k0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((Q, J) => {
        return { ...Q, [J]: y0(X, Y) };
      }, {});
    else
      return {};
  }, NJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, FJ = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, UJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, AJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    const W = k0.TemplateLiteralParser.ParseExact($.pattern);
    if (!k0.TemplateLiteralFinite.Check(W))
      throw new i8($);
    return k0.TemplateLiteralGenerator.Generate(W).next().value;
  }, BJ = function($, Y) {
    if (RY++ > bY)
      throw new m8($, bY);
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, DJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => y0($.items[X], Y));
  }, wJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, KJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], Y);
  }, jJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, PJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, OJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, SJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, Y) {
    const W = (0, a.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[k0.Kind]) {
      case "Any":
        return n4(X, W);
      case "Array":
        return c4(X, W);
      case "AsyncIterator":
        return l4(X, W);
      case "BigInt":
        return t4(X, W);
      case "Boolean":
        return s4(X, W);
      case "Constructor":
        return r4(X, W);
      case "Date":
        return a4(X, W);
      case "Function":
        return e4(X, W);
      case "Integer":
        return $J(X, W);
      case "Intersect":
        return YJ(X, W);
      case "Iterator":
        return WJ(X, W);
      case "Literal":
        return XJ(X, W);
      case "Never":
        return ZJ(X, W);
      case "Not":
        return QJ(X, W);
      case "Null":
        return JJ(X, W);
      case "Number":
        return zJ(X, W);
      case "Object":
        return HJ(X, W);
      case "Promise":
        return qJ(X, W);
      case "Record":
        return MJ(X, W);
      case "Ref":
        return NJ(X, W);
      case "String":
        return FJ(X, W);
      case "Symbol":
        return UJ(X, W);
      case "TemplateLiteral":
        return AJ(X, W);
      case "This":
        return BJ(X, W);
      case "Tuple":
        return DJ(X, W);
      case "Undefined":
        return wJ(X, W);
      case "Union":
        return KJ(X, W);
      case "Uint8Array":
        return jJ(X, W);
      case "Unknown":
        return PJ(X, W);
      case "Void":
        return OJ(X, W);
      default:
        if (!k0.TypeRegistry.Has(X[k0.Kind]))
          throw new d8(X);
        return SJ(X, W);
    }
  }, LJ = function(...$) {
    return RY = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_Y, "__esModule", { value: true });
  _Y.Create = _Y.ValueCreateRecursiveInstantiationError = _Y.ValueCreateTempateLiteralTypeError = _Y.ValueCreateIntersectTypeError = _Y.ValueCreateNotTypeError = _Y.ValueCreateNeverTypeError = _Y.ValueCreateUnknownTypeError = undefined;
  var a = x0(), o4 = Q$(), GY = D1(), k0 = f0();

  class d8 extends k0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _Y.ValueCreateUnknownTypeError = d8;

  class y8 extends k0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _Y.ValueCreateNeverTypeError = y8;

  class v8 extends k0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _Y.ValueCreateNotTypeError = v8;

  class p8 extends k0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateIntersectTypeError = p8;

  class i8 extends k0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateTempateLiteralTypeError = i8;

  class m8 extends k0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  _Y.ValueCreateRecursiveInstantiationError = m8;
  var bY = 512, RY = 0;
  _Y.Create = LJ;
});
var dY = J0((fY) => {
  var kY = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y);
  }, o8 = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? W : (0, N1.Create)($, Y);
  }, EJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    const X = (0, w1.IsArray)(W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y), Z = (0, w1.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, J = ((0, w1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((U) => Y1($.items, Y, U));
    if ($.uniqueItems !== true)
      return J;
    const z = [...new Set(J)];
    if (!(0, m0.Check)($, Y, z))
      throw new n8($, z);
    return z;
  }, VJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, N1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, J] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && W.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = Y1(J, Y, W.prototype[Q]);
    }
    return Z;
  }, xJ = function($, Y, W) {
    const X = (0, N1.Create)($, Y), Z = (0, w1.IsPlainObject)(X) && (0, w1.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, m0.Check)($, Y, Z) ? Z : (0, N1.Create)($, Y);
  }, kJ = function($, Y, W) {
    throw new c8($);
  }, gJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, N1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [Q, J] of Object.entries($.properties)) {
      if (!X.has(Q) && W[Q] === undefined)
        continue;
      Z[Q] = Y1(J, Y, W[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let J of Object.getOwnPropertyNames(W)) {
        if (Q.includes(J))
          continue;
        Z[J] = Y1($.additionalProperties, Y, W[J]);
      }
    }
    return Z;
  }, fJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, N1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = Y1(Z, Y, z);
    return Q;
  }, TJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, dJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, yJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (!(0, w1.IsArray)(W))
      return (0, N1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => Y1(X, Y, W[Z]));
  }, vJ = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : h8.Create($, Y, W);
  }, Y1 = function($, Y, W) {
    const X = (0, w1.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[M1.Kind]) {
      case "Array":
        return EJ(Z, X, W);
      case "Constructor":
        return VJ(Z, X, W);
      case "Intersect":
        return xJ(Z, X, W);
      case "Never":
        return kJ(Z, X, W);
      case "Object":
        return gJ(Z, X, W);
      case "Record":
        return fJ(Z, X, W);
      case "Ref":
        return TJ(Z, X, W);
      case "This":
        return dJ(Z, X, W);
      case "Tuple":
        return yJ(Z, X, W);
      case "Union":
        return vJ(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return o8(Z, X, W);
      default:
        if (!M1.TypeRegistry.Has(Z[M1.Kind]))
          throw new l8(Z);
        return o8(Z, X, W);
    }
  }, gY = function(...$) {
    return $.length === 3 ? Y1($[0], $[1], $[2]) : Y1($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Cast = fY.Default = fY.DefaultClone = fY.ValueCastUnknownTypeError = fY.ValueCastRecursiveTypeError = fY.ValueCastNeverTypeError = fY.ValueCastArrayUniqueItemsTypeError = undefined;
  var w1 = x0(), N1 = u8(), m0 = Q$(), u1 = i1(), VY = D1(), M1 = f0();

  class n8 extends M1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  fY.ValueCastArrayUniqueItemsTypeError = n8;

  class c8 extends M1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fY.ValueCastNeverTypeError = c8;

  class xY extends M1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fY.ValueCastRecursiveTypeError = xY;

  class l8 extends M1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCastUnknownTypeError = l8;
  var h8;
  (function($) {
    function Y(Z, Q, J) {
      if (Z[M1.Kind] === "Object" && typeof J === "object" && !(0, w1.IsNull)(J)) {
        const z = Z, U = Object.getOwnPropertyNames(J), D = Object.entries(z.properties), [B, j] = [1 / D.length, D.length];
        return D.reduce((b, [S, N]) => {
          const O = N[M1.Kind] === "Literal" && N.const === J[S] ? j : 0, P = (0, m0.Check)(N, Q, J[S]) ? B : 0, F = U.includes(S) ? B : 0;
          return b + (O + P + F);
        }, 0);
      } else
        return (0, m0.Check)(Z, Q, J) ? 1 : 0;
    }
    function W(Z, Q, J) {
      let [z, U] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const B = Y(D, Q, J);
        if (B > U)
          z = D, U = B;
      }
      return z;
    }
    function X(Z, Q, J) {
      if ("default" in Z)
        return Z.default;
      else {
        const z = W(Z, Q, J);
        return gY(z, Q, J);
      }
    }
    $.Create = X;
  })(h8 || (h8 = {}));
  fY.DefaultClone = kY;
  fY.Default = o8;
  fY.Cast = gY;
});
var hY = J0((mY) => {
  var V$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, lJ = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, J$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, z$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, tJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, $9 = function($, Y) {
    const W = pY($);
    return W === Y ? W : $;
  }, Y9 = function($, Y) {
    const W = iY($);
    return W === Y ? W : $;
  }, W9 = function($, Y) {
    const W = vY($);
    return W === Y ? W : $;
  }, X9 = function($, Y) {
    if (typeof $.const === "string")
      return $9(Y, $.const);
    else if (typeof $.const === "number")
      return Y9(Y, $.const);
    else if (typeof $.const === "boolean")
      return W9(Y, $.const);
    else
      return (0, nJ.Clone)(Y);
  }, vY = function($) {
    return J$($) ? true : z$($) ? false : $;
  }, Z9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : z$($) ? BigInt(0) : J$($) ? BigInt(1) : $;
  }, pY = function($) {
    return lJ($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iY = function($) {
    return V$($) ? parseFloat($) : J$($) ? 1 : z$($) ? 0 : $;
  }, Q9 = function($) {
    return V$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : J$($) ? 1 : z$($) ? 0 : $;
  }, J9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, z9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, H9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : J$($) ? new Date(1) : z$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : sJ($) ? new Date(`1970-01-01T${$}.000Z`) : tJ($) ? new Date(`1970-01-01T${$}`) : aJ($) ? new Date(`${$}.000Z`) : rJ($) ? new Date($) : eJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, t8 = function($) {
    return $;
  }, q9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => n0($.items, Y, X));
    return W;
  }, M9 = function($, Y, W) {
    return Z9(W);
  }, N9 = function($, Y, W) {
    return vY(W);
  }, F9 = function($, Y, W) {
    return H9(W);
  }, U9 = function($, Y, W) {
    return Q9(W);
  }, A9 = function($, Y, W) {
    return $.allOf.every((X) => h1.TypeGuard.TObject(X)) ? n0(h1.Type.Composite($.allOf), Y, W) : n0($.allOf[0], Y, W);
  }, B9 = function($, Y, W) {
    return X9($, W);
  }, D9 = function($, Y, W) {
    return J9(W);
  }, w9 = function($, Y, W) {
    return iY(W);
  }, K9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: n0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, j9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = n0(Z, Y, z);
    return Q;
  }, P9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, O9 = function($, Y, W) {
    return pY(W);
  }, S9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, L9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, C9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? n0($.items[Z], Y, X) : X;
      });
    return W;
  }, I9 = function($, Y, W) {
    return z9(W);
  }, b9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = n0(X, Y, W);
      if ((0, cJ.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, n0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[h1.Kind]) {
      case "Array":
        return q9(Z, X, W);
      case "BigInt":
        return M9(Z, X, W);
      case "Boolean":
        return N9(Z, X, W);
      case "Date":
        return F9(Z, X, W);
      case "Integer":
        return U9(Z, X, W);
      case "Intersect":
        return A9(Z, X, W);
      case "Literal":
        return B9(Z, X, W);
      case "Null":
        return D9(Z, X, W);
      case "Number":
        return w9(Z, X, W);
      case "Object":
        return K9(Z, X, W);
      case "Record":
        return j9(Z, X, W);
      case "Ref":
        return P9(Z, X, W);
      case "String":
        return O9(Z, X, W);
      case "Symbol":
        return S9(Z, X, W);
      case "This":
        return L9(Z, X, W);
      case "Tuple":
        return C9(Z, X, W);
      case "Undefined":
        return I9(Z, X, W);
      case "Union":
        return b9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return t8(W);
      default:
        if (!h1.TypeRegistry.Has(Z[h1.Kind]))
          throw new s8(Z);
        return t8(W);
    }
  }, G9 = function(...$) {
    return $.length === 3 ? n0($[0], $[1], $[2]) : n0($[0], [], $[1]);
  };
  Object.defineProperty(mY, "__esModule", { value: true });
  mY.Convert = mY.Default = mY.ValueConvertUnknownTypeError = undefined;
  var Z0 = x0(), nJ = i1(), cJ = Q$(), yY = D1(), h1 = f0();

  class s8 extends h1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mY.ValueConvertUnknownTypeError = s8;
  mY.Default = t8;
  mY.Convert = G9;
});
var e8 = J0((sY) => {
  Object.defineProperty(sY, "__esModule", { value: true });
  sY.EncodeTransform = sY.DecodeTransform = sY.HasTransform = sY.TransformEncodeError = sY.TransformDecodeError = sY.TransformEncodeCheckError = sY.TransformDecodeCheckError = sY.TransformUnknownTypeError = undefined;
  var c0 = x0(), o1 = D1(), h = f0();

  class H$ extends h.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sY.TransformUnknownTypeError = H$;

  class lY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformDecodeCheckError = lY;

  class tY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformEncodeCheckError = tY;

  class r8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformDecodeError = r8;

  class a8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformEncodeError = a8;
  var oY;
  (function($) {
    function Y(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function W(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function X(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Q(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((G) => O(G, I));
    }
    function J(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.not, I);
    }
    function U(w, I) {
      return h.TypeGuard.TTransform(w) || Object.values(w.properties).some((G) => O(G, I)) || h.TypeGuard.TSchema(w.additionalProperties) && O(w.additionalProperties, I);
    }
    function D(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.item, I);
    }
    function B(w, I) {
      const G = Object.getOwnPropertyNames(w.patternProperties)[0], k = w.patternProperties[G];
      return h.TypeGuard.TTransform(w) || O(k, I) || h.TypeGuard.TSchema(w.additionalProperties) && h.TypeGuard.TTransform(w.additionalProperties);
    }
    function j(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function b(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function S(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TSchema(w.items) && w.items.some((G) => O(G, I));
    }
    function N(w, I) {
      return h.TypeGuard.TTransform(w) || w.anyOf.some((G) => O(G, I));
    }
    function O(w, I) {
      const G = (0, c0.IsString)(w.$id) ? [...I, w] : I, k = w;
      if (w.$id && P.has(w.$id))
        return false;
      if (w.$id)
        P.add(w.$id);
      switch (w[h.Kind]) {
        case "Array":
          return Y(k, G);
        case "AsyncIterator":
          return W(k, G);
        case "Constructor":
          return X(k, G);
        case "Function":
          return Z(k, G);
        case "Intersect":
          return Q(k, G);
        case "Iterator":
          return J(k, G);
        case "Not":
          return z(k, G);
        case "Object":
          return U(k, G);
        case "Promise":
          return D(k, G);
        case "Record":
          return B(k, G);
        case "Ref":
          return j(k, G);
        case "This":
          return b(k, G);
        case "Tuple":
          return S(k, G);
        case "Union":
          return N(k, G);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return h.TypeGuard.TTransform(w);
        default:
          if (!h.TypeRegistry.Has(k[h.Kind]))
            throw new H$(k);
          return h.TypeGuard.TTransform(w);
      }
    }
    const P = new Set;
    function F(w, I) {
      return P.clear(), O(w, I);
    }
    $.Has = F;
  })(oY || (sY.HasTransform = oY = {}));
  var nY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Decode(O) : O;
      } catch (P) {
        throw new r8(N, O, P);
      }
    }
    function W(N, O, P) {
      const F = P.map((w) => j(N.items, O, w));
      return Y(N, F);
    }
    function X(N, O, P) {
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return Y(N, P);
      const F = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), w = Object.entries(P).reduce((G, [k, _]) => {
        return !F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, w);
      const I = Object.entries(w).reduce((G, [k, _]) => {
        return F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
      return Y(N, I);
    }
    function Z(N, O, P) {
      const F = j(N.not, O, P);
      return Y(N, F);
    }
    function Q(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.entries(P).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, F);
      const w = N.additionalProperties, I = Object.entries(F).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(w, O, _) };
      }, {});
      return Y(N, I);
    }
    function J(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.getOwnPropertyNames(N.patternProperties)[0], w = N.patternProperties[F], I = new RegExp(F), G = Object.entries(P).reduce((e, [o, r]) => {
        return !I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(w, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, G);
      const k = N.additionalProperties, _ = Object.entries(G).reduce((e, [o, r]) => {
        return I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(k, O, r) };
      }, {});
      return Y(N, _);
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, P[I])) : [];
      return Y(N, F);
    }
    function B(N, O, P) {
      const F = Y(N, P);
      for (let w of N.anyOf) {
        if (!b(w, O, F))
          continue;
        return j(w, O, F);
      }
      return F;
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "Symbol":
          return Y(w, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Decode = S;
  })(nY || (sY.DecodeTransform = nY = {}));
  var cY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Encode(O) : O;
      } catch (P) {
        throw new a8(N, O, P);
      }
    }
    function W(N, O, P) {
      return Y(N, P).map((w) => j(N.items, O, w));
    }
    function X(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return F;
      const w = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), I = Object.entries(F).reduce((G, [k, _]) => {
        return !w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, I);
      return Object.entries(I).reduce((G, [k, _]) => {
        return w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
    }
    function Z(N, O, P) {
      const F = Y(N, P);
      return Y(N.not, F);
    }
    function Q(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.entries(F).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return w;
      const I = N.additionalProperties;
      return Object.entries(w).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(I, O, _) };
      }, {});
    }
    function J(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.getOwnPropertyNames(N.patternProperties)[0], I = N.patternProperties[w], G = new RegExp(w), k = Object.entries(F).reduce((e, [o, r]) => {
        return !G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(I, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, k);
      const _ = N.additionalProperties;
      return Object.entries(k).reduce((e, [o, r]) => {
        return G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(_, O, r) };
      }, {});
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = Y(N, P);
      return (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, F[I])) : [];
    }
    function B(N, O, P) {
      for (let F of N.anyOf) {
        if (!b(F, O, P))
          continue;
        const w = j(F, O, P);
        return Y(N, w);
      }
      return Y(N, P);
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Encode = S;
  })(cY || (sY.EncodeTransform = cY = {}));
});
var JW = J0((ZW) => {
  Object.defineProperty(ZW, "__esModule", { value: true });
  ZW.Value = undefined;
  var aY = I$(), d9 = jY(), y9 = Y$(), v9 = SY(), eY = dY(), p9 = i1(), $W = hY(), YW = u8(), x$ = Q$(), WW = V8(), k$ = e8(), XW;
  (function($) {
    function Y(...N) {
      return eY.Cast.apply(eY, N);
    }
    $.Cast = Y;
    function W(...N) {
      return YW.Create.apply(YW, N);
    }
    $.Create = W;
    function X(...N) {
      return x$.Check.apply(x$, N);
    }
    $.Check = X;
    function Z(...N) {
      return $W.Convert.apply($W, N);
    }
    $.Convert = Z;
    function Q(N) {
      return p9.Clone(N);
    }
    $.Clone = Q;
    function J(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]];
      if (!X(O, P, F))
        throw new k$.TransformDecodeCheckError(O, F, U(O, P, F).First());
      return k$.DecodeTransform.Decode(O, P, F, x$.Check);
    }
    $.Decode = J;
    function z(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]], w = k$.EncodeTransform.Encode(O, P, F, x$.Check);
      if (!X(O, P, w))
        throw new k$.TransformEncodeCheckError(O, F, U(O, P, F).First());
      return w;
    }
    $.Encode = z;
    function U(...N) {
      return aY.Errors.apply(aY, N);
    }
    $.Errors = U;
    function D(N, O) {
      return v9.Equal(N, O);
    }
    $.Equal = D;
    function B(N, O) {
      return WW.Diff(N, O);
    }
    $.Diff = B;
    function j(N) {
      return y9.Hash(N);
    }
    $.Hash = j;
    function b(N, O) {
      return WW.Patch(N, O);
    }
    $.Patch = b;
    function S(N, O) {
      d9.Mutate(N, O);
    }
    $.Mutate = S;
  })(XW || (ZW.Value = XW = {}));
});
var $6 = J0((W1) => {
  Object.defineProperty(W1, "__esModule", { value: true });
  W1.Value = W1.ValuePointer = W1.Delete = W1.Update = W1.Insert = W1.Edit = W1.ValueErrorIterator = W1.ValueErrorType = undefined;
  var zW = I$();
  Object.defineProperty(W1, "ValueErrorType", { enumerable: true, get: function() {
    return zW.ValueErrorType;
  } });
  Object.defineProperty(W1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zW.ValueErrorIterator;
  } });
  var g$ = V8();
  Object.defineProperty(W1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(W1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(W1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(W1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var i9 = b$();
  Object.defineProperty(W1, "ValuePointer", { enumerable: true, get: function() {
    return i9.ValuePointer;
  } });
  var m9 = JW();
  Object.defineProperty(W1, "Value", { enumerable: true, get: function() {
    return m9.Value;
  } });
});
var UW = J0((NW) => {
  Object.defineProperty(NW, "__esModule", { value: true });
  NW.TypeCompiler = NW.Policy = NW.TypeCompilerTypeGuardError = NW.TypeCompilerUnknownTypeError = NW.TypeCheck = undefined;
  var N$ = e8(), c = x0(), r9 = $$(), F$ = E$(), a9 = D1(), e9 = Y$(), F0 = f0();

  class Q6 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = N$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, r9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new N$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? N$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? N$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new N$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  NW.TypeCheck = Q6;
  var F1;
  (function($) {
    function Y(Q) {
      return Q === 36;
    }
    $.DollarSign = Y;
    function W(Q) {
      return Q === 95;
    }
    $.IsUnderscore = W;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(F1 || (F1 = {}));
  var v$;
  (function($) {
    function Y(Q) {
      if (Q.length === 0)
        return false;
      return F1.IsNumeric(Q.charCodeAt(0));
    }
    function W(Q) {
      if (Y(Q))
        return false;
      for (let J = 0;J < Q.length; J++) {
        const z = Q.charCodeAt(J);
        if (!(F1.IsAlpha(z) || F1.IsNumeric(z) || F1.DollarSign(z) || F1.IsUnderscore(z)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, J) {
      return W(J) ? `${Q}.${J}` : `${Q}['${X(J)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var X6;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const Q = W.charCodeAt(Z);
        if (F1.IsNumeric(Q) || F1.IsAlpha(Q))
          X.push(W.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(X6 || (X6 = {}));
  var Z6;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(Z6 || (Z6 = {}));

  class J6 extends F0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  NW.TypeCompilerUnknownTypeError = J6;

  class p$ extends F0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  NW.TypeCompilerTypeGuardError = p$;
  var L1;
  (function($) {
    function Y(J, z, U) {
      return F$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${z}' in ${J} ? ${U} : true)` : `(${v$.Encode(J, z)} !== undefined ? ${U} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}))` : `(typeof ${J} === 'object' && ${J} !== null)`;
    }
    $.IsObjectLike = W;
    function X(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}) && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))` : `(typeof ${J} === 'object' && ${J} !== null && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(J) {
      return !F$.TypeSystemPolicy.AllowNaN ? `(typeof ${J} === 'number' && Number.isFinite(${J}))` : `typeof ${J} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q(J) {
      return F$.TypeSystemPolicy.AllowNullVoid ? `(${J} === undefined || ${J} === null)` : `${J} === undefined`;
    }
    $.IsVoidLike = Q;
  })(L1 || (NW.Policy = L1 = {}));
  var MW;
  (function($) {
    function Y(K) {
      return K[F0.Kind] === "Any" || K[F0.Kind] === "Unknown";
    }
    function* W(K, E, L) {
      yield "true";
    }
    function* X(K, E, L) {
      yield `Array.isArray(${L})`;
      const [p, T] = [B0("value", "any"), B0("acc", "number")];
      if ((0, c.IsNumber)(K.maxItems))
        yield `${L}.length <= ${K.maxItems}`;
      if ((0, c.IsNumber)(K.minItems))
        yield `${L}.length >= ${K.minItems}`;
      const d = f(K.items, E, "value");
      if (yield `${L}.every((${p}) => ${d})`, F0.TypeGuard.TSchema(K.contains) || (0, c.IsNumber)(K.minContains) || (0, c.IsNumber)(K.maxContains)) {
        const W0 = F0.TypeGuard.TSchema(K.contains) ? K.contains : F0.Type.Never(), j0 = f(W0, E, "value"), X0 = (0, c.IsNumber)(K.minContains) ? [`(count >= ${K.minContains})`] : [], M = (0, c.IsNumber)(K.maxContains) ? [`(count <= ${K.maxContains})`] : [], l = `const count = value.reduce((${T}, ${p}) => ${j0} ? acc + 1 : acc, 0)`, S0 = ["(count > 0)", ...X0, ...M].join(" && ");
        yield `((${p}) => { ${l}; return ${S0}})(${L})`;
      }
      if (K.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${L})`;
    }
    function* Z(K, E, L) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${L})`;
    }
    function* Q(K, E, L) {
      if (yield `(typeof ${L} === 'bigint')`, (0, c.IsBigInt)(K.exclusiveMaximum))
        yield `${L} < BigInt(${K.exclusiveMaximum})`;
      if ((0, c.IsBigInt)(K.exclusiveMinimum))
        yield `${L} > BigInt(${K.exclusiveMinimum})`;
      if ((0, c.IsBigInt)(K.maximum))
        yield `${L} <= BigInt(${K.maximum})`;
      if ((0, c.IsBigInt)(K.minimum))
        yield `${L} >= BigInt(${K.minimum})`;
      if ((0, c.IsBigInt)(K.multipleOf))
        yield `(${L} % BigInt(${K.multipleOf})) === 0`;
    }
    function* J(K, E, L) {
      yield `(typeof ${L} === 'boolean')`;
    }
    function* z(K, E, L) {
      yield* v0(K.returns, E, `${L}.prototype`);
    }
    function* U(K, E, L) {
      if (yield `(${L} instanceof Date) && Number.isFinite(${L}.getTime())`, (0, c.IsNumber)(K.exclusiveMaximumTimestamp))
        yield `${L}.getTime() < ${K.exclusiveMaximumTimestamp}`;
      if ((0, c.IsNumber)(K.exclusiveMinimumTimestamp))
        yield `${L}.getTime() > ${K.exclusiveMinimumTimestamp}`;
      if ((0, c.IsNumber)(K.maximumTimestamp))
        yield `${L}.getTime() <= ${K.maximumTimestamp}`;
      if ((0, c.IsNumber)(K.minimumTimestamp))
        yield `${L}.getTime() >= ${K.minimumTimestamp}`;
      if ((0, c.IsNumber)(K.multipleOfTimestamp))
        yield `(${L}.getTime() % ${K.multipleOfTimestamp}) === 0`;
    }
    function* D(K, E, L) {
      yield `(typeof ${L} === 'function')`;
    }
    function* B(K, E, L) {
      if (yield `(typeof ${L} === 'number' && Number.isInteger(${L}))`, (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* j(K, E, L) {
      const p = K.allOf.map((T) => f(T, E, L)).join(" && ");
      if (K.unevaluatedProperties === false) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key))`;
        yield `(${p} && ${d})`;
      } else if (F0.TypeGuard.TSchema(K.unevaluatedProperties)) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key) || ${f(K.unevaluatedProperties, E, `${L}[key]`)})`;
        yield `(${p} && ${d})`;
      } else
        yield `(${p})`;
    }
    function* b(K, E, L) {
      yield `(typeof value === 'object' && Symbol.iterator in ${L})`;
    }
    function* S(K, E, L) {
      if (typeof K.const === "number" || typeof K.const === "boolean")
        yield `(${L} === ${K.const})`;
      else
        yield `(${L} === '${Z6.Escape(K.const)}')`;
    }
    function* N(K, E, L) {
      yield "false";
    }
    function* O(K, E, L) {
      yield `(!${f(K.not, E, L)})`;
    }
    function* P(K, E, L) {
      yield `(${L} === null)`;
    }
    function* F(K, E, L) {
      if (yield L1.IsNumberLike(L), (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* w(K, E, L) {
      if (yield L1.IsObjectLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const p = Object.getOwnPropertyNames(K.properties);
      for (let T of p) {
        const d = v$.Encode(L, T), W0 = K.properties[T];
        if (K.required && K.required.includes(T)) {
          if (yield* v0(W0, E, d), F0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${T}' in ${L})`;
        } else {
          const j0 = f(W0, E, d);
          yield L1.IsExactOptionalProperty(L, T, j0);
        }
      }
      if (K.additionalProperties === false)
        if (K.required && K.required.length === p.length)
          yield `Object.getOwnPropertyNames(${L}).length === ${p.length}`;
        else {
          const T = `[${p.map((d) => `'${d}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${L}).every(key => ${T}.includes(key))`;
        }
      if (typeof K.additionalProperties === "object") {
        const T = f(K.additionalProperties, E, `${L}[key]`), d = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${L}).every(key => ${d}.includes(key) || ${T}))`;
      }
    }
    function* I(K, E, L) {
      yield `(typeof value === 'object' && typeof ${L}.then === 'function')`;
    }
    function* G(K, E, L) {
      if (yield L1.IsRecordLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const [p, T] = Object.entries(K.patternProperties)[0], d = n(`${new RegExp(p)}`), W0 = f(T, E, "value"), j0 = F0.TypeGuard.TSchema(K.additionalProperties) ? f(K.additionalProperties, E, L) : K.additionalProperties === false ? "false" : "true", X0 = `(${d}.test(key) ? ${W0} : ${j0})`;
      yield `(Object.entries(${L}).every(([key, value]) => ${X0}))`;
    }
    function* k(K, E, L) {
      const p = (0, a9.Deref)(K, E);
      if (R.functions.has(K.$ref))
        return yield `${i(K.$ref)}(${L})`;
      yield* v0(p, E, L);
    }
    function* _(K, E, L) {
      if (yield `(typeof ${L} === 'string')`, (0, c.IsNumber)(K.maxLength))
        yield `${L}.length <= ${K.maxLength}`;
      if ((0, c.IsNumber)(K.minLength))
        yield `${L}.length >= ${K.minLength}`;
      if (K.pattern !== undefined)
        yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
      if (K.format !== undefined)
        yield `format('${K.format}', ${L})`;
    }
    function* e(K, E, L) {
      yield `(typeof ${L} === 'symbol')`;
    }
    function* o(K, E, L) {
      yield `(typeof ${L} === 'string')`, yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
    }
    function* r(K, E, L) {
      yield `${i(K.$ref)}(${L})`;
    }
    function* g0(K, E, L) {
      if (yield `Array.isArray(${L})`, K.items === undefined)
        return yield `${L}.length === 0`;
      yield `(${L}.length === ${K.maxItems})`;
      for (let p = 0;p < K.items.length; p++)
        yield `${f(K.items[p], E, `${L}[${p}]`)}`;
    }
    function* b0(K, E, L) {
      yield `${L} === undefined`;
    }
    function* E0(K, E, L) {
      yield `(${K.anyOf.map((T) => f(T, E, L)).join(" || ")})`;
    }
    function* H0(K, E, L) {
      if (yield `${L} instanceof Uint8Array`, (0, c.IsNumber)(K.maxByteLength))
        yield `(${L}.length <= ${K.maxByteLength})`;
      if ((0, c.IsNumber)(K.minByteLength))
        yield `(${L}.length >= ${K.minByteLength})`;
    }
    function* z0(K, E, L) {
      yield "true";
    }
    function* u0(K, E, L) {
      yield L1.IsVoidLike(L);
    }
    function* a0(K, E, L) {
      const p = R.instances.size;
      R.instances.set(p, K), yield `kind('${K[F0.Kind]}', ${p}, ${L})`;
    }
    function* v0(K, E, L, p = true) {
      const T = (0, c.IsString)(K.$id) ? [...E, K] : E, d = K;
      if (p && (0, c.IsString)(K.$id)) {
        const W0 = i(K.$id);
        if (R.functions.has(W0))
          return yield `${W0}(${L})`;
        else {
          const j0 = q0(W0, K, E, "value", false);
          return R.functions.set(W0, j0), yield `${W0}(${L})`;
        }
      }
      switch (d[F0.Kind]) {
        case "Any":
          return yield* W(d, T, L);
        case "Array":
          return yield* X(d, T, L);
        case "AsyncIterator":
          return yield* Z(d, T, L);
        case "BigInt":
          return yield* Q(d, T, L);
        case "Boolean":
          return yield* J(d, T, L);
        case "Constructor":
          return yield* z(d, T, L);
        case "Date":
          return yield* U(d, T, L);
        case "Function":
          return yield* D(d, T, L);
        case "Integer":
          return yield* B(d, T, L);
        case "Intersect":
          return yield* j(d, T, L);
        case "Iterator":
          return yield* b(d, T, L);
        case "Literal":
          return yield* S(d, T, L);
        case "Never":
          return yield* N(d, T, L);
        case "Not":
          return yield* O(d, T, L);
        case "Null":
          return yield* P(d, T, L);
        case "Number":
          return yield* F(d, T, L);
        case "Object":
          return yield* w(d, T, L);
        case "Promise":
          return yield* I(d, T, L);
        case "Record":
          return yield* G(d, T, L);
        case "Ref":
          return yield* k(d, T, L);
        case "String":
          return yield* _(d, T, L);
        case "Symbol":
          return yield* e(d, T, L);
        case "TemplateLiteral":
          return yield* o(d, T, L);
        case "This":
          return yield* r(d, T, L);
        case "Tuple":
          return yield* g0(d, T, L);
        case "Undefined":
          return yield* b0(d, T, L);
        case "Union":
          return yield* E0(d, T, L);
        case "Uint8Array":
          return yield* H0(d, T, L);
        case "Unknown":
          return yield* z0(d, T, L);
        case "Void":
          return yield* u0(d, T, L);
        default:
          if (!F0.TypeRegistry.Has(d[F0.Kind]))
            throw new J6(K);
          return yield* a0(d, T, L);
      }
    }
    const R = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function f(K, E, L, p = true) {
      return `(${[...v0(K, E, L, p)].join(" && ")})`;
    }
    function i(K) {
      return `check_${X6.Encode(K)}`;
    }
    function n(K) {
      const E = `local_${R.variables.size}`;
      return R.variables.set(E, `const ${E} = ${K}`), E;
    }
    function q0(K, E, L, p, T = true) {
      const [d, W0] = ["\n", (l) => "".padStart(l, " ")], j0 = B0("value", "any"), X0 = D0("boolean"), M = [...v0(E, L, p, T)].map((l) => `${W0(4)}${l}`).join(` &&${d}`);
      return `function ${K}(${j0})${X0} {${d}${W0(2)}return (${d}${M}${d}${W0(2)})\n}`;
    }
    function B0(K, E) {
      const L = R.language === "typescript" ? `: ${E}` : "";
      return `${K}${L}`;
    }
    function D0(K) {
      return R.language === "typescript" ? `: ${K}` : "";
    }
    function w0(K, E, L) {
      const p = q0("check", K, E, "value"), T = B0("value", "any"), d = D0("boolean"), W0 = [...R.functions.values()], j0 = [...R.variables.values()], X0 = (0, c.IsString)(K.$id) ? `return function check(${T})${d} {\n  return ${i(K.$id)}(value)\n}` : `return ${p}`;
      return [...j0, ...W0, X0].join("\n");
    }
    function M0(...K) {
      const E = { language: "javascript" }, [L, p, T] = K.length === 2 && (0, c.IsArray)(K[1]) ? [K[0], K[1], E] : K.length === 2 && !(0, c.IsArray)(K[1]) ? [K[0], [], K[1]] : K.length === 3 ? [K[0], K[1], K[2]] : K.length === 1 ? [K[0], [], E] : [null, [], E];
      if (R.language = T.language, R.variables.clear(), R.functions.clear(), R.instances.clear(), !F0.TypeGuard.TSchema(L))
        throw new p$(L);
      for (let d of p)
        if (!F0.TypeGuard.TSchema(d))
          throw new p$(d);
      return w0(L, p, T);
    }
    $.Code = M0;
    function B1(K, E = []) {
      const L = M0(K, E, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", L), T = new Map(R.instances);
      function d(M, l, S0) {
        if (!F0.TypeRegistry.Has(M) || !T.has(l))
          return false;
        const l$ = F0.TypeRegistry.Get(M), t$ = T.get(l);
        return l$(t$, S0);
      }
      function W0(M, l) {
        if (!F0.FormatRegistry.Has(M))
          return false;
        return F0.FormatRegistry.Get(M)(l);
      }
      function j0(M) {
        return (0, e9.Hash)(M);
      }
      const X0 = p(d, W0, j0);
      return new Q6(K, E, X0, L);
    }
    $.Compile = B1;
  })(MW || (NW.TypeCompiler = MW = {}));
});
var BW = J0((l0) => {
  var Z7 = l0 && l0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), Q7 = l0 && l0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        Z7(Y, $, W);
  };
  Object.defineProperty(l0, "__esModule", { value: true });
  l0.ValueErrorIterator = l0.ValueErrorType = undefined;
  var AW = I$();
  Object.defineProperty(l0, "ValueErrorType", { enumerable: true, get: function() {
    return AW.ValueErrorType;
  } });
  Object.defineProperty(l0, "ValueErrorIterator", { enumerable: true, get: function() {
    return AW.ValueErrorIterator;
  } });
  Q7(UW(), l0);
});
var bW = J0((K5, IW) => {
  var H7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, Q = 0, J = Y, z = LW;
    while (Y > -1 && Y < W) {
      var U = CW($[Y + 1], 4), D = CW($[Y + 2], 0), B = U | D, j = U6[B];
      if (z = U6[256 + z + j], Q = Q << 6 | B & U6[364 + j], z === LW)
        X += $.slice(Z, J), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = Y + 3, Y = J = $.indexOf("%", Z);
      else if (z === z7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, CW = function($, Y) {
    var W = q7[$];
    return W === undefined ? 255 : W << Y;
  }, LW = 12, z7 = 0, U6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], q7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  IW.exports = H7;
});
var VW = J0((j5, EW) => {
  var M7 = function($) {
    const Y = new _W;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", Q = -1, J = -1, z = false, U = false, D = false, B = false, j = false, b = 0;
    for (let S = 0;S < W + 1; S++)
      if (b = S !== W ? $.charCodeAt(S) : 38, b === 38) {
        if (j = J > Q, !j)
          J = S;
        if (X = $.slice(Q + 1, J), j || X.length > 0) {
          if (D)
            X = X.replace(RW, " ");
          if (z)
            X = GW(X) || X;
          if (j) {
            if (Z = $.slice(J + 1, S), B)
              Z = Z.replace(RW, " ");
            if (U)
              Z = GW(Z) || Z;
          }
          const N = Y[X];
          if (N === undefined)
            Y[X] = Z;
          else if (N.pop)
            N.push(Z);
          else
            Y[X] = [N, Z];
        }
        Z = "", Q = S, J = S, z = false, U = false, D = false, B = false;
      } else if (b === 61)
        if (J <= Q)
          J = S;
        else
          U = true;
      else if (b === 43)
        if (J > Q)
          B = true;
        else
          D = true;
      else if (b === 37)
        if (J > Q)
          U = true;
        else
          z = true;
    return Y;
  }, GW = bW(), RW = /\+/g, _W = function() {
  };
  _W.prototype = Object.create(null);
  EW.exports = M7;
});
var kW = J0((P5, xW) => {
  var F7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (N7[Q] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += Z1[Q];
          }
          if (++Z === Y)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, W += Z1[192 | Q >> 6] + Z1[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, W += Z1[224 | Q >> 12] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const J = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | J), W += Z1[240 | Q >> 18] + Z1[128 | Q >> 12 & 63] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, Z1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), N7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  xW.exports = { encodeString: F7 };
});
var TW = J0((O5, fW) => {
  var gW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return A6($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : A6("" + $);
    return "";
  }, U7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let J = 0;J < Z; J++) {
      const z = X[J], U = $[z], D = A6(z) + "=";
      if (J)
        Y += W;
      if (Array.isArray(U)) {
        Q = U.length;
        for (let B = 0;B < Q; B++) {
          if (B)
            Y += W;
          Y += D, Y += gW(U[B]);
        }
      } else
        Y += D, Y += gW(U);
    }
    return Y;
  }, { encodeString: A6 } = kW();
  fW.exports = U7;
});
var B6 = J0((S5, B$) => {
  var dW = VW(), yW = TW(), vW = { parse: dW, stringify: yW };
  B$.exports = vW;
  B$.exports.default = vW;
  B$.exports.parse = dW;
  B$.exports.stringify = yW;
});
var _1 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var L6 = ($, Y) => ({ ...$, part: Y });
var C6 = ($) => ({ paramName: $, store: null, inert: null });

class E1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let Q = Y.split(E1.regex.static), J = Y.match(E1.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = _1("/");
    let z = 0;
    for (let U = 0;U < Q.length; ++U) {
      let D = Q[U];
      if (U > 0) {
        let B = J[z++].slice(1);
        if (X.params === null)
          X.params = C6(B);
        else if (X.params.paramName !== B)
          throw Error(`Cannot create route "${Y}" with parameter "${B}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let j = X.params;
        if (j.inert === null) {
          X = j.inert = _1(D);
          continue;
        }
        X = j.inert;
      }
      for (let B = 0;; ) {
        if (B === D.length) {
          if (B < X.part.length) {
            let j = L6(X, X.part.slice(B));
            Object.assign(X, _1(D, [j]));
          }
          break;
        }
        if (B === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(B))) {
            X = X.inert.get(D.charCodeAt(B)), D = D.slice(B), B = 0;
            continue;
          }
          let j = _1(D.slice(B));
          X.inert.set(D.charCodeAt(B), j), X = j;
          break;
        }
        if (D[B] !== X.part[B]) {
          let j = L6(X, X.part.slice(B)), b = _1(D.slice(B));
          Object.assign(X, _1(X.part.slice(0, B), [j, b])), X = b;
          break;
        }
        ++B;
      }
    }
    if (z < J.length) {
      let U = J[z], D = U.slice(1);
      if (X.params === null)
        X.params = C6(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? r$(Y, Y.length, W, 0) : null;
  }
}
var r$ = ($, Y, W, X) => {
  let Z = W?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > Y)
      return null;
    if (Z.length < 15) {
      for (let J = 1, z = X + 1;J < Z.length; ++J, ++z)
        if (Z.charCodeAt(J) !== $.charCodeAt(z))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let J = W.inert.get($.charCodeAt(Q));
    if (J !== undefined) {
      let z = r$($, Y, J, Q);
      if (z !== null)
        return z;
    }
  }
  if (W.params !== null) {
    let J = W.params, z = $.indexOf("/", Q);
    if (z !== Q) {
      if (z === -1 || z >= Y) {
        if (J.store !== null) {
          let U = {};
          return U[J.paramName] = $.substring(Q, Y), { store: J.store, params: U };
        }
      } else if (J.inert !== null) {
        let U = r$($, Y, J.inert, z);
        if (U !== null)
          return U.params[J.paramName] = $.substring(Q, z), U;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(Q, Y) } } : null;
};
var G6 = Q1(b6(), 1);
var R6 = G6.default;
var _6 = ($, Y) => {
  return async function W(X) {
    const Z = X.id;
    if (X.event === "request" && X.type === "begin") {
      const Q = () => {
        let O, P, F = -1;
        const w = [], I = [];
        let G = false;
        const k = new Promise((o) => {
          O = (r) => {
            if (G)
              return;
            else
              G = true;
            o(r);
          };
        });
        let _ = false;
        const e = new Promise((o) => {
          P = (r) => {
            if (_)
              return;
            else
              _ = true;
            if (F === -1)
              F = 0;
            for (;F < I.length; F++) {
              let g0;
              const b0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((E0) => {
                E0(g0);
              }), children: [] };
              g0 = performance.now(), w[F](b0);
            }
            o(r);
          };
        });
        return { signal: k, consumeChild(o) {
          switch (o.type) {
            case "begin":
              w[++F]({ name: o.name, time: o.time, skip: false, end: new Promise((r) => {
                I.push(r);
              }) });
              break;
            case "end":
              I[F](o.time);
              break;
          }
        }, consume(o) {
          switch (o.type) {
            case "begin":
              const r = [], g0 = o.unit ?? 0;
              for (let b0 = 0;b0 < g0; b0++) {
                let E0;
                r.push(new Promise((H0) => {
                  E0 = H0;
                })), w.push(E0);
              }
              O({ name: o.name, time: o.time, skip: false, end: e, children: r });
              break;
            case "end":
              P(o.time);
              break;
          }
        }, resolve() {
          if (G && _)
            return;
          let o;
          const r = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((g0) => {
            g0(o);
          }), children: [] };
          o = performance.now(), O(r), P(o);
        } };
      }, J = Q(), z = Q(), U = Q(), D = Q(), B = Q(), j = Q(), b = Q(), S = Q();
      J.consume(X);
      const N = (O) => {
        if (O.id === Z)
          switch (O.event) {
            case "request":
              J.consume(O);
              break;
            case "request.unit":
              J.consumeChild(O);
              break;
            case "parse":
              z.consume(O);
              break;
            case "parse.unit":
              z.consumeChild(O);
              break;
            case "transform":
              U.consume(O);
              break;
            case "transform.unit":
              U.consumeChild(O);
              break;
            case "beforeHandle":
              D.consume(O);
              break;
            case "beforeHandle.unit":
              D.consumeChild(O);
              break;
            case "handle":
              B.consume(O);
              break;
            case "afterHandle":
              j.consume(O);
              break;
            case "afterHandle.unit":
              j.consumeChild(O);
              break;
            case "error":
              b.consume(O);
              break;
            case "error.unit":
              b.consumeChild(O);
              break;
            case "response":
              if (O.type === "begin")
                J.resolve(), z.resolve(), U.resolve(), D.resolve(), B.resolve(), j.resolve(), b.resolve();
              else
                $.off("event", N);
              S.consume(O);
              break;
            case "response.unit":
              S.consumeChild(O);
              break;
          }
      };
      $.on("event", N), await Y({ id: X.id, context: X.ctx, set: X.ctx?.set, store: X.ctx?.store, time: X.time, request: J.signal, parse: z.signal, transform: U.signal, beforeHandle: D.signal, handle: B.signal, afterHandle: j.signal, error: b.signal, response: S.signal }), $.emit(`res${Z}`, undefined);
    }
  };
};
var Y6 = Q1($6(), 1);
var HW = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var n1 = Symbol("ErrorCode");
var q$ = (HW?.NODE_ENV ?? HW?.ENV) === "production";

class f$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class S1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class M$ extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class P0 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = q$ ? undefined : Y.Errors(W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, Q = q$ ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(Y6.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(Q);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, P0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return Y6.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W6 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class c1 {
  $;
  Y;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator;
  }
  get publish() {
    return ($, Y = undefined, W) => {
      if (this.validator?.Check(Y) === false)
        throw new P0("message", this.validator, Y);
      if (typeof Y === "object")
        Y = JSON.stringify(Y);
      return this.raw.publish($, Y, W), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new P0("message", this.validator, $);
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var o9 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || c9, Q = 0;
  while (Q < $.length) {
    var J = $.indexOf("=", Q);
    if (J === -1)
      break;
    var z = $.indexOf(";", Q);
    if (z === -1)
      z = $.length;
    else if (z < J) {
      Q = $.lastIndexOf(";", J - 1) + 1;
      continue;
    }
    var U = $.slice(Q, J).trim();
    if (W[U] === undefined) {
      var D = $.slice(J + 1, z).trim();
      if (D.charCodeAt(0) === 34)
        D = D.slice(1, -1);
      W[U] = s9(D, Z);
    }
    Q = z + 1;
  }
  return W;
};
var n9 = function($, Y, W) {
  var X = W || {}, Z = X.encode || l9;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$.test($))
    throw new TypeError("argument name is invalid");
  var Q = Z(Y);
  if (Q && !T$.test(Q))
    throw new TypeError("argument val is invalid");
  var J = $ + "=" + Q;
  if (X.maxAge != null) {
    var z = X.maxAge - 0;
    if (isNaN(z) || !isFinite(z))
      throw new TypeError("option maxAge is invalid");
    J += "; Max-Age=" + Math.floor(z);
  }
  if (X.domain) {
    if (!T$.test(X.domain))
      throw new TypeError("option domain is invalid");
    J += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!T$.test(X.path))
      throw new TypeError("option path is invalid");
    J += "; Path=" + X.path;
  }
  if (X.expires) {
    var U = X.expires;
    if (!t9(U) || isNaN(U.valueOf()))
      throw new TypeError("option expires is invalid");
    J += "; Expires=" + U.toUTCString();
  }
  if (X.httpOnly)
    J += "; HttpOnly";
  if (X.secure)
    J += "; Secure";
  if (X.priority) {
    var D = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (D) {
      case "low":
        J += "; Priority=Low";
        break;
      case "medium":
        J += "; Priority=Medium";
        break;
      case "high":
        J += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var B = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (B) {
      case true:
        J += "; SameSite=Strict";
        break;
      case "lax":
        J += "; SameSite=Lax";
        break;
      case "strict":
        J += "; SameSite=Strict";
        break;
      case "none":
        J += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J;
};
var c9 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var l9 = function($) {
  return encodeURIComponent($);
};
var t9 = function($) {
  return h9.call($) === "[object Date]" || $ instanceof Date;
};
var s9 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$ = o9;
var y$ = n9;
var h9 = Object.prototype.toString;
var T$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$ = Q1(f0(), 1);
var U$ = Q1($6(), 1);
var H6 = Q1(BW(), 1);
var z6 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var J7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || t0(Object.getPrototypeOf($));
var U1 = ($, Y, { skipKeys: W } = {}) => {
  if (z6($) && z6(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!z6(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (J7(Z)) {
        $[X] = Z;
        continue;
      }
      $[X] = U1($[X], Z);
    }
  return $;
};
var DW = ($, Y) => U1($, Y, { skipKeys: ["properties"] });
var O0 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var C1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: U1(Y?.detail ?? {}, $?.detail ?? {}), parse: O0($?.parse ?? [], Y?.parse ?? []), transform: O0($?.transform ?? [], Y?.transform ?? []), beforeHandle: O0($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: O0($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: O0($?.onResponse ?? [], Y?.onResponse ?? []), trace: O0($?.trace ?? [], Y?.trace ?? []), error: O0($?.error ?? [], Y?.error ?? []) };
};
var X1 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && "additionalProperties" in Z === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => U$.Value.Check(Z, Q), Errors: (Q) => U$.Value.Errors(Z, Q), Code: () => "" };
  return H6.TypeCompiler.Compile(Z);
};
var q6 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, Q = (z) => {
    if (X)
      return { schema: z, references: "", checkFunc: () => {
      }, code: "", Check: (U) => U$.Value.Check(z, U), Errors: (U) => U$.Value.Errors(z, U), Code: () => "" };
    return H6.TypeCompiler.Compile(z);
  };
  if (i$.Kind in Z) {
    if ("additionalProperties" in Z === false)
      Z.additionalProperties = W;
    return { 200: Q(Z) };
  }
  const J = {};
  return Object.keys(Z).forEach((z) => {
    const U = Z[+z];
    if (typeof U === "string") {
      if (U in Y) {
        const D = Y[U];
        D.type === "object" && "additionalProperties" in D, J[+z] = i$.Kind in D ? Q(D) : D;
      }
      return;
    }
    if (U.type === "object" && "additionalProperties" in U === false)
      U.additionalProperties = W;
    J[+z] = i$.Kind in U ? Q(U) : U;
  }), J;
};
var M6 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var m$ = ($, Y, W) => {
  const X = (Z) => {
    if (W)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: O0($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: O0($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: O0($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: O0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: O0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: O0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: O0($.onResponse, (Y?.onResponse ?? []).map(X)), trace: O0($.trace, ("trace" in Y ? Y.trace ?? [] : []).map(X)), error: O0($.error, (Y?.error ?? []).map(X)), stop: O0($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var wW = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var l1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var N6 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: l1($?.parse), transform: l1($?.transform), beforeHandle: l1($?.beforeHandle), afterHandle: l1($?.afterHandle), onResponse: l1($?.onResponse), error: l1($?.error) };
};
var F6 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var KW = import.meta.require("crypto");
var I1 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  return $ + "." + KW.createHmac("sha256", Y).update($).digest("base64").replace(/\=+$/, "");
};
var u$ = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  var W = $.slice(0, $.lastIndexOf(".")), X = I1(W, Y), Z = Buffer.from(X), Q = Buffer.from($);
  return Z.length === Q.length && KW.timingSafeEqual(Z, Q) ? W : false;
};

class s0 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({ value: "", expires: new Date });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var jW = ($, Y, W) => new Proxy($, { get(X, Z) {
  if (Z in X)
    return X[Z];
  const Q = new s0(undefined, W ? { ...W } : undefined);
  return Q.setter = Y, Q.name = Z, Q;
}, set(X, Z, Q) {
  if (!(Q instanceof s0))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return Q.setter = Y, Q.name = Z, Q.sync(), X[Z] = Q, true;
} });
var h$ = ($, Y, { secret: W, sign: X, ...Z } = {}) => {
  if (!Y)
    return jW({}, $, Z);
  const Q = {}, J = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const z = Object.keys(d$(Y));
  for (let U = 0;U < z.length; U++) {
    const D = z[U];
    let B = d$(Y)[D];
    if (X === true || X?.includes(D)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (J) {
        if (B = u$(B, W), B === false)
          throw new M$(D);
      } else {
        let S = true;
        for (let N = 0;N < W.length; N++) {
          const O = u$(B, W[N]);
          if (O !== false) {
            B = O, S = false;
            break;
          }
        }
        if (S)
          throw new M$(D);
      }
    }
    const j = B.charCodeAt(0);
    if (j === 123 || j === 91)
      try {
        const S = new s0(JSON.parse(B));
        S.setter = $, S.name = D, Q[D] = S;
        continue;
      } catch {
      }
    if (!Number.isNaN(+B))
      B = +B;
    else if (B === "true")
      B = true;
    else if (B === "false")
      B = false;
    const b = new s0(B, Z);
    b.setter = $, b.name = D, Q[D] = b;
  }
  return jW(Q, $);
};
var PW = "toJSON" in new Headers;
var t0 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var OW = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var SW = ($) => {
  if (!$ || typeof $ !== "object" || !t0($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let Q = X.value[Z];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Y.push(y$(W, Q, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(y$(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var A1 = ($, Y) => {
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((Z) => A1(Z, Y));
      case "Function":
        return A1($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = K1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var r0 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q = r0(Z, Y);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return r0($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = r0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var K1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return A$($);
    case "Promise":
      return $.then((W) => {
        const X = K1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return K1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var A$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var pW = Q1(B6(), 1);
var A7 = new Headers().toJSON;
var iW = new RegExp(" (\\w+) = context", "g");
var mW = { value: 0 };
var uW = ({ hasTrace: $, hasTraceSet: Y = false, addFn: W, condition: X = {} }) => {
  if ($)
    return (Z, { name: Q, attribute: J = "", unit: z = 0 } = {}) => {
      const U = Z.indexOf("."), D = U === -1;
      if (Z !== "request" && Z !== "response" && !X[D ? Z : Z.slice(0, U)])
        return () => {
          if (Y && Z === "afterHandle")
            W("\nawait traceDone\n");
        };
      if (D)
        Q ||= Z;
      else
        Q ||= "anonymous";
      W("\n" + `reporter.emit('event', { 
					id,
					event: '${Z}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${D ? `unit: ${z},` : ""}
					${J}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let B = false;
      return () => {
        if (B)
          return;
        if (B = true, W("\n" + `reporter.emit('event', {
							id,
							event: '${Z}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && Z === "afterHandle")
          W("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var D$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var B7 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var K0 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [W];
  if (Z)
    Q.push(Z);
  for (let z of Y.matchAll(iW))
    Q.push(z[1]);
  const J = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [z] of Y.matchAll(J))
    if (z.includes(`{ ${$}`) || z.includes(`, ${$}`))
      return true;
  return false;
};
var w$ = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let J of $.matchAll(iW))
    Z.push(J[1]);
  for (let J of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t1 = Symbol.for("TypeBox.Kind");
var o$ = ($, Y) => {
  if (!Y)
    return;
  if (t1 in Y && Y[t1] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (o$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q = 0;Q < Z.anyOf.length; Q++)
          if (o$($, Z.anyOf[Q]))
            return true;
      }
      if (t1 in Z && Z[t1] === $)
        return true;
    }
    return false;
  }
  return Y.properties && t1 in Y.properties && Y.properties[t1] === $;
};
var D6 = Symbol.for("TypeBox.Transform");
var b1 = ($) => {
  if (!$)
    return;
  if ($.type === "object") {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (b1(X))
          return true;
      } else if (X.anyOf) {
        for (let Q = 0;Q < X.anyOf.length; Q++)
          if (b1(X.anyOf[Q]))
            return true;
      }
      if (D6 in X)
        return true;
    }
    return false;
  }
  return D6 in $ || $.properties && D6 in $.properties;
};
var D7 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && "anyOf" in Y) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var w7 = /(?:return|=>) \S*\(/g;
var N0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(w7);
};
var hW = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: Q, definitions: J, schema: z, onRequest: U, config: D, reporter: B }) => {
  const j = D.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, b = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((R, f) => `await res${f}(c)`).join(";")}})();\n` : "", S = W.trace.map((R) => R.toString());
  let N = false;
  if (w$(Z.toString()))
    N = true;
  if (!N)
    for (let [R, f] of Object.entries(W)) {
      if (!Array.isArray(f) || !f.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(R))
        continue;
      for (let i of f) {
        if (typeof i !== "function")
          continue;
        if (w$(i.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const O = { parse: S.some((R) => K0("parse", R)), transform: S.some((R) => K0("transform", R)), handle: S.some((R) => K0("handle", R)), beforeHandle: S.some((R) => K0("beforeHandle", R)), afterHandle: S.some((R) => K0("afterHandle", R)), error: j || S.some((R) => K0("error", R)) }, P = W.trace.length > 0;
  let F = "";
  if (P)
    F += "\nconst id = c.$$requestId\n";
  F += j ? "try {\n" : "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((R) => R.toString()) : [], I = N || Y !== "GET" && Y !== "HEAD" && W.type !== "none" && (!!X.body || !!W.type || w.some((R) => K0("body", R))), G = N || X.headers || w.some((R) => K0("headers", R)), k = N || X.cookie || w.some((R) => K0("cookie", R)), _ = X?.cookie?.schema;
  let e = "";
  if (_?.sign) {
    if (!_.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const R = !_.secrets ? undefined : typeof _.secrets === "string" ? _.secrets : _.secrets[0];
    if (e += `const _setCookie = c.set.cookie
		if(_setCookie) {`, _.sign === true)
      e += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = signCookie(cookie.value, '${R}')
			}`;
    else
      for (let f of _.sign)
        e += `if(_setCookie['${f}']?.value) { c.set.cookie['${f}'].value = signCookie(_setCookie['${f}'].value, '${R}') }\n`;
    e += "}\n";
  }
  const { composeValidation: o, composeResponseValidation: r } = B7(j);
  if (G)
    F += A7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (k) {
    const R = (i, n) => {
      const q0 = _?.[i] ?? n;
      if (!q0)
        return typeof n === "string" ? `${i}: "${n}",` : `${i}: ${n},`;
      if (typeof q0 === "string")
        return `${i}: '${q0}',`;
      if (q0 instanceof Date)
        return `${i}: new Date(${q0.getTime()}),`;
      return `${i}: ${q0},`;
    }, f = _ ? `{
			secret: ${_.secrets !== undefined ? typeof _.secrets === "string" ? `'${_.secrets}'` : "[" + _.secrets.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			sign: ${_.sign === true ? true : _.sign !== undefined ? "[" + _.sign.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			${R("domain")}
			${R("expires")}
			${R("httpOnly")}
			${R("maxAge")}
			${R("path", "/")}
			${R("priority")}
			${R("sameSite")}
			${R("secure")}
		}` : "undefined";
    if (G)
      F += `\nc.cookie = parseCookie(c.set, c.headers.cookie, ${f})\n`;
    else
      F += `\nc.cookie = parseCookie(c.set, c.request.headers.get('cookie'), ${f})\n`;
  }
  if (N || X.query || w.some((R) => K0("query", R)))
    F += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const E0 = W.trace.map((R) => R.toString()).some((R) => K0("set", R) || w$(R));
  N || W.trace.some((R) => K0("set", R.toString()));
  const H0 = E0 || k || w.some((R) => K0("set", R)) || U.some((R) => K0("set", R.toString())), z0 = uW({ hasTrace: P, hasTraceSet: E0, condition: O, addFn: (R) => {
    F += R;
  } });
  if (P)
    F += "\nconst traceDone = new Promise(r => { reporter.once(`res${id}`, r) })\n";
  const u0 = I || E0 || N0(Z) || W.parse.length > 0 || W.afterHandle.some(N0) || W.beforeHandle.some(N0) || W.transform.some(N0), a0 = z0("parse", { unit: W.parse.length });
  if (I) {
    const R = D7(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            F += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            F += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            F += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            F += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            F += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        F += "}}";
    } else {
      const i = (() => {
        if (W.parse.length && R && !Array.isArray(W.type)) {
          const n = X?.body?.schema;
          switch (R) {
            case "object":
              if (o$("File", n) || o$("Files", n))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (i)
        F += i;
      else {
        if (F += "\n", F += G ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", F += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          F += "let used = false\n";
          const n = z0("parse", { unit: W.parse.length });
          for (let q0 = 0;q0 < W.parse.length; q0++) {
            const B0 = z0("parse.unit", { name: W.parse[q0].name }), D0 = `bo${q0}`;
            if (q0 !== 0)
              F += "if(!used) {\n";
            if (F += `let ${D0} = parse[${q0}](c, contentType)\n`, F += `if(${D0} instanceof Promise) ${D0} = await ${D0}\n`, F += `if(${D0} !== undefined) { c.body = ${D0}; used = true }\n`, B0(), q0 !== 0)
              F += "}";
          }
          n();
        }
        if (W.parse.length)
          F += "if (!used)";
        F += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, F += "}\n";
      }
    }
    F += "\n";
  }
  if (a0(), W?.transform) {
    const R = z0("transform", { unit: W.transform.length });
    for (let f = 0;f < W.transform.length; f++) {
      const i = W.transform[f], n = z0("transform.unit", { name: i.name });
      if (i.$elysia === "derive")
        F += N0(W.transform[f]) ? `Object.assign(c, await transform[${f}](c));` : `Object.assign(c, transform[${f}](c));`;
      else
        F += N0(W.transform[f]) ? `await transform[${f}](c);` : `transform[${f}](c);`;
      n();
    }
    R();
  }
  if (X) {
    if (F += "\n", X.headers) {
      if (F += `if(headers.Check(c.headers) === false) {
				${o("headers")}
			}`, b1(X.headers.schema))
        F += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (F += `if(params.Check(c.params) === false) {
				${o("params")}
			}`, b1(X.params.schema))
        F += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (F += `if(query.Check(c.query) === false) {
				${o("query")} 
			}`, b1(X.query.schema))
        F += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (F += `if(body.Check(c.body) === false) { 
				${o("body")}
			}`, b1(X.body.schema))
        F += "\nc.body = body.Decode(c.body)\n";
    }
    if (t0(X.cookie?.schema.properties ?? {})) {
      if (F += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${o("cookie", "cookieValue")}
			}`, b1(X.cookie.schema))
        F += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const R = z0("beforeHandle", { unit: W.beforeHandle.length });
    for (let f = 0;f < W.beforeHandle.length; f++) {
      const i = z0("beforeHandle.unit", { name: W.beforeHandle[f].name }), n = `be${f}`;
      if (!D$(W.beforeHandle[f].toString()))
        F += N0(W.beforeHandle[f]) ? `await beforeHandle[${f}](c);\n` : `beforeHandle[${f}](c);\n`, i();
      else {
        F += N0(W.beforeHandle[f]) ? `let ${n} = await beforeHandle[${f}](c);\n` : `let ${n} = beforeHandle[${f}](c);\n`, i(), F += `if(${n} !== undefined) {\n`;
        const B0 = z0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const D0 = n;
          for (let w0 = 0;w0 < W.afterHandle.length; w0++) {
            const M0 = D$(W.afterHandle[w0].toString()), B1 = z0("afterHandle.unit", { name: W.afterHandle[w0].name });
            if (F += `c.response = ${D0}\n`, !M0)
              F += N0(W.afterHandle[w0]) ? `await afterHandle[${w0}](c, ${D0});\n` : `afterHandle[${w0}](c, ${D0});\n`;
            else {
              const K = `af${w0}`;
              F += N0(W.afterHandle[w0]) ? `const ${K} = await afterHandle[${w0}](c);\n` : `const ${K} = afterHandle[${w0}](c);\n`, F += `if(${K} !== undefined) { c.response = ${D0} = ${K} }\n`;
            }
            B1();
          }
        }
        if (B0(), X.response)
          F += r(n);
        F += e, F += `return mapEarlyResponse(${n}, c.set)}\n`;
      }
    }
    R();
  }
  if (W?.afterHandle.length) {
    const R = z0("handle", { name: Z.name });
    if (W.afterHandle.length)
      F += N0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    R();
    const f = z0("afterHandle", { unit: W.afterHandle.length });
    for (let i = 0;i < W.afterHandle.length; i++) {
      const n = `af${i}`, q0 = D$(W.afterHandle[i].toString()), B0 = z0("afterHandle.unit", { name: W.afterHandle[i].name });
      if (!q0)
        F += N0(W.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`, B0();
      else {
        if (X.response)
          F += N0(W.afterHandle[i]) ? `let ${n} = await afterHandle[${i}](c)\n` : `let ${n} = afterHandle[${i}](c)\n`;
        else
          F += N0(W.afterHandle[i]) ? `let ${n} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${n} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
        if (B0(), X.response)
          F += `if(${n} !== undefined) {`, F += r(n), F += `${n} = mapEarlyResponse(${n}, c.set)\n`, F += `if(${n}) {`, f(), F += `return ${n} } }`;
        else
          F += `if(${n}) {`, f(), F += `return ${n}}\n`;
      }
    }
    if (f(), F += "r = c.response\n", X.response)
      F += r();
    if (F += e, H0)
      F += "return mapResponse(r, c.set)\n";
    else
      F += "return mapCompactResponse(r)\n";
  } else {
    const R = z0("handle", { name: Z.name });
    if (X.response)
      if (F += N0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", R(), F += r(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else if (O.handle || k)
      if (F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", R(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else {
      R();
      const f = N0(Z) ? "await handler(c) " : "handler(c)";
      if (z0("afterHandle")(), H0)
        F += `return mapResponse(${f}, c.set)\n`;
      else
        F += `return mapCompactResponse(${f})\n`;
    }
  }
  if (j || b) {
    if (F += `
} catch(error) {`, !u0)
      F += "return (async () => {";
    F += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const R = z0("error", { unit: W.error.length });
    if (W.error.length)
      for (let f = 0;f < W.error.length; f++) {
        const i = `er${f}`, n = z0("error.unit", { name: W.error[f].name });
        if (F += `\nlet ${i} = handleErrors[${f}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, N0(W.error[f]))
          F += `if (${i} instanceof Promise) ${i} = await ${i}\n`;
        n(), F += `${i} = mapEarlyResponse(${i}, set)\n`, F += `if (${i}) {`, F += `return ${i} }\n`;
      }
    if (R(), F += "return handleError(c, error)\n\n", !u0)
      F += "})()";
    if (F += "}", b || P) {
      F += " finally { ";
      const f = z0("response", { unit: W.onResponse.length });
      F += b, f(), F += "}";
    }
  }
  return F = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		reporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((R, f) => `res${f} = onResponse[${f}]`).join(",")}` : ""}

	return ${u0 ? "async" : ""} function(c) {
		${z && J ? "c.schema = schema; c.defs = definitions;" : ""}
		${F}
	}`, Function("hooks", F)({ handler: Z, hooks: W, validator: X, handleError: Q, utils: { mapResponse: A1, mapCompactResponse: K1, mapEarlyResponse: r0, parseQuery: pW.parse }, error: { NotFoundError: S1, ValidationError: P0, InternalServerError: f$ }, schema: z, definitions: J, ERROR_CODE: n1, reporter: B, requestId: mW, parseCookie: h$, signCookie: I1 });
};
var w6 = ($) => {
  let Y = "", W = "";
  for (let j of Object.keys($.decorators))
    Y += `,${j}: app.decorators.${j}`;
  const { router: X, staticRouter: Z } = $, Q = $.event.trace.length > 0, J = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let z = "";
  for (let [j, { code: b, all: S }] of Object.entries(Z.map))
    z += `case '${j}':\nswitch(request.method) {\n${b}\n${S ?? "default: break map"}}\n\n`;
  const U = $.event.request.some(N0);
  W += `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		reporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${U ? "async" : ""} function map(request) {
	`;
  const D = $.event.trace.map((j) => j.toString()), B = uW({ hasTrace: Q, hasTraceSet: $.event.trace.some((j) => {
    const b = j.toString();
    return K0("set", b) || w$(b);
  }), condition: { request: D.some((j) => K0("request", j) || w$(j)) }, addFn: (j) => {
    W += j;
  } });
  if ($.event.request.length) {
    W += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const j = B("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let b = 0;b < $.event.request.length; b++) {
      const S = $.event.request[b], N = D$(S.toString()), O = N0(S), P = B("request.unit", { name: $.event.request[b].name }), F = `re${b}`;
      if (N)
        W += `const ${F} = mapEarlyResponse(
					${O ? "await" : ""} onRequest[${b}](ctx),
					ctx.set
				)\n`, P(), W += `if(${F}) return ${F}\n`;
      else
        W += `${O ? "await" : ""} onRequest[${b}](ctx)\n`, P();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, j(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Y}
		}`, B("request", { unit: $.event.request.length, attribute: D.some((j) => K0("context", j)) || D.some((j) => K0("store", j)) || D.some((j) => K0("set", j)) ? "ctx" : "" })();
  return W += `
		map: switch(path) {
			${z}

			default:
				break
		}

		${J}
	}`, $.handleError = K6($), Function("data", W)({ app: $, mapEarlyResponse: r0, NotFoundError: S1, reporter: $.reporter, requestId: mW });
};
var K6 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(N0) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${N0(X) ? "await " : ""}onError[${W}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (D$(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) return mapResponse(r${W}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: A1, ERROR_CODE: n1 });
};
var n$ = Q1(B6(), 1);
var j6 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, Q = Z.indexOf("/", 11), J = Z.indexOf("?", Q + 1), z = J === -1 ? Z.substring(Q) : Z.substring(Q, J);
  try {
    for (let P = 0;P < $.event.request.length; P++) {
      const F = $.event.request[P];
      let w = F(X);
      if (w instanceof Promise)
        w = await w;
      if (w = r0(w, W), w)
        return w;
    }
    const U = $.dynamicRouter.find(Y.method, z) ?? $.dynamicRouter.find("ALL", z);
    if (!U)
      throw new S1;
    const { handle: D, hooks: B, validator: j, content: b } = U.store;
    let S;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (b)
        switch (b) {
          case "application/json":
            S = await Y.json();
            break;
          case "text/plain":
            S = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            S = n$.parse(await Y.text());
            break;
          case "application/octet-stream":
            S = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            S = {};
            const P = await Y.formData();
            for (let F of P.keys()) {
              if (S[F])
                continue;
              const w = P.getAll(F);
              if (w.length === 1)
                S[F] = w[0];
              else
                S[F] = w;
            }
            break;
        }
      else {
        let P = Y.headers.get("content-type");
        if (P) {
          const F = P.indexOf(";");
          if (F !== -1)
            P = P.slice(0, F);
          for (let w = 0;w < $.event.parse.length; w++) {
            let I = $.event.parse[w](X, P);
            if (I instanceof Promise)
              I = await I;
            if (I) {
              S = I;
              break;
            }
          }
          if (S === undefined)
            switch (P) {
              case "application/json":
                S = await Y.json();
                break;
              case "text/plain":
                S = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                S = n$.parse(await Y.text());
                break;
              case "application/octet-stream":
                S = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                S = {};
                const w = await Y.formData();
                for (let I of w.keys()) {
                  if (S[I])
                    continue;
                  const G = w.getAll(I);
                  if (G.length === 1)
                    S[I] = G[0];
                  else
                    S[I] = G;
                }
                break;
            }
        }
      }
    X.body = S, X.params = U?.params || undefined, X.query = J === -1 ? {} : n$.parse(Z.substring(J + 1)), X.headers = {};
    for (let [P, F] of Y.headers.entries())
      X.headers[P] = F;
    const N = j?.cookie?.schema;
    X.cookie = h$(X.set, X.headers.cookie, N ? { secret: N.secrets !== undefined ? typeof N.secrets === "string" ? N.secrets : N.secrets.join(",") : undefined, sign: N.sign === true ? true : N.sign !== undefined ? typeof N.sign === "string" ? N.sign : N.sign.join(",") : undefined } : undefined);
    for (let P = 0;P < B.transform.length; P++) {
      const F = B.transform[P](X);
      if (B.transform[P].$elysia === "derive")
        if (F instanceof Promise)
          Object.assign(X, await F);
        else
          Object.assign(X, F);
      else if (F instanceof Promise)
        await F;
    }
    if (j) {
      if (j.headers) {
        const P = {};
        for (let F in Y.headers)
          P[F] = Y.headers.get(F);
        if (j.headers.Check(P) === false)
          throw new P0("header", j.headers, P);
      }
      if (j.params?.Check(X.params) === false)
        throw new P0("params", j.params, X.params);
      if (j.query?.Check(X.query) === false)
        throw new P0("query", j.query, X.query);
      if (j.cookie) {
        const P = {};
        for (let [F, w] of Object.entries(X.cookie))
          P[F] = w.value;
        if (j.cookie?.Check(P) === false)
          throw new P0("cookie", j.cookie, P);
      }
      if (j.body?.Check(S) === false)
        throw new P0("body", j.body, S);
    }
    for (let P = 0;P < B.beforeHandle.length; P++) {
      let F = B.beforeHandle[P](X);
      if (F instanceof Promise)
        F = await F;
      if (F !== undefined) {
        X.response = F;
        for (let I = 0;I < B.afterHandle.length; I++) {
          let G = B.afterHandle[I](X);
          if (G instanceof Promise)
            G = await G;
          if (G)
            F = G;
        }
        const w = r0(F, X.set);
        if (w)
          return w;
      }
    }
    let O = D(X);
    if (O instanceof Promise)
      O = await O;
    if (!B.afterHandle.length) {
      const P = j?.response?.[O.status];
      if (P?.Check(O) === false)
        throw new P0("response", P, O);
    } else {
      X.response = O;
      for (let P = 0;P < B.afterHandle.length; P++) {
        let F = B.afterHandle[P](X);
        if (F instanceof Promise)
          F = await F;
        const w = r0(F, X.set);
        if (w !== undefined) {
          const I = j?.response?.[O.status];
          if (I?.Check(w) === false)
            throw new P0("response", I, w);
          return w;
        }
      }
    }
    if (X.set.cookie && N?.sign) {
      const P = !N.secrets ? undefined : typeof N.secrets === "string" ? N.secrets : N.secrets[0];
      if (N.sign === true)
        for (let [F, w] of Object.entries(X.set.cookie))
          X.set.cookie[F].value = I1(w.value, "${secret}");
      else
        for (let F of N.sign) {
          if (!(F in N.properties))
            continue;
          if (X.set.cookie[F]?.value)
            X.set.cookie[F].value = I1(X.set.cookie[F].value, P);
        }
    }
    return A1(O, X.set);
  } catch (U) {
    if (U.status)
      W.status = U.status;
    return $.handleError(X, U);
  } finally {
    for (let U of $.event.onResponse)
      await U(X);
  }
};
var oW = ($) => async (Y, W) => {
  const X = Object.assign(Y, W);
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z](X);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return A1(Q, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var G1 = Q1(E$(), 1);
var Y0 = Q1(f0(), 1);
try {
  G1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), G1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), G1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), G1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var nW = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P6 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < nW($.minSize))
    return false;
  if ($.maxSize && Y.size > nW($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var K7 = G1.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return P6($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!P6($, Y[W]))
      return false;
  return true;
});
Y0.FormatRegistry.Set("numeric", ($) => !isNaN(+$));
Y0.FormatRegistry.Set("ObjectString", ($) => {
  let Y = $.charCodeAt(0);
  if (Y === 9 || Y === 10 || Y === 32)
    Y = $.trimStart().charCodeAt(0);
  if (Y !== 123 && Y !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var R1 = { Numeric: ($) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "numeric", default: 0 }), Y0.Type.Number($)])).Decode((Y) => {
  const W = +Y;
  if (isNaN(W))
    return Y;
  return W;
}).Encode((Y) => Y), ObjectString: ($, Y) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "ObjectString", default: "" }), Y0.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: G1.TypeSystem.Type("File", P6), Files: ($ = {}) => Y0.Type.Transform(Y0.Type.Union([K7($)])).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => Y0.Type.Union([Y0.Type.Null(), $]), MaybeEmpty: ($) => Y0.Type.Union([Y0.Type.Null(), Y0.Type.Undefined(), $]), Cookie: ($, Y) => Y0.Type.Object($, Y) };
Y0.Type.ObjectString = R1.ObjectString;
Y0.Type.Numeric = R1.Numeric;
Y0.Type.File = ($ = {}) => R1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
Y0.Type.Files = ($ = {}) => R1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
Y0.Type.Nullable = ($) => R1.Nullable($);
Y0.Type.MaybeEmpty = R1.MaybeEmpty;
Y0.Type.Cookie = R1.Cookie;

class c$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new R6;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new E1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  dynamicRouter = new E1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let J of Y) {
      if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix && !Q)
        J = this.config.prefix + J;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const z = this.definitions.type;
      let U = X1(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: z, additionalProperties: true });
      if (t0(this.config.cookie ?? {}))
        if (U)
          U.schema = DW(U.schema, this.config.cookie ?? {});
        else
          U = X1(Y0.Type.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: z, additionalProperties: true });
      const D = { body: X1(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: z }), headers: X1(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: z, additionalProperties: true }), params: X1(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: z }), query: X1(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: z }), cookie: U, response: q6(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: z }) }, B = C1(this.event, X), j = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J, { validator: D, hooks: B, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, j, { validator: D, hooks: B, content: X?.type, handle: W });
        this.routes.push({ method: $, path: J, composed: null, handler: W, hooks: B });
        return;
      }
      const b = hW({ path: J, method: $, hooks: B, validator: D, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, reporter: this.reporter }), S = this.routes.findIndex((N) => N.path === J && N.method === $);
      if (S !== -1)
        this.routes.splice(S, 1);
      if (this.routes.push({ method: $, path: J, composed: b, handler: W, hooks: B }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
        const N = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(b), this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`, !this.staticRouter.map[J])
          this.staticRouter.map[J] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J].all = `default: return st${N}(ctx)\n`;
        else
          this.staticRouter.map[J].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[J].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[j])
            this.staticRouter.map[j] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[j].all = `default: return st${N}(ctx)\n`;
          else
            this.staticRouter.map[j].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[j].code}`;
        }
      } else if (this.router.add($, J, b), !this.config.strictPath)
        this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", b);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _6(this.reporter, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[n1] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[n1] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = wW(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new c$({ ...this.config, prefix: "" });
    X.store = this.store;
    const Z = typeof Y === "object", Q = (Z ? W : Y)(X);
    if (this.decorators = U1(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    return this.model(Q.definitions.type), Object.values(X.routes).forEach(({ method: J, path: z, handler: U, hooks: D }) => {
      if (z = (Z ? "" : this.config.prefix) + $ + z, Z) {
        const B = Y, j = D;
        this.add(J, z, U, C1(B, { ...j, error: !j.error ? Q.event.error : Array.isArray(j.error) ? [...j.error, ...Q.event.error] : [j.error, ...Q.event.error] }));
      } else
        this.add(J, z, U, C1(D, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = m$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new c$;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = U1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: Q, handler: J, hooks: z }) => {
      this.add(Z, Q, J, C1($, { ...z, error: !z.error ? X.event.error : Array.isArray(z.error) ? [...z.error, ...X.event.error] : [z.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q) => {
          if (typeof Q === "function")
            return Q(this);
          if (typeof Q.default === "function")
            return Q.default(this);
          return this._use(Q);
        }).then((Q) => Q.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config;
    $.getServer = () => this.getServer();
    const X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Q = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((J) => Q === J))
          return this;
        this.dependencies[Y].push(Q);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Q) => {
        Object.assign(Q, this.decorators), Object.assign(Q.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const Z = this.mount($.fetch);
      return this.routes = this.routes.concat(Z.routes), this;
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q, handler: J, hooks: z } of Object.values($.routes))
      this.add(Z, Q, J, C1(z, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z), this.event = m$(this.event, N6($.event), Z);
      } else
        this.event = m$(this.event, N6($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, Q = async ({ request: J, path: z }) => Z(new Request("http://a.cc" + z || "/", J));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: Q }) => Y(new Request("http://a.cc" + Q.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    let X = null;
    const Z = X1(Y?.body, { models: this.definitions.type }), Q = X1(Y?.response, { models: this.definitions.type }), J = (z) => {
      const U = z.charCodeAt(0);
      if (U === 47 || U === 123)
        try {
          z = JSON.parse(z);
        } catch {
        }
      else if (!Number.isNaN(+z))
        z = +z;
      if (W?.length)
        for (let D = 0;D < W.length; D++) {
          const B = W[D](z);
          if (B !== undefined)
            z = B;
        }
      return z;
    };
    return this.get($, (z) => {
      const { set: U, path: D, qi: B, headers: j, query: b, params: S } = z;
      if (X === null)
        X = this.getServer();
      if (X?.upgrade(z.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(z) : Y.upgrade, data: { validator: Q, open(N) {
        Y.open?.(new c1(N, z));
      }, message: (N, O) => {
        const P = J(O);
        if (Z?.Check(P) === false)
          return void N.send(new P0("message", Z, P).message);
        Y.message?.(new c1(N, z), P);
      }, drain(N) {
        Y.drain?.(new c1(N, z));
      }, close(N, O, P) {
        Y.close?.(new c1(N, z), O, P);
      } } }))
        return;
      return U.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = U1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = U1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (U) => U[0].toUpperCase() + U.slice(1), Q = $ === "prefix" ? (U, D) => X.includes(U.at(-1) ?? "") ? U + D : U + Z(D) : X.includes(W.at(-1) ?? "") ? (U, D) => D + U : (U, D) => D + Z(U), J = (U) => {
      const D = {};
      switch (U) {
        case "decorator":
          for (let B in this.decorators)
            D[Q(W, B)] = this.decorators[B];
          this.decorators = D;
          break;
        case "state":
          for (let B in this.store)
            D[Q(W, B)] = this.store[B];
          this.store = D;
          break;
        case "model":
          for (let B in this.definitions.type)
            D[Q(W, B)] = this.definitions.type[B];
          this.definitions.type = D;
          break;
        case "error":
          for (let B in this.definitions.error)
            D[Q(W, B)] = this.definitions.error[B];
          this.definitions.error = D;
          break;
      }
    }, z = Array.isArray(Y) ? Y : [Y];
    for (let U of z.some((D) => D === "all") ? ["decorator", "state", "model", "error"] : z)
      J(U);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? w6(this) : j6(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w6(this) : j6(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? K6(this) : oW(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !q$, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W6 }, fetch: W, error: this.outerErrorHandler } : { development: !q$, ...this.config.serve, websocket: { ...this.config.websocket, ...W6 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X), this.event.start.length)
      (async () => {
        const Z = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Q = 0;Q < this.event.transform.length; Q++) {
          const J = this.event.transform[Q](Z);
          if (this.event.transform[Q].$elysia === "derive")
            if (J instanceof Promise)
              Object.assign(Z, await J);
            else
              Object.assign(Z, J);
        }
        for (let Q = 0;Q < this.event.start.length; Q++)
          this.event.start[Q](Z);
      })();
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      (async () => {
        const $ = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Y = 0;Y < this.event.transform.length; Y++) {
          const W = this.event.transform[Y]($);
          if (this.event.transform[Y].$elysia === "derive")
            if (W instanceof Promise)
              Object.assign($, await W);
            else
              Object.assign($, W);
        }
        for (let Y = 0;Y < this.event.stop.length; Y++)
          this.event.stop[Y]($);
      })();
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = Y0.Type;

// ../../node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: "*",
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: false,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
  const app = new c$({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart === -1)
          return false;
        return origin2 === from.slice(protocolStart + 3);
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set, request) => {
    if (origin === true) {
      set.headers["Vary"] = "*";
      set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value = processOrigin(origins[i], request, from);
        if (value === true) {
          set.headers["Vary"] = origin ? "Origin" : "*";
          set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
          return;
        }
        if (value)
          headers.push(value);
      }
    }
    set.headers["Vary"] = "Origin";
    set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set) => {
    if (!methods?.length)
      return;
    if (methods === "*")
      return set.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set.headers["Access-Control-Allow-Methods"] = methods;
    set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  return app.onRequest(({ set, request }) => {
    handleOrigin(set, request);
    handleMethod(set);
    if (allowedHeaders.length)
      set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
    if (exposedHeaders.length)
      set.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
    if (credentials)
      set.headers["Access-Control-Allow-Credentials"] = "true";
  });
};

// ../../node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 6,
  patch: 0,
  preReleaseTag: null
});
// ../../node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// ../../node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === undefined ? undefined : value.then) === "function";
}

// ../../node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// ../../node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// ../../node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp = /\r\n|[\n\r]/g;

// ../../node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0;i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
var printPrefixedLines = function(lines) {
  const existingLines = lines.filter(([_, line]) => line !== undefined);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
};

// ../../node_modules/graphql/error/GraphQLError.mjs
var toNormalizedOptions = function(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
};
var undefinedIfEmpty = function(array) {
  return array === undefined || array.length === 0 ? undefined : array;
};
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== undefined ? path : undefined;
    this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
    this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
    this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== undefined && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location3 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location3);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}

// ../../node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// ../../node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}

class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}

class Token {
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// ../../node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// ../../node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// ../../node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// ../../node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0;i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent = leadingWhitespace(line);
    if (indent === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent < commonIndent) {
      commonIndent = indent;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
};
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0;i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// ../../node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// ../../node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
var isUnicodeScalarValue = function(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
};
var isSupplementaryCodePoint = function(body, location3) {
  return isLeadingSurrogate(body.charCodeAt(location3)) && isTrailingSurrogate(body.charCodeAt(location3 + 1));
};
var isLeadingSurrogate = function(code) {
  return code >= 55296 && code <= 56319;
};
var isTrailingSurrogate = function(code) {
  return code >= 56320 && code <= 57343;
};
var printCodePointAt = function(lexer, location3) {
  const code = lexer.source.body.codePointAt(location3);
  if (code === undefined) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? "'\"'" : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
};
var createToken = function(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
};
var readNextToken = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
};
var readComment = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
};
var readNumber = function(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
};
var readDigits = function(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
};
var readString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readEscapedUnicodeVariableWidth = function(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
};
var readEscapedUnicodeFixedWidth = function(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
};
var read16BitHexCode = function(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
};
var readHexDigit = function(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
};
var readEscapedCharacter = function(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: `\r`,
        size: 2
      };
    case 116:
      return {
        value: "\t",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
};
var readBlockString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readName = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
};

class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}

// ../../node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
var formatValue = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
};
var formatObjectValue = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
};
var isJSONable = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;

// ../../node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = function instanceOf3(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (typeof value === "object" && value !== null) {
    var _value$constructor;
    const className = constructor.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// ../../node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}

class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

// ../../node_modules/graphql/language/parser.mjs
function parse(source2, options) {
  const parser = new Parser(source2, options);
  return parser.parseDocument();
}
var getTokenDesc = function(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
};
var getTokenKindDesc = function(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
};

class Parser {
  constructor(source2, options = {}) {
    const sourceObj = isSource(source2) ? source2 : new Source(source2);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
      }
    }
  }
}

// ../../node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS = 5;

// ../../node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// ../../node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// ../../node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// ../../node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// ../../node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var isDigit2 = function(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
};
var DIGIT_0 = 48;
var DIGIT_9 = 57;

// ../../node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== undefined) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
var stringToArray = function(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0;i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return;
    }
    const rows = this._rows;
    for (let j = 0;j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1;i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1;j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : undefined;
  }
}

// ../../node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// ../../node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedReplacer = function(str) {
  return escapeSequences[str.charCodeAt(0)];
};
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// ../../node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = new Map;
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = undefined;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = undefined;
  let parent = undefined;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === undefined) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== undefined) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== undefined);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(undefined);
    const leaveList = new Array(visitors.length).fill(undefined);
    for (let i = 0;i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: undefined
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK = Object.freeze({});

// ../../node_modules/graphql/language/printer.mjs
function print(ast4) {
  return visit(ast4, printDocASTReducer);
}
var join2 = function(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
};
var block = function(array) {
  return wrap("{\n", indent(join2(array, "\n")), "\n}");
};
var wrap = function(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
};
var indent = function(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
};
var hasMultilineItems = function(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
};
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2([
        node.operation,
        join2([node.name, varDefs]),
        join2(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join2(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join2([
      "...",
      wrap("on ", typeCondition),
      join2(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join2(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join2(["schema", join2(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join2(["scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join2([
      "type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type + wrap(" ", join2(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join2([name + ": " + type, wrap("= ", defaultValue), join2(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join2([
      "interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join2(["union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join2(["enum", name, join2(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join2([name, join2(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join2(["input", name, join2(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join2([
      "extend union",
      name,
      join2(directives, " "),
      wrap("= ", join2(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block(fields)], " ")
  }
};

// ../../node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind.VARIABLE:
      return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
  }
}

// ../../node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1;i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// ../../node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var defineInterfaces = function(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
};
var defineFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
var isPlainObj = function(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
};
var fieldsToFieldsConfig = function(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
};
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === undefined;
}
var defineTypes = function(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
  return types;
};
var didYouMeanEnumValue = function(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
};
var defineEnumValues = function(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== undefined ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
};
var defineInputFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === undefined;
}

class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);
    config.serialize == null || typeof config.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLEnumType {
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === undefined) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({
      description: value.description,
      value: value.value,
      deprecationReason: value.deprecationReason,
      extensions: value.extensions,
      astNode: value.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(undefined, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

// ../../node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// ../../node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
var serializeObject = function(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
};
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
        nodes: valueNode
      });
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);

// ../../node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}

class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(false, `@${config.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// ../../node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
}

// ../../node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === undefined) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => ("name" in type) ? type.name : undefined
    },
    description: {
      type: GraphQLString,
      resolve: (type) => ("description" in type) ? type.description : undefined
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => ("ofType" in type) ? type.ofType : undefined
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: undefined,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: undefined,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// ../../node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
var collectReferencedTypes = function(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
};

class GraphQLSchema {
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : undefined;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect(config.types)}.`);
    !config.directives || Array.isArray(config.directives) || devAssert(false, '"directives" must be Array if provided but got: ' + `${inspect(config.directives)}.`);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = Object.create(null);
    this._subTypeMap = Object.create(null);
    this._implementationsMap = Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(false, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== undefined) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== undefined ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === undefined) {
      map = Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== undefined;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== undefined
    };
  }
}

// ../../node_modules/graphql/type/validate.mjs
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  const context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema2.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema2) {
  const errors = validateSchema(schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var validateRootTypes = function(context) {
  const schema2 = context.schema;
  const queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema2, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema2, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema2, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
};
var getOperationTypeNode = function(schema2, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap((schemaNode) => {
    var _schemaNode$operation;
    return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
};
var validateDirectives = function(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
        ]);
      }
    }
  }
};
var validateName = function(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
  }
};
var validateTypes = function(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
};
var validateFields = function(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
        ]);
      }
    }
  }
};
var validateInterfaces = function(context, type) {
  const ifaceTypeNames = Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (type === iface) {
      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
};
var validateTypeImplementsInterface = function(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
      ]);
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
        ]);
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
      }
    }
  }
};
var validateTypeImplementsAncestors = function(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
        ...getAllImplementsInterfaceNodes(iface, transitive),
        ...getAllImplementsInterfaceNodes(type, iface)
      ]);
    }
  }
};
var validateUnionMembers = function(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
  }
  const includedTypeNames = Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
};
var validateEnumValues = function(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
};
var validateInputFields = function(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
      ]);
    }
  }
};
var createInputObjectCircularRefsValidator = function(context) {
  const visitedTypes = Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === undefined) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = undefined;
  }
};
var getAllImplementsInterfaceNodes = function(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
};
var getUnionMemberTypeNodes = function(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
  }).filter((typeNode) => typeNode.name.value === typeName);
};
var getDeprecatedDirectiveNode = function(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);
};

class SchemaValidationContext {
  constructor(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(new GraphQLError(message, {
      nodes: _nodes
    }));
  }
  getErrors() {
    return this._errors;
  }
}

// ../../node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema2, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema2.getType(typeNode.name.value);
  }
}

// ../../node_modules/graphql/utilities/TypeInfo.mjs
var getFieldDef = function(schema2, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
};
function visitWithTypeInfo(typeInfo, visitor3) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor3, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor3, args);
        if (result !== undefined) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor3, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor3, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

class TypeInfo {
  constructor(schema2, initialType, getFieldDefFn) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema2 = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema2.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(undefined);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
}

// ../../node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// ../../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition10 of node.definitions) {
        if (!isExecutableDefinitionNode(definition10)) {
          const defName = definition10.kind === Kind.SCHEMA_DEFINITION || definition10.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition10.name.value + '"';
          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, {
            nodes: definition10
          }));
        }
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema2 = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema2, type, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
            nodes: node
          }));
        }
      }
    }
  };
}
var getSuggestedTypeNames = function(schema2, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = new Set;
  const usageCount = Object.create(null);
  for (const possibleType of schema2.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
};
var getSuggestedFieldNames = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
};

// ../../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
            nodes: typeCondition
          }));
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
          nodes: node.typeCondition
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), {
          nodes: argNode
        }));
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), {
              nodes: argNode
            }));
          }
        }
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(new GraphQLError(`Unknown directive "@${name}".`, {
          nodes: node
        }));
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
          nodes: node
        }));
      }
    }
  };
}
var getDirectiveLocationForASTPath = function(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
};
var getDirectiveLocationForOperation = function(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
};

// ../../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, {
          nodes: node.name
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypesMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _12, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), {
          nodes: node
        }));
      }
    }
  };
}
var isSDLNode = function(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
};
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type) => type.name);

// ../../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter((definition12) => definition12.kind === Kind.OPERATION_DEFINITION).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", {
          nodes: node
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", {
          nodes: node
        }));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", {
          nodes: node
        }));
      }
      ++schemaDefinitionsCount;
    }
  };
}

// ../../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === undefined) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
          nodes: cyclePath
        }));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = undefined;
  }
}

// ../../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "\$${varName}" is not defined.`, {
              nodes: [node, operation]
            }));
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// ../../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, {
              nodes: fragmentDef
            }));
          }
        }
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "\$${variableName}" is never used.`, {
              nodes: variableDef
            }));
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// ../../node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
var sortFields = function(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));
};

// ../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
var reasonMessage = function(reason) {
  if (Array.isArray(reason)) {
    return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
  }
  return reason;
};
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet;
  const cachedFieldsAndFragmentNames = new Map;
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
          nodes: fields1.concat(fields2)
        }));
      }
    }
  };
}
var findConflictsWithinSelectionSet = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (let i = 0;i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (let j = i + 1;j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
};
var collectConflictsBetweenFieldsAndFragment = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
      continue;
    }
    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
  }
};
var collectConflictsBetweenFragments = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
  }
};
var findConflictsBetweenSubSelectionSets = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
    }
  }
  return conflicts;
};
var collectConflictsWithin = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0;i < fields.length; i++) {
        for (let j = i + 1;j < fields.length; j++) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var collectConflictsBetween = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var findConflict = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
  const type2 = def2 === null || def2 === undefined ? undefined : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(type2)}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
};
var stringifyArguments = function(fieldNode) {
  var _fieldNode$arguments;
  const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== undefined ? _fieldNode$arguments : [];
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
};
var doTypesConflict = function(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
};
var getFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = Object.create(null);
  const fragmentNames = Object.create(null);
  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
};
var getReferencedFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
};
var _collectFieldsAndFragmentNames = function(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
};
var subfieldConflicts = function(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
};

class PairSet {
  constructor() {
    this._data = new Map;
  }
  has(a, b, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(key2);
    if (result === undefined) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a, b, areMutuallyExclusive) {
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const map = this._data.get(key1);
    if (map === undefined) {
      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
}

// ../../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    }
  };
}
var getFragmentType = function(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
};

// ../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema2 = context.getSchema();
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema2 === null || schema2 === undefined ? undefined : schema2.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
          nodes: defNode ? [defNode, node] : node
        }));
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema2 === null || schema2 === undefined ? undefined : schema2.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
        nodes: node.name
      }));
    }
  }
}
var typeToExtKind = function(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
};
var extensionKindToTypeName = function(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
};
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};

// ../../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
              nodes: fieldNode
            }));
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === undefined ? undefined : schema2.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), (arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                nodes: directiveNode
              }));
            }
          }
        }
      }
    }
  };
}
var isRequiredArgumentNode = function(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
};

// ../../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
              nodes: selectionSet
            }));
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
            nodes: node
          }));
        }
      }
    }
  };
}

// ../../node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// ../../node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}

// ../../node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, undefined);
}
var defaultOnError = function(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
};
var coerceInputValueImpl = function(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect(type)}" not to be null.`));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, undefined);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}" to be an object.`));
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === undefined) {
        if (field.defaultValue !== undefined) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}". ` + error.message, {
          originalError: error
        }));
      }
      return;
    }
    if (parseResult === undefined) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}".`));
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
};

// ../../node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === undefined) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === undefined) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === undefined) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === undefined) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === undefined) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var isMissingVariable = function(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
};

// ../../node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", {
          nodes: node
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: valueNode
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", {
        nodes: valueNode
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw new GraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: valueNode
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
var hasOwnProperty = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

// ../../node_modules/graphql/execution/collectFields.mjs
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new Map;
  collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
  return fields;
}
function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new Map;
  const visitedFragmentNames = new Set;
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
var collectFieldsImpl = function(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== undefined) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
};
var shouldIncludeNode = function(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return false;
  }
  return true;
};
var doesFragmentConditionMatch = function(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema2.isSubType(conditionalType, type);
  }
  return false;
};
var getFieldEntryKey = function(node) {
  return node.alias ? node.alias.value : node.name.value;
};

// ../../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema2 = context.getSchema();
        const subscriptionType = schema2.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = Object.create(null);
          const document2 = context.getDocument();
          const fragments = Object.create(null);
          for (const definition21 of document2.definitions) {
            if (definition21.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition21.name.value] = definition21;
            }
          }
          const fields = collectFields(schema2, fragments, variableValues, subscriptionType, node.selectionSet);
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
              nodes: extraFieldSelections
            }));
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                nodes: fieldNodes
              }));
            }
          }
        }
      }
    }
  };
}

// ../../node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = new Map;
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === undefined) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// ../../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
  }
}

// ../../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema2 !== null && schema2 !== undefined && schema2.getDirective(directiveName)) {
        context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
          nodes: node.name
        }));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
          nodes: [knownDirectiveNames[directiveName], node.name]
        }));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = Object.create(null);
  const typeDirectivesMap = Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === undefined) {
          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
        }
      } else {
        seenDirectives = Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
              nodes: [seenDirectives[directiveName], directive]
            }));
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: valueDef.name
        }));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
          nodes: [valueNames[valueName], valueDef.name]
        }));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: fieldDef.name
        }));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
          nodes: [fieldNames[fieldName], fieldDef.name]
        }));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
var hasField = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
};

// ../../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
          nodes: [knownFragmentNames[fragmentName], node.name]
        }));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, {
          nodes: [knownNames[fieldName], node.name]
        }));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
            nodes: [
              knownOperationNames[operationName.value],
              operationName
            ]
          }));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// ../../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema2 = context.getSchema();
  const definedOperationTypes = Object.create(null);
  const existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
          nodes: operationType
        }));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, {
          nodes: [alreadyDefinedOperationType, operationType]
        }));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema2 !== null && schema2 !== undefined && schema2.getType(typeName)) {
      context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
        nodes: node.name
      }));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, {
        nodes: [knownTypeNames[typeName], node.name]
      }));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(new GraphQLError(`There can be only one variable named "\$${variableName}".`, {
            nodes: variableNodes.map((node) => node.variable.name)
          }));
        }
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(new GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
            nodes: node
          }));
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), {
          nodes: node
        }));
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(new GraphQLError(`Expected value of type "${inspect(type)}", found ${print(node)}.`, {
          nodes: node
        }));
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
var isValidValueNode = function(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
      nodes: node
    }));
    return;
  }
  try {
    const parseResult = type.parseLiteral(node, undefined);
    if (parseResult === undefined) {
      const typeStr = inspect(locationType);
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
        nodes: node
      }));
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}; ` + error.message, {
        nodes: node,
        originalError: error
      }));
    }
  }
};

// ../../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== undefined && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(new GraphQLError(`Variable "\$${variableName}" cannot be non-input type "${typeName}".`, {
          nodes: node.type
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema2 = context.getSchema();
            const varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(schema2, varType, varDef.defaultValue, type, defaultValue)) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(new GraphQLError(`Variable "\$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                nodes: [varDef, node]
              }));
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
var allowedVariableUsage = function(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== undefined;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
};

// ../../node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// ../../node_modules/graphql/validation/ValidationContext.mjs
class ASTValidationContext {
  constructor(ast8, onError) {
    this._ast = ast8;
    this._fragments = undefined;
    this._fragmentSpreads = new Map;
    this._recursivelyReferencedFragments = new Map;
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}
class ValidationContext extends ASTValidationContext {
  constructor(schema2, ast8, typeInfo, onError) {
    super(ast8, onError);
    this._schema = schema2;
    this._typeInfo = typeInfo;
    this._variableUsages = new Map;
    this._recursiveVariableUsages = new Map;
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: () => false,
        Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}

// ../../node_modules/graphql/validation/validate.mjs
function validate2(schema2, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema2)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema2);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(schema2, documentAST, typeInfo, (error) => {
    if (errors.length >= maxErrors) {
      errors.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors.push(error);
  });
  const visitor5 = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor5));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}

// ../../node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === undefined) {
      cache0 = new WeakMap;
    }
    let cache1 = cache0.get(a1);
    if (cache1 === undefined) {
      cache1 = new WeakMap;
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === undefined) {
      cache2 = new WeakMap;
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === undefined) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// ../../node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}

class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}

// ../../node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
var isLocatedGraphQLError = function(error) {
  return Array.isArray(error.path);
};

// ../../node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source2, args, contextValue, info) {
  if (isObjectLike(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
// ../../node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition26 of documentAST.definitions) {
    if (definition26.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition26;
      } else if (((_definition$name = definition26.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
        return definition26;
      }
    }
  }
  return operation;
}
// ../../node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema3) {
  const schemaConfig = schema3.toConfig();
  const typeMap = keyValMap(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
var sortObjMap = function(map, sortValueFn) {
  const sortedMap = Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
};
var sortByName = function(array) {
  return sortBy(array, (obj) => obj.name);
};
var sortBy = function(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
};
// ../../node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema3) {
  return printFilteredSchema(schema3, (n) => !isSpecifiedDirective(n), isDefinedType);
}
var isDefinedType = function(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
};
var printFilteredSchema = function(schema3, directiveFilter, typeFilter) {
  const directives10 = schema3.getDirectives().filter(directiveFilter);
  const types = Object.values(schema3.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema3),
    ...directives10.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
};
var printSchemaDefinition = function(schema3) {
  if (schema3.description == null && isSchemaOfCommonNames(schema3)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema3.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema3) + `schema {\n${operationTypes.join("\n")}\n}`;
};
var isSchemaOfCommonNames = function(schema3) {
  const queryType = schema3.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema3.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
};
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
var printScalar = function(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
};
var printImplementedInterfaces = function(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
};
var printObject = function(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printInterface = function(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printUnion = function(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
};
var printEnum = function(type) {
  const values2 = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
  return printDescription(type) + `enum ${type.name}` + printBlock(values2);
};
var printInputObject = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
  return printDescription(type) + `input ${type.name}` + printBlock(fields);
};
var printFields = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
  return printBlock(fields);
};
var printBlock = function(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
};
var printArgs = function(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
};
var printInputValue = function(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
};
var printDirective = function(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
};
var printDeprecated = function(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
};
var printSpecifiedByURL = function(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
};
var printDescription = function(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString4 = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString4.replace(/\n/g, "\n" + indentation) + "\n";
};
// ../../node_modules/cross-inspect/esm/index.js
function inspect25(value) {
  return formatValue2(value, []);
}
var formatValue2 = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value, seenValues);
    default:
      return String(value);
  }
};
var formatError2 = function(value) {
  if (value.name = "GraphQLError") {
    return value.toString();
  }
  return `${value.name}: ${value.message};\n ${value.stack}`;
};
var formatObjectValue2 = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable2(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray2(value, seenValues);
  }
  return formatObject2(value, seenValues);
};
var isJSONable2 = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject2 = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray2 = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue2(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag2 = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_RECURSIVE_DEPTH2 = 3;

// ../../node_modules/@graphql-tools/utils/esm/errors.js
var isGraphQLErrorLike = function(error) {
  return error != null && typeof error === "object" && Object.keys(error).every((key) => possibleGraphQLErrorProperties.includes(key));
};
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];

// ../../node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject4(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike10(value) {
  return typeof value === "object" && value !== null;
}
function isPromise3(value) {
  return value?.then != null;
}
function promiseReduce(values2, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values2) {
    accumulator = isPromise3(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// ../../node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues2(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== undefined) {
        coercedValues[name] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect25(argType)}" ` + "was not provided.", {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect25(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect25(argType)}" ` + "must not be null.", {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// ../../node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = new WeakMap;
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === undefined) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize33(fn) {
  const memoize3Cache = new WeakMap;
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize3Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const newValue = fn(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = new WeakMap;
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize5Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const cache42 = new WeakMap;
      cache32.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const cache42 = new WeakMap;
      cache3.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = new WeakMap;
      cache3.set(a3, cache4);
      const cache52 = new WeakMap;
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = new WeakMap;
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
// ../../node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema3, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema3);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema3) {
  const rootTypes = getRootTypes(schema3);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema3) {
  const rootTypeMap = getRootTypeMap(schema3);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema3) {
  const rootTypeMap = new Map;
  const queryType = schema3.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});
// ../../node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator, onNext, onError, onEnd) {
  if (Symbol.asyncIterator in iterator) {
    iterator = iterator[Symbol.asyncIterator]();
  }
  let $return;
  let abruptClose;
  let onEndWithValue;
  if (onEnd) {
    onEndWithValue = (value) => {
      const onEnd$ = onEnd();
      return isPromise3(onEnd$) ? onEnd$.then(() => value) : value;
    };
  }
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => Promise.reject(error);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    if (result.done) {
      return onEndWithValue ? onEndWithValue(result) : result;
    }
    return asyncMapValue(result.value, onNext).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (onError) {
    const reject = onError;
    mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
      return onEndWithValue ? res$.then(onEndWithValue) : res$;
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      return Promise.reject(error).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var asyncMapValue = function(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
};
var iteratorResult = function(value) {
  return { value, done: false };
};
// ../../node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
class AccumulatorMap extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === undefined) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
}

// ../../node_modules/@graphql-tools/utils/esm/directives.js
var GraphQLDeferDirective = new GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FIELD],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// ../../node_modules/@graphql-tools/utils/esm/collectFields.js
var collectFieldsImpl2 = function(schema3, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey2(selection), selection);
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema3, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch2(schema3, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
};
function collectFields4(schema3, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap;
  const patches = [];
  collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set);
  return { fields, patches };
}
function shouldIncludeNode2(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch2(schema3, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema3, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema3.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey2(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : undefined
  };
}
var collectSubFields = memoize5(function collectSubfields3(schema3, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap;
  const visitedFragmentNames = new Set;
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl2(schema3, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});
// ../../node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value) {
  return value?.[Symbol.asyncIterator] != null;
}
// ../../node_modules/@graphql-tools/utils/esm/Path.js
function addPath2(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray2(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray3(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}
// ../../node_modules/graphql-yoga/esm/error.js
var isAggregateError = function(obj) {
  return obj != null && typeof obj === "object" && "errors" in obj;
};
var hasToString = function(obj) {
  return obj != null && typeof obj.toString === "function";
};
function isGraphQLError(val) {
  return val instanceof GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error, maskedErrorsOpts, logger) {
  const errors4 = new Set;
  if (isAggregateError(error)) {
    for (const singleError of error.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors4.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error) {
      logger.error(error);
    }
    errors4.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error)) {
    errors4.add(error);
  } else if (error instanceof Error) {
    errors4.add(createGraphQLError(error.message, {
      originalError: error
    }));
  } else if (typeof error === "string") {
    errors4.add(createGraphQLError(error, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error)) {
    errors4.add(createGraphQLError(error.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error);
    errors4.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors4);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if ("extensions" in result && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if ("errors" in result && result.errors?.length) {
    for (const error of result.errors) {
      if (error.extensions?.http) {
        if (error.extensions.http.headers) {
          Object.assign(headers, error.extensions.http.headers);
        }
        if (isApplicationJson && error.extensions.http.spec) {
          continue;
        }
        if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
          status = error.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.some(isGraphQLError);
}

// ../../node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// ../../node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = "<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\"https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/yoga-graphiql.es.js\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>";

// ../../node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
function useGraphiQL(config) {
  const logger = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || url.pathname === config.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse(response);
        }
      }
    }
  };
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));

// ../../node_modules/graphql-yoga/esm/plugins/use-schema.js
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema3;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema3 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema3) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema3);
      }
    };
  }
  const schemaByRequest = new WeakMap;
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema3 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema3);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema3 = schemaByRequest.get(context.request);
      if (schema3 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema3);
    }
  };
};

// ../../node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = new WeakMap;

// ../../node_modules/@envelop/core/esm/utils.js
var getSubscribeArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
};
function mapAsyncIterator3(source2, mapper) {
  const iterator = source2[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: undefined, done: true };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error;
    }
  };
  return stream;
}
var getExecuteArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
};
function isAsyncIterable3(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable3(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return;
}
function finalAsyncIterator(source2, onFinal) {
  const iterator = source2[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source2, onError) {
  const iterator = source2[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error) {
        onError(error);
        return { done: true, value: undefined };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));

// ../../node_modules/@envelop/core/esm/orchestrator.js
var throwEngineFunctionError = function(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
};
function createEnvelopOrchestrator({ plugins }) {
  let schema3 = null;
  let initDone = false;
  const parse2 = () => throwEngineFunctionError("parse");
  const validate3 = () => throwEngineFunctionError("validate");
  const execute2 = () => throwEngineFunctionError("execute");
  const subscribe2 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema3 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema3,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin] of plugins.entries()) {
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        plugins.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source2, parseOptions) => {
    let result = null;
    let parseFn = parse2;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source: source2, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source2, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source2.toString());
    return result;
  } : () => parse2;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema4, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : undefined;
    let validateFn = validate3;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema4,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema4, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate3;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe2;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await subscribeFn({
        ...args,
        contextValue: context
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable3(result)) {
      result = mapAsyncIterator3(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable3(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable3(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error,
            setError: (err2) => {
              error = err2;
            }
          });
        }
        throw error;
      });
    }
    return result;
  }) : makeSubscribe(subscribe2);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute2;
    let result;
    const afterCalls = [];
    const context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable3(result)) {
      result = mapAsyncIterator3(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable3(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute2);
  initDone = true;
  if (schema3) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema3,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema3;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// ../../node_modules/@envelop/core/esm/create.js
var notEmpty = function(value) {
  return value != null;
};
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator2 = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator2;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// ../../node_modules/@envelop/core/esm/plugins/use-masked-errors.js
function isGraphQLError2(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError2(error) {
  if (isGraphQLError2(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError2(error.originalError);
    }
    return true;
  }
  return false;
}
var createSerializableGraphQLError = function(message, originalError, isDev) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError(error, message));
        }
      };
    }
  };
}
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var createDefaultMaskError = (isDev) => (error, message) => {
  if (isOriginalGraphQLError2(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError(error, message)) });
  }
};

// ../../node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// ../../node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// ../../node_modules/value-or-promise/build/module/ValueOrPromise.js
var isPromiseLike = function(object) {
  return object != null && typeof object.then === "function";
};
var defaultOnRejectedFn = (reason) => {
  throw reason;
};

class ValueOrPromise {
  state;
  constructor(executor2) {
    let value;
    try {
      value = executor2();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike(value)) {
      this.state = { status: "pending", value };
      return;
    }
    this.state = { status: "fulfilled", value };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
      return onFulfilledFn === undefined ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e) {
      return new ValueOrPromise(() => onRejectedFn(e));
    }
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let rejected = false;
    let reason;
    let containsPromise = false;
    const values2 = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        if (rejected) {
          continue;
        }
        rejected = true;
        reason = state.value;
        continue;
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values2.push(state.value);
    }
    if (containsPromise) {
      if (rejected) {
        Promise.all(values2).catch(() => {
        });
        return new ValueOrPromise(() => {
          throw reason;
        });
      }
      return new ValueOrPromise(() => Promise.all(values2));
    }
    return new ValueOrPromise(() => values2);
  }
}
// ../../node_modules/@graphql-tools/executor/esm/execution/coerceError.js
function coerceError(error) {
  if (error instanceof Error) {
    return error;
  }
  if (typeof error === "object" && error != null) {
    if ("message" in error && typeof error.message === "string") {
      let errorOptions;
      if ("cause" in error) {
        errorOptions = { cause: error.cause };
      }
      const coercedError = new Error(error.message, errorOptions);
      if ("stack" in error && typeof error.stack === "string") {
        coercedError.stack = error.stack;
      }
      if ("name" in error && typeof error.name === "string") {
        coercedError.name = error.name;
      }
      return coercedError;
    }
  }
  return new Error(String(error));
}

// ../../node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: undefined, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = undefined;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = undefined;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: undefined, done: true };
    },
    async throw(error) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// ../../node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant12(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// ../../node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object, signal) {
  const resolvedObject = Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      reject(signal.reason);
    });
    Promise.all(Object.entries(object).map(async ([key, value]) => {
      resolvedObject[key] = await value;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// ../../node_modules/@graphql-tools/executor/esm/execution/values.js
function getVariableValues2(schema3, varDefNodes, inputs, options) {
  const errors4 = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema3, varDefNodes, inputs, (error) => {
      if (maxErrors != null && errors4.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors4.push(error);
    });
    if (errors4.length === 0) {
      return { coerced };
    }
  } catch (error) {
    errors4.push(error);
  }
  return { errors: errors4 };
}
var coerceVariableValues = function(schema3, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema3, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(createGraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty2(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect25(varType);
        onError(createGraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect25(varType);
      onError(createGraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error) => {
      let prefix = `Variable "\$${varName}" got invalid value ` + inspect25(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray3(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error.message, {
        nodes: varDefNode,
        originalError: error
      }));
    });
  }
  return coercedValues;
};

// ../../node_modules/@graphql-tools/executor/esm/execution/execute.js
function execute2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
var executeImpl = function(exeContext) {
  if (exeContext.signal?.aborted) {
    throw exeContext.signal.reason;
  }
  const result = new ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error) => {
    if (exeContext.signal?.aborted) {
      throw exeContext.signal.reason;
    }
    if (error.errors) {
      exeContext.errors.push(...error.errors);
    } else {
      exeContext.errors.push(error);
    }
    return buildResponse(null, exeContext.errors);
  }).resolve();
  return result;
};
var buildResponse = function(data, errors4) {
  return errors4.length === 0 ? { data } : { errors: errors4, data };
};
function buildExecutionContext(args) {
  const { schema: schema3, document: document2, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args;
  assertValidSchema(schema3);
  const fragments = getFragmentsFromDocument(document2);
  let operation;
  for (const definition28 of document2.definitions) {
    switch (definition28.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== undefined) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition28;
        } else if (definition28.name?.value === operationName) {
          operation = definition28;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues2(schema3, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema3,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver2,
    typeResolver: typeResolver ?? defaultTypeResolver2,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver2,
    subsequentPayloads: new Set,
    errors: [],
    signal
  };
}
var buildPerEventExecutionContext = function(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: new Set,
    errors: []
  };
};
var executeOperation = function(exeContext) {
  const { operation, schema: schema3, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema3, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields4(schema3, fragments, variableValues, rootType, operation.selectionSet);
  const path = undefined;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
};
var executeFieldsSerially = function(exeContext, parentType, sourceValue, path, fields2) {
  return promiseReduce(fields2, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath2(path, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      throw exeContext.signal.reason;
    }
    return new ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      return results;
    });
  }, Object.create(null)).resolve();
};
var executeFields = function(exeContext, parentType, sourceValue, path, fields2, asyncPayloadRecord) {
  const results = Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields2) {
      if (exeContext.signal?.aborted) {
        throw exeContext.signal.reason;
      }
      const fieldPath = addPath2(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== undefined) {
        results[responseName] = result;
        if (isPromise3(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
};
var executeField = function(exeContext, parentType, source2, fieldNodes, path, asyncPayloadRecord) {
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source2, args, contextValue, info);
    let completed;
    if (isPromise3(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise3(completed)) {
      return completed.then(undefined, (rawError) => {
        if (rawError instanceof AggregateError) {
          return new AggregateError(rawError.errors.map((rawErrorItem) => {
            rawErrorItem = coerceError(rawErrorItem);
            const error2 = locatedError(rawErrorItem, fieldNodes, pathToArray2(path));
            const handledError2 = handleFieldError(error2, returnType, errors4);
            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
            return handledError2;
          }));
        }
        rawError = coerceError(rawError);
        const error = locatedError(rawError, fieldNodes, pathToArray2(path));
        const handledError = handleFieldError(error, returnType, errors4);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    if (rawError instanceof AggregateError) {
      return new AggregateError(rawError.errors.map((rawErrorItem) => {
        const coercedError2 = coerceError(rawErrorItem);
        const error2 = locatedError(coercedError2, fieldNodes, pathToArray2(path));
        return handleFieldError(error2, returnType, errors4);
      }));
    }
    const coercedError = coerceError(rawError);
    const error = locatedError(coercedError, fieldNodes, pathToArray2(path));
    const handledError = handleFieldError(error, returnType, errors4);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
};
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
var handleFieldError = function(error, returnType, errors4) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  if (error.extensions?.[CRITICAL_ERROR]) {
    throw error;
  }
  errors4.push(error);
  return null;
};
var completeValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect25(returnType));
};
var getStreamValues = function(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant12(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant12(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : undefined
  };
};
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator.return?.();
  });
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath2(path, index, undefined);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const coercedError = coerceError(rawError);
      const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
      completedResults.push(handleFieldError(error, itemType, errors4));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
var completeListValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject4(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath2(path, index, undefined);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
};
var completeListItemValue = function(item, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise3(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise3(completedItem)) {
      completedResults.push(completedItem.then(undefined, (rawError) => {
        rawError = coerceError(rawError);
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, errors4);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
    const handledError = handleFieldError(error, itemType, errors4);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
};
var completeLeafValue = function(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect25(returnType)}.serialize(${inspect25(result)})\` to ` + `return non-nullable value, returned: ${inspect25(serializedResult)}`);
  }
  return serializedResult;
};
var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise3(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
};
var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (isObjectType(runtimeTypeName)) {
    if (versionInfo.major >= 16) {
      throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
    }
    runtimeTypeName = runtimeTypeName.name;
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect25(result)}, received "${inspect25(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
};
var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise3(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
};
var invalidReturnTypeError = function(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect25(result)}.`, {
    nodes: fieldNodes
  });
};
var collectAndExecuteSubfields = function(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields4(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
};
function subscribe2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise3(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: undefined,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error) {
      done = true;
      return subsequentIterator.throw(error);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult);
  } else {
    yield someExecutionResult;
  }
}
var mapSourceToResponse = function(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream, async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload))), (error) => {
    if (error instanceof AggregateError) {
      throw new AggregateError(error.errors.map((e) => wrapError(e, exeContext.operation)), error.message);
    }
    throw wrapError(error, exeContext.operation);
  }));
};
var wrapError = function(error, operation) {
  return createGraphQLError(error.message, {
    originalError: error,
    nodes: [operation]
  });
};
var createSourceEventStreamImpl = function(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise3(eventStream)) {
      return eventStream.then(undefined, (error) => ({ errors: [error] }));
    }
    return eventStream;
  } catch (error) {
    return { errors: [error] };
  }
};
var executeSubscription = function(exeContext) {
  const { schema: schema3, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema3.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields4(schema3, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef2(schema3, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path = addPath2(undefined, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise3(result)) {
      return result.then(assertEventStream).then(undefined, (error) => {
        throw locatedError(error, fieldNodes, pathToArray2(path));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray2(path));
  }
};
var assertEventStream = function(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError("Subscription field must return Async Iterable. " + `Received: ${inspect25(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
};
var executeDeferredFragment = function(exeContext, parentType, sourceValue, fields2, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields2, asyncPayloadRecord);
    if (isPromise3(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
};
var executeStreamField = function(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise3(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise3(completedItem)) {
        completedItem = completedItem.then(undefined, (rawError) => {
          rawError = coerceError(rawError);
          const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
          const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const coercedError = coerceError(rawError);
      const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
      completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error) {
    asyncPayloadRecord.errors.push(error);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise3(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error) => {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
};
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: undefined };
    }
    item = value;
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise3(completedItem)) {
      completedItem = completedItem.then(undefined, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? undefined;
  while (true) {
    const itemPath = addPath2(path, index, undefined);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error) {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise3(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error) => {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
var filterSubsequentPayloads = function(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray2(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0;i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
};
var getCompletedIncrementalResults = function(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
};
var yieldSubsequentPayloads = function(exeContext) {
  let isDone = false;
  const abortPromise = new Promise((_, reject) => {
    exeContext.signal?.addEventListener("abort", () => {
      isDone = true;
      reject(exeContext.signal?.reason);
    });
  });
  async function next() {
    if (isDone) {
      return { value: undefined, done: true };
    }
    await Promise.race([
      abortPromise,
      ...Array.from(exeContext.subsequentPayloads).map((p) => p.promise)
    ]);
    if (isDone) {
      return { value: undefined, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: undefined, done: true };
    },
    async throw(error) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error);
    }
  };
};
var isStreamPayload = function(asyncPayload) {
  return asyncPayload.type === "stream";
};
function getFieldDef2(schema3, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema3.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema3.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields4 = memoize33((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document2) {
  const fragments = Object.create(null);
  for (const definition28 of document2.definitions) {
    if (definition28.kind === Kind.FRAGMENT_DEFINITION) {
      fragments[definition28.name.value] = definition28;
    }
  }
  return fragments;
});
var CRITICAL_ERROR = "CRITICAL_ERROR";
var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
  if (isObjectLike10(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise3(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver2 = function(source2, args, contextValue, info) {
  if (isObjectLike10(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};

class DeferredFragmentRecord {
  type;
  errors;
  label;
  path;
  promise;
  data;
  parentContext;
  isCompleted;
  _exeContext;
  _resolve;
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
}

class StreamRecord {
  type;
  errors;
  label;
  path;
  items;
  promise;
  parentContext;
  iterator;
  isCompletedIterator;
  isCompleted;
  _exeContext;
  _resolve;
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
}

// ../../node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
function normalizedExecutor(args) {
  const operationAST = getOperationAST(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe2(args);
  }
  return new ValueOrPromise(() => execute2(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result);
    }
    return result;
  }).resolve();
}

// ../../node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill = {};
__export(exports_node_ponyfill, {
  fetch: () => {
    {
      return $fetch;
    }
  },
  crypto: () => {
    {
      return $crypto;
    }
  },
  createFetch: () => {
    {
      return $createFetch;
    }
  },
  btoa: () => {
    {
      return $btoa;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern;
    }
  },
  URL: () => {
    {
      return $URL;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder;
    }
  },
  Response: () => {
    {
      return $Response;
    }
  },
  Request: () => {
    {
      return $Request;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream;
    }
  },
  Headers: () => {
    {
      return $Headers;
    }
  },
  FormData: () => {
    {
      return $FormData;
    }
  },
  File: () => {
    {
      return $File;
    }
  },
  DecompressionStream: () => {
    {
      return $DecompressionStream;
    }
  },
  CompressionStream: () => {
    {
      return $CompressionStream;
    }
  },
  Blob: () => {
    {
      return $Blob;
    }
  }
});
var createNodePonyfill = require_create_node_ponyfill();
var shouldSkipPonyfill = require_shouldSkipPonyfill();
var ponyfills = createNodePonyfill();
if (!shouldSkipPonyfill()) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || import.meta.require(nodelibcurlName);
  } catch (e) {
  }
}
var $fetch = ponyfills.fetch;
var $Headers = ponyfills.Headers;
var $Request = ponyfills.Request;
var $Response = ponyfills.Response;
var $FormData = ponyfills.FormData;
var $ReadableStream = ponyfills.ReadableStream;
var $WritableStream = ponyfills.WritableStream;
var $TransformStream = ponyfills.TransformStream;
var $CompressionStream = ponyfills.CompressionStream;
var $DecompressionStream = ponyfills.DecompressionStream;
var $Blob = ponyfills.Blob;
var $File = ponyfills.File;
var $crypto = ponyfills.crypto;
var $btoa = ponyfills.btoa;
var $TextEncoder = ponyfills.TextEncoder;
var $TextDecoder = ponyfills.TextDecoder;
var $URLPattern = ponyfills.URLPattern;
var $URL = ponyfills.URL;
var $URLSearchParams = ponyfills.URLSearchParams;
var $createFetch = createNodePonyfill;

// ../../node_modules/@whatwg-node/server/esm/utils.js
function isAsyncIterable4(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
var getPort = function(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
};
var getHostnameWithPort = function(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
};
var buildFullUrl = function(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? "https" : "http");
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
};
var isRequestBody = function(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable4(body)) {
    return true;
  }
  return false;
};
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new $URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  let signal;
  const nodeResponse = nodeRequestResponseMap.get(nodeRequest);
  nodeRequestResponseMap.delete(nodeRequest);
  let normalizedHeaders = nodeRequest.headers;
  if (nodeRequest.headers?.[":method"]) {
    normalizedHeaders = {};
    for (const key in nodeRequest.headers) {
      if (!key.startsWith(":")) {
        normalizedHeaders[key] = nodeRequest.headers[key];
      }
    }
  }
  if (nodeResponse?.once) {
    let sendAbortSignal;
    if (RequestCtor !== globalThis.Request) {
      signal = new ServerAdapterRequestAbortSignal;
      sendAbortSignal = () => signal.sendAbort();
    } else {
      const controller = new AbortController;
      signal = controller.signal;
      sendAbortSignal = () => controller.abort();
    }
    const closeEventListener = () => {
      if (signal && !signal.aborted) {
        rawRequest.aborted = true;
        sendAbortSignal();
      }
    };
    nodeResponse.once("error", closeEventListener);
    nodeResponse.once("close", closeEventListener);
    nodeResponse.once("finish", () => {
      nodeResponse.removeListener("close", closeEventListener);
    });
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: normalizedHeaders,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: normalizedHeaders,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: normalizedHeaders,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  if (globalThis.process?.versions?.bun && isReadable(rawRequest)) {
    if (!bunNodeCompatModeWarned) {
      bunNodeCompatModeWarned = true;
      console.warn(`You use Bun Node compatibility mode, which is not recommended!
It will affect your performance. Please check our Bun integration recipe, and avoid using 'http' for your server implementation.`);
    }
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: normalizedHeaders,
      duplex: "half",
      body: new ReadableStream({
        start(controller) {
          rawRequest.on("data", (chunk) => {
            controller.enqueue(chunk);
          });
          rawRequest.on("error", (e) => {
            controller.error(e);
          });
          rawRequest.on("end", () => {
            controller.close();
          });
        },
        cancel(e) {
          rawRequest.destroy(e);
        }
      }),
      signal
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: normalizedHeaders,
    body: rawRequest,
    duplex: "half",
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
var configureSocket = function(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
};
var endResponse = function(serverResponse) {
  serverResponse.end(null, null, null);
};
async function sendAsyncIterable(serverResponse, asyncIterable) {
  let closed = false;
  const closeEventListener = () => {
    closed = true;
  };
  serverResponse.once("error", closeEventListener);
  serverResponse.once("close", closeEventListener);
  serverResponse.once("finish", () => {
    serverResponse.removeListener("close", closeEventListener);
  });
  for await (const chunk of asyncIterable) {
    if (closed) {
      break;
    }
    if (!serverResponse.write(chunk)) {
      if (closed) {
        break;
      }
      await new Promise((resolve) => serverResponse.once("drain", resolve));
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  let setCookiesSet = false;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      if (setCookiesSet) {
        return;
      }
      setCookiesSet = true;
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable4(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source2) => {
    const descriptors = Object.getOwnPropertyNames(source2).reduce((descriptors2, key) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, key);
      if (descriptor) {
        descriptors2[key] = Object.getOwnPropertyDescriptor(source2, key);
      }
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source2).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, sym);
      if (descriptor?.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise4(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value, stopEarlyFn);
    if (isPromise4(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error, ResponseCtor) {
  return new ResponseCtor(error.stack || error.message || error.toString(), {
    status: error.status || 500
  });
}
function isolateObject(originalCtx, waitUntilPromises) {
  if (originalCtx == null) {
    if (waitUntilPromises == null) {
      return {};
    }
    originalCtx = {};
  }
  const extraProps = {};
  const deletedProps = new Set;
  return new Proxy(originalCtx, {
    get(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return function waitUntil(promise) {
          waitUntilPromises.push(promise.catch((err) => console.error(err)));
        };
      }
      const extraPropVal = extraProps[prop];
      if (extraPropVal != null) {
        if (typeof extraPropVal === "function") {
          return extraPropVal.bind(extraProps);
        }
        return extraPropVal;
      }
      if (deletedProps.has(prop)) {
        return;
      }
      return originalCtx2[prop];
    },
    set(_originalCtx, prop, value) {
      extraProps[prop] = value;
      return true;
    },
    has(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return true;
      }
      if (deletedProps.has(prop)) {
        return false;
      }
      if (prop in extraProps) {
        return true;
      }
      return prop in originalCtx2;
    },
    defineProperty(_originalCtx, prop, descriptor) {
      return Reflect.defineProperty(extraProps, prop, descriptor);
    },
    deleteProperty(_originalCtx, prop) {
      if (prop in extraProps) {
        return Reflect.deleteProperty(extraProps, prop);
      }
      deletedProps.add(prop);
      return true;
    },
    ownKeys(originalCtx2) {
      const extraKeys = Reflect.ownKeys(extraProps);
      const originalKeys = Reflect.ownKeys(originalCtx2);
      const deletedKeys = Array.from(deletedProps);
      const allKeys = new Set(extraKeys.concat(originalKeys.filter((keys) => !deletedKeys.includes(keys))));
      if (waitUntilPromises != null) {
        allKeys.add("waitUntil");
      }
      return Array.from(allKeys);
    },
    getOwnPropertyDescriptor(originalCtx2, prop) {
      if (prop in extraProps) {
        return Reflect.getOwnPropertyDescriptor(extraProps, prop);
      }
      if (deletedProps.has(prop)) {
        return;
      }
      return Reflect.getOwnPropertyDescriptor(originalCtx2, prop);
    }
  });
}
function createDeferredPromise() {
  let resolveFn;
  let rejectFn;
  const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return {
    promise,
    get resolve() {
      return resolveFn;
    },
    get reject() {
      return rejectFn;
    }
  };
}
function handleAbortSignalAndPromiseResponse(response$, abortSignal) {
  if (isPromise4(response$) && abortSignal) {
    const deferred$ = createDeferredPromise();
    abortSignal.addEventListener("abort", function abortSignalFetchErrorHandler() {
      deferred$.reject(abortSignal.reason);
    });
    response$.then(function fetchSuccessHandler(res) {
      deferred$.resolve(res);
    }).catch(function fetchErrorHandler(err) {
      deferred$.reject(err);
    });
    return deferred$.promise;
  }
  return response$;
}
class ServerAdapterRequestAbortSignal extends EventTarget {
  aborted = false;
  _onabort = null;
  reason;
  throwIfAborted() {
    if (this.aborted) {
      throw this.reason;
    }
  }
  sendAbort() {
    this.reason = new DOMException("This operation was aborted", "AbortError");
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("abort", value);
    } else {
      this.removeEventListener("abort", value);
    }
  }
  any(signals) {
    return AbortSignal.any([...signals]);
  }
}
var bunNodeCompatModeWarned = false;
var nodeRequestResponseMap = new WeakMap;
var decompressedResponseMap = new WeakMap;
var supportedEncodingsByFetchAPI = new WeakMap;

// ../../node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI, signal }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    let controller;
    body = new fetchAPI.ReadableStream({
      start(c) {
        controller = c;
      }
    });
    const readable = body.readable;
    if (readable) {
      signal.addEventListener("abort", () => {
        readable.push(null);
      });
      res.onData(function(ab, isLast) {
        const chunk = Buffer.from(ab, 0, ab.byteLength);
        readable.push(Buffer.from(chunk));
        if (isLast) {
          readable.push(null);
        }
      });
    } else {
      let closed = false;
      signal.addEventListener("abort", () => {
        if (!closed) {
          closed = true;
          controller.close();
        }
      });
      res.onData(function(ab, isLast) {
        const chunk = Buffer.from(ab, 0, ab.byteLength);
        controller.enqueue(Buffer.from(chunk));
        if (isLast) {
          closed = true;
          controller.close();
        }
      });
    }
  }
  const headers = new fetchAPI.Headers;
  req.forEach((key, value) => {
    headers.append(key, value);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal,
    duplex: "half"
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse, signal) {
  for await (const chunk of fetchResponse.body) {
    if (signal.aborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse, signal) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  if (signal.aborted) {
    return;
  }
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse, signal);
}

// ../../node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  await Promise.allSettled(waitUntilPromises);
}
var isRequestAccessible = function(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
};
var createServerAdapter = function(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...exports_node_ponyfill,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      setRequest(newRequest) {
        request = newRequest;
      },
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onResponseHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext,
        setResponse(newResponse) {
          response2 = newResponse;
        },
        fetchAPI
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise4(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise4(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise4(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {
    const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;
    nodeRequestResponseMap.set(nodeRequest, nodeResponse);
    return handleNodeRequest(nodeRequest, ...ctx);
  }
  function requestListener(nodeRequest, nodeResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: nodeResponse,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    let response$;
    try {
      response$ = handleNodeRequestAndResponse(nodeRequest, nodeResponse, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => sendNodeResponse(response, nodeResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, nodeResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const signal = new ServerAdapterRequestAbortSignal;
    const originalResEnd = res.end.bind(res);
    let resEnded = false;
    res.end = function(data) {
      resEnded = true;
      return originalResEnd(data);
    };
    const originalOnAborted = res.onAborted.bind(res);
    originalOnAborted(function() {
      signal.sendAbort();
    });
    res.onAborted = function(cb) {
      signal.addEventListener("abort", cb);
    };
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI,
      signal
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => {
        if (!signal.aborted && !resEnded) {
          return sendResponseToUwsOpts(res, response, signal);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: \n${err.stack || err.message || err}`);
      });
    }
    try {
      if (!signal.aborted && !resEnded) {
        return sendResponseToUwsOpts(res, response$, signal);
      }
    } catch (err) {
      console.error(`Unexpected error while handling request: \n${err.stack || err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign({}, event, ...filteredCtxParts) : isolateObject(event);
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    let waitUntilPromises;
    const serverContext = filteredCtxParts.length > 1 ? completeAssign({}, ...filteredCtxParts) : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntilPromises = [] : undefined);
    const response$ = handleRequest(request, serverContext);
    if (waitUntilPromises?.length) {
      return handleWaitUntils(waitUntilPromises).then(() => response$);
    }
    return response$;
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || "href" in input) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        const request2 = new fetchAPI.Request(input, initOrCtx);
        const res$2 = handleRequestWithWaitUntil(request2, ...restOfCtx);
        return handleAbortSignalAndPromiseResponse(res$2, initOrCtx?.signal);
      }
      const request = new fetchAPI.Request(input);
      return handleRequestWithWaitUntil(request, ...maybeCtx);
    }
    const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);
    return handleAbortSignalAndPromiseResponse(res$, input._signal);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest: handleRequestWithWaitUntil,
    fetch: fetchFn,
    handleNodeRequest,
    handleNodeRequestAndResponse,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    has: (_, prop) => {
      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
};
var EMPTY_OBJECT = {};

// ../../node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      } else {
        headers["Vary"] = "Access-Control-Request-Headers";
      }
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// ../../node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
function createDefaultErrorHandler(ResponseCtor = $Response) {
  return function defaultErrorHandler(e) {
    if (e.details || e.status || e.headers || e.name === "HTTPError") {
      return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.message, {
        status: e.status,
        headers: e.headers || {}
      });
    }
    console.error(e);
    return createDefaultErrorResponse(ResponseCtor);
  };
}
var createDefaultErrorResponse = function(ResponseCtor) {
  if (ResponseCtor.error) {
    return ResponseCtor.error();
  }
  return new ResponseCtor(null, { status: 500 });
};
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
        try {
          const response$ = requestHandler(request, serverContext);
          if (isPromise4(response$)) {
            return response$.catch((e) => errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response));
          }
          return response$;
        } catch (e) {
          return errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response);
        }
      });
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || undefined;
  const query = searchParams.get("query") || undefined;
  const variablesStr = searchParams.get("variables") || undefined;
  const extensionsStr = searchParams.get("extensions") || undefined;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : undefined,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new $URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new $URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// ../../node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = "" + keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map;
    try {
      map = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map) {
      const file = requestBody.get(fileIndex);
      const keys = map[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
var extendedTypeof = function(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
};
var isObject = function(val) {
  return extendedTypeof(val) === "object";
};
var expectedParameters = new Set(["query", "variables", "operationName", "extensions"]);

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error of result) {
            error.extensions.http = {
              ...error.extensions.http,
              spec: error.extensions.http?.spec ?? true,
              status: error.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
function assertMutationViaGet(method, document2, operationName) {
  const operation = document2 ? getOperationAST(document2, operationName) ?? undefined : undefined;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// ../../node_modules/graphql-yoga/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal2 {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== undefined && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === undefined)
      return;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === undefined)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === undefined || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === undefined)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== undefined)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// ../../node_modules/graphql-yoga/esm/utils/create-lru-cache.js
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 3600000;

// ../../node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document2 = documentCache.get(strDocument);
      if (document2) {
        setParsedDocument(document2);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema3, documentAST, rules },
      setResult
    }) {
      if (schema3 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = new WeakMap;
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema3);
        if (!validationCacheByDocument) {
          validationCacheByDocument = new WeakMap;
          validationCacheBySchema.set(schema3, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/use-request-parser.js
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}
var DEFAULT_MATCHER = () => true;

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : undefined;
    }
    return newResult;
  }
  return result;
}
var omitInternalsFromError = function(err) {
  if (isGraphQLError(err)) {
    const serializedError = "toJSON" in err && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || undefined),
      extensions: Object.keys(extensions).length ? extensions : undefined
    });
  }
  return err;
};

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder;
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable3(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (value != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions.originalError || isGraphQLError(err.extensions.originalError)));
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12000;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder;
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable3(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode(`event: next\n`));
          const chunk = jsonStringifyResultWithoutInternals(value);
          controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete\n\n`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var getSSEProcessorConfig = function() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
};
function useResultProcessors() {
  const isSubscriptionRequestMap = new WeakMap;
  const sse2 = getSSEProcessorConfig();
  const defaultList = [sse2, multipart2, regular2];
  const subscriptionList = [sse2, regular2];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable3(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}
var multipart2 = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
var regular2 = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};

// ../../node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// ../../node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && url.pathname !== args.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// ../../node_modules/graphql-yoga/esm/process-request.js
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document2 = enveloped.parse(params.query);
  const errors4 = enveloped.validate(enveloped.schema, document2);
  if (errors4.length > 0) {
    return { errors: errors4 };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document: document2,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = getOperationAST(document2, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// ../../node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error7, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error7)) {
    if (error7.originalError) {
      if (error7.originalError.name === "GraphQLError") {
        return error7;
      }
      const extensions = {
        ...error7.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error7.originalError.message,
          stack: error7.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error7.nodes,
        source: error7.source,
        positions: error7.positions,
        path: error7.path,
        extensions
      });
    }
    return error7;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error7 instanceof Error ? {
        message: error7.message,
        stack: error7.stack
      } : error7 : undefined
    }
  });
};

// ../../node_modules/graphql-yoga/esm/server.js
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

class YogaServer {
  constructor(options) {
    this.handle = async (request, serverContext) => {
      let url = new Proxy({}, {
        get: (_target, prop, _receiver) => {
          url = new this.fetchAPI.URL(request.url, "http://localhost");
          return Reflect.get(url, prop, url);
        }
      });
      let requestParser;
      const onRequestParseDoneList = [];
      for (const onRequestParse of this.onRequestParseHooks) {
        const onRequestParseResult = await onRequestParse({
          request,
          url,
          requestParser,
          serverContext,
          setRequestParser(parser) {
            requestParser = parser;
          }
        });
        if (onRequestParseResult?.onRequestParseDone != null) {
          onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
        }
      }
      this.logger.debug(`Parsing request to extract GraphQL parameters`);
      if (!requestParser) {
        return new this.fetchAPI.Response(null, {
          status: 415,
          statusText: "Unsupported Media Type"
        });
      }
      let requestParserResult = await requestParser(request);
      for (const onRequestParseDone of onRequestParseDoneList) {
        await onRequestParseDone({
          requestParserResult,
          setRequestParserResult(newParams) {
            requestParserResult = newParams;
          }
        });
      }
      const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
        params,
        request
      }, serverContext))) : this.getResultForParams({
        params: requestParserResult,
        request
      }, serverContext));
      return processResult({
        request,
        result,
        fetchAPI: this.fetchAPI,
        onResultProcessHooks: this.onResultProcessHooks
      });
    };
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...exports_node_ponyfill
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger2 = options?.logging == null ? true : options.logging;
    this.logger = typeof logger2 === "boolean" ? logger2 === true ? createLogger() : createLogger("silent") : typeof logger2 === "string" ? createLogger(logger2) : logger2;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = new WeakSet;
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error8, message) => {
        if (maskedErrorSet.has(error8)) {
          return error8;
        }
        const newError = maskErrorFn(error8, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error8) {
          this.logger.error(error8);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse,
        validate: validate2,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules
      }),
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      useResultProcessors(),
      useErrorHandling((error8, request) => {
        const errors4 = handleError(error8, this.maskedErrorsOpts, this.logger);
        const result = {
          errors: errors4
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache));
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(useUnhandledRoute({
            graphqlEndpoint,
            showLandingPage: options?.landingPage ?? true
          }));
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(useHTTPValidationError());
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const serverContext = args[0];
        const initialContext = {
          ...serverContext,
          request,
          params
        };
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error8) {
      const errors4 = handleError(error8, this.maskedErrorsOpts, this.logger);
      const result = {
        errors: errors4
      };
      return result;
    }
  }
}

// ../../node_modules/@repeaterjs/repeater/repeater.js
var __extends = function(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : undefined, done: true };
  }
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
};
var swallow = function(value) {
  if (value != null && typeof value.then === "function") {
    value.then(NOOP, NOOP);
  }
};
var consumeExecution = function(r) {
  var err = r.err;
  var execution = Promise.resolve(r.execution).then(function(value) {
    if (err != null) {
      throw err;
    }
    return value;
  });
  r.err = undefined;
  r.execution = execution.then(function() {
    return;
  }, function() {
    return;
  });
  return r.pending === undefined ? execution : r.pending.then(function() {
    return execution;
  });
};
var createIteration = function(r, value) {
  var done = r.state >= Done;
  return Promise.resolve(value).then(function(value2) {
    if (!done && r.state >= Rejected) {
      return consumeExecution(r).then(function(value3) {
        return {
          value: value3,
          done: true
        };
      });
    }
    return { value: value2, done };
  });
};
var stop = function(r, err) {
  var e_1, _a;
  if (r.state >= Stopped) {
    return;
  }
  r.state = Stopped;
  r.onnext();
  r.onstop();
  if (r.err == null) {
    r.err = err;
  }
  if (r.pushes.length === 0 && (typeof r.buffer === "undefined" || r.buffer.empty)) {
    finish(r);
  } else {
    try {
      for (var _b = __values(r.pushes), _d = _b.next();!_d.done; _d = _b.next()) {
        var push_1 = _d.value;
        push_1.resolve();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
};
var finish = function(r) {
  var e_2, _a;
  if (r.state >= Done) {
    return;
  }
  if (r.state < Stopped) {
    stop(r);
  }
  r.state = Done;
  r.buffer = undefined;
  try {
    for (var _b = __values(r.nexts), _d = _b.next();!_d.done; _d = _b.next()) {
      var next = _d.value;
      var execution = r.pending === undefined ? consumeExecution(r) : r.pending.then(function() {
        return consumeExecution(r);
      });
      next.resolve(createIteration(r, execution));
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  r.pushes = [];
  r.nexts = [];
};
var reject = function(r) {
  if (r.state >= Rejected) {
    return;
  }
  if (r.state < Done) {
    finish(r);
  }
  r.state = Rejected;
};
var push = function(r, value) {
  swallow(value);
  if (r.pushes.length >= MAX_QUEUE_LENGTH) {
    throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
  } else if (r.state >= Stopped) {
    return Promise.resolve(undefined);
  }
  var valueP = r.pending === undefined ? Promise.resolve(value) : r.pending.then(function() {
    return value;
  });
  valueP = valueP.catch(function(err) {
    if (r.state < Stopped) {
      r.err = err;
    }
    reject(r);
    return;
  });
  var nextP;
  if (r.nexts.length) {
    var next_1 = r.nexts.shift();
    next_1.resolve(createIteration(r, valueP));
    if (r.nexts.length) {
      nextP = Promise.resolve(r.nexts[0].value);
    } else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
      nextP = Promise.resolve(undefined);
    } else {
      nextP = new Promise(function(resolve) {
        return r.onnext = resolve;
      });
    }
  } else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
    r.buffer.add(valueP);
    nextP = Promise.resolve(undefined);
  } else {
    nextP = new Promise(function(resolve) {
      return r.pushes.push({ resolve, value: valueP });
    });
  }
  var floating = true;
  var next = {};
  var unhandled = nextP.catch(function(err) {
    if (floating) {
      throw err;
    }
    return;
  });
  next.then = function(onfulfilled, onrejected) {
    floating = false;
    return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
  };
  next.catch = function(onrejected) {
    floating = false;
    return Promise.prototype.catch.call(nextP, onrejected);
  };
  next.finally = nextP.finally.bind(nextP);
  r.pending = valueP.then(function() {
    return unhandled;
  }).catch(function(err) {
    r.err = err;
    reject(r);
  });
  return next;
};
var createStop = function(r) {
  var stop1 = stop.bind(null, r);
  var stopP = new Promise(function(resolve) {
    return r.onstop = resolve;
  });
  stop1.then = stopP.then.bind(stopP);
  stop1.catch = stopP.catch.bind(stopP);
  stop1.finally = stopP.finally.bind(stopP);
  return stop1;
};
var execute4 = function(r) {
  if (r.state >= Started) {
    return;
  }
  r.state = Started;
  var push1 = push.bind(null, r);
  var stop1 = createStop(r);
  r.execution = new Promise(function(resolve) {
    return resolve(r.executor(push1, stop1));
  });
  r.execution.catch(function() {
    return stop(r);
  });
};
var getIterators = function(values3, options) {
  var e_3, _a;
  var iters = [];
  var _loop_1 = function(value2) {
    if (value2 != null && typeof value2[Symbol.asyncIterator] === "function") {
      iters.push(value2[Symbol.asyncIterator]());
    } else if (value2 != null && typeof value2[Symbol.iterator] === "function") {
      iters.push(value2[Symbol.iterator]());
    } else {
      iters.push(function valueToAsyncIterator() {
        return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!options.yieldValues)
                  return [3, 3];
                return [4, __await(value2)];
              case 1:
                return [4, _a2.sent()];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (!options.returnValues)
                  return [3, 5];
                return [4, __await(value2)];
              case 4:
                return [2, _a2.sent()];
              case 5:
                return [2];
            }
          });
        });
      }());
    }
  };
  try {
    for (var values_1 = __values(values3), values_1_1 = values_1.next();!values_1_1.done; values_1_1 = values_1.next()) {
      var value = values_1_1.value;
      _loop_1(value);
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (values_1_1 && !values_1_1.done && (_a = values_1.return))
        _a.call(values_1);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  return iters;
};
var race = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, stopped, finalIteration, iteration, i_1, _loop_2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            iteration = undefined;
            i_1 = 0;
            _loop_2 = function() {
              var j, iters_1, iters_1_1, iter;
              var e_4, _a2;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    j = i_1;
                    try {
                      for (iters_1 = (e_4 = undefined, __values(iters)), iters_1_1 = iters_1.next();!iters_1_1.done; iters_1_1 = iters_1.next()) {
                        iter = iters_1_1.value;
                        Promise.resolve(iter.next()).then(function(iteration2) {
                          if (iteration2.done) {
                            stop2();
                            if (finalIteration === undefined) {
                              finalIteration = iteration2;
                            }
                          } else if (i_1 === j) {
                            i_1++;
                            advance(iteration2);
                          }
                        }, function(err) {
                          return stop2(err);
                        });
                      }
                    } catch (e_4_1) {
                      e_4 = { error: e_4_1 };
                    } finally {
                      try {
                        if (iters_1_1 && !iters_1_1.done && (_a2 = iters_1.return))
                          _a2.call(iters_1);
                      } finally {
                        if (e_4)
                          throw e_4.error;
                      }
                    }
                    return [4, new Promise(function(resolve) {
                      return advance = resolve;
                    })];
                  case 1:
                    iteration = _b.sent();
                    if (!(iteration !== undefined))
                      return [3, 3];
                    return [4, push2(iteration.value)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    return [2];
                }
              });
            };
            _a.label = 2;
          case 2:
            if (!!stopped)
              return [3, 4];
            return [5, _loop_2()];
          case 3:
            _a.sent();
            return [3, 2];
          case 4:
            return [2, finalIteration && finalIteration.value];
          case 5:
            stop2();
            return [4, Promise.race(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [7];
          case 7:
            return [2];
        }
      });
    });
  });
};
var merge = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { yieldValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advances, stopped, finalIteration;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_5, _a2;
              stopped = true;
              try {
                for (var advances_1 = __values(advances), advances_1_1 = advances_1.next();!advances_1_1.done; advances_1_1 = advances_1.next()) {
                  var advance = advances_1_1.value;
                  advance();
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (advances_1_1 && !advances_1_1.done && (_a2 = advances_1.return))
                    _a2.call(advances_1);
                } finally {
                  if (e_5)
                    throw e_5.error;
                }
              }
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, undefined, undefined, function() {
                var iteration, _a2;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, , 6, 9]);
                      _b.label = 1;
                    case 1:
                      if (!!stopped)
                        return [3, 5];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _b.sent();
                      if (!(iteration !== undefined))
                        return [3, 4];
                      if (iteration.done) {
                        finalIteration = iteration;
                        return [2];
                      }
                      return [4, push2(iteration.value)];
                    case 3:
                      _b.sent();
                      _b.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      _a2 = iter.return;
                      if (!_a2)
                        return [3, 8];
                      return [4, iter.return()];
                    case 7:
                      _a2 = _b.sent();
                      _b.label = 8;
                    case 8:
                      return [7];
                    case 9:
                      return [2];
                  }
                });
              });
            }))];
          case 2:
            _a.sent();
            return [2, finalIteration && finalIteration.value];
          case 3:
            stop2();
            return [7];
          case 4:
            return [2];
        }
      });
    });
  });
};
var zip = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, stopped, iterations, values3;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 6, 8]);
            _a.label = 2;
          case 2:
            if (!!stopped)
              return [3, 5];
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations2) {
              return advance(iterations2);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 3:
            iterations = _a.sent();
            if (iterations === undefined) {
              return [2];
            }
            values3 = iterations.map(function(iteration) {
              return iteration.value;
            });
            if (iterations.some(function(iteration) {
              return iteration.done;
            })) {
              return [2, values3];
            }
            return [4, push2(values3)];
          case 4:
            _a.sent();
            return [3, 2];
          case 5:
            return [3, 8];
          case 6:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 7:
            _a.sent();
            return [7];
          case 8:
            return [2];
        }
      });
    });
  });
};
var latest = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, {
    yieldValues: true,
    returnValues: true
  });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, advances, stopped, iterations_1, values_2;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_6, _a2;
              advance();
              try {
                for (var advances_2 = __values(advances), advances_2_1 = advances_2.next();!advances_2_1.done; advances_2_1 = advances_2.next()) {
                  var advance1 = advances_2_1.value;
                  advance1();
                }
              } catch (e_6_1) {
                e_6 = { error: e_6_1 };
              } finally {
                try {
                  if (advances_2_1 && !advances_2_1.done && (_a2 = advances_2.return))
                    _a2.call(advances_2);
                } finally {
                  if (e_6)
                    throw e_6.error;
                }
              }
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations) {
              return advance(iterations);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 2:
            iterations_1 = _a.sent();
            if (iterations_1 === undefined) {
              return [2];
            }
            values_2 = iterations_1.map(function(iteration) {
              return iteration.value;
            });
            if (iterations_1.every(function(iteration) {
              return iteration.done;
            })) {
              return [2, values_2];
            }
            return [4, push2(values_2.slice())];
          case 3:
            _a.sent();
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, undefined, undefined, function() {
                var iteration;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (iterations_1[i].done) {
                        return [2, iterations_1[i].value];
                      }
                      _a2.label = 1;
                    case 1:
                      if (!!stopped)
                        return [3, 4];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        return advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _a2.sent();
                      if (iteration === undefined) {
                        return [2, iterations_1[i].value];
                      } else if (iteration.done) {
                        return [2, iteration.value];
                      }
                      values_2[i] = iteration.value;
                      return [4, push2(values_2.slice())];
                    case 3:
                      _a2.sent();
                      return [3, 1];
                    case 4:
                      return [2];
                  }
                });
              });
            }))];
          case 4:
            return [2, _a.sent()];
          case 5:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [7];
          case 7:
            return [2];
        }
      });
    });
  });
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
var RepeaterOverflowError = function(_super) {
  __extends(RepeaterOverflowError2, _super);
  function RepeaterOverflowError2(message) {
    var _this = _super.call(this, message) || this;
    Object.defineProperty(_this, "name", {
      value: "RepeaterOverflowError",
      enumerable: false
    });
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(_this, _this.constructor.prototype);
    } else {
      _this.__proto__ = _this.constructor.prototype;
    }
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(_this, _this.constructor);
    }
    return _this;
  }
  return RepeaterOverflowError2;
}(Error);
var FixedBuffer = function() {
  function FixedBuffer2(capacity) {
    if (capacity < 0) {
      throw new RangeError("Capacity may not be less than 0");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(FixedBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FixedBuffer2.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: false,
    configurable: true
  });
  FixedBuffer2.prototype.add = function(value) {
    if (this.full) {
      throw new Error("Buffer full");
    } else {
      this._q.push(value);
    }
  };
  FixedBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return FixedBuffer2;
}();
var SlidingBuffer = function() {
  function SlidingBuffer2(capacity) {
    if (capacity < 1) {
      throw new RangeError("Capacity may not be less than 1");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(SlidingBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SlidingBuffer2.prototype, "full", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  SlidingBuffer2.prototype.add = function(value) {
    while (this._q.length >= this._c) {
      this._q.shift();
    }
    this._q.push(value);
  };
  SlidingBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return SlidingBuffer2;
}();
var DroppingBuffer = function() {
  function DroppingBuffer2(capacity) {
    if (capacity < 1) {
      throw new RangeError("Capacity may not be less than 1");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(DroppingBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DroppingBuffer2.prototype, "full", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  DroppingBuffer2.prototype.add = function(value) {
    if (this._q.length < this._c) {
      this._q.push(value);
    }
  };
  DroppingBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return DroppingBuffer2;
}();
var Initial = 0;
var Started = 1;
var Stopped = 2;
var Done = 3;
var Rejected = 4;
var MAX_QUEUE_LENGTH = 1024;
var NOOP = function() {
};
var records = new WeakMap;
var Repeater = function() {
  function Repeater2(executor3, buffer) {
    records.set(this, {
      executor: executor3,
      buffer,
      err: undefined,
      state: Initial,
      pushes: [],
      nexts: [],
      pending: undefined,
      execution: undefined,
      onnext: NOOP,
      onstop: NOOP
    });
  }
  Repeater2.prototype.next = function(value) {
    swallow(value);
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    if (r.nexts.length >= MAX_QUEUE_LENGTH) {
      throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
    }
    if (r.state <= Initial) {
      execute4(r);
    }
    r.onnext(value);
    if (typeof r.buffer !== "undefined" && !r.buffer.empty) {
      var result = createIteration(r, r.buffer.remove());
      if (r.pushes.length) {
        var push_2 = r.pushes.shift();
        r.buffer.add(push_2.value);
        r.onnext = push_2.resolve;
      }
      return result;
    } else if (r.pushes.length) {
      var push_3 = r.pushes.shift();
      r.onnext = push_3.resolve;
      return createIteration(r, push_3.value);
    } else if (r.state >= Stopped) {
      finish(r);
      return createIteration(r, consumeExecution(r));
    }
    return new Promise(function(resolve) {
      return r.nexts.push({ resolve, value });
    });
  };
  Repeater2.prototype.return = function(value) {
    swallow(value);
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    finish(r);
    r.execution = Promise.resolve(r.execution).then(function() {
      return value;
    });
    return createIteration(r, consumeExecution(r));
  };
  Repeater2.prototype.throw = function(err) {
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    if (r.state <= Initial || r.state >= Stopped || typeof r.buffer !== "undefined" && !r.buffer.empty) {
      finish(r);
      if (r.err == null) {
        r.err = err;
      }
      return createIteration(r, consumeExecution(r));
    }
    return this.next(Promise.reject(err));
  };
  Repeater2.prototype[Symbol.asyncIterator] = function() {
    return this;
  };
  Repeater2.race = race;
  Repeater2.merge = merge;
  Repeater2.zip = zip;
  Repeater2.latest = latest;
  return Repeater2;
}();

// ../../node_modules/@whatwg-node/events/esm/index.js
var CustomEvent = globalThis.CustomEvent || class PonyfillCustomEvent extends Event {
  detail = null;
  constructor(type, eventInitDict) {
    super(type, eventInitDict);
    if (eventInitDict?.detail != null) {
      this.detail = eventInitDict.detail;
    }
  }
  initCustomEvent(type, bubbles, cancelable, detail) {
    this.initEvent(type, bubbles, cancelable);
    if (detail != null) {
      this.detail = detail;
    }
  }
};

// ../../node_modules/@graphql-yoga/subscription/esm/create-pub-sub.js
var createPubSub = (config) => {
  const target = config?.eventTarget ?? new EventTarget;
  return {
    publish(routingKey, ...args) {
      const payload = args[1] ?? args[0] ?? null;
      const topic = args[1] === undefined ? routingKey : `${routingKey}:${args[0]}`;
      const event = new CustomEvent(topic, {
        detail: payload
      });
      target.dispatchEvent(event);
    },
    subscribe(...[routingKey, id]) {
      const topic = id === undefined ? routingKey : `${routingKey}:${id}`;
      return new Repeater(function subscriptionRepeater(next, stop2) {
        stop2.then(function subscriptionRepeaterStopHandler() {
          target.removeEventListener(topic, pubsubEventListener);
        });
        target.addEventListener(topic, pubsubEventListener);
        function pubsubEventListener(event) {
          next(event.detail);
        }
      });
    }
  };
};
// ../../node_modules/@graphql-yoga/subscription/esm/operator/map.js
var map = (mapper) => (source2) => new Repeater(async (push2, stop2) => {
  const iterable = source2[Symbol.asyncIterator]();
  stop2.then(() => {
    iterable.return?.();
  });
  let latest2;
  while ((latest2 = await iterable.next()).done === false) {
    await push2(await mapper(latest2.value));
  }
  stop2();
});
// ../../node_modules/@graphql-yoga/subscription/esm/utils/pipe.js
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default:
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
  }
}
// ../../node_modules/@pothos/core/esm/builder.js
var _defineProperty22 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/build-cache.js
var _defineProperty9 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/errors.js
class PothosError extends Error {
  constructor(message) {
    super(message);
    this.name = "PothosError";
  }
}

class PothosSchemaError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosSchemaError";
  }
}

class PothosValidationError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosValidationError";
  }
}

// ../../node_modules/@pothos/core/esm/plugins/merge-plugins.js
var _defineProperty2 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/plugins/plugin.js
var _defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/utils/context-cache.js
function createContextCache(create) {
  const cache = new WeakMap;
  return (context, ...args) => {
    const cacheKey = context[contextCacheSymbol] || context;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const entry = create(context, ...args);
    cache.set(cacheKey, entry);
    return entry;
  };
}
var contextCacheSymbol = Symbol.for("Pothos.contextCache");

// ../../node_modules/@pothos/core/esm/plugins/plugin.js
var runCache = new WeakMap;

class BasePlugin {
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  beforeBuild() {
  }
  afterBuild(schema3) {
    return schema3;
  }
  wrapResolve(resolver, fieldConfig) {
    return resolver;
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return subscribe3;
  }
  wrapResolveType(resolveType, typeConfig) {
    return resolveType;
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, new Map);
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  createRequestData(context) {
    throw new PothosError("createRequestData not implemented");
  }
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    _defineProperty(this, "name", undefined);
    _defineProperty(this, "builder", undefined);
    _defineProperty(this, "buildCache", undefined);
    _defineProperty(this, "options", undefined);
    _defineProperty(this, "requestDataMap", createContextCache((ctx) => this.createRequestData(ctx)));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
}

// ../../node_modules/@pothos/core/esm/plugins/merge-plugins.js
class MergedPlugins extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onTypeConfig(config), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onInputFieldConfig(config), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onOutputFieldConfig(config), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onEnumValueConfig(config), valueConfig);
  }
  beforeBuild() {
    for (const plugin2 of this.plugins) {
      plugin2.beforeBuild();
    }
  }
  afterBuild(schema3) {
    return this.plugins.reduceRight((nextSchema, plugin2) => plugin2.afterBuild(nextSchema), schema3);
  }
  wrapResolve(resolve, fieldConfig) {
    return this.plugins.reduceRight((nextResolve, plugin2) => plugin2.wrapResolve(nextResolve, fieldConfig), resolve);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return this.plugins.reduceRight((nextSubscribe, plugin2) => plugin2.wrapSubscribe(nextSubscribe, fieldConfig), subscribe3);
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin2) => plugin2.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin2) => plugin2.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin");
    _defineProperty2(this, "plugins", undefined);
    this.plugins = plugins;
  }
}
// ../../node_modules/@pothos/core/esm/refs/builtin-scalar.js
var _defineProperty5 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/scalar.js
var _defineProperty4 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
// ../../node_modules/@pothos/core/esm/types/type-params.js
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");
// ../../node_modules/@pothos/core/esm/refs/base.js
var _defineProperty3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

class BaseTypeRef {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  constructor(kind, name) {
    _defineProperty3(this, "kind", undefined);
    _defineProperty3(this, "name", undefined);
    this.kind = kind;
    this.name = name;
  }
}

// ../../node_modules/@pothos/core/esm/refs/scalar.js
var _outputShapeKey = outputShapeKey;
var _parentShapeKey = parentShapeKey;
var _inputShapeKey = inputShapeKey;

class ScalarRef extends BaseTypeRef {
  constructor(name) {
    super("Scalar", name);
    _defineProperty4(this, "kind", "Scalar");
    _defineProperty4(this, _outputShapeKey, undefined);
    _defineProperty4(this, _parentShapeKey, undefined);
    _defineProperty4(this, _inputShapeKey, undefined);
  }
}

// ../../node_modules/@pothos/core/esm/refs/builtin-scalar.js
class BuiltinScalarRef extends ScalarRef {
  constructor(type) {
    super(type.name);
    _defineProperty5(this, "type", undefined);
    this.type = type;
  }
}

// ../../node_modules/@pothos/core/esm/refs/input-object.js
var _defineProperty6 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey2 = inputShapeKey;

class InputObjectRef extends BaseTypeRef {
  constructor(name) {
    super("InputObject", name);
    _defineProperty6(this, "kind", "InputObject");
    _defineProperty6(this, _inputShapeKey2, undefined);
  }
}
class ImplementableInputObjectRef extends InputObjectRef {
  implement(options) {
    this.builder.inputType(this, options);
    return this;
  }
  constructor(builder, name) {
    super(name);
    _defineProperty6(this, "builder", undefined);
    this.builder = builder;
  }
}

// ../../node_modules/@pothos/core/esm/refs/input-list.js
var _defineProperty7 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey3 = inputShapeKey;

class InputObjectRef2 extends BaseTypeRef {
  constructor(listType, required) {
    super("InputList", `InputList<${String(listType)}>`);
    _defineProperty7(this, "kind", "InputList");
    _defineProperty7(this, _inputShapeKey3, undefined);
    _defineProperty7(this, "listType", undefined);
    _defineProperty7(this, "required", undefined);
    this.listType = listType;
    this.required = required;
  }
}

// ../../node_modules/@pothos/core/esm/refs/list.js
var _defineProperty8 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey2 = outputShapeKey;
var _parentShapeKey2 = parentShapeKey;

class ListRef extends BaseTypeRef {
  constructor(listType, nullable) {
    super("List", `List<${String(listType)}>`);
    _defineProperty8(this, "kind", "List");
    _defineProperty8(this, _outputShapeKey2, undefined);
    _defineProperty8(this, _parentShapeKey2, undefined);
    _defineProperty8(this, "listType", undefined);
    _defineProperty8(this, "nullable", undefined);
    this.listType = listType;
    this.nullable = nullable;
  }
}

// ../../node_modules/@pothos/core/esm/utils/base64.js
function encodeBase64(value) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.btoa === "function") {
    return globalThis1.btoa(value);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value).toString("base64");
  }
  throw new Error("Unable to locate global `btoa` or `Buffer`");
}
function decodeBase64(value) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.atob === "function") {
    return globalThis1.atob(value);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value, "base64").toString();
  }
  throw new Error("Unable to locate global `atob` or `Buffer`");
}
var getGlobalThis = () => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (true)
    return null;
  throw new Error("Unable to locate global `this`");
};
// ../../node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values3) {
  const result = {};
  if (Array.isArray(values3)) {
    values3.forEach((key) => {
      result[String(key)] = {
        pothosOptions: {}
      };
    });
  } else {
    Object.entries(values3).forEach(([key, value]) => {
      if (value && typeof value === "object") {
        result[key] = {
          ...value,
          pothosOptions: value
        };
      } else if (typeof value === "string") {
        result[value] = {
          pothosOptions: {}
        };
      }
    });
  }
  return result;
}
function valuesFromEnum(Enum, values3) {
  const result = {};
  Object.keys(Enum).filter((key) => typeof Enum[Enum[key]] !== "number").forEach((key) => {
    result[key] = {
      value: Enum[key],
      pothosOptions: {},
      ...values3 === null || values3 === undefined ? undefined : values3[key]
    };
  });
  return result;
}
// ../../node_modules/@pothos/core/esm/utils/params.js
function typeFromParam(param, configStore, nullableOption) {
  const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
  const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromParam(param[0], configStore, itemNullable),
      nullable
    };
  }
  if (param instanceof ListRef) {
    return {
      kind: "List",
      type: typeFromParam(param.listType, configStore, param.nullable),
      nullable
    };
  }
  const ref = configStore.getOutputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
    return {
      kind,
      ref,
      nullable
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function unwrapInputFieldType(type) {
  if (type.kind === "List") {
    return unwrapInputFieldType(type.type);
  }
  return type.ref;
}
function inputTypeFromParam(param, configStore, requiredOption) {
  const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
  const required = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromParam(param[0], configStore, itemRequired),
      required
    };
  }
  if (param instanceof InputObjectRef2) {
    return {
      kind: "List",
      type: inputTypeFromParam(param.listType, configStore, param.required),
      required
    };
  }
  const ref = configStore.getInputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref,
      required
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}

// ../../node_modules/@pothos/core/esm/utils/input.js
function resolveInputTypeConfig(type, buildCache) {
  if (type.kind === "List") {
    return resolveInputTypeConfig(type.type, buildCache);
  }
  const config = buildCache.getTypeConfig(type.ref);
  if (config.kind === "Enum" || config.kind === "Scalar" || config.kind === "InputObject") {
    return config;
  }
  throw new PothosSchemaError(`Unexpected config type ${config.kind} for input ref ${String(type.ref)}`);
}
function mapInputFields(inputs, buildCache, mapper) {
  const filterMappings = new Map;
  return filterMapped(internalMapInputFields(inputs, buildCache, mapper, new Map));
  function filterMapped(map2) {
    if (filterMappings.has(map2)) {
      return filterMappings.get(map2);
    }
    const filtered = new Map;
    filterMappings.set(map2, filtered);
    map2.forEach((mapping, fieldName) => {
      if (mapping.kind === "Enum" || mapping.kind === "Scalar") {
        filtered.set(fieldName, mapping);
        return;
      }
      const hasNestedMappings = checkForMappings(mapping.fields.map);
      if (mapping.value !== null || hasNestedMappings) {
        const filteredTypeFields = filterMapped(mapping.fields.map);
        const mappingForType = {
          ...mapping,
          fields: {
            configs: mapping.fields.configs,
            map: filteredTypeFields
          }
        };
        filtered.set(fieldName, mappingForType);
      }
    });
    return filtered.size > 0 ? filtered : null;
  }
  function checkForMappings(map2, hasMappings = new Map) {
    if (hasMappings.has(map2)) {
      return hasMappings.get(map2);
    }
    hasMappings.set(map2, false);
    let result = false;
    map2.forEach((mapping) => {
      if (mapping.value !== null) {
        result = true;
      } else if (mapping.kind === "InputObject" && mapping.fields.map && checkForMappings(mapping.fields.map, hasMappings)) {
        result = true;
      }
    });
    hasMappings.set(map2, result);
    return result;
  }
}
var internalMapInputFields = function(inputs, buildCache, mapper, seenTypes) {
  const map2 = new Map;
  Object.keys(inputs).forEach((fieldName) => {
    const inputField = inputs[fieldName];
    const typeConfig = resolveInputTypeConfig(inputField.type, buildCache);
    const fieldMapping = mapper(inputField);
    if (typeConfig.kind === "Enum" || typeConfig.kind === "Scalar") {
      if (fieldMapping !== null) {
        map2.set(fieldName, {
          kind: typeConfig.kind,
          isList: inputField.type.kind === "List",
          config: inputField,
          value: fieldMapping
        });
      }
      return;
    }
    const inputFieldConfigs = buildCache.getInputTypeFieldConfigs(unwrapInputFieldType(inputField.type));
    if (!seenTypes.has(typeConfig.name)) {
      const typeEntry = {
        configs: inputFieldConfigs,
        map: new Map
      };
      seenTypes.set(typeConfig.name, typeEntry);
      typeEntry.map = internalMapInputFields(inputFieldConfigs, buildCache, mapper, seenTypes);
    }
    const typeFields = seenTypes.get(typeConfig.name);
    map2.set(fieldName, {
      kind: typeConfig.kind,
      isList: inputField.type.kind === "List",
      config: inputField,
      value: fieldMapping,
      fields: typeFields
    });
  });
  return map2;
};
function createInputValueMapper(argMap, mapValue3) {
  return function mapObject(obj, map2 = argMap, ...args) {
    const mapped = {
      ...obj
    };
    map2.forEach((field, fieldName) => {
      let fieldVal = obj[fieldName];
      if (fieldVal === null || fieldVal === undefined) {
        return;
      }
      if (field.kind === "InputObject" && field.fields.map) {
        fieldVal = field.isList ? fieldVal.map((val) => val && mapObject(val, field.fields.map, ...args)) : mapObject(fieldVal, field.fields.map, ...args);
        mapped[fieldName] = fieldVal;
      }
      if (field.kind !== "InputObject" || field.value !== null) {
        mapped[fieldName] = field.isList ? fieldVal.map((val) => mapValue3(val, field, ...args)) : mapValue3(fieldVal, field, ...args);
      }
    });
    return mapped;
  };
}

// ../../node_modules/@pothos/core/esm/utils/index.js
function assertNever(value) {
  throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
  if (!Array.isArray(value)) {
    throw new PothosValidationError("List resolvers must return arrays");
  }
  return true;
}
function isThenable(value) {
  return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
  if (ref === undefined) {
    throw new PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new PothosSchemaError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === undefined) {
      throw new PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function brandWithType(val, type) {
  if (typeof val !== "object" || val === null) {
    return;
  }
  Object.defineProperty(val, typeBrandKey, {
    enumerable: false,
    value: type
  });
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && typeBrandKey in val) {
    return val[typeBrandKey];
  }
  return null;
}
function unwrapListParam(param) {
  if (Array.isArray(param)) {
    return unwrapListParam(param[0]);
  }
  if (param instanceof ListRef || param instanceof InputObjectRef2) {
    return unwrapListParam(param.listType);
  }
  return param;
}
function completeValue2(valOrPromise, onSuccess, onError) {
  if (isThenable(valOrPromise)) {
    return Promise.resolve(valOrPromise).then(onSuccess, onError);
  }
  const result = onSuccess(valOrPromise);
  if (isThenable(result)) {
    return Promise.resolve(result);
  }
  return result;
}

// ../../node_modules/@pothos/core/esm/build-cache.js
class BuildCache {
  getTypeConfig(ref, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref) {
    const typeConfig = this.getTypeConfig(ref, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields2 = builtType.getFields();
    const fieldConfigs = {};
    Object.keys(fields2).forEach((fieldName) => {
      var _fields_fieldName_extensions;
      fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields2[fieldName].extensions) === null || _fields_fieldName_extensions === undefined ? undefined : _fields_fieldName_extensions.pothosConfig;
    });
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "InputObject") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof GraphQLInputObjectType) {
        type.getFields();
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Interface") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Object") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Union") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType) {
        type.getFields();
      } else if (type instanceof GraphQLUnionType) {
        type.getTypes();
      }
    });
  }
  buildTypeFromConfig(baseConfig) {
    const config = this.getTypeConfig(baseConfig.name);
    const { name } = config;
    this.typeConfigs.set(name, config);
    switch (config.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config));
        break;
      default:
        assertNever(config);
    }
  }
  addType(ref, type) {
    if (this.types.has(ref)) {
      throw new PothosSchemaError(`reference or name has already been used to create another type (${type.name})`);
    }
    this.types.set(ref, type);
  }
  buildOutputTypeParam(type) {
    if (type.kind === "List") {
      if (type.nullable) {
        return new GraphQLList(this.buildOutputTypeParam(type.type));
      }
      return new GraphQLNonNull(new GraphQLList(this.buildOutputTypeParam(type.type)));
    }
    if (type.nullable) {
      return this.getOutputType(type.ref);
    }
    return new GraphQLNonNull(this.getOutputType(type.ref));
  }
  buildInputTypeParam(type) {
    if (type.kind === "List") {
      if (type.required) {
        return new GraphQLNonNull(new GraphQLList(this.buildInputTypeParam(type.type)));
      }
      return new GraphQLList(this.buildInputTypeParam(type.type));
    }
    if (type.required) {
      return new GraphQLNonNull(this.getInputType(type.ref));
    }
    return this.getInputType(type.ref);
  }
  buildFields(fields2) {
    const built = {};
    for (const [fieldName, originalConfig] of fields2) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config = {
        ...updatedConfig
      };
      const argMap = new Map;
      Object.keys(config.args).forEach((argName) => {
        argMap.set(argName, config.args[argName]);
      });
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      Object.keys(config.args).forEach((argName) => {
        argConfigs[argName] = this.inputFieldConfigs.get(config.args[argName]);
      });
      config.args = argConfigs;
      var _config_resolve;
      const resolve = this.plugin.wrapResolve((_config_resolve = config.resolve) !== null && _config_resolve !== undefined ? _config_resolve : defaultFieldResolver, config);
      const subscribe3 = this.plugin.wrapSubscribe(config.subscribe, config);
      var _config_resolve1;
      built[fieldName] = {
        ...config,
        type: this.buildOutputTypeParam(config.type),
        args,
        extensions: {
          ...config.extensions,
          pothosResolveWrapped: resolve !== ((_config_resolve1 = config.resolve) !== null && _config_resolve1 !== undefined ? _config_resolve1 : defaultFieldResolver),
          pothosSubscribeWrapped: subscribe3 !== config.subscribe,
          pothosOptions: config.pothosOptions,
          pothosConfig: config
        },
        resolve: resolve === defaultFieldResolver ? undefined : resolve,
        subscribe: subscribe3
      };
    }
    return built;
  }
  buildInputFields(fields2) {
    const built = {};
    for (const [fieldName, originalConfig] of fields2) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config = this.inputFieldConfigs.get(originalConfig);
      if (config) {
        built[fieldName] = {
          ...config,
          type: this.buildInputTypeParam(config.type),
          extensions: {
            ...config.extensions,
            pothosOptions: config.pothosOptions,
            pothosConfig: config
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const configs2 = this.configStore.getFields(type.name, "Interface");
    const fields2 = this.buildFields(configs2);
    return {
      ...interfaceFields,
      ...fields2
    };
  }
  getObjectFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const objectFields = this.buildFields(this.configStore.getFields(type.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type) {
    return this.buildFields(this.configStore.getFields(type.name, "Object"));
  }
  getFields(type) {
    if (type instanceof GraphQLObjectType) {
      if (type.name === "Query" || type.name === "Mutation" || type.name === "Subscription") {
        return this.getRootFields(type);
      }
      return this.getObjectFields(type);
    }
    if (type instanceof GraphQLInterfaceType) {
      return this.getInterfaceFields(type);
    }
    throw new PothosSchemaError(`Type ${type.name} does not have fields to resolve`);
  }
  getInputFields(type) {
    return this.buildInputFields(this.configStore.getFields(type.name, "InputObject"));
  }
  getType(ref) {
    if (ref instanceof BuiltinScalarRef) {
      return ref.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref);
    const type = this.types.get(typeConfig.name);
    if (!type) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type;
  }
  getOutputType(ref) {
    const type = this.getType(ref);
    if (type instanceof GraphQLInputObjectType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
    }
    return type;
  }
  getInputType(ref) {
    const type = this.getType(ref);
    if (!type) {
      throw new PothosSchemaError(`Missing implementation of for type ${String(ref)}`);
    }
    if (type instanceof GraphQLObjectType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type instanceof GraphQLInterfaceType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type instanceof GraphQLUnionType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type;
  }
  getTypeOfKind(ref, kind) {
    const type = this.getType(ref);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type instanceof GraphQLObjectType) {
          return type;
        }
        break;
      case "Interface":
        if (type instanceof GraphQLInterfaceType) {
          return type;
        }
        break;
      case "Union":
        if (type instanceof GraphQLUnionType) {
          return type;
        }
        break;
      case "Enum":
        if (type instanceof GraphQLEnumType) {
          return type;
        }
        break;
      case "Scalar":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      case "InputObject":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      default:
        break;
    }
    throw new PothosSchemaError(`Expected ${String(ref)} to be of type ${kind}`);
  }
  buildObject(config) {
    var _config_isTypeOf;
    const type = new GraphQLObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getFields(type),
      isTypeOf: config.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config.isTypeOf) !== null && _config_isTypeOf !== undefined ? _config_isTypeOf : undefined, config) : undefined,
      interfaces: config.kind === "Object" ? () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : undefined
    });
    return type;
  }
  buildInterface(config) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _config_resolveType;
      const resolver = (_config_resolveType = config.resolveType) !== null && _config_resolveType !== undefined ? _config_resolveType : defaultTypeResolver;
      return resolver(parent, context, info, type);
    };
    const type = new GraphQLInterfaceType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      interfaces: () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
    return type;
  }
  buildUnion(config) {
    const resolveType = (parent, context, info, type) => {
      if (typeof parent === "object" && parent !== null && typeBrandKey in parent) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config.resolveType) {
        return defaultTypeResolver(parent, context, info, type);
      }
      const resultOrPromise = config.resolveType(parent, context, info, type);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new GraphQLUnionType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      types: () => config.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
  }
  buildInputObject(config) {
    const type = new GraphQLInputObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getInputFields(type)
    });
    return type;
  }
  buildScalar(config) {
    if (config.name === "ID") {
      return GraphQLID;
    }
    if (config.name === "Int") {
      return GraphQLInt;
    }
    if (config.name === "Float") {
      return GraphQLFloat;
    }
    if (config.name === "Boolean") {
      return GraphQLBoolean;
    }
    if (config.name === "String") {
      return GraphQLString;
    }
    return new GraphQLScalarType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  buildEnum(config) {
    const values3 = {};
    for (const key of Object.keys(config.values)) {
      const original = config.values[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values3[key] = this.enumValueConfigs.get(original);
      }
    }
    return new GraphQLEnumType({
      ...config,
      values: values3,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  constructor(builder, options) {
    _defineProperty9(this, "types", new Map);
    _defineProperty9(this, "builder", undefined);
    _defineProperty9(this, "plugin", undefined);
    _defineProperty9(this, "options", undefined);
    _defineProperty9(this, "configStore", undefined);
    _defineProperty9(this, "pluginMap", undefined);
    _defineProperty9(this, "pluginList", undefined);
    _defineProperty9(this, "implementers", new Map);
    _defineProperty9(this, "typeConfigs", new Map);
    _defineProperty9(this, "enumValueConfigs", new Map);
    _defineProperty9(this, "outputFieldConfigs", new Map);
    _defineProperty9(this, "inputFieldConfigs", new Map);
    this.builder = builder;
    this.configStore = builder.configStore;
    this.options = options;
    const plugins3 = {};
    var _builder_options_plugins;
    this.pluginList = ((_builder_options_plugins = builder.options.plugins) !== null && _builder_options_plugins !== undefined ? _builder_options_plugins : []).map((pluginName) => {
      const Plugin = this.builder.constructor.plugins[pluginName];
      if (!Plugin) {
        throw new PothosError(`No plugin named ${pluginName} was registered`);
      }
      plugins3[pluginName] = new Plugin(this, pluginName);
      return plugins3[pluginName];
    });
    this.pluginMap = plugins3;
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
}

// ../../node_modules/@pothos/core/esm/config-store.js
var _defineProperty12 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/input.js
var _defineProperty10 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey4 = inputShapeKey;

class InputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty10(this, "kind", undefined);
    _defineProperty10(this, _inputShapeKey4, undefined);
    this.kind = kind;
  }
}

// ../../node_modules/@pothos/core/esm/refs/output.js
var _defineProperty11 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey3 = outputShapeKey;
var _parentShapeKey3 = parentShapeKey;

class OutputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty11(this, "kind", undefined);
    _defineProperty11(this, _outputShapeKey3, undefined);
    _defineProperty11(this, _parentShapeKey3, undefined);
    this.kind = kind;
  }
}

// ../../node_modules/@pothos/core/esm/config-store.js
class ConfigStore {
  hasConfig(typeParam) {
    if (typeof typeParam === "string") {
      return this.typeConfigs.has(typeParam);
    }
    return this.refsToName.has(typeParam);
  }
  addUnionTypes(typeName, unionTypes) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Union") {
        throw new PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.types = [
        ...typeConfig.types,
        ...typeof unionTypes === "function" ? unionTypes() : unionTypes
      ];
    });
  }
  addInterfaces(typeName, interfaces) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
        throw new PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.interfaces = [
        ...typeConfig.interfaces,
        ...typeof interfaces === "function" ? interfaces() : interfaces
      ];
    });
  }
  addFieldRef(ref, typeParam, args, getConfig) {
    if (this.fieldRefs.has(ref)) {
      throw new PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
    }
    const typeRefOrName = unwrapListParam(typeParam);
    const argRefs = Object.keys(args).map((argName) => {
      const argRef = args[argName];
      argRef.fieldName = argName;
      argRef.argFor = ref;
      return argRef;
    });
    const checkArgs = () => {
      for (const arg of argRefs) {
        if (this.pendingFields.has(arg)) {
          const unresolvedArgType = this.pendingFields.get(arg);
          this.pendingFields.set(ref, unresolvedArgType);
          this.onTypeConfig(unresolvedArgType, checkArgs);
          return;
        }
      }
      this.pendingFields.delete(ref);
      this.fieldRefs.set(ref, getConfig);
    };
    if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
      checkArgs();
    } else {
      this.pendingFields.set(ref, typeRefOrName);
      this.onTypeConfig(typeRefOrName, () => {
        checkArgs();
      });
    }
  }
  createFieldConfig(ref, name, typeConfig, parentField, kind) {
    if (!this.fieldRefs.has(ref)) {
      if (this.pendingFields.has(ref)) {
        throw new PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
      }
      throw new PothosSchemaError(`Missing definition for ${String(ref)}`);
    }
    const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
    if (kind && config.graphqlKind !== kind) {
      throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
    }
    return config;
  }
  associateRefWithName(ref, name) {
    if (!this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`${name} has not been implemented yet`);
    }
    this.refsToName.set(ref, name);
    if (this.pendingRefResolutions.has(ref)) {
      const cbs = this.pendingRefResolutions.get(ref);
      this.pendingRefResolutions.delete(ref);
      cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
    }
  }
  addTypeConfig(config, ref) {
    const { name } = config;
    if (this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
    }
    this.typeConfigs.set(config.name, config);
    if (ref) {
      this.associateRefWithName(ref, name);
    }
    if (this.pendingRefResolutions.has(name)) {
      const cbs = this.pendingRefResolutions.get(name);
      this.pendingRefResolutions.delete(name);
      cbs.forEach((cb) => void cb(config));
    }
  }
  getTypeConfig(ref, kind) {
    let config;
    if (typeof ref === "string") {
      if (!this.typeConfigs.has(ref)) {
        throw new PothosSchemaError(`Type ${String(ref)} has not been implemented`);
      }
      config = this.typeConfigs.get(ref);
    } else if (this.refsToName.has(ref)) {
      config = this.typeConfigs.get(this.refsToName.get(ref));
    } else if (ref instanceof ListRef || ref instanceof InputObjectRef2) {
      throw new PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
    } else {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    }
    if (kind && config.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
    }
    return config;
  }
  getInputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config = this.typeConfigs.get(ref);
        if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
          throw new PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
        }
        const newRef = new InputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref;
  }
  getOutputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind === "InputObject" || ref.kind === "InputList") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
      }
      if (ref.kind === "List") {
        throw new PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config = this.typeConfigs.get(ref);
        if (config.graphqlKind === "InputObject") {
          throw new PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
        }
        const newRef = new OutputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref;
  }
  onTypeConfig(ref, cb) {
    if (!ref) {
      throw new PothosSchemaError(`${String(ref)} is not a valid type ref`);
    }
    if (this.refsToName.has(ref)) {
      cb(this.getTypeConfig(ref));
    } else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
      cb(this.typeConfigs.get(ref));
    } else if (!this.pending) {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    } else if (this.pendingRefResolutions.has(ref)) {
      this.pendingRefResolutions.get(ref).push(cb);
    } else {
      this.pendingRefResolutions.set(ref, [
        cb
      ]);
    }
  }
  onFieldUse(ref, cb) {
    if (!this.fieldRefCallbacks.has(ref)) {
      this.fieldRefCallbacks.set(ref, []);
    }
    this.fieldRefCallbacks.get(ref).push(cb);
    if (this.fieldRefsToConfigs.has(ref)) {
      this.fieldRefsToConfigs.get(ref).forEach((config) => void cb(config));
    }
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, new Map);
    }
    const fields2 = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields2;
  }
  prepareForBuild() {
    this.pending = false;
    const { pendingActions } = this;
    this.pendingActions = [];
    pendingActions.forEach((fn) => void fn());
    if (this.pendingRefResolutions.size > 0) {
      throw new PothosSchemaError(`Missing implementations for some references (${[
        ...this.pendingRefResolutions.keys()
      ].map((ref) => this.describeRef(ref)).join(", ")}).`);
    }
  }
  onPrepare(cb) {
    if (this.pending) {
      this.pendingActions.push(cb);
    } else {
      cb();
    }
  }
  addFields(typeRef, fields2) {
    this.onPrepare(() => void this.onTypeConfig(typeRef, (config) => {
      this.buildFields(typeRef, typeof fields2 === "function" ? fields2() : fields2);
    }));
  }
  getImplementers(ref) {
    const typeConfig = this.getTypeConfig(ref, "Interface");
    const implementers = [
      ...this.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
    return implementers;
  }
  describeRef(ref) {
    var _find;
    if (typeof ref === "string") {
      return ref;
    }
    if (ref.toString !== {}.toString) {
      return String(ref);
    }
    const usedBy = (_find = [
      ...this.pendingFields.entries()
    ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || _find === undefined ? undefined : _find[0];
    if (usedBy) {
      return `<unnamed ref or enum: used by ${usedBy}>`;
    }
    return `<unnamed ref or enum>`;
  }
  buildFields(typeRef, fields2) {
    Object.keys(fields2).forEach((fieldName) => {
      const fieldRef = fields2[fieldName];
      fieldRef.fieldName = fieldName;
      if (this.pendingFields.has(fieldRef)) {
        this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
          this.buildField(typeRef, fieldRef, fieldName);
        });
      } else {
        this.buildField(typeRef, fieldRef, fieldName);
      }
    });
  }
  buildField(typeRef, field, fieldName) {
    const typeConfig = this.getTypeConfig(typeRef);
    const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
    const existingFields = this.getFields(typeConfig.name);
    if (existingFields.has(fieldName)) {
      throw new PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
    }
    if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
      throw new PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
    }
    existingFields.set(fieldName, fieldConfig);
    if (!this.fieldRefsToConfigs.has(field)) {
      this.fieldRefsToConfigs.set(field, []);
    }
    this.fieldRefsToConfigs.get(field).push(fieldConfig);
    if (this.fieldRefCallbacks.has(field)) {
      this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
    }
  }
  constructor() {
    _defineProperty12(this, "typeConfigs", new Map);
    _defineProperty12(this, "fieldRefs", new WeakMap);
    _defineProperty12(this, "fields", new Map);
    _defineProperty12(this, "pendingActions", []);
    _defineProperty12(this, "refsToName", new Map);
    _defineProperty12(this, "scalarsToRefs", new Map);
    _defineProperty12(this, "fieldRefsToConfigs", new Map);
    _defineProperty12(this, "pendingFields", new Map);
    _defineProperty12(this, "pendingRefResolutions", new Map);
    _defineProperty12(this, "fieldRefCallbacks", new Map);
    _defineProperty12(this, "pending", true);
    const scalars6 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars6.forEach((scalar2) => {
      const ref = new BuiltinScalarRef(scalar2);
      this.scalarsToRefs.set(scalar2.name, ref);
      this.refsToName.set(ref, scalar2.name);
    });
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/input.js
var _defineProperty14 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/input-field.js
var _defineProperty13 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputFieldShapeKey = inputFieldShapeKey;

class InputFieldRef {
  toString() {
    var _this_argFor;
    if (this.kind !== "Arg") {
      if (this.fieldName) {
        return `${this.parentTypename}.${this.fieldName}`;
      }
      return this.parentTypename;
    }
    var _this_argFor_fieldName;
    const fieldName = (_this_argFor_fieldName = (_this_argFor = this.argFor) === null || _this_argFor === undefined ? undefined : _this_argFor.fieldName) !== null && _this_argFor_fieldName !== undefined ? _this_argFor_fieldName : "[unnamed field]";
    var _this_fieldName;
    const argName = (_this_fieldName = this.fieldName) !== null && _this_fieldName !== undefined ? _this_fieldName : "[unnamed argument]";
    return `${this.parentTypename}.${fieldName}(${argName})`;
  }
  constructor(kind, parentTypename) {
    _defineProperty13(this, "kind", undefined);
    _defineProperty13(this, "parentTypename", undefined);
    _defineProperty13(this, "fieldName", undefined);
    _defineProperty13(this, "argFor", undefined);
    _defineProperty13(this, _inputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/input.js
class InputFieldBuilder {
  argBuilder() {
    const builder = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === undefined);
    [
      ...Object.keys(this),
      ...protoKeys
    ].forEach((key) => {
      builder[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    });
    return builder;
  }
  field(options) {
    const ref = new InputFieldRef(this.kind, this.typename);
    var _options_required;
    this.builder.configStore.addFieldRef(ref, options.type, {}, (name, parentField, typeConfig) => ({
      name,
      parentField,
      kind: this.kind,
      graphqlKind: this.kind,
      parentType: typeConfig.name,
      type: inputTypeFromParam(options.type, this.builder.configStore, (_options_required = options.required) !== null && _options_required !== undefined ? _options_required : this.builder.defaultInputFieldRequiredness),
      pothosOptions: options,
      description: options.description,
      deprecationReason: options.deprecationReason,
      defaultValue: options.defaultValue,
      extensions: options.extensions
    }));
    return ref;
  }
  helper(type) {
    return (...args) => {
      const [options = {}] = args;
      return this.field({
        ...options,
        type
      });
    };
  }
  constructor(builder, kind, typename) {
    _defineProperty14(this, "builder", undefined);
    _defineProperty14(this, "kind", undefined);
    _defineProperty14(this, "typename", undefined);
    _defineProperty14(this, "boolean", this.helper("Boolean"));
    _defineProperty14(this, "float", this.helper("Float"));
    _defineProperty14(this, "id", this.helper("ID"));
    _defineProperty14(this, "int", this.helper("Int"));
    _defineProperty14(this, "string", this.helper("String"));
    _defineProperty14(this, "booleanList", this.helper([
      "Boolean"
    ]));
    _defineProperty14(this, "floatList", this.helper([
      "Float"
    ]));
    _defineProperty14(this, "idList", this.helper([
      "ID"
    ]));
    _defineProperty14(this, "intList", this.helper([
      "Int"
    ]));
    _defineProperty14(this, "stringList", this.helper([
      "String"
    ]));
    var _options_required;
    _defineProperty14(this, "listRef", (type, options) => {
      return new InputObjectRef2(type, (_options_required = options === null || options === undefined ? undefined : options.required) !== null && _options_required !== undefined ? _options_required : true);
    });
    this.builder = builder;
    this.kind = kind;
    this.typename = typename;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/root.js
var _defineProperty17 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/fieldUtils/base.js
var _defineProperty16 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/field.js
var _defineProperty15 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputFieldShapeKey = outputFieldShapeKey;

class FieldRef {
  toString() {
    if (this.fieldName) {
      return `${this.parentTypename}.${this.fieldName}`;
    }
    return this.parentTypename;
  }
  constructor(kind, parentTypename) {
    _defineProperty15(this, "kind", undefined);
    _defineProperty15(this, "parentTypename", undefined);
    _defineProperty15(this, "fieldName", undefined);
    _defineProperty15(this, _outputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/base.js
class BaseFieldUtil {
  createField(options) {
    const ref = new FieldRef(this.kind, this.typename);
    var _options_args;
    this.builder.configStore.addFieldRef(ref, options.type, (_options_args = options.args) !== null && _options_args !== undefined ? _options_args : {}, (name, parentField, typeConfig) => {
      var _options_extensions;
      const args = {};
      if (options.args) {
        Object.keys(options.args).forEach((argName) => {
          const argRef = options.args[argName];
          args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
        });
      }
      var _options_resolve;
      let resolve = (_options_resolve = options.resolve) !== null && _options_resolve !== undefined ? _options_resolve : () => {
        throw new PothosSchemaError(`Not implemented: No resolver found for ${this.typename}.${name}`);
      };
      if (((_options_extensions = options.extensions) === null || _options_extensions === undefined ? undefined : _options_extensions.pothosExposedField) === name) {
        resolve = defaultFieldResolver;
      }
      const { subscribe: subscribe3 } = options;
      var _options_nullable;
      return {
        kind: this.kind,
        graphqlKind: this.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : this.builder.defaultFieldNullability),
        pothosOptions: options,
        extensions: {
          pothosOriginalResolve: resolve,
          pothosOriginalSubscribe: subscribe3,
          ...options.extensions
        },
        description: options.description,
        deprecationReason: options.deprecationReason,
        resolve,
        subscribe: subscribe3
      };
    });
    return ref;
  }
  exposeField(name, { extensions, ...options }) {
    return this.createField({
      ...options,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(name, builder, kind, graphqlKind) {
    _defineProperty16(this, "typename", undefined);
    _defineProperty16(this, "builder", undefined);
    _defineProperty16(this, "kind", undefined);
    _defineProperty16(this, "graphqlKind", undefined);
    this.typename = name;
    this.builder = builder;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/root.js
class RootFieldBuilder extends BaseFieldUtil {
  boolean(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Boolean"
    });
  }
  float(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Float"
    });
  }
  id(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "ID"
    });
  }
  int(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Int"
    });
  }
  string(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "String"
    });
  }
  booleanList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  floatList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Float"
      ]
    });
  }
  idList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "ID"
      ]
    });
  }
  intList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Int"
      ]
    });
  }
  stringList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "String"
      ]
    });
  }
  field(options) {
    return this.createField(options);
  }
  listRef(type, options) {
    var _options_nullable;
    return new ListRef(type, (_options_nullable = options === null || options === undefined ? undefined : options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : false);
  }
  constructor(...args) {
    super(...args);
    _defineProperty17(this, "arg", new InputFieldBuilder(this.builder, "Arg", this.typename).argBuilder());
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/builder.js
class FieldBuilder extends RootFieldBuilder {
  exposeBoolean(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Boolean"
    });
  }
  exposeFloat(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Float"
    });
  }
  exposeID(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "ID"
    });
  }
  exposeInt(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Int"
    });
  }
  exposeString(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "String"
    });
  }
  exposeBooleanList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  exposeFloatList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Float"
      ]
    });
  }
  exposeIDList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "ID"
      ]
    });
  }
  exposeIntList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Int"
      ]
    });
  }
  exposeStringList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "String"
      ]
    });
  }
  expose(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, options);
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/interface.js
class InterfaceFieldBuilder extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Interface", "Interface");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/mutation.js
class MutationFieldBuilder extends RootFieldBuilder {
  constructor(builder2) {
    super("Mutation", builder2, "Mutation", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/object.js
class ObjectFieldBuilder extends FieldBuilder {
  constructor(name, builder3) {
    super(name, builder3, "Object", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/query.js
class QueryFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Query", builder3, "Query", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/subscription.js
class SubscriptionFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Subscription", builder3, "Subscription", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/refs/enum.js
var _defineProperty18 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey4 = outputShapeKey;
var _inputShapeKey5 = inputShapeKey;

class EnumRef extends BaseTypeRef {
  constructor(name) {
    super("Enum", name);
    _defineProperty18(this, "kind", "Enum");
    _defineProperty18(this, _outputShapeKey4, undefined);
    _defineProperty18(this, _inputShapeKey5, undefined);
  }
}

// ../../node_modules/@pothos/core/esm/refs/interface.js
var _defineProperty19 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey5 = outputShapeKey;
var _parentShapeKey4 = parentShapeKey;

class InterfaceRef extends BaseTypeRef {
  constructor(name) {
    super("Interface", name);
    _defineProperty19(this, "kind", "Interface");
    _defineProperty19(this, _outputShapeKey5, undefined);
    _defineProperty19(this, _parentShapeKey4, undefined);
  }
}
class ImplementableInterfaceRef extends InterfaceRef {
  implement(options) {
    return this.builder.interfaceType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty19(this, "builder", undefined);
    this.builder = builder3;
  }
}

// ../../node_modules/@pothos/core/esm/refs/object.js
var _defineProperty20 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey6 = outputShapeKey;
var _parentShapeKey5 = parentShapeKey;

class ObjectRef extends BaseTypeRef {
  constructor(name) {
    super("Object", name);
    _defineProperty20(this, "kind", "Object");
    _defineProperty20(this, _outputShapeKey6, undefined);
    _defineProperty20(this, _parentShapeKey5, undefined);
  }
}
class ImplementableObjectRef extends ObjectRef {
  implement(options) {
    return this.builder.objectType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty20(this, "builder", undefined);
    this.builder = builder3;
  }
}

// ../../node_modules/@pothos/core/esm/refs/union.js
var _defineProperty21 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey7 = outputShapeKey;
var _parentShapeKey6 = parentShapeKey;

class UnionRef extends BaseTypeRef {
  constructor(name) {
    super("Union", name);
    _defineProperty21(this, "kind", "Union");
    _defineProperty21(this, _outputShapeKey7, undefined);
    _defineProperty21(this, _parentShapeKey6, undefined);
  }
}

// ../../node_modules/@pothos/core/esm/builder.js
class SchemaBuilder {
  static registerPlugin(name, plugin3) {
    if (!this.allowPluginReRegistration && this.plugins[name]) {
      throw new PothosError(`Received multiple implementations for plugin ${name}`);
    }
    this.plugins[name] = plugin3;
  }
  objectType(param, options, fields2) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    if (name === "Query" || name === "Mutation" || name === "Subscription") {
      throw new PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
    }
    const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
    const config = {
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options.description,
      extensions: options.extensions,
      isTypeOf: options.isTypeOf,
      pothosOptions: options
    };
    this.configStore.addTypeConfig(config, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(name, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields2) {
      this.configStore.addFields(ref, () => fields2(new ObjectFieldBuilder(name, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => {
        const t = new ObjectFieldBuilder(name, this);
        return options.fields(t);
      });
    }
    return ref;
  }
  objectFields(ref, fields2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields2(new ObjectFieldBuilder(name, this)));
    });
  }
  objectField(ref, fieldName, field2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field2(new ObjectFieldBuilder(name, this))
      }));
    });
  }
  queryType(...args) {
    const [options = {}, fields2] = args;
    const config = {
      kind: "Query",
      graphqlKind: "Object",
      name: "Query",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    const ref = new ObjectRef("Query");
    this.configStore.addTypeConfig(config, ref);
    if (fields2) {
      this.configStore.addFields("Query", () => fields2(new QueryFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
    }
    return ref;
  }
  queryFields(fields2) {
    this.configStore.addFields("Query", () => fields2(new QueryFieldBuilder(this)));
  }
  queryField(name, field2) {
    this.configStore.addFields("Query", () => ({
      [name]: field2(new QueryFieldBuilder(this))
    }));
  }
  mutationType(...args) {
    const [options = {}, fields2] = args;
    const config = {
      kind: "Mutation",
      graphqlKind: "Object",
      name: "Mutation",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields2) {
      this.configStore.addFields("Mutation", () => fields2(new MutationFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
    }
  }
  mutationFields(fields2) {
    this.configStore.addFields("Mutation", () => fields2(new MutationFieldBuilder(this)));
  }
  mutationField(name, field2) {
    this.configStore.addFields("Mutation", () => ({
      [name]: field2(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(...args) {
    const [options = {}, fields2] = args;
    const config = {
      kind: "Subscription",
      graphqlKind: "Object",
      name: "Subscription",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields2) {
      this.configStore.addFields("Subscription", () => fields2(new SubscriptionFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
    }
  }
  subscriptionFields(fields2) {
    this.configStore.addFields("Subscription", () => fields2(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field2) {
    this.configStore.addFields("Subscription", () => ({
      [name]: field2(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields2) {
    return fields2(new InputFieldBuilder(this, "Arg", "[unknown]"));
  }
  interfaceType(param, options, fields2) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
    const typename = ref.name;
    const config = {
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions,
      resolveType: options.resolveType
    };
    this.configStore.addTypeConfig(config, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(typename, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields2) {
      this.configStore.addFields(ref, () => fields2(new InterfaceFieldBuilder(typename, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(typename, this)));
    }
    return ref;
  }
  interfaceFields(ref, fields2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields2(new InterfaceFieldBuilder(name, this)));
    });
  }
  interfaceField(ref, fieldName, field2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field2(new InterfaceFieldBuilder(name, this))
      }));
    });
  }
  unionType(name, options) {
    const ref = new UnionRef(name);
    if (Array.isArray(options.types)) {
      options.types.forEach((type) => {
        verifyRef(type);
      });
    }
    const config = {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: [],
      description: options.description,
      resolveType: options.resolveType,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    this.configStore.addUnionTypes(name, options.types);
    return ref;
  }
  enumType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options.name;
    const ref = new EnumRef(name);
    const values3 = typeof param === "object" ? valuesFromEnum(param, options === null || options === undefined ? undefined : options.values) : normalizeEnumValues(options.values);
    const config = {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values: values3,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    if (typeof param !== "string") {
      this.configStore.associateRefWithName(param, name);
    }
    return ref;
  }
  scalarType(name, options) {
    const ref = new ScalarRef(name);
    const config = {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options.description,
      parseLiteral: options.parseLiteral,
      parseValue: options.parseValue,
      serialize: options.serialize,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    return ref;
  }
  addScalarType(name, scalar3, options) {
    const config = scalar3.toConfig();
    return this.scalarType(name, {
      ...config,
      ...options,
      extensions: {
        ...config.extensions,
        ...options.extensions
      }
    });
  }
  inputType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref = typeof param === "string" ? new InputObjectRef(name) : param;
    const config = {
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    this.configStore.addFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
    return ref;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(...args) {
    const [options = {}] = args;
    const { directives: directives12, extensions } = options;
    const scalars6 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars6.forEach((scalar3) => {
      if (!this.configStore.hasConfig(scalar3.name)) {
        this.addScalarType(scalar3.name, scalar3, {});
      }
    });
    const buildCache = new BuildCache(this, options);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const schema3 = new GraphQLSchema({
      query: buildCache.types.get("Query"),
      mutation: buildCache.types.get("Mutation"),
      subscription: buildCache.types.get("Subscription"),
      extensions: extensions !== null && extensions !== undefined ? extensions : {},
      directives: directives12,
      types: builtTypes
    });
    const processedSchema = buildCache.plugin.afterBuild(schema3);
    return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
  }
  constructor(options) {
    _defineProperty22(this, "configStore", undefined);
    _defineProperty22(this, "options", undefined);
    _defineProperty22(this, "defaultFieldNullability", undefined);
    _defineProperty22(this, "defaultInputFieldRequiredness", undefined);
    this.options = options;
    this.configStore = new ConfigStore;
    var _options_defaultFieldNullability;
    this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== undefined ? _options_defaultFieldNullability : false;
    var _options_defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== undefined ? _options_defaultInputFieldRequiredness : false;
  }
}
_defineProperty22(SchemaBuilder, "plugins", {});
_defineProperty22(SchemaBuilder, "allowPluginReRegistration", false);

// ../../node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;
var RootFieldBuilder2 = RootFieldBuilder;
var QueryFieldBuilder2 = QueryFieldBuilder;
var MutationFieldBuilder2 = MutationFieldBuilder;
var SubscriptionFieldBuilder2 = SubscriptionFieldBuilder;
var ObjectFieldBuilder2 = ObjectFieldBuilder;
var InterfaceFieldBuilder2 = InterfaceFieldBuilder;
var InputFieldBuilder2 = InputFieldBuilder;
var BaseTypeRef2 = BaseTypeRef;
var InputObjectRef3 = InputObjectRef;
var InterfaceRef2 = InterfaceRef;
var ObjectRef2 = ObjectRef;

// src/utils/prisma.ts
var client = __toESM(require_client2(), 1);

// src/env.ts
var envsToCheck = {
  NODE_ENV: [false, false],
  PORT: [false, false],
  DATABASE_URL: [true, true],
  ORIGIN: [true, false],
  PATH_TO_PLUGINS: [false, true]
};
var env = {};
console.log("\x1B[2mEnvironment variables:\x1B[0m");
for (const [envKey, [required, sensitive]] of Object.entries(envsToCheck)) {
  const envValue = process.env[envKey];
  if (required && !envValue) {
    throw `\x1B[31mEnvironment variable ${envKey} is required but not set.\x1B[0m`;
  }
  if (sensitive) {
    console.log(`\x1B[2m  ${envKey}: ${envValue ? `***${envValue.slice(-15)}` : undefined}\x1B[0m`);
  } else {
    console.log(`\x1B[2m  ${envKey}: ${envValue}\x1B[0m`);
  }
  env[envKey] = envValue;
  delete process.env[envKey];
}

// src/pubsub.ts
var pubsub = createPubSub();

// src/utils/dayjs.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var customParseFormat = __toESM(require_customParseFormat(), 1);
var utc = __toESM(require_utc(), 1);
var timezone = __toESM(require_timezone(), 1);
import_dayjs.default.extend(customParseFormat.default);
import_dayjs.default.extend(utc.default);
import_dayjs.default.extend(timezone.default);
var dayjs = import_dayjs.default;

// src/utils/prisma.ts
var $prisma = new client.PrismaClient({
  datasources: {
    db: {
      url: env.DATABASE_URL
    }
  }
});
var withPubsub = (delegate, pub) => ({
  ...delegate,
  async create(args) {
    const res = await delegate.create(args);
    pub("Created", [res], { args: args.data, operation: "create" });
    return res;
  },
  async createMany(args) {
    const now = dayjs().subtract(1, "second").toDate();
    const res = await delegate.createMany(args);
    const created = await delegate.findMany({ where: { createdAt: { gte: now } } });
    pub("Created", created, { args: {}, operation: "createMany" });
    return res;
  },
  async update(args) {
    const res = await delegate.update(args);
    pub("Updated", [res], { args: args.data, operation: "update" });
    return res;
  },
  async updateMany(args) {
    const now = dayjs().subtract(1, "second").toDate();
    const res = await delegate.updateMany(args);
    const updated = await delegate.findMany({ where: { updatedAt: { gte: now } } });
    pub("Updated", updated, { args, operation: "updateMany" });
    return res;
  },
  async upsert(args) {
    const res = await delegate.upsert(args);
    if (dayjs(res.updatedAt).isSame(dayjs(res.createdAt))) {
      pub("Created", [res], { args: { c: args.create, u: args.update }, operation: "upsert" });
    } else {
      pub("Updated", [res], { args: { c: args.create, u: args.update }, operation: "upsert" });
    }
    return res;
  },
  async delete(args) {
    const res = await delegate.delete(args);
    pub("Deleted", [res], { args, operation: "delete" });
    return res;
  },
  async deleteMany(args) {
    const toBeDeleted = await delegate.findMany(args);
    const res = await delegate.deleteMany(args);
    pub("Deleted", toBeDeleted, { args, operation: "deleteMany" });
    return res;
  }
});
var prisma = {
  ...$prisma,
  task: withPubsub($prisma.task, (action, rows) => pubsub.publish(`Tasks${action}`, rows)),
  item: withPubsub($prisma.item, (action, rows, op) => {
    if (op.operation === "create" || op.operation === "update" || op.operation === "upsert") {
      taskPubsub(op.args, (action2, rowsRaw) => pubsub.publish(`Tasks${action2}`, rowsRaw));
    }
    pubsub.publish(`Items${action}`, rows);
  }),
  async $transaction(fn, options) {
    const tasksCreated = [];
    const tasksUpdated = [];
    const tasksDeleted = [];
    const itemsCreated = [];
    const itemsUpdated = [];
    const itemsDeleted = [];
    if (typeof fn !== "function") {
      return $prisma.$transaction(fn, options);
    }
    const res = await $prisma.$transaction((tx) => {
      return fn({
        ...tx,
        task: withPubsub(tx.task, (action, rowsRaw) => {
          const rows = rowsRaw;
          switch (action) {
            case "Created":
              tasksCreated.push(...rows);
              break;
            case "Updated":
              tasksUpdated.push(...rows);
              break;
            case "Deleted":
              tasksDeleted.push(...rows);
              break;
          }
        }),
        item: withPubsub(tx.item, (action, rowsRaw) => {
          const rows = rowsRaw;
          switch (action) {
            case "Created":
              itemsCreated.push(...rows);
              break;
            case "Updated":
              itemsUpdated.push(...rows);
              break;
            case "Deleted":
              itemsDeleted.push(...rows);
              break;
          }
        })
      });
    }, options);
    if (tasksCreated.length)
      pubsub.publish("TasksCreated", tasksCreated);
    if (tasksUpdated.length)
      pubsub.publish("TasksUpdated", tasksUpdated);
    if (tasksDeleted.length)
      pubsub.publish("TasksDeleted", tasksDeleted);
    if (itemsCreated.length)
      pubsub.publish("ItemsCreated", itemsCreated);
    if (itemsUpdated.length)
      pubsub.publish("ItemsUpdated", itemsUpdated);
    if (itemsDeleted.length)
      pubsub.publish("ItemsDeleted", itemsDeleted);
    return res;
  },
  $executeRaw: $prisma.$executeRaw,
  $executeRawUnsafe: (...args) => $prisma.$executeRawUnsafe(...args),
  $on: $prisma.$on,
  $use: $prisma.$use,
  $connect: $prisma.$connect,
  $disconnect: $prisma.$disconnect,
  $queryRaw: $prisma.$queryRaw,
  $queryRawUnsafe: $prisma.$queryRawUnsafe
};
var taskPubsub = (args, pub) => {
  setImmediate(async () => {
    const secondsAgo = dayjs().subtract(3, "second").toDate();
    if (!/task/i.test(JSON.stringify(args)))
      return;
    const created = await $prisma.task.findMany({
      where: { createdAt: { gte: secondsAgo } }
    });
    const updated = await $prisma.task.findMany({
      where: { updatedAt: { gte: secondsAgo } }
    });
    pub("Created", created, { args: {}, operation: "create" });
    pub("Updated", updated, { args: {}, operation: "update" });
  });
};
// ../../node_modules/@pothos/plugin-relay/esm/utils/global-ids.js
function encodeGlobalID(typename, id) {
  return encodeBase64(`${typename}:${id}`);
}
function decodeGlobalID(globalID) {
  const [typename, id] = decodeBase64(globalID).split(":");
  if (!typename || !id) {
    throw new TypeError(`Invalid global ID: ${globalID}`);
  }
  return {
    typename,
    id
  };
}
// ../../node_modules/@pothos/plugin-relay/esm/utils/internal.js
function internalEncodeGlobalID(builder5, typename, id, ctx) {
  if (builder5.options.relayOptions.encodeGlobalID) {
    return builder5.options.relayOptions.encodeGlobalID(typename, id, ctx);
  }
  return encodeGlobalID(typename, id);
}
function internalDecodeGlobalID(builder5, globalID, ctx) {
  if (builder5.options.relayOptions.decodeGlobalID) {
    return builder5.options.relayOptions.decodeGlobalID(globalID, ctx);
  }
  return decodeGlobalID(globalID);
}

// ../../node_modules/@pothos/plugin-relay/esm/utils/resolve-nodes.js
async function resolveNodes(builder5, context, info, globalIDs) {
  const requestCache = getRequestCache(context);
  const idsByType = {};
  const results = {};
  globalIDs.forEach((globalID, i) => {
    if (globalID == null) {
      return;
    }
    if (requestCache.has(globalID)) {
      results[globalID] = requestCache.get(globalID);
      return;
    }
    const { id, typename } = internalDecodeGlobalID(builder5, globalID, context);
    idsByType[typename] = idsByType[typename] || new Map;
    idsByType[typename].set(id, globalID);
  });
  await Promise.all(Object.keys(idsByType).map(async (typename) => {
    const ids = [
      ...idsByType[typename].keys()
    ];
    const globalIds = [
      ...idsByType[typename].values()
    ];
    const config = builder5.configStore.getTypeConfig(typename, "Object");
    const options = config.pothosOptions;
    var _brandLoadedObjects, ref;
    const shouldBrandObjects = (ref = (_brandLoadedObjects = options.brandLoadedObjects) !== null && _brandLoadedObjects !== undefined ? _brandLoadedObjects : builder5.options.relayOptions.brandLoadedObjects) !== null && ref !== undefined ? ref : false;
    const resultsForType = await resolveUncachedNodesForType(builder5, context, info, ids, typename);
    resultsForType.forEach((val, i) => {
      if (shouldBrandObjects) {
        brandWithType(val, typename);
      }
      results[globalIds[i]] = val;
    });
  }));
  var _globalID;
  return globalIDs.map((globalID) => globalID == null ? null : (_globalID = results[globalID]) !== null && _globalID !== undefined ? _globalID : null);
}
async function resolveUncachedNodesForType(builder5, context, info, ids, type) {
  const requestCache = getRequestCache(context);
  const config = builder5.configStore.getTypeConfig(type, "Object");
  const options = config.pothosOptions;
  if (options.loadMany) {
    const loadManyPromise = Promise.resolve(options.loadMany(ids, context));
    return Promise.all(ids.map((id, i) => {
      const globalID = internalEncodeGlobalID(builder5, config.name, id, context);
      const entryPromise = loadManyPromise.then((results) => results[i]).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadOne) {
    return Promise.all(ids.map((id) => {
      const globalID = internalEncodeGlobalID(builder5, config.name, id, context);
      const entryPromise = Promise.resolve(options.loadOne(id, context)).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadManyWithoutCache) {
    return options.loadManyWithoutCache(ids, context);
  }
  if (options.loadWithoutCache) {
    return Promise.all(ids.map((id) => Promise.resolve(options.loadWithoutCache(id, context, info))));
  }
  throw new Error(`${config.name} does not support loading by id`);
}
var getRequestCache = createContextCache(() => new Map);

// ../../node_modules/@pothos/plugin-relay/esm/utils/index.js
function capitalize(s) {
  return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
}

// ../../node_modules/@pothos/plugin-relay/esm/field-builder.js
var fieldBuilderProto = RootFieldBuilder2.prototype;
fieldBuilderProto.globalIDList = function globalIDList({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result) {
      return result;
    }
    assertArray(result);
    if (Array.isArray(result)) {
      return (await Promise.all(result)).map((item) => item == null || typeof item === "string" ? item : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context));
    }
    return null;
  };
  return this.field({
    ...options,
    type: [
      "ID"
    ],
    resolve: wrappedResolve
  });
};
fieldBuilderProto.globalID = function globalID({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result || typeof result === "string") {
      return result;
    }
    const item = result;
    return internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context);
  };
  return this.field({
    ...options,
    type: "ID",
    resolve: wrappedResolve
  });
};
fieldBuilderProto.node = function node({ id, ...options }) {
  return this.field({
    ...options,
    type: this.builder.nodeInterfaceRef(),
    nullable: true,
    resolve: async (parent, args, context, info) => {
      const rawID = await id(parent, args, context, info);
      if (rawID == null) {
        return null;
      }
      const globalID2 = typeof rawID === "string" ? rawID : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(rawID.type).name, String(rawID.id), context);
      return (await resolveNodes(this.builder, context, info, [
        globalID2
      ]))[0];
    }
  });
};
fieldBuilderProto.nodeList = function nodeList({ ids, ...options }) {
  return this.field({
    ...options,
    nullable: {
      list: false,
      items: true
    },
    type: [
      this.builder.nodeInterfaceRef()
    ],
    resolve: async (parent, args, context, info) => {
      const rawIDList = await ids(parent, args, context, info);
      assertArray(rawIDList);
      if (!Array.isArray(rawIDList)) {
        return [];
      }
      const rawIds = await Promise.all(rawIDList);
      const globalIds = rawIds.map((id) => !id || typeof id === "string" ? id : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(id.type).name, String(id.id), context));
      return resolveNodes(this.builder, context, info, globalIds);
    }
  });
};
fieldBuilderProto.connection = function connection({ type, edgesNullable, nodeNullable, ...fieldOptions }, connectionOptionsOrRef = {}, edgeOptionsOrRef = {}) {
  var ref;
  const connectionRef = connectionOptionsOrRef instanceof ObjectRef2 ? connectionOptionsOrRef : this.builder.objectRef("Unnamed connection");
  const fieldRef = this.field({
    ...(ref = this.builder.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultConnectionFieldOptions,
    ...fieldOptions,
    type: connectionRef,
    args: {
      ...fieldOptions.args,
      ...this.arg.connectionArgs()
    },
    resolve: fieldOptions.resolve
  });
  if (!(connectionOptionsOrRef instanceof ObjectRef2)) {
    this.builder.configStore.onFieldUse(fieldRef, (fieldConfig) => {
      var _name;
      const connectionName = (_name = connectionOptionsOrRef.name) !== null && _name !== undefined ? _name : `${this.typename}${capitalize(fieldConfig.name)}${fieldConfig.name.toLowerCase().endsWith("connection") ? "" : "Connection"}`;
      this.builder.connectionObject({
        type,
        edgesNullable,
        nodeNullable,
        ...connectionOptionsOrRef,
        name: connectionName
      }, edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : {
        name: `${connectionName}Edge`,
        ...edgeOptionsOrRef
      });
      this.builder.configStore.associateRefWithName(connectionRef, connectionName);
    });
  }
  return fieldRef;
};

// ../../node_modules/@pothos/plugin-relay/esm/input-field-builder.js
var inputFieldBuilder = InputFieldBuilder2.prototype;
inputFieldBuilder.globalIDList = function globalIDList2(options = {}) {
  return this.idList({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.globalID = function globalID2(options = {}) {
  return this.id({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.connectionArgs = function connectionArgs() {
  const {
    cursorType = "ID",
    beforeArgOptions = {},
    afterArgOptions = {},
    firstArgOptions = {},
    lastArgOptions = {}
  } = this.builder.options.relayOptions;
  return {
    before: this.field({
      ...beforeArgOptions,
      type: cursorType,
      required: false
    }),
    after: this.field({
      ...afterArgOptions,
      type: cursorType,
      required: false
    }),
    first: this.int({
      ...firstArgOptions,
      required: false
    }),
    last: this.int({
      ...lastArgOptions,
      required: false
    })
  };
};

// ../../node_modules/@pothos/plugin-relay/esm/schema-builder.js
var schemaBuilderProto = esm_default.prototype;
var pageInfoRefMap = new WeakMap;
var nodeInterfaceRefMap = new WeakMap;
var connectionRefs = new WeakMap;
var globalConnectionFieldsMap = new WeakMap;
schemaBuilderProto.pageInfoRef = function pageInfoRef() {
  if (pageInfoRefMap.has(this)) {
    return pageInfoRefMap.get(this);
  }
  const ref = this.objectRef("PageInfo");
  pageInfoRefMap.set(this, ref);
  const { cursorType = "String", hasNextPageFieldOptions = {}, hasPreviousPageFieldOptions = {}, startCursorFieldOptions = {}, endCursorFieldOptions = {} } = this.options.relayOptions;
  ref.implement({
    ...this.options.relayOptions.pageInfoTypeOptions,
    fields: (t) => ({
      hasNextPage: t.exposeBoolean("hasNextPage", {
        nullable: false,
        ...hasNextPageFieldOptions
      }),
      hasPreviousPage: t.exposeBoolean("hasPreviousPage", {
        nullable: false,
        ...hasPreviousPageFieldOptions
      }),
      startCursor: t.expose("startCursor", {
        nullable: true,
        ...startCursorFieldOptions,
        type: cursorType
      }),
      endCursor: t.expose("endCursor", {
        nullable: true,
        ...endCursorFieldOptions,
        type: cursorType
      })
    })
  });
  return ref;
};
schemaBuilderProto.nodeInterfaceRef = function nodeInterfaceRef() {
  if (nodeInterfaceRefMap.has(this)) {
    return nodeInterfaceRefMap.get(this);
  }
  const ref = this.interfaceRef("Node");
  nodeInterfaceRefMap.set(this, ref);
  var ref1;
  ref.implement({
    resolveType: (value, context, info, graphQLType) => {
      if (!value) {
        return defaultTypeResolver(value, context, info, graphQLType);
      }
      const typeBrand = getTypeBrand(value);
      if (typeBrand) {
        const type = this.configStore.getTypeConfig(typeBrand);
        return type.name;
      }
      try {
        if (typeof value === "object") {
          const typename = value.__typename;
          if (typename) {
            return typename;
          }
          const nodeRef = value.__type;
          if (nodeRef) {
            const config = this.configStore.getTypeConfig(nodeRef);
            if (config) {
              return config.name;
            }
          }
        }
      } catch {
      }
      return defaultTypeResolver(value, context, info, graphQLType);
    },
    ...this.options.relayOptions.nodeTypeOptions,
    fields: (t) => {
      var ref2;
      return {
        [(ref1 = (ref2 = this.options.relayOptions) === null || ref2 === undefined ? undefined : ref2.idFieldName) !== null && ref1 !== undefined ? ref1 : "id"]: t.globalID({
          nullable: false,
          resolve: (parent) => {
            throw new Error("id field not implemented");
          }
        })
      };
    }
  });
  this.queryField("node", (t) => t.field({
    nullable: true,
    ...this.options.relayOptions.nodeQueryOptions,
    type: ref,
    args: {
      id: t.arg.id({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => (await resolveNodes(this, context, info, [
      String(args.id)
    ]))[0]
  }));
  this.queryField("nodes", (t) => t.field({
    nullable: {
      list: false,
      items: true
    },
    ...this.options.relayOptions.nodesQueryOptions,
    type: [
      ref
    ],
    args: {
      ids: t.arg.idList({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => await resolveNodes(this, context, info, args.ids)
  }));
  return ref;
};
schemaBuilderProto.node = function node2(param, { interfaces, ...options }, fields2) {
  verifyRef(param);
  const interfacesWithNode = [
    this.nodeInterfaceRef(),
    ...interfaces !== null && interfaces !== undefined ? interfaces : []
  ];
  let nodeName;
  var _isTypeOf;
  const ref = this.objectType(param, {
    ...options,
    isTypeOf: (_isTypeOf = options.isTypeOf) !== null && _isTypeOf !== undefined ? _isTypeOf : typeof param === "function" ? (maybeNode, context, info) => {
      if (!maybeNode) {
        return false;
      }
      if (maybeNode instanceof param) {
        return true;
      }
      const proto = Object.getPrototypeOf(maybeNode);
      try {
        if (proto === null || proto === undefined ? undefined : proto.constructor) {
          const config = this.configStore.getTypeConfig(proto.constructor);
          return config.name === nodeName;
        }
      } catch {
      }
      return false;
    } : undefined,
    interfaces: interfacesWithNode
  }, fields2);
  this.configStore.onTypeConfig(ref, (nodeConfig) => {
    nodeName = nodeConfig.name;
    var _idFieldName;
    this.objectField(ref, (_idFieldName = this.options.relayOptions.idFieldName) !== null && _idFieldName !== undefined ? _idFieldName : "id", (t) => t.globalID({
      nullable: false,
      ...this.options.relayOptions.idFieldOptions,
      ...options.id,
      args: {},
      resolve: async (parent, args, context, info) => ({
        type: nodeConfig.name,
        id: await options.id.resolve(parent, args, context, info)
      })
    }));
  });
  return ref;
};
schemaBuilderProto.globalConnectionField = function globalConnectionField(name, field2) {
  var ref;
  const onRef = (ref2) => {
    this.objectField(ref2, name, field2);
  };
  (ref = connectionRefs.get(this)) === null || ref === undefined || ref.forEach((ref2) => void onRef(ref2));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
schemaBuilderProto.globalConnectionFields = function globalConnectionFields(fields2) {
  var ref;
  const onRef = (ref2) => {
    this.objectFields(ref2, fields2);
  };
  (ref = connectionRefs.get(this)) === null || ref === undefined || ref.forEach((ref2) => void onRef(ref2));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
var mutationIdCache = createContextCache(() => new Map);
schemaBuilderProto.relayMutationField = function relayMutationField(fieldName, inputOptionsOrRef, { resolve, ...fieldOptions }, { name: payloadName = `${capitalize(fieldName)}Payload`, outputFields, interfaces, ...paylaodOptions }) {
  var ref;
  const { relayOptions: { clientMutationIdInputOptions = {}, clientMutationIdFieldOptions = {}, mutationInputArgOptions = {} } } = this.options;
  const includeClientMutationId = this.options.relayOptions.clientMutationId !== "omit";
  let inputRef;
  let argName = "input";
  if (inputOptionsOrRef instanceof InputObjectRef3) {
    inputRef = inputOptionsOrRef;
  } else {
    var ref1;
    const { name: inputName = `${capitalize(fieldName)}Input`, argName: argNameFromOptions = "input", inputFields, ...inputOptions } = inputOptionsOrRef;
    argName = argNameFromOptions;
    inputRef = this.inputType(inputName, {
      ...(ref1 = this.options.relayOptions) === null || ref1 === undefined ? undefined : ref1.defaultMutationInputTypeOptions,
      ...inputOptions,
      fields: (t) => ({
        ...inputFields(t),
        ...includeClientMutationId ? {
          clientMutationId: t.id({
            ...clientMutationIdInputOptions,
            required: this.options.relayOptions.clientMutationId !== "optional"
          })
        } : {}
      })
    });
  }
  const payloadRef = this.objectRef(payloadName).implement({
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultPayloadTypeOptions,
    ...paylaodOptions,
    interfaces,
    fields: (t) => ({
      ...outputFields(t),
      ...includeClientMutationId ? {
        clientMutationId: t.id({
          nullable: this.options.relayOptions.clientMutationId === "optional",
          ...clientMutationIdFieldOptions,
          resolve: (parent, args, context, info) => mutationIdCache(context).get(String(info.path.prev.key))
        })
      } : {}
    })
  });
  this.mutationField(fieldName, (t) => t.field({
    ...fieldOptions,
    type: payloadRef,
    args: {
      [argName]: t.arg({
        ...mutationInputArgOptions,
        type: inputRef,
        required: true
      })
    },
    resolve: (root6, args, context, info) => {
      mutationIdCache(context).set(String(info.path.key), args[argName].clientMutationId);
      return resolve(root6, args, context, info);
    }
  }));
  return {
    inputType: inputRef,
    payloadType: payloadRef
  };
};
schemaBuilderProto.connectionObject = function connectionObject({ type, name: connectionName, edgesNullable: edgesNullableField, nodeNullable, ...connectionOptions }, edgeOptionsOrRef) {
  var ref, ref1;
  verifyRef(type);
  const { edgesFieldOptions: { nullable: edgesNullable = {
    items: true,
    list: false
  }, ...edgesFieldOptions } = {}, pageInfoFieldOptions = {} } = this.options.relayOptions;
  const connectionRef = this.objectRef(connectionName);
  const edgeRef = edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : this.edgeObject({
    name: `${connectionName.replace(/Connection$/, "")}Edge`,
    ...edgeOptionsOrRef,
    nodeNullable,
    type
  });
  const connectionFields = connectionOptions.fields;
  const { nodesOnConnection } = this.options.relayOptions;
  const edgesNullableOption = edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable;
  const edgeListNullable = typeof edgesNullableOption === "object" ? edgesNullableOption.list : !!edgesNullableOption;
  const edgeItemsNullable = typeof edgesNullableOption === "object" && "items" in edgesNullableOption ? edgesNullableOption.items : false;
  var ref2, ref3, ref4;
  this.objectType(connectionRef, {
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultConnectionTypeOptions,
    ...connectionOptions,
    fields: (t) => {
      var ref5, ref12;
      return {
        pageInfo: t.field({
          nullable: false,
          ...pageInfoFieldOptions,
          type: this.pageInfoRef(),
          resolve: (parent) => parent.pageInfo
        }),
        edges: t.field({
          nullable: edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable,
          ...edgesFieldOptions,
          type: [
            edgeRef
          ],
          resolve: (parent) => parent.edges
        }),
        ...nodesOnConnection ? {
          nodes: t.field({
            ...typeof nodesOnConnection === "object" ? nodesOnConnection : {},
            type: [
              type
            ],
            nullable: {
              list: edgeListNullable,
              items: (ref3 = (ref2 = edgeItemsNullable !== null && edgeItemsNullable !== undefined ? edgeItemsNullable : nodeNullable) !== null && ref2 !== undefined ? ref2 : (ref5 = this.options.relayOptions) === null || ref5 === undefined ? undefined : (ref12 = ref5.nodeFieldOptions) === null || ref12 === undefined ? undefined : ref12.nullable) !== null && ref3 !== undefined ? ref3 : false
            },
            resolve: (con) => {
              var ref6;
              return (ref4 = (ref6 = con.edges) === null || ref6 === undefined ? undefined : ref6.map((edge) => {
                return edge === null || edge === undefined ? undefined : edge.node;
              })) !== null && ref4 !== undefined ? ref4 : [];
            }
          })
        } : {},
        ...connectionFields === null || connectionFields === undefined ? undefined : connectionFields(t)
      };
    }
  });
  if (!connectionRefs.has(this)) {
    connectionRefs.set(this, []);
  }
  connectionRefs.get(this).push(connectionRef);
  (ref1 = globalConnectionFieldsMap.get(this)) === null || ref1 === undefined || ref1.forEach((fieldFn) => void fieldFn(connectionRef));
  return connectionRef;
};
schemaBuilderProto.edgeObject = function edgeObject({ type, name: edgeName, nodeNullable: nodeFieldNullable, ...edgeOptions }) {
  var ref;
  verifyRef(type);
  const { cursorType = "String", cursorFieldOptions = {}, nodeFieldOptions: { nullable: nodeNullable = false, ...nodeFieldOptions } = {} } = this.options.relayOptions;
  const edgeRef = this.objectRef(edgeName);
  const edgeFields = edgeOptions.fields;
  this.objectType(edgeRef, {
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultEdgeTypeOptions,
    ...edgeOptions,
    fields: (t) => {
      return {
        node: t.field({
          nullable: nodeFieldNullable !== null && nodeFieldNullable !== undefined ? nodeFieldNullable : nodeNullable,
          ...nodeFieldOptions,
          type,
          resolve: (parent) => parent.node
        }),
        cursor: t.expose("cursor", {
          nullable: false,
          type: cursorType,
          ...cursorFieldOptions
        }),
        ...edgeFields === null || edgeFields === undefined ? undefined : edgeFields(t)
      };
    }
  });
  return edgeRef;
};

// ../../node_modules/@pothos/plugin-relay/esm/index.js
var pluginName = "relay";
var esm_default2 = pluginName;

class PothosRelayPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref;
      if ((ref = inputField.extensions) === null || ref === undefined ? undefined : ref.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => resolver(parent, argMapper(args, undefined, context), context, info);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref;
      if ((ref = inputField.extensions) === null || ref === undefined ? undefined : ref.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings || !subscribe3) {
      return subscribe3;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => subscribe3(parent, argMapper(args, undefined, context), context, info);
  }
}
esm_default.registerPlugin(pluginName, PothosRelayPlugin);

// ../../node_modules/@pothos/plugin-prisma/esm/interface-ref.js
var _define_property2 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-prisma/esm/object-ref.js
var _define_property = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var prismaModelKey = Symbol.for("Pothos.prismaModelKey");
var _prismaModelKey = prismaModelKey;
var _abstractReturnShapeKey = abstractReturnShapeKey;

class PrismaObjectRef extends ObjectRef2 {
  addBrand(value) {
    if (Array.isArray(value)) {
      value.forEach((val) => void brandWithType(val, this.name));
      return value;
    }
    brandWithType(value, this.name);
    return value;
  }
  hasBrand(value) {
    return typeof value === "object" && value !== null && typeBrandKey in value && value[typeBrandKey] === this.name;
  }
  constructor(name, modelName) {
    super(name);
    _define_property(this, _prismaModelKey, undefined);
    _define_property(this, _abstractReturnShapeKey, undefined);
    _define_property(this, "modelName", undefined);
    this.modelName = modelName;
  }
}

// ../../node_modules/@pothos/plugin-prisma/esm/interface-ref.js
var _prismaModelKey2 = prismaModelKey;

class PrismaInterfaceRef extends InterfaceRef2 {
  constructor(name, modelName) {
    super(name);
    _define_property2(this, _prismaModelKey2, undefined);
    _define_property2(this, "modelName", undefined);
    this.modelName = modelName;
  }
}

// ../../node_modules/@pothos/plugin-prisma/esm/model-loader.js
var _define_property3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-prisma/esm/util/get-client.js
function getClient(builder5, context) {
  if (typeof builder5.options.prisma.client === "function") {
    return prismaClientCache(builder5)(context);
  }
  return builder5.options.prisma.client;
}
function getDMMF(builder5) {
  var _client__baseDmmf;
  if ("dmmf" in builder5.options.prisma && builder5.options.prisma.dmmf) {
    return builder5.options.prisma.dmmf.datamodel;
  }
  const client2 = builder5.options.prisma.client;
  var _client__runtimeDataModel, _ref;
  return (_ref = (_client__runtimeDataModel = client2._runtimeDataModel) !== null && _client__runtimeDataModel !== undefined ? _client__runtimeDataModel : (_client__baseDmmf = client2._baseDmmf) === null || _client__baseDmmf === undefined ? undefined : _client__baseDmmf.datamodel) !== null && _ref !== undefined ? _ref : client2._dmmf.datamodel;
}
var prismaClientCache = createContextCache((builder5) => createContextCache((context) => typeof builder5.options.prisma.client === "function" ? builder5.options.prisma.client(context) : builder5.options.prisma.client));

// ../../node_modules/@pothos/plugin-prisma/esm/util/datamodel.js
function getRefFromModel(name, builder5, type = "object") {
  if (!refMap.has(builder5)) {
    refMap.set(builder5, new Map);
  }
  const cache = refMap.get(builder5);
  if (!cache.has(name)) {
    cache.set(name, type === "object" ? new PrismaObjectRef(name, name) : new PrismaInterfaceRef(name, name));
  }
  return cache.get(name);
}
function getRelation(name, builder5, relation) {
  const fieldData = getFieldData(name, builder5, relation);
  if (fieldData.kind !== "object") {
    throw new PothosSchemaError(`Field ${relation} of model '${name}' is not a relation (${fieldData.kind})`);
  }
  return fieldData;
}
function getFieldData(name, builder5, fieldName) {
  const modelData = getModel(name, builder5);
  const fieldData = modelData.fields.find((field2) => field2.name === fieldName);
  if (!fieldData) {
    throw new PothosSchemaError(`Field '${fieldName}' not found in model '${name}'`);
  }
  return fieldData;
}
function getModel(name, builder5) {
  const dmmf = getDMMF(builder5);
  const modelData = Array.isArray(dmmf.models) ? dmmf.models.find((model) => model.name === name) : dmmf.models[name];
  if (!modelData) {
    throw new PothosSchemaError(`Model '${name}' not found in DMMF`);
  }
  return modelData;
}
function getDelegateFromModel(client2, model) {
  const lowerCase = `${model.slice(0, 1).toLowerCase()}${model.slice(1)}`;
  const delegate = lowerCase in client2 ? client2[lowerCase] : null;
  if (!delegate) {
    throw new PothosSchemaError(`Unable to find delegate for model ${model}`);
  }
  return delegate;
}
var refMap = new WeakMap;
var findUniqueMap = new WeakMap;
var includeForRefMap = new WeakMap;

// ../../node_modules/@pothos/plugin-prisma/esm/util/loader-map.js
function cacheKey(type, path, subPath = []) {
  let key = "";
  let current = path;
  while (current) {
    if (typeof current.key === "string") {
      key = key ? `${current.key}.${key}` : current.key;
    }
    current = current.prev;
  }
  for (const entry of subPath) {
    key = `${key}.${entry}`;
  }
  return `${type}@${key}`;
}
function setLoaderMappings(ctx, info, value) {
  Object.keys(value).forEach((field2) => {
    const map2 = cache(ctx);
    const mapping = value[field2];
    const subPath = [
      ...mapping.indirectPath,
      field2
    ];
    const key = cacheKey(mapping.type, info.path, subPath);
    map2.set(key, mapping.mappings);
  });
}
function getLoaderMapping(ctx, path, type) {
  const map2 = cache(ctx);
  const key = cacheKey(type, path, []);
  var _map_get;
  return (_map_get = map2.get(key)) !== null && _map_get !== undefined ? _map_get : null;
}
var cache = createContextCache((ctx) => new Map);

// ../../node_modules/@pothos/plugin-prisma/esm/util/deep-equal.js
function deepEqual(left, right, ignore) {
  if (left === right) {
    return true;
  }
  if (left && right && typeof left === "object" && typeof right === "object") {
    var _left_valueOf, _right_valueOf;
    if (Array.isArray(left)) {
      if (!Array.isArray(right)) {
        return false;
      }
      const { length } = left;
      if (right.length !== length) {
        return false;
      }
      for (let i = 0;i < length; i += 1) {
        if (!deepEqual(left[i], right[i])) {
          return false;
        }
      }
      return true;
    }
    const lValue = (_left_valueOf = left.valueOf) === null || _left_valueOf === undefined ? undefined : _left_valueOf.call(left);
    const rValue = (_right_valueOf = right.valueOf) === null || _right_valueOf === undefined ? undefined : _right_valueOf.call(right);
    if ((lValue != null || rValue != null) && typeof lValue !== "object") {
      return lValue === rValue;
    }
    const keys = Object.keys(left);
    const keyLength = keys.length;
    if (keyLength !== Object.keys(right).length) {
      return false;
    }
    for (const key of keys) {
      if (ignore === null || ignore === undefined ? undefined : ignore.has(key)) {
        continue;
      }
      if (!deepEqual(left[key], right[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// ../../node_modules/@pothos/plugin-prisma/esm/util/selections.js
function selectionCompatible(state, selectionMap, ignoreQuery = false) {
  if (typeof selectionMap === "boolean") {
    return ignoreQuery || !selectionMap || Object.keys(state.query).length === 0;
  }
  const { select, include, ...query3 } = selectionMap;
  if (select && Object.keys(select).some((key) => compare(key, select[key]))) {
    return false;
  }
  if (include && Object.keys(include).some((key) => compare(key, include[key]))) {
    return false;
  }
  return ignoreQuery || deepEqual(state.query, query3);
  function compare(key, value) {
    if (key === "_count") {
      const selections = value && value.select;
      const keys = selections && Object.keys(selections);
      if (!keys || keys.length === 0) {
        return false;
      }
      return keys.some((k) => state.counts.has(k) && !deepEqual(state.counts.get(k), selections[k]));
    }
    return value && state.fieldMap.relations.has(key) && state.relations.has(key) && !selectionCompatible(state.relations.get(key), value);
  }
}
function createState(fieldMap, mode, parent) {
  return {
    parent,
    mode,
    fieldMap,
    query: {},
    fields: new Set,
    counts: new Map,
    relations: new Map,
    mappings: {}
  };
}
function mergeSelection(state, { select, include, ...query3 }) {
  if (state.mode === "select" && !select) {
    state.mode = "include";
  }
  if (include) {
    Object.keys(include).forEach((key) => {
      merge2(key, include[key]);
    });
  }
  if (select) {
    Object.keys(select).forEach((key) => {
      merge2(key, select[key]);
    });
  }
  if (Object.keys(query3).length > 0) {
    state.query = query3;
  }
  function merge2(key, value) {
    if (!value) {
      return;
    }
    if (key === "_count") {
      var _value_select;
      const counts = (_value_select = value.select) !== null && _value_select !== undefined ? _value_select : {};
      Object.keys(counts).forEach((count) => {
        state.counts.set(count, counts[count]);
      });
      return;
    }
    const selection = value === true ? {
      include: {}
    } : value;
    const childMap = state.fieldMap.relations.get(key);
    if (childMap) {
      if (state.relations.has(key)) {
        mergeSelection(state.relations.get(key), selection);
      } else {
        const relatedState = createState(childMap, "select");
        mergeSelection(relatedState, selection);
        state.relations.set(key, relatedState);
      }
    } else {
      state.fields.add(key);
    }
  }
}
function selectionToQuery(state) {
  const nestedIncludes = {};
  const counts = {};
  let hasSelection = false;
  state.relations.forEach((sel, relation) => {
    hasSelection = true;
    const nested = selectionToQuery(sel);
    nestedIncludes[relation] = Object.keys(nested).length > 0 ? nested : true;
  });
  if (state.counts.size > 0) {
    hasSelection = true;
    for (const [count, selection] of state.counts) {
      counts[count] = selection;
    }
    nestedIncludes._count = {
      select: counts
    };
  }
  if (state.mode === "select") {
    state.fields.forEach((field2) => {
      hasSelection = true;
      nestedIncludes[field2] = true;
    });
    return {
      ...state.query,
      select: nestedIncludes
    };
  }
  return hasSelection ? {
    ...state.query,
    include: nestedIncludes
  } : state.query;
}

// ../../node_modules/@pothos/plugin-prisma/esm/util/usage.js
function wrapWithUsageCheck(obj) {
  const result = {};
  let used = true;
  Object.defineProperty(result, usageSymbol, {
    get() {
      return used;
    },
    set(value) {
      used = value;
    },
    enumerable: false
  });
  for (const key of Object.keys(obj)) {
    used = false;
    Object.defineProperty(result, key, {
      enumerable: true,
      configurable: true,
      get() {
        used = true;
        return obj[key];
      }
    });
  }
  return result;
}
function isUsed(obj) {
  return !(usageSymbol in obj) || obj[usageSymbol];
}
function extendWithUsage(original, extension) {
  if (!(usageSymbol in original)) {
    return {
      ...original,
      ...extension
    };
  }
  const result = {
    ...extension
  };
  for (const key of [
    usageSymbol,
    ...Object.keys(original)
  ]) {
    if (key in result) {
      continue;
    }
    Object.defineProperty(result, key, {
      enumerable: key !== usageSymbol,
      configurable: key !== usageSymbol,
      get() {
        return original[key];
      }
    });
  }
  return result;
}
var usageSymbol = Symbol.for("Pothos.isUsed");

// ../../node_modules/@pothos/plugin-prisma/esm/util/map-query.js
var addTypeSelectionsForField = function(type, context, info, state, selection, indirectPath) {
  if (selection.name.value.startsWith("__")) {
    return;
  }
  var _type_extensions;
  const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_type_extensions = type.extensions) !== null && _type_extensions !== undefined ? _type_extensions : {};
  if (!!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.path) && pothosPrismaIndirectInclude.path.length > 0 || !!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.paths) && pothosPrismaIndirectInclude.paths.length === 0) {
    var _pothosPrismaIndirectInclude_paths;
    resolveIndirectIncludePaths(type, info, selection, [], (_pothosPrismaIndirectInclude_paths = pothosPrismaIndirectInclude.paths) !== null && _pothosPrismaIndirectInclude_paths !== undefined ? _pothosPrismaIndirectInclude_paths : [
      pothosPrismaIndirectInclude.path
    ], indirectPath, (resolvedType, field2, path) => {
      addTypeSelectionsForField(resolvedType, context, info, state, field2, path);
    });
  } else if (pothosPrismaIndirectInclude) {
    addTypeSelectionsForField(info.schema.getType(pothosPrismaIndirectInclude.getType()), context, info, state, selection, indirectPath);
    return;
  }
  if (!(isObjectType(type) || isInterfaceType(type))) {
    return;
  }
  if (pothosPrismaModel && !pothosPrismaSelect) {
    state.mode = "include";
  }
  if (pothosPrismaInclude !== null && pothosPrismaInclude !== undefined ? pothosPrismaInclude : pothosPrismaSelect) {
    mergeSelection(state, {
      select: pothosPrismaSelect ? {
        ...pothosPrismaSelect
      } : undefined,
      include: pothosPrismaInclude ? {
        ...pothosPrismaInclude
      } : undefined
    });
  }
  if (selection.selectionSet) {
    addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
  }
};
var resolveIndirectIncludePaths = function(type, info, selection, pathPrefix, includePaths, path, resolve) {
  for (const includePath of includePaths) {
    if (pathPrefix.length > 0) {
      resolveIndirectInclude(type, info, selection, [
        ...pathPrefix,
        ...includePath
      ], path, resolve);
    } else {
      resolveIndirectInclude(type, info, selection, includePath, path, resolve);
    }
  }
};
var resolveIndirectInclude = function(type, info, selection, includePath, path, resolve, expectedType = type) {
  if (includePath.length === 0) {
    resolve(type, selection, path);
    return;
  }
  const [include, ...rest] = includePath;
  if (!selection.selectionSet || !include) {
    return;
  }
  for (const sel of selection.selectionSet.selections) {
    switch (sel.kind) {
      case Kind.FIELD:
        if (expectedType.name === type.name && !fieldSkipped(info, sel) && sel.name.value === include.name && (isObjectType(type) || isInterfaceType(type))) {
          var _sel_alias;
          const returnType = getNamedType(type.getFields()[sel.name.value].type);
          var _sel_alias_value;
          resolveIndirectInclude(returnType, info, sel, rest, [
            ...path,
            (_sel_alias_value = (_sel_alias = sel.alias) === null || _sel_alias === undefined ? undefined : _sel_alias.value) !== null && _sel_alias_value !== undefined ? _sel_alias_value : sel.name.value
          ], resolve);
        }
        continue;
      case Kind.FRAGMENT_SPREAD:
        resolveIndirectInclude(info.schema.getType(info.fragments[sel.name.value].typeCondition.name.value), info, info.fragments[sel.name.value], includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
        continue;
      case Kind.INLINE_FRAGMENT:
        if (!sel.typeCondition || !include.type || sel.typeCondition.name.value === include.type) {
          resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
        }
        continue;
      default:
        throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
    }
  }
};
var addNestedSelections = function(type, context, info, state, selections2, indirectPath, expectedType = type) {
  let parentType = type;
  for (const selection of selections2.selections) {
    switch (selection.kind) {
      case Kind.FIELD:
        if (expectedType.name !== type.name) {
          continue;
        }
        addFieldSelection(type, context, info, state, selection, indirectPath);
        continue;
      case Kind.FRAGMENT_SPREAD:
        var _parentType_extensions;
        parentType = info.schema.getType(info.fragments[selection.name.value].typeCondition.name.value);
        addNestedSelections(parentType, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath, ((_parentType_extensions = parentType.extensions) === null || _parentType_extensions === undefined ? undefined : _parentType_extensions.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
        continue;
      case Kind.INLINE_FRAGMENT:
        var _parentType_extensions1;
        parentType = selection.typeCondition ? info.schema.getType(selection.typeCondition.name.value) : type;
        addNestedSelections(parentType, context, info, state, selection.selectionSet, indirectPath, ((_parentType_extensions1 = parentType.extensions) === null || _parentType_extensions1 === undefined ? undefined : _parentType_extensions1.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
        continue;
      default:
        throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
    }
  }
};
var addFieldSelection = function(type, context, info, state, selection, indirectPath) {
  var _field_extensions;
  if (selection.name.value.startsWith("__") || fieldSkipped(info, selection)) {
    return;
  }
  const field2 = type.getFields()[selection.name.value];
  if (!field2) {
    throw new PothosValidationError(`Unknown field ${selection.name.value} on ${type.name}`);
  }
  const fieldSelect = (_field_extensions = field2.extensions) === null || _field_extensions === undefined ? undefined : _field_extensions.pothosPrismaSelect;
  let fieldSelectionMap;
  let mappings = {};
  if (typeof fieldSelect === "function") {
    const args = getArgumentValues(field2, selection, info.variableValues);
    fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude) => {
      const returnType = getNamedType(field2.type);
      const query3 = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
      const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info)) : indirectInclude;
      const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
      if (typeof query3 === "object" && Object.keys(query3).length > 0) {
        mergeSelection(fieldState, {
          select: {},
          ...query3
        });
      }
      if (!!(normalizedIndirectInclude === null || normalizedIndirectInclude === undefined ? undefined : normalizedIndirectInclude.path) && normalizedIndirectInclude.path.length > 0 || !!(normalizedIndirectInclude === null || normalizedIndirectInclude === undefined ? undefined : normalizedIndirectInclude.paths) && normalizedIndirectInclude.paths.length > 0) {
        var _this, _returnType_extensions;
        var _path, _normalizedIndirectInclude_paths;
        resolveIndirectIncludePaths(returnType, info, selection, (_path = (_this = (_returnType_extensions = returnType.extensions) === null || _returnType_extensions === undefined ? undefined : _returnType_extensions.pothosPrismaIndirectInclude) === null || _this === undefined ? undefined : _this.path) !== null && _path !== undefined ? _path : [], (_normalizedIndirectInclude_paths = normalizedIndirectInclude.paths) !== null && _normalizedIndirectInclude_paths !== undefined ? _normalizedIndirectInclude_paths : [
          normalizedIndirectInclude.path
        ], [], (resolvedType, resolvedField, path) => {
          addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
        });
      }
      addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
      mappings = fieldState.mappings;
      return selectionToQuery(fieldState);
    }, (path) => {
      if (path.length === 0) {
        return selection;
      }
      const returnType = getNamedType(field2.type);
      let node3 = null;
      resolveIndirectInclude(returnType, info, selection, path.map((name) => ({
        name
      })), [], (_, resolvedField) => {
        node3 = resolvedField;
      });
      return node3;
    });
  } else {
    fieldSelectionMap = {
      select: fieldSelect
    };
  }
  if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
    var _selection_alias;
    mergeSelection(state, fieldSelectionMap);
    var _selection_alias_value;
    state.mappings[(_selection_alias_value = (_selection_alias = selection.alias) === null || _selection_alias === undefined ? undefined : _selection_alias.value) !== null && _selection_alias_value !== undefined ? _selection_alias_value : selection.name.value] = {
      field: selection.name.value,
      type: type.name,
      mappings,
      indirectPath
    };
  }
};
function queryFromInfo({ context, info, typeName, select, path = [], paths = [], withUsageCheck = false }) {
  const returnType = getNamedType(info.returnType);
  const type = typeName ? info.schema.getTypeMap()[typeName] : returnType;
  let state;
  const initialSelection = select ? {
    select
  } : undefined;
  if (path.length > 0 || paths.length > 0) {
    var _returnType_extensions;
    const { pothosPrismaIndirectInclude } = (_returnType_extensions = returnType.extensions) !== null && _returnType_extensions !== undefined ? _returnType_extensions : {};
    var _pothosPrismaIndirectInclude_path;
    resolveIndirectInclude(returnType, info, info.fieldNodes[0], (_pothosPrismaIndirectInclude_path = pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.path) !== null && _pothosPrismaIndirectInclude_path !== undefined ? _pothosPrismaIndirectInclude_path : [], [], (indirectType, indirectField, subPath) => {
      resolveIndirectIncludePaths(indirectType, info, indirectField, [], paths.length > 0 ? paths.map((p) => p.map((n) => typeof n === "string" ? {
        name: n
      } : n)) : [
        path.map((n) => typeof n === "string" ? {
          name: n
        } : n)
      ], subPath, (resolvedType, resolvedField, nested) => {
        state = createStateForType(typeName ? type : resolvedType, info, undefined, initialSelection);
        addTypeSelectionsForField(typeName ? type : resolvedType, context, info, state, resolvedField, nested);
      });
    });
  } else {
    state = createStateForType(type, info, undefined, initialSelection);
    addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
  }
  if (!state) {
    state = createStateForType(type, info, undefined, initialSelection);
  }
  setLoaderMappings(context, info, state.mappings);
  const query3 = selectionToQuery(state);
  return withUsageCheck ? wrapWithUsageCheck(query3) : query3;
}
function selectionStateFromInfo(context, info, typeName) {
  const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
  const state = createStateForType(type, info);
  if (!(isObjectType(type) || isInterfaceType(type))) {
    throw new PothosValidationError("Prisma plugin can only resolve includes for object and interface types");
  }
  addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
  return state;
}
var createStateForType = function(type, info, parent, initialSelections) {
  var _targetType_extensions, _targetType_extensions1;
  const targetType = getIndirectType(type, info);
  const fieldMap = (_targetType_extensions = targetType.extensions) === null || _targetType_extensions === undefined ? undefined : _targetType_extensions.pothosPrismaFieldMap;
  const state = createState(fieldMap, ((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === undefined ? undefined : _targetType_extensions1.pothosPrismaSelect) ? "select" : "include", parent);
  if (initialSelections) {
    mergeSelection(state, initialSelections);
  }
  return state;
};
function getIndirectType(type, info) {
  var _targetType_extensions;
  let targetType = type;
  while ((_targetType_extensions = targetType.extensions) === null || _targetType_extensions === undefined ? undefined : _targetType_extensions.pothosPrismaIndirectInclude) {
    var _targetType_extensions1;
    targetType = info.schema.getType(((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === undefined ? undefined : _targetType_extensions1.pothosPrismaIndirectInclude).getType());
  }
  return targetType;
}
var normalizeInclude = function(path, type) {
  let currentType = type;
  const normalized = [];
  if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
    throw new PothosValidationError(`Expected ${currentType} to be an Object type`);
  }
  for (const fieldName of path) {
    const field2 = currentType.getFields()[fieldName];
    if (!field2) {
      throw new PothosValidationError(`Expected ${currentType} to have a field ${fieldName}`);
    }
    currentType = getNamedType(field2.type);
    if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
      throw new PothosValidationError(`Expected ${currentType} to be an Object or Interface type`);
    }
    normalized.push({
      name: fieldName,
      type: currentType.name
    });
  }
  return {
    getType: () => normalized.length > 0 ? normalized[normalized.length - 1].type : type.name,
    path: normalized
  };
};
var fieldSkipped = function(info, selection) {
  const skip = getDirectiveValues(GraphQLSkipDirective, selection, info.variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return true;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, selection, info.variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return true;
  }
  return false;
};

// ../../node_modules/@pothos/plugin-prisma/esm/model-loader.js
var createResolvablePromise = function() {
  let resolveFn;
  let rejectFn;
  const promise = new Promise((resolve, reject2) => {
    resolveFn = resolve;
    rejectFn = reject2;
  });
  return {
    promise,
    resolve: resolveFn,
    reject: rejectFn
  };
};

class ModelLoader {
  static forRef(ref, modelName, findUnique, builder5) {
    return createContextCache((model) => new ModelLoader(model, builder5, modelName, findUnique === null ? () => {
      throw new PothosSchemaError(`Missing findUnique for ${ref.name}`);
    } : findUnique !== null && findUnique !== undefined ? findUnique : this.getDefaultFindUnique(ref, modelName, builder5)));
  }
  static getFindUnique(findBy) {
    if (typeof findBy === "string") {
      return (parent) => ({
        [findBy]: parent[findBy]
      });
    }
    const { fields: fields2, name: primaryKeyName } = findBy;
    return (parent) => {
      const primaryKey = {};
      for (const key of fields2) {
        primaryKey[key] = parent[key];
      }
      return {
        [primaryKeyName !== null && primaryKeyName !== undefined ? primaryKeyName : fields2.join("_")]: primaryKey
      };
    };
  }
  static getDefaultFindBy(ref, modelName, builder5) {
    const model = getModel(modelName, builder5);
    const idField = model.fields.find((field2) => field2.isId);
    const uniqueField = model.fields.find((field2) => field2.isRequired && field2.isUnique);
    const uniqueIndex = model.uniqueIndexes.find((idx) => idx.fields.every((field2) => {
      var _model_fields_find;
      return (_model_fields_find = model.fields.find((f) => f.name === field2)) === null || _model_fields_find === undefined ? undefined : _model_fields_find.isRequired;
    }));
    let findBy;
    if (model.primaryKey) {
      findBy = model.primaryKey;
    } else if (idField) {
      findBy = idField.name;
    } else if (uniqueField) {
      findBy = uniqueField.name;
    } else if (uniqueIndex) {
      findBy = uniqueIndex;
    }
    if (!findBy) {
      throw new PothosSchemaError(`Missing findUnique for ${ref.name}`);
    }
    return findBy;
  }
  static getDefaultFindUnique(ref, modelName, builder5) {
    const findBy = this.getDefaultFindBy(ref, modelName, builder5);
    return this.getFindUnique(findBy);
  }
  static getDefaultIDSelection(ref, modelName, builder5) {
    const findBy = this.getDefaultFindBy(ref, modelName, builder5);
    if (typeof findBy === "string") {
      return {
        [findBy]: true
      };
    }
    const result = {};
    for (const field2 of findBy.fields) {
      result[field2] = true;
    }
    return result;
  }
  static getCursorSelection(ref, modelName, cursor, builder5) {
    const model = getModel(modelName, builder5);
    const field2 = model.fields.find((field3) => field3.name === cursor);
    if (field2) {
      return {
        [field2.name]: true
      };
    }
    const index = [
      model.primaryKey,
      ...model.uniqueIndexes
    ].filter(Boolean).find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
    });
    if (!index) {
      throw new PothosSchemaError(`Can't find "${cursor}" field or index for ${ref.name}`);
    }
    const selection = {};
    for (const column of index.fields) {
      selection[column] = true;
    }
    return selection;
  }
  static getFindUniqueForField(ref, modelName, fieldName, builder5) {
    var _model_primaryKey, _model_primaryKey1;
    const model = getModel(modelName, builder5);
    const uniqueIndex = model.uniqueIndexes.find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
    });
    let findBy;
    var _model_primaryKey_name;
    if (model.fields.some((field2) => field2.name === fieldName)) {
      findBy = fieldName;
    } else if (model.primaryKey && ((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
      findBy = model.primaryKey;
    } else if (uniqueIndex) {
      findBy = uniqueIndex;
    }
    if (!findBy) {
      throw new PothosSchemaError(`Unable to find field or index for ${fieldName} of ${ref.name}`);
    }
    return this.getFindUnique(findBy);
  }
  getSelection(info) {
    const key = cacheKey(info.parentType.name, info.path);
    if (!this.queryCache.has(key)) {
      const selection = selectionStateFromInfo(this.context, info);
      this.queryCache.set(key, {
        selection,
        query: selectionToQuery(selection)
      });
    }
    return this.queryCache.get(key);
  }
  async loadSelection(info, model) {
    const { selection, query: query3 } = this.getSelection(info);
    const result = await this.stageQuery(selection, query3, model);
    if (result) {
      const mappings = selection.mappings[info.path.key];
      if (mappings) {
        setLoaderMappings(this.context, info, mappings.mappings);
      }
    }
    return result;
  }
  async stageQuery(selection, query3, model) {
    for (const entry of this.staged) {
      if (selectionCompatible(entry.state, query3)) {
        mergeSelection(entry.state, query3);
        if (!entry.models.has(model)) {
          entry.models.set(model, createResolvablePromise());
        }
        return entry.models.get(model).promise;
      }
    }
    return this.initLoad(selection, model);
  }
  async initLoad(state, initialModel) {
    const models = new Map;
    const promise = createResolvablePromise();
    models.set(initialModel, promise);
    const entry = {
      models,
      state
    };
    this.staged.add(entry);
    const nextTick = createResolvablePromise();
    this.tick.then(() => {
      this.staged.delete(entry);
      for (const [model, { resolve, reject: reject2 }] of entry.models) {
        if (this.delegate.findUniqueOrThrow) {
          this.delegate.findUniqueOrThrow({
            ...selectionToQuery(state),
            where: {
              ...this.findUnique(model, this.context)
            }
          }).then(resolve, reject2);
        } else {
          this.delegate.findUnique({
            rejectOnNotFound: true,
            ...selectionToQuery(state),
            where: {
              ...this.findUnique(model, this.context)
            }
          }).then(resolve, reject2);
        }
      }
    });
    setTimeout(() => void nextTick.resolve(), 0);
    this.tick = nextTick.promise;
    return promise.promise;
  }
  constructor(context, builder5, modelName, findUnique) {
    _define_property3(this, "context", undefined);
    _define_property3(this, "builder", undefined);
    _define_property3(this, "findUnique", undefined);
    _define_property3(this, "modelName", undefined);
    _define_property3(this, "queryCache", new Map);
    _define_property3(this, "staged", new Set);
    _define_property3(this, "delegate", undefined);
    _define_property3(this, "tick", Promise.resolve());
    this.context = context;
    this.builder = builder5;
    this.findUnique = findUnique;
    this.modelName = modelName;
    this.delegate = getDelegateFromModel(getClient(this.builder, this.context), this.modelName);
  }
}

// ../../node_modules/@pothos/plugin-prisma/esm/node-ref.js
class PrismaNodeRef extends PrismaObjectRef {
}

// ../../node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var _define_property4 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-prisma/esm/util/cursors.js
function formatCursorChunk(value) {
  if (value instanceof Date) {
    return `D:${String(Number(value))}`;
  }
  switch (typeof value) {
    case "number":
      return `N:${value}`;
    case "string":
      return `S:${value}`;
    case "bigint":
      return `I:${value}`;
    default:
      throw new PothosValidationError(`Unsupported cursor type ${typeof value}`);
  }
}
function cursorFormatter(fields2) {
  return (value) => {
    if (typeof fields2 === "string") {
      return encodeBase64(`GPC:${formatCursorChunk(value[fields2])}`);
    }
    return encodeBase64(`GPC:J:${JSON.stringify(fields2.map((name) => value[name]))}`);
  };
}
function parsePrismaCursor(cursor) {
  if (typeof cursor !== "string") {
    throw new PothosValidationError("Cursor must be a string");
  }
  try {
    const decoded = decodeBase64(cursor);
    const [, type, value] = decoded.match(/^GPC:(\w):(.*)/);
    switch (type) {
      case "S":
        return value;
      case "N":
        return Number.parseInt(value, 10);
      case "D":
        return new Date(Number.parseInt(value, 10));
      case "J":
        return JSON.parse(value);
      case "I":
        return BigInt(value);
      default:
        throw new PothosValidationError(`Invalid cursor type ${type}`);
    }
  } catch {
    throw new PothosValidationError(`Invalid cursor: ${cursor}`);
  }
}
function parseID(id, dataType) {
  if (!id) {
    return id;
  }
  switch (dataType) {
    case "String":
      return id;
    case "Int":
      return Number.parseInt(id, 10);
    case "BigInt":
      return BigInt(id);
    case "Boolean":
      return id !== "false";
    case "Float":
    case "Decimal":
      return Number.parseFloat(id);
    case "DateTime":
      return new Date(id);
    case "Json":
      return JSON.parse(id);
    case "Byte":
      return Buffer.from(id, "base64");
    default:
      return id;
  }
}
function getDefaultIDSerializer(modelName, fieldName, builder5) {
  var _model_primaryKey, _model_primaryKey1;
  const model = getModel(modelName, builder5);
  const field2 = model.fields.find((f) => f.name === fieldName);
  if (field2) {
    return (parent) => serializeID(parent[fieldName], field2.type);
  }
  var _model_primaryKey_name;
  if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
    const fields2 = model.primaryKey.fields.map((n) => model.fields.find((f) => f.name === n));
    return (parent) => JSON.stringify(fields2.map((f) => serializeID(parent[f.name], f.kind)));
  }
  const index = model.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
  });
  if (index) {
    const fields2 = index.fields.map((n) => model.fields.find((f) => f.name === n));
    return (parent) => JSON.stringify(fields2.map((f) => serializeID(parent[f.name], f.kind)));
  }
  throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
}
function getDefaultIDParser(modelName, fieldName, builder5) {
  var _model_primaryKey, _model_primaryKey1;
  if (!fieldName) {
    throw new PothosValidationError("Missing field name");
  }
  const model = getModel(modelName, builder5);
  const field2 = model.fields.find((f) => f.name === fieldName);
  if (field2) {
    return (id) => parseID(id, field2.type);
  }
  const index = model.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
  });
  let fields2;
  var _model_primaryKey_name;
  if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
    fields2 = model.primaryKey.fields.map((n) => model.fields.find((f) => f.name === n));
  } else if (index) {
    fields2 = index.fields.map((n) => model.fields.find((f) => f.name === n));
  }
  if (!fields2) {
    throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
  }
  return (id) => {
    const parts = JSON.parse(id);
    if (!Array.isArray(parts)) {
      throw new PothosValidationError(`Invalid id received for ${fieldName} of ${modelName}`);
    }
    const result = {};
    for (let i = 0;i < fields2.length; i += 1) {
      result[fields2[i].name] = parseID(parts[i], fields2[i].type);
    }
    return result;
  };
}
function serializeID(id, dataType) {
  switch (dataType) {
    case "Json":
      return JSON.stringify(id);
    case "Byte":
      return id.toString("base64");
    default:
      return String(id);
  }
}
function parseCompositeCursor(fields2) {
  return (cursor) => {
    const parsed = parsePrismaCursor(cursor);
    if (!Array.isArray(parsed)) {
      throw new PothosValidationError(`Expected compound cursor to contain an array, but got ${parsed}`);
    }
    const record = {};
    fields2.forEach((field2, i) => {
      record[field2] = parsed[i];
    });
    return record;
  };
}
function prismaCursorConnectionQuery({ args, ctx, maxSize = DEFAULT_MAX_SIZE, defaultSize = DEFAULT_SIZE, parseCursor }) {
  const { before, after, first, last } = args;
  if (first != null && first < 0) {
    throw new PothosValidationError("Argument \"first\" must be a non-negative integer");
  }
  if (last != null && last < 0) {
    throw new PothosValidationError("Argument \"last\" must be a non-negative integer");
  }
  if (before && after) {
    throw new PothosValidationError("Arguments \"before\" and \"after\" are not supported at the same time");
  }
  if (before != null && first != null) {
    throw new PothosValidationError("Arguments \"before\" and \"first\" are not supported at the same time");
  }
  if (after != null && last != null) {
    throw new PothosValidationError("Arguments \"after\" and \"last\" are not supported at the same time");
  }
  const cursor = before !== null && before !== undefined ? before : after;
  const maxSizeForConnection = typeof maxSize === "function" ? maxSize(args, ctx) : maxSize;
  const defaultSizeForConnection = typeof defaultSize === "function" ? defaultSize(args, ctx) : defaultSize;
  var _ref;
  let take = Math.min((_ref = first !== null && first !== undefined ? first : last) !== null && _ref !== undefined ? _ref : defaultSizeForConnection, maxSizeForConnection) + 1;
  if (before || last) {
    take = -take;
  }
  return cursor == null ? {
    take,
    skip: 0
  } : {
    cursor: parseCursor(cursor),
    take,
    skip: 1
  };
}
function wrapConnectionResult(parent, results, args, take, cursor, totalCount, resolveNode) {
  var _edges_, _edges_1;
  const gotFullResults = results.length === Math.abs(take);
  const hasNextPage = args.before ? true : args.last ? false : gotFullResults;
  const hasPreviousPage = args.after ? true : args.before || args.last ? gotFullResults : false;
  const nodes = gotFullResults ? results.slice(take < 0 ? 1 : 0, take < 0 ? results.length : -1) : results;
  const connection2 = {
    parent,
    args,
    totalCount,
    edges: [],
    pageInfo: {
      startCursor: null,
      endCursor: null,
      hasPreviousPage,
      hasNextPage
    }
  };
  const edges = nodes.map((value, index) => value == null ? null : resolveNode ? {
    connection: connection2,
    ...value,
    cursor: cursor(value),
    node: resolveNode(value)
  } : {
    connection: connection2,
    cursor: cursor(value),
    node: value
  });
  connection2.edges = edges;
  var _edges__cursor;
  connection2.pageInfo.startCursor = (_edges__cursor = (_edges_ = edges[0]) === null || _edges_ === undefined ? undefined : _edges_.cursor) !== null && _edges__cursor !== undefined ? _edges__cursor : null;
  var _edges__cursor1;
  connection2.pageInfo.endCursor = (_edges__cursor1 = (_edges_1 = edges[edges.length - 1]) === null || _edges_1 === undefined ? undefined : _edges_1.cursor) !== null && _edges__cursor1 !== undefined ? _edges__cursor1 : null;
  return connection2;
}
async function resolvePrismaCursorConnection(options, cursor, resolve) {
  const query3 = prismaCursorConnectionQuery(options);
  const results = await resolve(extendWithUsage(options.query, query3));
  if (!results) {
    return results;
  }
  return wrapConnectionResult(options.parent, results, options.args, query3.take, cursor, options.totalCount);
}
function getCursorFormatter(name, builder5, cursor) {
  var _modelData_primaryKey, _modelData_primaryKey1;
  const modelData = getModel(name, builder5);
  var _modelData_primaryKey_name;
  const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === undefined ? undefined : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== undefined ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === undefined ? undefined : _modelData_primaryKey1.fields.join("_");
  if (primaryKey === cursor) {
    return cursorFormatter(modelData.primaryKey.fields);
  }
  const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
  });
  var _uniqueIndex_fields;
  return cursorFormatter((_uniqueIndex_fields = uniqueIndex === null || uniqueIndex === undefined ? undefined : uniqueIndex.fields) !== null && _uniqueIndex_fields !== undefined ? _uniqueIndex_fields : cursor);
}
function getCursorParser(name, builder5, cursor) {
  var _modelData_primaryKey, _modelData_primaryKey1;
  const modelData = getModel(name, builder5);
  var _modelData_primaryKey_name;
  const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === undefined ? undefined : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== undefined ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === undefined ? undefined : _modelData_primaryKey1.fields.join("_");
  let parser = parsePrismaCursor;
  if (primaryKey === cursor) {
    parser = parseCompositeCursor(modelData.primaryKey.fields);
  } else {
    const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
    });
    if (uniqueIndex) {
      parser = parseCompositeCursor(uniqueIndex.fields);
    }
  }
  return (rawCursor) => ({
    [cursor]: parser(rawCursor)
  });
}
var DEFAULT_MAX_SIZE = 100;
var DEFAULT_SIZE = 20;

// ../../node_modules/@pothos/plugin-prisma/esm/util/description.js
function getFieldDescription(model, builder5, fieldName, description) {
  const { exposeDescriptions } = builder5.options.prisma;
  const usePrismaDescription = exposeDescriptions === true || typeof exposeDescriptions === "object" && (exposeDescriptions === null || exposeDescriptions === undefined ? undefined : exposeDescriptions.fields) === true;
  return (usePrismaDescription ? description !== null && description !== undefined ? description : getFieldData(model, builder5, fieldName).documentation : description) || undefined;
}
function getModelDescription(model, builder5, description) {
  const { exposeDescriptions } = builder5.options.prisma;
  const usePrismaDescription = exposeDescriptions === true || typeof exposeDescriptions === "object" && (exposeDescriptions === null || exposeDescriptions === undefined ? undefined : exposeDescriptions.models) === true;
  return (usePrismaDescription ? description !== null && description !== undefined ? description : getModel(model, builder5).documentation : description) || undefined;
}

// ../../node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var addScopes = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var withAuth = function(scopes) {
  return addScopes(scopes, new PrismaObjectFieldBuilder(this.typename, this.builder, this.model, this.prismaFieldMap));
};
var RootBuilder = RootFieldBuilder2;

class PrismaObjectFieldBuilder extends RootBuilder {
  relation(name, ...allArgs) {
    const [{ description: description2, ...options } = {}] = allArgs;
    const relationField = getRelation(this.model, this.builder, name);
    var _options_type;
    const ref = (_options_type = options.type) !== null && _options_type !== undefined ? _options_type : getRefFromModel(relationField.type, this.builder);
    const { query: query3 = {}, resolve, extensions, ...rest } = options;
    const relationSelect = (args, context, nestedQuery) => ({
      select: {
        [name]: nestedQuery(query3)
      }
    });
    return this.field({
      ...rest,
      type: relationField.isList ? [
        ref
      ] : ref,
      description: getFieldDescription(this.model, this.builder, name, description2),
      extensions: {
        ...extensions,
        pothosPrismaSelect: relationSelect,
        pothosPrismaLoaded: (value) => value[name] !== undefined,
        pothosPrismaFallback: resolve && ((q, parent, args, context, info) => resolve({
          ...q,
          ...typeof query3 === "function" ? query3(args, context) : query3
        }, parent, args, context, info))
      },
      resolve: (parent) => parent[name]
    });
  }
  relationCount(name, ...allArgs) {
    const [{ where, ...options } = {}] = allArgs;
    const { resolve, ...rest } = options;
    const countSelect = typeof where === "function" ? (args, context) => ({
      _count: {
        select: {
          [name]: {
            where: where(args, context)
          }
        }
      }
    }) : {
      _count: {
        select: {
          [name]: where ? {
            where
          } : true
        }
      }
    };
    return this.field({
      ...rest,
      type: "Int",
      nullable: false,
      select: countSelect,
      resolve: (parent, args, context, info) => {
        var _parent__count;
        return (_parent__count = parent._count) === null || _parent__count === undefined ? undefined : _parent__count[name];
      }
    });
  }
  variant(variant, ...allArgs) {
    const [{ isNull, nullable, ...options } = {}] = allArgs;
    const ref = typeof variant === "string" ? getRefFromModel(variant, this.builder) : variant;
    const selfSelect = (args, context, nestedQuery) => nestedQuery({});
    return this.field({
      ...options,
      type: ref,
      extensions: {
        ...options === null || options === undefined ? undefined : options.extensions,
        pothosPrismaSelect: selfSelect
      },
      nullable: nullable !== null && nullable !== undefined ? nullable : !!isNull,
      resolve: isNull ? (parent, args, context, info) => {
        const parentIsNull = isNull(parent, args, context, info);
        if (parentIsNull) {
          if (isThenable(parentIsNull)) {
            return parentIsNull.then((resolved) => resolved ? null : parent);
          }
          return null;
        }
        return parent;
      } : (parent) => parent
    });
  }
  expose(name, ...args) {
    var _typeConfig_extensions;
    const [options = {}] = args;
    const typeConfig = this.builder.configStore.getTypeConfig(this.typename);
    const usingSelect = !!((_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === undefined ? undefined : _typeConfig_extensions.pothosPrismaSelect);
    return this.exposeField(name, {
      ...options,
      description: getFieldDescription(this.model, this.builder, name, options.description),
      extensions: {
        ...options.extensions,
        pothosPrismaVariant: name,
        pothosPrismaSelect: usingSelect && {
          [name]: true
        }
      }
    });
  }
  createExpose(type) {
    return (name, ...args) => {
      const [options = {}] = args;
      return this.expose(name, {
        ...options,
        type
      });
    };
  }
  constructor(name, builder5, model, fieldMap, graphqlKind = "Object") {
    super(name, builder5, "PrismaObject", graphqlKind);
    _define_property4(this, "model", undefined);
    _define_property4(this, "prismaFieldMap", undefined);
    _define_property4(this, "exposeBoolean", this.createExpose("Boolean"));
    _define_property4(this, "exposeFloat", this.createExpose("Float"));
    _define_property4(this, "exposeInt", this.createExpose("Int"));
    _define_property4(this, "exposeID", this.createExpose("ID"));
    _define_property4(this, "exposeString", this.createExpose("String"));
    _define_property4(this, "exposeBooleanList", this.createExpose([
      "Boolean"
    ]));
    _define_property4(this, "exposeFloatList", this.createExpose([
      "Float"
    ]));
    _define_property4(this, "exposeIntList", this.createExpose([
      "Int"
    ]));
    _define_property4(this, "exposeIDList", this.createExpose([
      "ID"
    ]));
    _define_property4(this, "exposeStringList", this.createExpose([
      "String"
    ]));
    _define_property4(this, "withAuth", withAuth);
    _define_property4(this, "relatedConnection", function relatedConnection(name2, { maxSize, defaultSize, cursor: cursorValue, query: query3, resolve, extensions, totalCount, description: description2, ...options }, connectionOptions = {}, edgeOptions = {}) {
      const relationField = getRelation(this.model, this.builder, name2);
      var _options_type;
      const ref = (_options_type = options.type) !== null && _options_type !== undefined ? _options_type : getRefFromModel(relationField.type, this.builder);
      let typeName;
      const formatCursor = getCursorFormatter(relationField.type, this.builder, cursorValue);
      const parseCursor = getCursorParser(relationField.type, this.builder, cursorValue);
      const getQuery = (args, ctx) => {
        const connectionQuery = prismaCursorConnectionQuery({
          parseCursor,
          ctx,
          maxSize,
          defaultSize,
          args
        });
        var _ref;
        const { take = connectionQuery.take, skip = connectionQuery.skip, cursor = connectionQuery.cursor, ...fieldQuery } = (_ref = typeof query3 === "function" ? query3(args, ctx) : query3) !== null && _ref !== undefined ? _ref : {};
        return {
          ...fieldQuery,
          ...connectionQuery,
          take,
          skip,
          ...cursor ? {
            cursor
          } : {}
        };
      };
      const cursorSelection = ModelLoader.getCursorSelection(ref, relationField.type, cursorValue, this.builder);
      const relationSelect = (args, context, nestedQuery, getSelection) => {
        var _selection_selectionSet;
        typeName !== null && typeName !== undefined || (typeName = this.builder.configStore.getTypeConfig(ref).name);
        const nested = nestedQuery(getQuery(args, context), {
          getType: () => typeName,
          paths: [
            [
              {
                name: "nodes"
              }
            ],
            [
              {
                name: "edges"
              },
              {
                name: "node"
              }
            ]
          ]
        });
        const selection = getSelection([]);
        const hasTotalCount = totalCount && !!getSelection([
          "totalCount"
        ]);
        const totalCountOnly = ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && hasTotalCount;
        const countSelect = this.builder.options.prisma.filterConnectionTotalCount ? nested.where ? {
          where: nested.where
        } : true : true;
        return {
          select: {
            ...hasTotalCount ? {
              _count: {
                select: {
                  [name2]: countSelect
                }
              }
            } : {},
            [name2]: totalCountOnly ? undefined : (nested === null || nested === undefined ? undefined : nested.select) ? {
              ...nested,
              select: {
                ...cursorSelection,
                ...nested.select
              }
            } : nested
          }
        };
      };
      const fieldRef = this.connection({
        ...options,
        description: getFieldDescription(this.model, this.builder, name2, description2),
        extensions: {
          ...extensions,
          pothosPrismaSelect: relationSelect,
          pothosPrismaLoaded: (value, info) => {
            const returnType = getNamedType(info.returnType);
            const fields2 = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
            const selections3 = info.fieldNodes;
            const totalCountOnly = selections3.every((selection) => {
              var _selection_selectionSet;
              return ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && selection.selectionSet.selections.every((s) => {
                var _fields_s_name_value_extensions, _fields_s_name_value;
                return s.kind === Kind.FIELD && ((_fields_s_name_value = fields2[s.name.value]) === null || _fields_s_name_value === undefined ? undefined : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === undefined ? undefined : _fields_s_name_value_extensions.pothosPrismaTotalCount);
              });
            });
            return totalCountOnly || value[name2] !== undefined;
          },
          pothosPrismaFallback: resolve && ((q, parent, args, context, info) => Promise.resolve(resolve({
            ...q,
            ...getQuery(args, context)
          }, parent, args, context, info)).then((result) => wrapConnectionResult(parent, result, args, q.take, formatCursor)))
        },
        type: ref,
        resolve: (parent, args, context) => {
          var _parent__count;
          const connectionQuery = getQuery(args, context);
          var _parent_name;
          return wrapConnectionResult(parent, (_parent_name = parent[name2]) !== null && _parent_name !== undefined ? _parent_name : [], args, connectionQuery.take, formatCursor, (_parent__count = parent._count) === null || _parent__count === undefined ? undefined : _parent__count[name2]);
        }
      }, connectionOptions instanceof ObjectRef2 ? connectionOptions : {
        ...connectionOptions,
        fields: totalCount ? (t) => {
          var _connectionOptions_fields;
          return {
            totalCount: t.int({
              nullable: false,
              extensions: {
                pothosPrismaTotalCount: true
              },
              resolve: (parent, args, context) => parent.totalCount
            }),
            ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === undefined ? undefined : _connectionOptions_fields.call(connectionOptions, t)
          };
        } : connectionOptions.fields
      }, edgeOptions);
      return fieldRef;
    });
    this.model = model;
    this.prismaFieldMap = fieldMap;
  }
}

// ../../node_modules/@pothos/plugin-prisma/esm/util/relation-map.js
function createRelationMap({ models }) {
  const relationMap = new Map;
  if (Array.isArray(models)) {
    models.forEach((model) => {
      relationMap.set(model.name, {
        model: model.name,
        relations: new Map
      });
    });
    models.forEach((model) => {
      const map2 = relationMap.get(model.name).relations;
      model.fields.forEach((field2) => {
        if (field2.kind === "object" && relationMap.has(field2.type)) {
          map2.set(field2.name, relationMap.get(field2.type));
        }
      });
    });
  } else {
    Object.keys(models).forEach((name) => {
      relationMap.set(name, {
        model: name,
        relations: new Map
      });
    });
    Object.entries(models).forEach(([name, model]) => {
      const map2 = relationMap.get(name).relations;
      model.fields.forEach((field2) => {
        if (field2.kind === "object" && relationMap.has(field2.type)) {
          map2.set(field2.name, relationMap.get(field2.type));
        }
      });
    });
  }
  return relationMap;
}
var getRelationMap = createContextCache((datamodel5) => createRelationMap(datamodel5));

// ../../node_modules/@pothos/plugin-prisma/esm/schema-builder.js
var schemaBuilderProto2 = esm_default.prototype;
schemaBuilderProto2.prismaObject = function prismaObject(type, { fields: fields2, findUnique, select, include, description: description3, ...options }) {
  const ref = options.variant ? new PrismaObjectRef(options.variant, type) : getRefFromModel(type, this);
  var _options_variant, _ref;
  const name = (_ref = (_options_variant = options.variant) !== null && _options_variant !== undefined ? _options_variant : options.name) !== null && _ref !== undefined ? _ref : type;
  const fieldMap = getRelationMap(getDMMF(this)).get(type);
  const idSelection = ModelLoader.getDefaultIDSelection(ref, type, this);
  ref.name = name;
  this.objectType(ref, {
    ...options,
    description: getModelDescription(type, this, description3),
    extensions: {
      ...options.extensions,
      pothosPrismaInclude: include,
      pothosPrismaModel: type,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: select && {
        ...idSelection,
        ...select
      },
      pothosPrismaLoader: ModelLoader.forRef(ref, type, findUnique, this)
    },
    name,
    fields: fields2 ? () => fields2(new PrismaObjectFieldBuilder(name, this, type, getRelationMap(getDMMF(this)).get(type))) : undefined
  });
  return ref;
};
schemaBuilderProto2.prismaInterface = function prismaInterface(type, { fields: fields2, findUnique, select, include, description: description3, ...options }) {
  const ref = options.variant ? new PrismaInterfaceRef(options.variant, type) : getRefFromModel(type, this, "interface");
  var _options_variant, _ref;
  const name = (_ref = (_options_variant = options.variant) !== null && _options_variant !== undefined ? _options_variant : options.name) !== null && _ref !== undefined ? _ref : type;
  const fieldMap = getRelationMap(getDMMF(this)).get(type);
  const idSelection = ModelLoader.getDefaultIDSelection(ref, type, this);
  ref.name = name;
  this.interfaceType(ref, {
    ...options,
    description: getModelDescription(type, this, description3),
    extensions: {
      ...options.extensions,
      pothosPrismaInclude: include,
      pothosPrismaModel: type,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: select && {
        ...idSelection,
        ...select
      },
      pothosPrismaLoader: ModelLoader.forRef(ref, type, findUnique, this)
    },
    name,
    fields: fields2 ? () => fields2(new PrismaObjectFieldBuilder(name, this, type, getRelationMap(getDMMF(this)).get(type), "Interface")) : undefined
  });
  return ref;
};
schemaBuilderProto2.prismaNode = function prismaNode(type, { id: { field: field2, resolve: rawResolve, ...idOptions }, findUnique: rawFindUnique, name, variant, nullable, ...options }) {
  var _this_nodeInterfaceRef, _this;
  const fieldName = field2;
  const interfaceRef = (_this_nodeInterfaceRef = (_this = this).nodeInterfaceRef) === null || _this_nodeInterfaceRef === undefined ? undefined : _this_nodeInterfaceRef.call(_this);
  const resolve = rawResolve !== null && rawResolve !== undefined ? rawResolve : getDefaultIDSerializer(type, fieldName, this);
  const idParser = fieldName ? getDefaultIDParser(type, fieldName, this) : undefined;
  var _ref;
  const typeName = (_ref = variant !== null && variant !== undefined ? variant : name) !== null && _ref !== undefined ? _ref : type;
  const nodeRef = new PrismaNodeRef(typeName, type);
  const findUnique = rawFindUnique ? (parent, context) => rawFindUnique(resolve(parent, context), context) : ModelLoader.getFindUniqueForField(nodeRef, type, fieldName, this);
  if (!interfaceRef) {
    throw new PothosError("builder.prismaNode requires @pothos/plugin-relay to be installed");
  }
  const extendedOptions = {
    ...options,
    name,
    variant,
    interfaces: [
      interfaceRef
    ],
    findUnique,
    loadWithoutCache: async (id, context, info) => {
      const query3 = queryFromInfo({
        context,
        info,
        typeName
      });
      const delegate = getDelegateFromModel(getClient(this, context), type);
      const record = await (delegate.findUniqueOrThrow && !nullable ? delegate.findUniqueOrThrow({
        ...query3,
        where: rawFindUnique ? rawFindUnique(id, context) : {
          [fieldName]: idParser(id)
        }
      }) : delegate.findUnique({
        ...query3,
        ...nullable ? {} : {
          rejectOnNotFound: true
        },
        where: rawFindUnique ? rawFindUnique(id, context) : {
          [fieldName]: idParser(id)
        }
      }));
      brandWithType(record, typeName);
      return record;
    }
  };
  const ref = this.prismaObject(type, extendedOptions);
  if (options.interfaces) {
    this.configStore.addInterfaces(typeName, options.interfaces);
  }
  this.configStore.onTypeConfig(ref, (nodeConfig) => {
    var _this_options_relayOptions;
    var _this_options_relayOptions_idFieldName;
    this.objectField(ref, (_this_options_relayOptions_idFieldName = (_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === undefined ? undefined : _this_options_relayOptions.idFieldName) !== null && _this_options_relayOptions_idFieldName !== undefined ? _this_options_relayOptions_idFieldName : "id", (t) => {
      var _this_options_relayOptions2;
      return t.globalID({
        ...(_this_options_relayOptions2 = this.options.relayOptions) === null || _this_options_relayOptions2 === undefined ? undefined : _this_options_relayOptions2.idFieldOptions,
        ...idOptions,
        nullable: false,
        args: {},
        resolve: (parent, args, context, info) => completeValue2(resolve(parent, context), (id) => ({
          type: nodeConfig.name,
          id
        }))
      });
    });
  });
  this.configStore.associateRefWithName(nodeRef, typeName);
  return nodeRef;
};
schemaBuilderProto2.prismaObjectField = function prismaObjectField(type, fieldName, field2) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => ({
      [fieldName]: field2(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName)))
    }));
  });
};
schemaBuilderProto2.prismaInterfaceField = function prismaInterfaceField(type, fieldName, field2) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => ({
      [fieldName]: field2(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName), "Interface"))
    }));
  });
};
schemaBuilderProto2.prismaObjectFields = function prismaObjectFields(type, fields2) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => fields2(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName))));
  });
};
schemaBuilderProto2.prismaInterfaceFields = function prismaInterfaceFields(type, fields2) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => fields2(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName), "Interface")));
  });
};

// ../../node_modules/@pothos/plugin-prisma/esm/field-builder.js
var checkIfQueryIsUsed = function(builder5, query3, info, result) {
  const { onUnusedQuery } = builder5.options.prisma || {};
  if (!onUnusedQuery) {
    return result;
  }
  if (isThenable(result)) {
    return result.then((resolved) => {
      if (!isUsed(query3)) {
        onUnused();
      }
      return resolved;
    });
  }
  if (!isUsed(query3)) {
    onUnused();
  }
  return result;
  function onUnused() {
    if (typeof onUnusedQuery === "function") {
      onUnusedQuery(info);
      return;
    }
    const message = `Prisma query was unused in resolver for ${info.parentType.name}.${info.fieldName}`;
    if (onUnusedQuery === "error") {
      throw new PothosError(message);
    } else if (onUnusedQuery === "warn") {
      console.warn(message);
    }
  }
};
var fieldBuilderProto2 = RootFieldBuilder2.prototype;
fieldBuilderProto2.prismaField = function prismaField({ type, resolve, ...options }) {
  const modelOrRef = Array.isArray(type) ? type[0] : type;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type) ? [
    typeRef
  ] : typeRef;
  return this.field({
    ...options,
    type: typeParam,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      return checkIfQueryIsUsed(this.builder, query3, info, resolve(query3, parent, args, context, info));
    }
  });
};
fieldBuilderProto2.prismaFieldWithInput = function prismaFieldWithInput({ type, resolve, ...options }) {
  const modelOrRef = Array.isArray(type) ? type[0] : type;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type) ? [
    typeRef
  ] : typeRef;
  return this.fieldWithInput({
    ...options,
    type: typeParam,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      return checkIfQueryIsUsed(this.builder, query3, info, resolve(query3, parent, args, context, info));
    }
  });
};
fieldBuilderProto2.prismaConnection = function prismaConnection({ type, cursor, maxSize, defaultSize, resolve, totalCount, ...options }, connectionOptions = {}, edgeOptions = {}) {
  var _this_builder_configStore_getTypeConfig_extensions;
  const ref = typeof type === "string" ? getRefFromModel(type, this.builder) : type;
  const typeName = this.builder.configStore.getTypeConfig(ref).name;
  const model = (_this_builder_configStore_getTypeConfig_extensions = this.builder.configStore.getTypeConfig(ref).extensions) === null || _this_builder_configStore_getTypeConfig_extensions === undefined ? undefined : _this_builder_configStore_getTypeConfig_extensions.pothosPrismaModel;
  const formatCursor = getCursorFormatter(model, this.builder, cursor);
  const parseCursor = getCursorParser(model, this.builder, cursor);
  const cursorSelection = ModelLoader.getCursorSelection(ref, model, cursor, this.builder);
  const fieldRef = this.connection({
    ...options,
    type: ref,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        select: cursorSelection,
        paths: [
          [
            "nodes"
          ],
          [
            "edges",
            "node"
          ]
        ],
        typeName,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      const returnType = getNamedType(info.returnType);
      const fields2 = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
      const selections3 = info.fieldNodes;
      const totalCountOnly = selections3.every((selection) => {
        var _selection_selectionSet;
        return ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && selection.selectionSet.selections.every((s) => {
          var _fields_s_name_value_extensions, _fields_s_name_value;
          return s.kind === Kind.FIELD && ((_fields_s_name_value = fields2[s.name.value]) === null || _fields_s_name_value === undefined ? undefined : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === undefined ? undefined : _fields_s_name_value_extensions.pothosPrismaTotalCount);
        });
      });
      return resolvePrismaCursorConnection({
        parent,
        query: query3,
        ctx: context,
        parseCursor,
        maxSize,
        defaultSize,
        args,
        totalCount: totalCount && (() => totalCount(parent, args, context, info))
      }, formatCursor, (q) => {
        if (totalCountOnly)
          return [];
        return checkIfQueryIsUsed(this.builder, query3, info, resolve(q, parent, args, context, info));
      });
    }
  }, connectionOptions instanceof ObjectRef2 ? connectionOptions : {
    ...connectionOptions,
    fields: totalCount ? (t) => {
      var _connectionOptions_fields;
      return {
        totalCount: t.int({
          nullable: false,
          extensions: {
            pothosPrismaTotalCount: true
          },
          resolve: (parent, args, context) => {
            var _parent_totalCount;
            return (_parent_totalCount = parent.totalCount) === null || _parent_totalCount === undefined ? undefined : _parent_totalCount.call(parent);
          }
        }),
        ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === undefined ? undefined : _connectionOptions_fields.call(connectionOptions, t)
      };
    } : connectionOptions.fields,
    extensions: {
      ...connectionOptions === null || connectionOptions === undefined ? undefined : connectionOptions.extensions
    }
  }, edgeOptions);
  return fieldRef;
};

// ../../node_modules/@pothos/plugin-prisma/esm/connection-helpers.js
var prismaModelKey2 = Symbol.for("Pothos.prismaModelKey");
// ../../node_modules/@pothos/plugin-prisma/esm/types.js
var prismaModelName = Symbol.for("Pothos.prismaModelName");

// ../../node_modules/@pothos/plugin-prisma/esm/index.js
var pluginName2 = "prisma";
var esm_default3 = pluginName2;
class PrismaPlugin extends BasePlugin {
  onTypeConfig(typeConfig) {
    var _typeConfig_extensions;
    if (typeConfig.kind !== "Object" && typeConfig.kind !== "Interface") {
      return typeConfig;
    }
    let model = (_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === undefined ? undefined : _typeConfig_extensions.pothosPrismaModel;
    typeConfig.interfaces.forEach((iface) => {
      var _this_buildCache_getTypeConfig_extensions;
      const interfaceModel = (_this_buildCache_getTypeConfig_extensions = this.buildCache.getTypeConfig(iface, "Interface").extensions) === null || _this_buildCache_getTypeConfig_extensions === undefined ? undefined : _this_buildCache_getTypeConfig_extensions.pothosPrismaModel;
      if (interfaceModel) {
        if (model && model !== interfaceModel) {
          throw new PothosSchemaError(`PrismaObjects must be based on the same prisma model as any PrismaInterfaces they extend. ${typeConfig.name} uses ${model} and ${iface.name} uses ${interfaceModel}`);
        }
        model = interfaceModel;
      }
    });
    return {
      ...typeConfig,
      extensions: {
        ...typeConfig.extensions,
        pothosPrismaModel: model
      }
    };
  }
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "PrismaObject" && fieldConfig.pothosOptions.select) {
      const { select } = fieldConfig.pothosOptions;
      return {
        ...fieldConfig,
        extensions: {
          ...fieldConfig.extensions,
          pothosPrismaSelect: typeof select === "function" ? (args, ctx, nestedQuery) => ({
            select: select(args, ctx, nestedQuery)
          }) : select
        }
      };
    }
    return fieldConfig;
  }
  wrapResolve(resolver, fieldConfig) {
    var _fieldConfig_extensions, _fieldConfig_extensions1, _parentConfig_extensions, _fieldConfig_extensions2;
    if (fieldConfig.kind !== "PrismaObject" || !((_fieldConfig_extensions = fieldConfig.extensions) === null || _fieldConfig_extensions === undefined ? undefined : _fieldConfig_extensions.pothosPrismaSelect)) {
      return resolver;
    }
    const parentConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    const loadedCheck = (_fieldConfig_extensions1 = fieldConfig.extensions) === null || _fieldConfig_extensions1 === undefined ? undefined : _fieldConfig_extensions1.pothosPrismaLoaded;
    const loaderCache = (_parentConfig_extensions = parentConfig.extensions) === null || _parentConfig_extensions === undefined ? undefined : _parentConfig_extensions.pothosPrismaLoader;
    const fallback = (_fieldConfig_extensions2 = fieldConfig.extensions) === null || _fieldConfig_extensions2 === undefined ? undefined : _fieldConfig_extensions2.pothosPrismaFallback;
    const parentTypes = new Set([
      fieldConfig.parentType
    ]);
    if (parentConfig.kind === "Interface" || parentConfig.kind === "Object") {
      parentConfig.interfaces.forEach((iface) => {
        var _interfaceConfig_extensions;
        const interfaceConfig = this.buildCache.getTypeConfig(iface, "Interface");
        if ((_interfaceConfig_extensions = interfaceConfig.extensions) === null || _interfaceConfig_extensions === undefined ? undefined : _interfaceConfig_extensions.pothosPrismaModel) {
          parentTypes.add(interfaceConfig.name);
        }
      });
    }
    return (parent, args, context, info) => {
      let mapping = getLoaderMapping(context, info.path, info.parentType.name);
      if (!mapping) {
        for (const parentType of parentTypes) {
          mapping = getLoaderMapping(context, info.path, parentType);
          if (mapping) {
            break;
          }
        }
      }
      if ((!loadedCheck || loadedCheck(parent, info)) && mapping) {
        setLoaderMappings(context, info, mapping);
        return resolver(parent, args, context, info);
      }
      if (fallback) {
        return fallback(queryFromInfo({
          context,
          info
        }), parent, args, context, info);
      }
      return loaderCache(context).loadSelection(info, parent).then((result) => resolver(result, args, context, info));
    };
  }
  constructor(cache2) {
    super(cache2, pluginName2);
  }
}
esm_default.registerPlugin(pluginName2, PrismaPlugin);

// ../../node_modules/@pothos/plugin-prisma-utils/esm/schema-builder.js
var nameFromType = function(type, builder5) {
  if (typeof type === "string") {
    return type;
  }
  if (builder5.configStore.hasConfig(type)) {
    return builder5.configStore.getTypeConfig(type).name;
  }
  if (typeof type === "function" && "name" in type) {
    return type.name;
  }
  if (type instanceof BaseTypeRef2) {
    return type.name;
  }
  throw new PothosSchemaError(`Unable to determine name for type ${String(type)}`);
};
var capitalize2 = function(str) {
  return str[0].toUpperCase() + str.slice(1);
};
var schemaBuilder = esm_default.prototype;
var OrderByRefMap = new WeakMap;
var PrismaStringFilterModeRefMap = new WeakMap;
schemaBuilder.prismaFilter = function prismaFilter(type, { ops, name, ...options }) {
  const filterName = name !== null && name !== undefined ? name : `${nameFromType(type, this)}Filter`;
  const ref = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map2, op) => {
    map2[op] = {};
    return map2;
  }, {}) : ops;
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fields2 = {};
      for (const op of Object.keys(opsOptions)) {
        const isList = op === "in" || op === "notIn";
        let fieldType;
        switch (op) {
          case "not":
            fieldType = ref;
            break;
          case "in":
          case "notIn":
            fieldType = [
              type
            ];
            break;
          case "mode":
            fieldType = this.prismaStringFilterModeEnum();
            break;
          default:
            fieldType = type;
        }
        fields2[op] = t.field({
          required: isList ? {
            list: false,
            items: true
          } : false,
          type: fieldType,
          ...opsOptions[op]
        });
      }
      return fields2;
    }
  });
  return ref;
};
schemaBuilder.prismaStringFilterModeEnum = function prismaStringFilterModeEnum() {
  if (PrismaStringFilterModeRefMap.has(this)) {
    return PrismaStringFilterModeRefMap.get(this);
  }
  const ref = this.enumType("StringFilterMode", {
    values: {
      Default: {
        value: "default"
      },
      Insensitive: {
        value: "insensitive"
      }
    }
  });
  PrismaStringFilterModeRefMap.set(this, ref);
  return ref;
};
schemaBuilder.prismaListFilter = function prismaListFilter(type, { name, ops, ...options }) {
  let filterName = name;
  if (!filterName) {
    const typeName = nameFromType(type, this);
    filterName = typeName.endsWith("Filter") ? typeName.replace(/Filter$/, "ListFilter") : `List${typeName}`;
  }
  const ref = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map2, op) => {
    map2[op] = {};
    return map2;
  }, {}) : ops;
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fields2 = {};
      for (const op of Object.keys(opsOptions)) {
        fields2[op] = t.field({
          required: false,
          type,
          ...opsOptions[op]
        });
      }
      return fields2;
    }
  });
  return ref;
};
schemaBuilder.prismaScalarListFilter = function prismaScalarListFilter(type, { name, ops, ...options }) {
  let filterName = name;
  if (!filterName) {
    const typeName = nameFromType(type, this);
    filterName = `${typeName}ListFilter`;
  }
  const ref = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map2, op) => {
    map2[op] = {};
    return map2;
  }, {}) : ops;
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fields2 = {};
      for (const op of Object.keys(opsOptions)) {
        let fieldType = type;
        switch (op) {
          case "has":
            fieldType = type;
            break;
          case "equals":
          case "hasSome":
          case "hasEvery":
            fieldType = [
              type
            ];
            break;
          case "isEmpty":
            fieldType = "Boolean";
            break;
          default:
            throw new Error(`Invalid op ${op} for scalar list filter`);
        }
        fields2[op] = t.field({
          required: false,
          type: fieldType,
          ...opsOptions[op]
        });
      }
      return fields2;
    }
  });
  return ref;
};
schemaBuilder.orderByEnum = function orderByEnum() {
  if (OrderByRefMap.has(this)) {
    return OrderByRefMap.get(this);
  }
  const ref = this.enumType("OrderBy", {
    values: {
      Asc: {
        value: "asc"
      },
      Desc: {
        value: "desc"
      }
    }
  });
  OrderByRefMap.set(this, ref);
  return ref;
};
schemaBuilder.prismaOrderBy = function prismaOrderBy(type, { name, fields: fields2, ...options }) {
  const filterName = name !== null && name !== undefined ? name : `${nameFromType(type, this)}OrderBy`;
  const ref = this.inputRef(filterName);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2() : fields2;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (typeof fieldOption === "function") {
          const { type: fieldType, ...fieldOptions } = fieldOption();
          fieldDefs[field2] = t.field({
            required: false,
            ...fieldOptions,
            type: fieldType
          });
        } else if (typeof fieldOption === "boolean") {
          fieldDefs[field2] = t.field({
            required: false,
            type: this.orderByEnum()
          });
        } else {
          fieldDefs[field2] = t.field({
            required: false,
            type: fieldOption
          });
        }
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaWhere = function prismaWhere(type, { name, fields: fields2, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}Filter`);
  const model = getModel(type, this);
  const nullableFields = new Set(model.fields.filter((field2) => !field2.isRequired).map((field2) => field2.name));
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: {
        nullableFields
      }
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2(t) : fields2;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        if (field2 === "AND" || field2 === "OR" || field2 === "NOT") {
          fieldDefs[field2] = t.field({
            required: false,
            type: field2 === "NOT" ? ref : [
              ref
            ],
            ...typeof fieldOption === "object" ? fieldOption : {}
          });
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaWhereUnique = function prismaWhereUnique(type, { name, fields: fields2, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}UniqueFilter`);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2(t) : fields2;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaCreate = function prismaCreate(type, { name, fields: fields2, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}CreateInput`);
  const model = getModel(type, this);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2(t) : fields2;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldModel = model.fields.find(({ name: fieldName }) => fieldName === field2);
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: fieldModel.isRequired && !fieldModel.isList && !fieldModel.hasDefaultValue && !fieldModel.isUpdatedAt,
          type: fieldModel.isList && fieldModel.kind !== "object" ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaUpdate = function prismaUpdate(type, { name, fields: fields2, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}UpdateInput`);
  const model = getModel(type, this);
  const nullableFields = new Set(model.fields.filter((field2) => !field2.isRequired).map((field2) => field2.name));
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: {
        nullableFields
      }
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2(t) : fields2;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldModel = model.fields.find(({ name: fieldName }) => fieldName === field2);
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldModel.isList && fieldModel.kind !== "object" ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaCreateRelation = function prismaCreateRelation(type, relation, { name, fields: fields2, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}Create${capitalize2(relation)}RelationInput`);
  const model = getModel(type, this);
  const fieldModel = model.fields.find((field2) => field2.name === relation);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2(t) : fields2;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldModel.isList ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaUpdateRelation = function prismaUpdateRelation(type, relation, { name, fields: fields2, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}Update${capitalize2(relation)}RelationInput`);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields2 === "function" ? fields2(t) : fields2;
      const model = getModel(type, this);
      const fieldModel = model.fields.find((field2) => field2.name === relation);
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        if (fieldOption instanceof InputFieldRef) {
          fieldDefs[field2] = fieldOption;
        } else if (fieldModel.isList && (field2 === "update" || field2 === "updateMany")) {
          const { name: nestedName = `${ref.name}U${field2.slice(1)}`, where: whereType, data: dataType } = fieldOption;
          const nestedRef = this.inputType(nestedName, {
            fields: (t2) => ({
              where: whereType instanceof InputFieldRef ? whereType : t2.field({
                type: whereType
              }),
              data: dataType instanceof InputFieldRef ? dataType : t2.field({
                type: dataType
              })
            })
          });
          fieldDefs[field2] = t.field({
            required: false,
            type: [
              nestedRef
            ]
          });
        } else {
          fieldDefs[field2] = t.field({
            required: false,
            type: fieldModel.isList ? [
              fieldOption
            ] : fieldOption
          });
        }
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaIntAtomicUpdate = function prismaIntUpdateOperations({ name, ops = [
  "set",
  "increment",
  "decrement",
  "multiply",
  "divide"
], ...options } = {}) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : "IntAtomicUpdate");
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      ops.forEach((op) => {
        fieldDefs[op] = t.field({
          required: false,
          type: "Int"
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};

// ../../node_modules/@pothos/plugin-prisma-utils/esm/index.js
var normalizeInputObject = function(object5, nullableFields) {
  if (!object5) {
    return object5;
  }
  if (typeof object5 !== "object") {
    return object5;
  }
  if (Array.isArray(object5)) {
    return object5.map((o) => normalizeInputObject(o, nullableFields));
  }
  const mapped = {};
  Object.keys(object5).forEach((key) => {
    mapped[key] = !nullableFields.has(key) && object5[key] === null ? undefined : object5[key];
  });
  return mapped;
};
var pluginName3 = "prismaUtils";
var esm_default4 = pluginName3;

class PrismaUtilsPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var _inputType_extensions;
      const inputType = this.buildCache.getTypeConfig(unwrapInputFieldType(inputField.type));
      if ((_inputType_extensions = inputType.extensions) === null || _inputType_extensions === undefined ? undefined : _inputType_extensions.pothosPrismaInput) {
        var _inputType_extensions1, _inputType_extensions2;
        return typeof ((_inputType_extensions1 = inputType.extensions) === null || _inputType_extensions1 === undefined ? undefined : _inputType_extensions1.pothosPrismaInput) === "object" ? (_inputType_extensions2 = inputType.extensions) === null || _inputType_extensions2 === undefined ? undefined : _inputType_extensions2.pothosPrismaInput : {
          nullableFields: new Set
        };
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    var _mapping_value_nullableFields;
    const argMapper = createInputValueMapper(argMappings, (inputObject, mapping) => {
      var _mapping_value;
      return normalizeInputObject(inputObject, (_mapping_value_nullableFields = (_mapping_value = mapping.value) === null || _mapping_value === undefined ? undefined : _mapping_value.nullableFields) !== null && _mapping_value_nullableFields !== undefined ? _mapping_value_nullableFields : new Set);
    });
    return (parent, args, context, info) => resolver(parent, argMapper(args), context, info);
  }
  constructor(cache2) {
    super(cache2, pluginName3);
  }
}
esm_default.registerPlugin(pluginName3, PrismaUtilsPlugin);

// ../../node_modules/@pothos/plugin-with-input/esm/schema-builder.js
var capitalize3 = function(s) {
  return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
};
var rootBuilderProto = RootFieldBuilder2.prototype;
rootBuilderProto.fieldWithInput = function fieldWithInput({ typeOptions: { name: typeName, ...typeOptions } = {}, argOptions: { name: argName = "input", ...argOptions } = {}, args, input: input6, ...fieldOptions }) {
  var ref;
  const inputRef = this.builder.inputRef(typeName !== null && typeName !== undefined ? typeName : `UnnamedWithInputOn${this.typename}`);
  const fieldRef = this.field({
    args: {
      ...args,
      [argName]: this.arg({
        required: true,
        ...(ref = this.builder.options.withInput) === null || ref === undefined ? undefined : ref.argOptions,
        ...argOptions,
        type: inputRef
      })
    },
    ...fieldOptions
  });
  this.builder.configStore.onFieldUse(fieldRef, (config) => {
    var ref2;
    const name = typeName !== null && typeName !== undefined ? typeName : `${this.typename}${capitalize3(config.name)}Input`;
    this.builder.inputType(name, {
      fields: () => input6,
      ...(ref2 = this.builder.options.withInput) === null || ref2 === undefined ? undefined : ref2.typeOptions,
      ...typeOptions
    });
    this.builder.configStore.associateRefWithName(inputRef, name);
  });
  return fieldRef;
};
Object.defineProperty(rootBuilderProto, "input", {
  get: function getInputBuilder() {
    return new InputFieldBuilder2(this.builder, "InputObject", `UnnamedWithInputOn${this.typename}`);
  }
});

// ../../node_modules/@pothos/plugin-with-input/esm/index.js
var pluginName4 = "withInput";
var esm_default5 = pluginName4;

class PothosWithInputPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName4, PothosWithInputPlugin);

// ../../node_modules/graphql-scalars/index.mjs
var _validateInt = function(value) {
  if (!Number.isFinite(value)) {
    throw new TypeError(`Value is not a finite number: ${value}`);
  }
  if (!Number.isInteger(value)) {
    throw new TypeError(`Value is not an integer: ${value}`);
  }
  if (!Number.isSafeInteger(value)) {
    throw new TypeError(`Value is not a safe integer: ${value}`);
  }
};
var _validateFloat = function(value) {
  if (!Number.isFinite(value)) {
    throw new TypeError(`Value is not a finite number: ${value}`);
  }
};
var processValue = function(value, scalarName) {
  const VALIDATIONS = {
    NonPositiveInt: {
      range: VALUE_RANGES.NON_POSITIVE,
      type: VALUE_TYPES.INT
    },
    PositiveInt: {
      range: VALUE_RANGES.POSITIVE,
      type: VALUE_TYPES.INT
    },
    NonNegativeInt: {
      range: VALUE_RANGES.NON_NEGATIVE,
      type: VALUE_TYPES.INT
    },
    NegativeInt: {
      range: VALUE_RANGES.NEGATIVE,
      type: VALUE_TYPES.INT
    },
    NonPositiveFloat: {
      range: VALUE_RANGES.NON_POSITIVE,
      type: VALUE_TYPES.FLOAT
    },
    PositiveFloat: {
      range: VALUE_RANGES.POSITIVE,
      type: VALUE_TYPES.FLOAT
    },
    NonNegativeFloat: {
      range: VALUE_RANGES.NON_NEGATIVE,
      type: VALUE_TYPES.FLOAT
    },
    NegativeFloat: {
      range: VALUE_RANGES.NEGATIVE,
      type: VALUE_TYPES.FLOAT
    }
  };
  const { range, type } = VALIDATIONS[scalarName];
  if (value === null || typeof value === "undefined" || isNaN(value) || Number.isNaN(value) || value === Number.NaN) {
    throw new TypeError(`Value is not a number: ${value}`);
  }
  let parsedValue;
  switch (type) {
    case VALUE_TYPES.FLOAT:
      parsedValue = parseFloat(value);
      _validateFloat(parsedValue);
      break;
    case VALUE_TYPES.INT:
      parsedValue = parseInt(value, 10);
      _validateInt(parsedValue);
      break;
  }
  if (range === VALUE_RANGES.NEGATIVE && !(parsedValue < 0) || range === VALUE_RANGES.NON_NEGATIVE && !(parsedValue >= 0) || range === VALUE_RANGES.POSITIVE && !(parsedValue > 0) || range === VALUE_RANGES.NON_POSITIVE && !(parsedValue <= 0)) {
    throw new TypeError(`Value is not a ${VALUE_RANGES[range].toLowerCase().replace("_", "-")} number: ${value}`);
  }
  return parsedValue;
};
var identity = function(value) {
  return value;
};
var ensureObject = function(value) {
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw new TypeError(`JSONObject cannot represent non-object value: ${value}`);
  }
  return value;
};
var parseObject$1 = function(ast8, variables) {
  const value = Object.create(null);
  ast8.fields.forEach((field2) => {
    value[field2.name.value] = parseLiteral(field2.value, variables);
  });
  return value;
};
var parseLiteral = function(ast8, variables) {
  switch (ast8.kind) {
    case Kind.STRING:
    case Kind.BOOLEAN:
      return ast8.value;
    case Kind.INT:
    case Kind.FLOAT:
      return parseFloat(ast8.value);
    case Kind.OBJECT:
      return parseObject$1(ast8, variables);
    case Kind.LIST:
      return ast8.values.map((n) => parseLiteral(n, variables));
    case Kind.NULL:
      return null;
    case Kind.VARIABLE: {
      const name = ast8.name.value;
      return variables ? variables[name] : undefined;
    }
  }
};
var leapYear = (year) => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var validateTime = (time) => {
  time = time === null || time === undefined ? undefined : time.toUpperCase();
  const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  return TIME_REGEX.test(time);
};
var validateDate = (datestring) => {
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;
  if (!RFC_3339_REGEX.test(datestring)) {
    return false;
  }
  const year = Number(datestring.substr(0, 4));
  const month = Number(datestring.substr(5, 2));
  const day2 = Number(datestring.substr(8, 2));
  switch (month) {
    case 2:
      if (leapYear(year) && day2 > 29) {
        return false;
      } else if (!leapYear(year) && day2 > 28) {
        return false;
      }
      return true;
    case 4:
    case 6:
    case 9:
    case 11:
      if (day2 > 30) {
        return false;
      }
      break;
  }
  return true;
};
var validateDateTime = (dateTimeString) => {
  dateTimeString = dateTimeString === null || dateTimeString === undefined ? undefined : dateTimeString.toUpperCase();
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  if (!RFC_3339_REGEX.test(dateTimeString)) {
    return false;
  }
  const time = Date.parse(dateTimeString);
  if (time !== time) {
    return false;
  }
  const index = dateTimeString.indexOf("T");
  const dateString = dateTimeString.substr(0, index);
  const timeString = dateTimeString.substr(index + 1);
  return validateDate(dateString) && validateTime(timeString);
};
var validateJSDate = (date) => {
  const time = date.getTime();
  return time === time;
};
var parseDate = (date) => {
  return new Date(date);
};
var serializeDate = (date) => {
  return date.toISOString().split("T")[0];
};
var parseDateTime = (dateTime) => {
  return new Date(dateTime);
};
var GraphQLDateConfig = {
  name: "Date",
  description: "A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return serializeDate(value);
      }
      throw new TypeError("Date cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDate(value)) {
        return value;
      }
      throw new TypeError(`Date cannot represent an invalid date-string ${value}.`);
    } else {
      throw new TypeError("Date cannot represent a non string, or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (!(typeof value === "string")) {
      throw new TypeError(`Date cannot represent non string type ${JSON.stringify(value)}`);
    }
    if (validateDate(value)) {
      return parseDate(value);
    }
    throw new TypeError(`Date cannot represent an invalid date-string ${value}.`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw new TypeError(`Date cannot represent non string type ${"value" in ast8 && ast8.value}`);
    }
    const { value } = ast8;
    if (validateDate(value)) {
      return parseDate(value);
    }
    throw new TypeError(`Date cannot represent an invalid date-string ${String(value)}.`);
  },
  extensions: {
    codegenScalarType: "Date | string"
  }
};
var GraphQLDate = new GraphQLScalarType(GraphQLDateConfig);
var GraphQLDateTimeConfig = {
  name: "DateTime",
  description: "A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw new TypeError("DateTime cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw new TypeError(`DateTime cannot represent an invalid date-time-string ${value}.`);
    } else if (typeof value === "number") {
      try {
        return new Date(value);
      } catch (e) {
        throw new TypeError("DateTime cannot represent an invalid Unix timestamp " + value);
      }
    } else {
      throw new TypeError("DateTime cannot be serialized from a non string, non numeric or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw new TypeError("DateTime cannot represent an invalid Date instance");
    }
    if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw new TypeError(`DateTime cannot represent an invalid date-time-string ${value}.`);
    }
    throw new TypeError(`DateTime cannot represent non string or Date type ${JSON.stringify(value)}`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw new TypeError(`DateTime cannot represent non string or Date type ${"value" in ast8 && ast8.value}`);
    }
    const { value } = ast8;
    if (validateDateTime(value)) {
      return parseDateTime(value);
    }
    throw new TypeError(`DateTime cannot represent an invalid date-time-string ${String(value)}.`);
  },
  extensions: {
    codegenScalarType: "Date | string"
  }
};
var GraphQLDateTime = new GraphQLScalarType(GraphQLDateTimeConfig);
var ISO_DURATION = /^(-|\+)?P(?!$)((-|\+)?\d+(?:(\.|,)\d+)?Y)?((-|\+)?\d+(?:(\.|,)\d+)?M)?((-|\+)?\d+(?:(\.|,)\d+)?W)?((-|\+)?\d+(?:(\.|,)\d+)?D)?(T(?=(-|\+)?\d)((-|\+)?\d+(?:(\.|,)\d+)?H)?((-|\+)?\d+(?:(\.|,)\d+)?M)?((-|\+)?\d+(?:(\.|,)\d+)?S)?)?$/;
var GraphQLDurationConfig = {
  name: "Duration",
  description: `
    A string representing a duration conforming to the ISO8601 standard,
    such as: P1W1DT13H23M34S
    P is the duration designator (for period) placed at the start of the duration representation.
    Y is the year designator that follows the value for the number of years.
    M is the month designator that follows the value for the number of months.
    W is the week designator that follows the value for the number of weeks.
    D is the day designator that follows the value for the number of days.
    T is the time designator that precedes the time components of the representation.
    H is the hour designator that follows the value for the number of hours.
    M is the minute designator that follows the value for the number of minutes.
    S is the second designator that follows the value for the number of seconds.

    Note the time designator, T, that precedes the time value.

    Matches moment.js, Luxon and DateFns implementations
    ,/. is valid for decimal places and +/- is a valid prefix
  `,
  serialize(value) {
    if (typeof value !== "string") {
      throw new TypeError(`Value is not string: ${value}`);
    }
    if (!ISO_DURATION.test(value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${value}`);
    }
    return value;
  },
  parseValue(value) {
    if (typeof value !== "string") {
      throw new TypeError(`Value is not string: ${value}`);
    }
    if (!ISO_DURATION.test(value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${value}`);
    }
    return value;
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw new GraphQLError(`Can only validate strings as ISO Durations but got a: ${ast8.kind}`);
    }
    if (!ISO_DURATION.test(ast8.value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${ast8.value}`);
    }
    return ast8.value;
  },
  extensions: {
    codegenScalarType: "string"
  }
};
var GraphQLISO8601Duration = new GraphQLScalarType({
  ...GraphQLDurationConfig,
  name: "ISO8601Duration"
});
var GraphQLDuration = new GraphQLScalarType({
  ...GraphQLDurationConfig,
  name: "Duration"
});
var VALUE_RANGES;
(function(VALUE_RANGES2) {
  VALUE_RANGES2[VALUE_RANGES2["NEGATIVE"] = 0] = "NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_NEGATIVE"] = 1] = "NON_NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["POSITIVE"] = 2] = "POSITIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_POSITIVE"] = 3] = "NON_POSITIVE";
})(VALUE_RANGES || (VALUE_RANGES = {}));
var VALUE_TYPES;
(function(VALUE_TYPES2) {
  VALUE_TYPES2[VALUE_TYPES2["INT"] = 0] = "INT";
  VALUE_TYPES2[VALUE_TYPES2["FLOAT"] = 1] = "FLOAT";
})(VALUE_TYPES || (VALUE_TYPES = {}));
var GraphQLPositiveInt = new GraphQLScalarType({
  name: "PositiveInt",
  description: "Integers that will have a value greater than 0.",
  serialize(value) {
    return processValue(value, "PositiveInt");
  },
  parseValue(value) {
    return processValue(value, "PositiveInt");
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.INT) {
      throw new GraphQLError(`Can only validate integers as positive integers but got a: ${ast8.kind}`);
    }
    return processValue(ast8.value, "PositiveInt");
  },
  extensions: {
    codegenScalarType: "number"
  }
});
var specifiedByURL$5 = "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf";
var GraphQLJSONConfig = {
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: identity,
  parseValue: identity,
  parseLiteral,
  specifiedByURL: specifiedByURL$5,
  specifiedByUrl: specifiedByURL$5,
  extensions: {
    codegenScalarType: "any"
  }
};
var GraphQLJSON = new GraphQLScalarType(GraphQLJSONConfig);
var specifiedByURL$6 = "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf";
var GraphQLJSONObjectConfig = {
  name: "JSONObject",
  description: "The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: ensureObject,
  parseValue: ensureObject,
  parseLiteral: parseObject$1,
  specifiedByURL: specifiedByURL$6,
  specifiedByUrl: specifiedByURL$6,
  extensions: {
    codegenScalarType: "Record<string, any>"
  }
};
var GraphQLJSONObject = new GraphQLScalarType(GraphQLJSONObjectConfig);
var A = "A".charCodeAt(0);
var Z = "Z".charCodeAt(0);

// ../../node_modules/@pothos/plugin-scope-auth/esm/errors.js
var _define_property5 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/types.js
var AuthScopeFailureType;
(function(AuthScopeFailureType2) {
  AuthScopeFailureType2["AuthScope"] = "AuthScope";
  AuthScopeFailureType2["AuthScopeFunction"] = "AuthScopeFunction";
  AuthScopeFailureType2["GrantedScope"] = "GrantedScope";
  AuthScopeFailureType2["AnyAuthScopes"] = "AnyAuthScopes";
  AuthScopeFailureType2["AllAuthScopes"] = "AllAuthScopes";
  AuthScopeFailureType2["Unknown"] = "Unknown";
})(AuthScopeFailureType || (AuthScopeFailureType = {}));

// ../../node_modules/@pothos/plugin-scope-auth/esm/errors.js
class ForbiddenError extends PothosValidationError {
  constructor(message, result) {
    super(message);
    _define_property5(this, "code", "FORBIDDEN");
    _define_property5(this, "result", undefined);
    this.name = "ForbiddenError";
    this.result = result !== null && result !== undefined ? result : {
      kind: AuthScopeFailureType.Unknown
    };
    Object.defineProperty(this, "name", {
      value: "ForbiddenError"
    });
  }
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var _define_property6 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/util.js
function canCache(map2) {
  if (map2.$granted) {
    return false;
  }
  return (map2.$all ? canCache(map2.$all) : true) && (map2.$any ? canCache(map2.$any) : true);
}
function cacheKey2(path) {
  if (!path) {
    return "*";
  }
  let key = String(path.key);
  let current = path.prev;
  while (current) {
    key = `${current.key}.${key}`;
    current = current.prev;
  }
  return key;
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var requestCache = new WeakMap;

class RequestCache {
  static fromContext(context, builder5) {
    if (!requestCache.has(context)) {
      requestCache.set(context, new RequestCache(builder5, context));
    }
    return requestCache.get(context);
  }
  getScopes() {
    if (!this.scopes) {
      const scopes = this.builder.options.authScopes(this.context);
      this.scopes = isThenable(scopes) ? scopes.then((resolved) => {
        this.scopes = resolved;
        return resolved;
      }) : scopes;
    }
    return this.scopes;
  }
  withScopes(cb) {
    const scopes = this.getScopes();
    if (isThenable(scopes)) {
      return scopes.then((resolvedScopes) => cb(resolvedScopes));
    }
    return cb(scopes);
  }
  saveGrantedScopes(scopes, path) {
    const key = cacheKey2(path);
    if (this.grantCache.has(key)) {
      const set = this.grantCache.get(key);
      scopes.forEach((scope) => set.add(scope));
    } else {
      this.grantCache.set(key, new Set(scopes));
    }
    return null;
  }
  testGrantedScopes(scope, path) {
    var _this_grantCache_get, _path_prev, _this_grantCache_get1;
    if ((_this_grantCache_get = this.grantCache.get(cacheKey2(path.prev))) === null || _this_grantCache_get === undefined ? undefined : _this_grantCache_get.has(scope)) {
      return true;
    }
    if (typeof ((_path_prev = path.prev) === null || _path_prev === undefined ? undefined : _path_prev.key) === "number" && ((_this_grantCache_get1 = this.grantCache.get(cacheKey2(path.prev.prev))) === null || _this_grantCache_get1 === undefined ? undefined : _this_grantCache_get1.has(scope))) {
      return true;
    }
    return false;
  }
  grantTypeScopes(type, parent, path, cb) {
    if (!this.typeGrants.has(type)) {
      this.typeGrants.set(type, new Map);
    }
    const cache2 = this.typeGrants.get(type);
    if (!cache2.has(parent)) {
      const result = cb();
      if (isThenable(result)) {
        cache2.set(parent, result.then((resolved) => this.saveGrantedScopes(resolved, path)));
      } else {
        cache2.set(parent, this.saveGrantedScopes(result, path));
      }
    }
    return cache2.get(parent);
  }
  evaluateScopeLoader(scopes, name, arg) {
    if (!this.scopeCache.has(name)) {
      this.scopeCache.set(name, new Map);
    }
    const cache2 = this.scopeCache.get(name);
    const key = this.cacheKey ? this.cacheKey(arg) : arg;
    if (!cache2.has(key)) {
      const loader = scopes[name];
      if (typeof loader !== "function") {
        throw new PothosValidationError(`Attempted to evaluate scope ${String(name)} as scope loader, but it is not a function`);
      }
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = loader(arg);
        } catch (error8) {
          cache2.set(key, {
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error8
          });
          return cache2.get(key);
        }
      } else {
        result = loader(arg);
      }
      if (isThenable(result)) {
        let promise = result.then((r) => r ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
        if (this.treatErrorsAsUnauthorized) {
          promise = promise.catch((error8) => ({
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error8
          }));
        }
        cache2.set(key, promise);
      } else {
        cache2.set(key, result ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
      }
    }
    return cache2.get(key);
  }
  evaluateScopeMapWithScopes({ $all, $any, $granted, ...map2 }, scopes, info, forAll) {
    const scopeNames = Object.keys(map2);
    const problems = [];
    const failure = {
      kind: forAll ? AuthScopeFailureType.AllAuthScopes : AuthScopeFailureType.AnyAuthScopes,
      failures: problems
    };
    const loaderList = [];
    for (const scopeName of scopeNames) {
      if (scopes[scopeName] == null || scopes[scopeName] === false) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map2[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
        continue;
      }
      const scope = scopes[scopeName];
      if (typeof scope === "function") {
        loaderList.push([
          scopeName,
          map2[scopeName]
        ]);
      } else if (scope && !forAll) {
        return null;
      } else if (!scope) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map2[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
      }
    }
    const promises = [];
    if ($granted) {
      const result = !!info && this.testGrantedScopes($granted, info.path);
      if (result && !forAll) {
        return null;
      }
      if (!result) {
        problems.push({
          kind: AuthScopeFailureType.GrantedScope,
          scope: $granted
        });
        if (forAll) {
          return failure;
        }
      }
    }
    if ($any) {
      const anyResult = this.evaluateScopeMap($any, info, false);
      if (isThenable(anyResult)) {
        promises.push(anyResult);
      } else if (anyResult === null && !forAll) {
        return null;
      } else if (anyResult) {
        problems.push(anyResult);
        if (forAll) {
          return failure;
        }
      }
    }
    if ($all) {
      const allResult = this.evaluateScopeMap($all, info, true);
      if (isThenable(allResult)) {
        promises.push(allResult);
      } else if (allResult === null && !forAll) {
        return resolveAndReturn(null);
      } else if (allResult) {
        problems.push(allResult);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    for (const [loaderName, arg] of loaderList) {
      const result = this.evaluateScopeLoader(scopes, loaderName, arg);
      if (isThenable(result)) {
        promises.push(result);
      } else if (result === null && !forAll) {
        return resolveAndReturn(null);
      } else if (result) {
        problems.push(result);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    if (promises.length === 0) {
      return forAll && problems.length === 0 ? null : failure;
    }
    return Promise.all(promises).then((results) => {
      let hasSuccess = false;
      results.forEach((result) => {
        if (result) {
          problems.push(result);
        } else {
          hasSuccess = true;
        }
      });
      if (forAll) {
        return problems.length > 0 ? failure : null;
      }
      return hasSuccess ? null : failure;
    });
    function resolveAndReturn(val) {
      if (promises.length > 0) {
        return Promise.all(promises).then(() => val);
      }
      return val;
    }
  }
  evaluateScopeMap(map2, info, forAll = this.defaultStrategy === "all") {
    if (typeof map2 === "boolean") {
      return map2 ? null : {
        kind: AuthScopeFailureType.AuthScopeFunction,
        error: null
      };
    }
    if (!this.mapCache.has(map2)) {
      const result = this.withScopes((scopes) => this.evaluateScopeMapWithScopes(map2, scopes, info, forAll));
      if (canCache(map2)) {
        this.mapCache.set(map2, result);
      }
      return result;
    }
    return this.mapCache.get(map2);
  }
  evaluateTypeScopeFunction(authScopes, type, parent, info) {
    const { typeCache } = this;
    if (!typeCache.has(type)) {
      typeCache.set(type, new Map);
    }
    const cache2 = typeCache.get(type);
    if (!cache2.has(parent)) {
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = authScopes(parent, this.context);
        } catch (error8) {
          cache2.set(parent, {
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error8
          });
          return cache2.get(parent);
        }
      } else {
        result = authScopes(parent, this.context);
      }
      if (isThenable(result)) {
        let promise = result.then((resolved) => this.evaluateScopeMap(resolved, info));
        if (this.treatErrorsAsUnauthorized) {
          promise = promise.catch((error8) => ({
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error8
          }));
        }
        cache2.set(parent, promise);
      } else {
        cache2.set(parent, this.evaluateScopeMap(result, info));
      }
    }
    return cache2.get(parent);
  }
  constructor(builder5, context) {
    var _builder_options_scopeAuthOptions, _builder_options_scopeAuthOptions1, _builder_options_scopeAuthOptions2;
    _define_property6(this, "builder", undefined);
    _define_property6(this, "context", undefined);
    _define_property6(this, "mapCache", new Map);
    _define_property6(this, "scopeCache", new Map);
    _define_property6(this, "typeCache", new Map);
    _define_property6(this, "typeGrants", new Map);
    _define_property6(this, "grantCache", new Map);
    _define_property6(this, "scopes", undefined);
    _define_property6(this, "cacheKey", undefined);
    _define_property6(this, "treatErrorsAsUnauthorized", undefined);
    _define_property6(this, "defaultStrategy", undefined);
    this.builder = builder5;
    this.context = context;
    this.cacheKey = (_builder_options_scopeAuthOptions = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions === undefined ? undefined : _builder_options_scopeAuthOptions.cacheKey;
    var _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized;
    this.treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions_treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions1 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions1 === undefined ? undefined : _builder_options_scopeAuthOptions1.treatErrorsAsUnauthorized) !== null && _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized !== undefined ? _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized : false;
    var _builder_options_scopeAuthOptions_defaultStrategy;
    this.defaultStrategy = (_builder_options_scopeAuthOptions_defaultStrategy = (_builder_options_scopeAuthOptions2 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions2 === undefined ? undefined : _builder_options_scopeAuthOptions2.defaultStrategy) !== null && _builder_options_scopeAuthOptions_defaultStrategy !== undefined ? _builder_options_scopeAuthOptions_defaultStrategy : "any";
  }
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/schema-builder.js
var schemaBuilderProto3 = esm_default.prototype;
schemaBuilderProto3.runAuthScopes = function runAuthScopes(context, scopes, unauthorizedError = (result) => new ForbiddenError(result.message, result.failure)) {
  const cache2 = RequestCache.fromContext(context, this);
  const resultOrPromise = cache2.evaluateScopeMap(scopes);
  if (isThenable(resultOrPromise)) {
    return resultOrPromise.then(handleScopeResult);
  }
  handleScopeResult(resultOrPromise);
  function handleScopeResult(result) {
    if (result) {
      const error8 = unauthorizedError({
        message: "Unauthorized",
        failure: result
      });
      if (typeof error8 === "string") {
        throw new ForbiddenError(error8, result);
      }
      throw error8;
    }
  }
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/field-builders.js
var addScopes2 = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var objectFieldBuilder = ObjectFieldBuilder2.prototype;
objectFieldBuilder.withAuth = function withAuth2(scopes) {
  return addScopes2(scopes, new ObjectFieldBuilder2(this.typename, this.builder));
};
var interfaceFieldBuilder = InterfaceFieldBuilder2.prototype;
interfaceFieldBuilder.withAuth = function withAuth3(scopes) {
  return addScopes2(scopes, new InterfaceFieldBuilder2(this.typename, this.builder));
};
var queryFieldBuilder = QueryFieldBuilder2.prototype;
queryFieldBuilder.withAuth = function withAuth4(scopes) {
  return addScopes2(scopes, new QueryFieldBuilder2(this.builder));
};
var mutationFieldBuilder = MutationFieldBuilder2.prototype;
mutationFieldBuilder.withAuth = function withAuth5(scopes) {
  return addScopes2(scopes, new MutationFieldBuilder2(this.builder));
};
var subscriptionFieldBuilder = SubscriptionFieldBuilder2.prototype;
subscriptionFieldBuilder.withAuth = function withAuth6(scopes) {
  return addScopes2(scopes, new SubscriptionFieldBuilder2(this.builder));
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/is-type-of-helper.js
function isTypeOfHelper(steps, plugin3, isTypeOf) {
  var _plugin_builder_options_scopeAuthOptions;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin3.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const createError = (parent, context, info, result) => globalUnauthorizedError ? globalUnauthorizedError(parent, context, info, result) : result.message;
  return (parent, context, info) => {
    const cache2 = RequestCache.fromContext(context, plugin3.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache2, parent, {}, context, info, () => {
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error8 = createError(parent, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
                failure: result
              });
              throw typeof error8 === "string" ? new ForbiddenError(error8, result) : error8;
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error8 = createError(parent, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
            failure: stepResult
          });
          throw typeof error8 === "string" ? new ForbiddenError(error8, stepResult) : error8;
        }
      }
      return isTypeOf ? isTypeOf(parent, context, info) : true;
    }
    return runSteps(0);
  };
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/resolve-helper.js
function resolveHelper(steps, plugin3, fieldConfig) {
  var _plugin_builder_options_scopeAuthOptions;
  var _fieldConfig_pothosOptions_unauthorizedResolver;
  const unauthorizedResolver = (_fieldConfig_pothosOptions_unauthorizedResolver = fieldConfig.pothosOptions.unauthorizedResolver) !== null && _fieldConfig_pothosOptions_unauthorizedResolver !== undefined ? _fieldConfig_pothosOptions_unauthorizedResolver : defaultUnauthorizedResolver;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin3.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const defaultUnauthorizedError = (parent, args, context, info, result) => {
    if (globalUnauthorizedError) {
      return globalUnauthorizedError(parent, context, info, result);
    }
    if ((result.failure.kind === AuthScopeFailureType.AuthScope || result.failure.kind === AuthScopeFailureType.AuthScopeFunction) && result.failure.error) {
      return result.failure.error;
    }
    return result.message;
  };
  var _fieldConfig_pothosOptions_unauthorizedError;
  const createError = (_fieldConfig_pothosOptions_unauthorizedError = fieldConfig.pothosOptions.unauthorizedError) !== null && _fieldConfig_pothosOptions_unauthorizedError !== undefined ? _fieldConfig_pothosOptions_unauthorizedError : defaultUnauthorizedError;
  return (parent, args, context, info) => {
    let resolvedValue;
    const cache2 = RequestCache.fromContext(context, plugin3.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache2, parent, args, context, info, (val) => {
          resolvedValue = val;
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error8 = createError(parent, args, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
                failure: result
              });
              return unauthorizedResolver(parent, args, context, info, typeof error8 === "string" ? new ForbiddenError(error8, result) : error8);
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error8 = createError(parent, args, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
            failure: stepResult
          });
          return unauthorizedResolver(parent, args, context, info, typeof error8 === "string" ? new ForbiddenError(error8, stepResult) : error8);
        }
      }
      return resolvedValue;
    }
    return runSteps(0);
  };
}
var defaultUnauthorizedResolver = (_root, _args, _context, _info, error8) => {
  throw error8;
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/steps.js
function createTypeAuthScopesStep(authScopes, type) {
  if (typeof authScopes === "function") {
    return {
      run: (state, parent, args, context, info) => state.evaluateTypeScopeFunction(authScopes, type, parent, info),
      errorMessage: `Not authorized to read fields for ${type}`
    };
  }
  return {
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info),
    errorMessage: `Not authorized to read fields for ${type}`
  };
}
function createTypeGrantScopesStep(grantScopes, type, forField) {
  return {
    run: (state, parent, args, context, info) => state.grantTypeScopes(type, parent, forField ? info.path.prev : info.path, () => grantScopes(parent, context)),
    errorMessage: `Unknown error creating grants for ${type}`
  };
}
function createFieldAuthScopesStep(authScopes) {
  if (typeof authScopes === "function") {
    return {
      errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
      run: (state, parent, args, context, info) => {
        const scopeMap = authScopes(parent, args, context, info);
        if (isThenable(scopeMap)) {
          return scopeMap.then((resolved) => state.evaluateScopeMap(resolved, info));
        }
        return state.evaluateScopeMap(scopeMap, info);
      }
    };
  }
  return {
    errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info)
  };
}
function createFieldGrantScopesStep(grantScopes) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue generating grants for ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => {
      if (typeof grantScopes !== "function") {
        state.saveGrantedScopes(grantScopes, info.path);
        return null;
      }
      const result = grantScopes(parent, args, context, info);
      if (isThenable(result)) {
        return result.then((resolved) => {
          state.saveGrantedScopes(resolved, info.path);
          return null;
        });
      }
      state.saveGrantedScopes(result, info.path);
      return null;
    }
  };
}
function createResolveStep(resolver) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue resolving ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info, setResolved) => {
      const result = resolver(parent, args, context, info);
      if (isThenable(result)) {
        return Promise.resolve(result).then((resolved) => {
          setResolved(resolved);
          return null;
        });
      }
      setResolved(result);
      return null;
    }
  };
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/index.js
var pluginName5 = "scopeAuth";
var esm_default6 = pluginName5;
var inResolveType = false;

class PothosScopeAuthPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    var _this_builder_options_scopeAuthOptions, _this_builder_options_scopeAuthOptions1;
    if (this.options.disableScopeAuth) {
      return resolver;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    const authorizedOnSubscribe = !!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) && typeConfig.kind === "Subscription";
    const nonRoot = (typeConfig.graphqlKind === "Interface" || typeConfig.graphqlKind === "Object") && typeConfig.kind !== "Query" && typeConfig.kind !== "Mutation" && typeConfig.kind !== "Subscription";
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const runTypeScopesOnField = !nonRoot || !((_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions1 = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions1 === undefined ? undefined : _this_builder_options_scopeAuthOptions1.runScopesOnType) !== null && _ref !== undefined ? _ref : false);
    const steps2 = this.createResolveSteps(fieldConfig, typeConfig, resolver, runTypeScopesOnField, authorizedOnSubscribe);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return resolver;
  }
  wrapSubscribe(subscriber, fieldConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return subscriber;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    if (!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) || typeConfig.kind !== "Subscription") {
      return subscriber;
    }
    const steps2 = this.createSubscribeSteps(fieldConfig, typeConfig, subscriber);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return subscriber;
  }
  wrapResolveType(resolveType, typeConfig) {
    return (...args) => {
      inResolveType = true;
      try {
        return resolveType(...args);
      } finally {
        inResolveType = false;
      }
    };
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return isTypeOf;
    }
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const shouldRunTypeScopes = (_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.runScopesOnType) !== null && _ref !== undefined ? _ref : false;
    if (!shouldRunTypeScopes) {
      return isTypeOf;
    }
    const steps2 = this.createStepsForType(typeConfig, {
      forField: false
    });
    if (steps2.length === 0) {
      return isTypeOf;
    }
    const runSteps = isTypeOfHelper(steps2, this, isTypeOf);
    return (source2, context, info) => {
      if (inResolveType) {
        var _isTypeOf;
        var _isTypeOf1;
        return (_isTypeOf1 = (_isTypeOf = isTypeOf) === null || _isTypeOf === undefined ? undefined : _isTypeOf(source2, context, info)) !== null && _isTypeOf1 !== undefined ? _isTypeOf1 : false;
      }
      return runSteps(source2, context, info);
    };
  }
  createStepsForType(typeConfig, { skipTypeScopes, skipInterfaceScopes, forField }) {
    const parentAuthScope = typeConfig.pothosOptions.authScopes;
    const parentGrantScopes = typeConfig.pothosOptions.grantScopes;
    const interfaceConfigs = typeConfig.kind === "Object" || typeConfig.kind === "Interface" ? typeConfig.interfaces.map((iface) => this.buildCache.getTypeConfig(iface, "Interface")) : [];
    const steps2 = [];
    if (parentAuthScope && !skipTypeScopes) {
      steps2.push(createTypeAuthScopesStep(parentAuthScope, typeConfig.name));
    }
    if (!skipInterfaceScopes && !(typeConfig.kind === "Object" && typeConfig.pothosOptions.skipInterfaceScopes)) {
      interfaceConfigs.forEach((interfaceConfig) => {
        if (interfaceConfig.pothosOptions.authScopes) {
          steps2.push(createTypeAuthScopesStep(interfaceConfig.pothosOptions.authScopes, interfaceConfig.name));
        }
      });
    }
    if (parentGrantScopes) {
      steps2.push(createTypeGrantScopesStep(parentGrantScopes, typeConfig.name, forField));
    }
    return steps2;
  }
  createResolveSteps(fieldConfig, typeConfig, resolver, shouldRunTypeScopes, authorizedOnSubscribe) {
    var _ref, _ref1;
    const stepsForType = shouldRunTypeScopes && !authorizedOnSubscribe ? this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    }) : [];
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const fieldGrantScopes = fieldConfig.pothosOptions.grantScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes && !authorizedOnSubscribe) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(resolver));
    if (fieldGrantScopes) {
      steps2.push(createFieldGrantScopesStep(fieldGrantScopes));
    }
    return steps2;
  }
  createSubscribeSteps(fieldConfig, typeConfig, subscriber) {
    var _ref, _ref1;
    const stepsForType = this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    });
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(subscriber));
    return steps2;
  }
}
var fieldBuilderProto3 = RootFieldBuilder2.prototype;
fieldBuilderProto3.authField = function authField(options) {
  return this.field(options);
};
esm_default.registerPlugin(pluginName5, PothosScopeAuthPlugin);

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/index.js
var _defineProperty29 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/cache.js
var _defineProperty27 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/cache-node.js
var _defineProperty26 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/manager/field.js
var _defineProperty24 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/manager/base.js
var _defineProperty23 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

class BaseSubscriptionManager {
  addRegistration(options) {
    this.registrations.push(options);
    this.manager.register(options);
  }
  reRegister() {
    this.registrations.forEach((options) => void this.manager.register(options));
  }
  constructor(manager) {
    _defineProperty23(this, "manager", undefined);
    _defineProperty23(this, "registrations", []);
    this.manager = manager;
  }
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/manager/field.js
class FieldSubscriptionManager extends BaseSubscriptionManager {
  register(name, { filter: filter2, invalidateCache } = {}) {
    this.addRegistration({
      name,
      filter: filter2,
      onValue: (value) => {
        if (invalidateCache) {
          invalidateCache(value);
        }
        return this.cacheNode.refetch();
      }
    });
  }
  constructor(manager, cacheNode) {
    super(manager);
    _defineProperty24(this, "cacheNode", undefined);
    this.cacheNode = cacheNode;
  }
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/manager/type.js
var _defineProperty25 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
class TypeSubscriptionManager extends BaseSubscriptionManager {
  register(name, { filter: filter2, invalidateCache, refetch } = {}) {
    this.addRegistration({
      name,
      filter: filter2,
      onValue: (value) => {
        if (invalidateCache) {
          invalidateCache(value);
        }
        if (refetch) {
          let resultOrPromise;
          try {
            resultOrPromise = refetch(value);
          } catch (error8) {
            this.manager.handleError(error8);
          }
          this.replace(resultOrPromise);
          return resultOrPromise;
        }
        return this.refetchParent();
      }
    });
  }
  constructor(manager, replace, refetchParent) {
    super(manager);
    _defineProperty25(this, "replace", undefined);
    _defineProperty25(this, "refetchParent", undefined);
    this.replace = replace;
    this.refetchParent = refetchParent;
  }
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/cache-node.js
class CacheNode {
  reRegister() {
    if (this.fieldManager) {
      this.fieldManager.reRegister();
    }
    this.typeManagers.forEach((manager) => void manager.reRegister());
  }
  managerForField() {
    this.fieldManager = new FieldSubscriptionManager(this.cache.manager, this);
    return this.fieldManager;
  }
  managerForType(key) {
    if (this.typeManagers.has(key)) {
      return null;
    }
    const typeManager = new TypeSubscriptionManager(this.cache.manager, (value) => {
      this.replaceValue(value, key);
    }, this.refetch);
    this.typeManagers.set(key, typeManager);
    return typeManager;
  }
  replaceValue(value, key) {
    if (typeof key === "number") {
      if (!Array.isArray(this.value)) {
        throw new PothosValidationError("Expected value of CacheNode for list path to be an array");
      }
      this.cache.invalidPaths.push(`${this.path}.${key}`);
      this.value[key] = value;
    } else {
      this.cache.invalidPaths.push(`${this.path}.`);
      this.value = value;
    }
    this.typeManagers.delete(key);
  }
  constructor(cache2, path, value, refetch) {
    _defineProperty26(this, "path", undefined);
    _defineProperty26(this, "value", undefined);
    _defineProperty26(this, "fieldManager", null);
    _defineProperty26(this, "typeManagers", new Map);
    _defineProperty26(this, "cache", undefined);
    _defineProperty26(this, "refetch", undefined);
    this.cache = cache2;
    this.path = path;
    this.value = value;
    this.refetch = refetch;
  }
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/cache.js
class SubscriptionCache {
  get(path, reRegister) {
    const node3 = this.currentCache.get(path);
    if (!node3) {
      return null;
    }
    for (const invalid of this.prevInvalidPaths) {
      if (path.startsWith(invalid)) {
        return null;
      }
    }
    if (reRegister) {
      this.nextCache.set(path, node3);
      node3.reRegister();
    }
    return node3;
  }
  getTypeSubscriber(type2) {
    const config = this.buildCache.getTypeConfig(type2, "Object");
    if (config.graphqlKind === "Object") {
      var _config_pothosOptions_subscribe;
      return (_config_pothosOptions_subscribe = config.pothosOptions.subscribe) !== null && _config_pothosOptions_subscribe !== undefined ? _config_pothosOptions_subscribe : null;
    }
    return null;
  }
  getParent(info) {
    let parentPath = info.path.prev;
    if (!parentPath) {
      return null;
    }
    if (typeof parentPath.key === "number") {
      parentPath = parentPath.prev;
    }
    const parentKey = this.cacheKey(parentPath);
    if (this.nextCache.has(parentKey)) {
      return this.nextCache.get(parentKey);
    }
    return null;
  }
  managerForParentType(info) {
    const parentPath = info.path.prev;
    if (!parentPath) {
      return null;
    }
    const isListItem = typeof parentPath.key === "number";
    const parentKey = this.cacheKey(isListItem ? parentPath.prev : parentPath);
    const parentCacheNode = this.nextCache.get(parentKey);
    var _parentCacheNode_managerForType;
    return (_parentCacheNode_managerForType = parentCacheNode === null || parentCacheNode === undefined ? undefined : parentCacheNode.managerForType(parentPath.key)) !== null && _parentCacheNode_managerForType !== undefined ? _parentCacheNode_managerForType : null;
  }
  add(info, path, canRefetch, value) {
    const parent = this.getParent(info);
    const node3 = new CacheNode(this, path, value, canRefetch || !parent ? () => void this.invalidPaths.push(path) : parent.refetch);
    this.nextCache.set(path, node3);
    return node3;
  }
  next() {
    this.prevInvalidPaths = this.invalidPaths;
    this.invalidPaths = [];
    this.currentCache = this.nextCache;
    this.nextCache = new Map;
  }
  cacheKey(path) {
    let { key, prev } = path;
    while (prev) {
      key = `${prev.key}.${key}`;
      prev = prev.prev;
    }
    return key.toString();
  }
  constructor(manager, buildCache) {
    _defineProperty27(this, "manager", undefined);
    _defineProperty27(this, "buildCache", undefined);
    _defineProperty27(this, "currentCache", new Map);
    _defineProperty27(this, "nextCache", new Map);
    _defineProperty27(this, "invalidPaths", []);
    _defineProperty27(this, "prevInvalidPaths", []);
    this.manager = manager;
    this.buildCache = buildCache;
  }
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/create-field-data.js
function getFieldSubscribe(field3, plugin3) {
  if (field3.graphqlKind === "Object" && field3.kind !== "Mutation" && field3.kind !== "Subscription") {
    return field3.pothosOptions.subscribe;
  }
  if (field3.kind === "Subscription" && plugin3.smartSubscriptionsToQueryField.has(field3.name)) {
    return plugin3.smartSubscriptionsToQueryField.get(field3.name).subscribe;
  }
  return null;
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/manager/index.js
var _defineProperty28 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _Symbol_asyncIterator = Symbol.asyncIterator;

class SubscriptionManager {
  register({ name, ...options }) {
    if (this.stopped) {
      return;
    }
    this.addOptions(name, options);
    if (this.nextSubscriptions.has(name)) {
      return;
    }
    this.nextSubscriptions.add(name);
    if (this.activeSubscriptions.has(name)) {
      return;
    }
    const maybePromise = this.subscribeToName(name, (err, value) => {
      if (err) {
        this.handleError(err);
      } else {
        this.handleValue(name, value);
      }
    });
    if (maybePromise) {
      maybePromise.catch((error8) => void this.handleError(error8));
    }
  }
  [_Symbol_asyncIterator]() {
    return this;
  }
  async return() {
    if (this.pendingError) {
      throw this.pendingError;
    }
    await this.stop();
    return {
      done: true,
      value: this.value
    };
  }
  async throw(error8) {
    this.handleError(error8);
    return Promise.reject(error8);
  }
  async next() {
    if (this.pendingError) {
      throw this.pendingError;
    }
    if (this.stopped) {
      return {
        done: true,
        value: this.value
      };
    }
    for (const name of this.activeSubscriptions) {
      if (!this.nextSubscriptions.has(name)) {
        await this.unsubscribeFromName(name);
      }
    }
    this.activeSubscriptions = this.nextSubscriptions;
    this.nextSubscriptions = new Set;
    this.activeOptions = this.nextOptions;
    this.nextOptions = new Map;
    if (this.pendingEvent) {
      this.pendingEvent = false;
      return {
        done: false,
        value: this.value
      };
    }
    return new Promise((resolve, reject2) => {
      this.resolveNext = (done = false) => {
        this.resolveNext = null;
        this.rejectNext = null;
        resolve({
          done,
          value: this.value
        });
      };
      this.rejectNext = (err) => {
        this.resolveNext = null;
        this.rejectNext = null;
        reject2(err);
      };
      const pending = this.pendingEvents;
      if (pending.length > 0) {
        this.pendingEvents = [];
        for (const [name, value] of pending) {
          this.handleValue(name, value);
        }
      }
    });
  }
  handleError(err) {
    this.pendingError = err;
    if (this.rejectNext) {
      this.rejectNext(err);
    }
    this.stop().catch((error8) => void this.handleError(error8));
  }
  async stop() {
    if (this.stopped) {
      return;
    }
    if (this.debounceRef) {
      clearTimeout(this.debounceRef);
      this.debounceRef = null;
    }
    this.stopped = true;
    const names = new Set([
      ...this.activeSubscriptions,
      ...this.nextSubscriptions
    ]);
    this.activeSubscriptions = new Set;
    this.nextSubscriptions = new Set;
    this.activeOptions = new Map;
    this.nextOptions = new Map;
    if (this.pendingError && this.rejectNext) {
      this.rejectNext(this.pendingError);
    } else if (this.resolveNext) {
      this.resolveNext(true);
    }
    for (const name of names) {
      await this.unsubscribeFromName(name);
    }
  }
  addOptions(name, options) {
    if (!this.nextOptions.has(name)) {
      this.nextOptions.set(name, []);
    }
    this.nextOptions.get(name).push(options);
  }
  filterValue(name, value) {
    const optionsList = this.activeOptions.get(name);
    if (!optionsList) {
      return {
        allowed: true
      };
    }
    let allowed = false;
    const promises = [];
    for (const options of optionsList) {
      const currentAllowed = !options.filter || options.filter(value);
      allowed = allowed || currentAllowed;
      if (currentAllowed && options.onValue) {
        const promise = options.onValue(value);
        if (promise) {
          promises.push(promise);
        }
      }
    }
    return {
      allowed,
      promises: Promise.all(promises)
    };
  }
  handleValue(name, value) {
    if (this.stopped) {
      return;
    }
    if (!this.resolveNext) {
      this.pendingEvents.push([
        name,
        value
      ]);
      return;
    }
    const { allowed, promises } = this.filterValue(name, value);
    if (promises) {
      promises.catch((error8) => void this.handleError(error8));
    }
    if (!allowed) {
      return;
    }
    if (this.debounceRef) {
      return;
    }
    if (this.debounceDelay === null) {
      this.pushValue();
    } else {
      this.debounceRef = setTimeout(() => {
        this.debounceRef = null;
        this.pushValue();
      }, this.debounceDelay);
      if (typeof this.debounceRef === "object" && "unref" in this.debounceRef) {
        this.debounceRef.unref();
      }
    }
  }
  pushValue() {
    if (this.stopped) {
      return;
    }
    if (this.resolveNext) {
      this.resolveNext();
    } else {
      this.pendingEvent = true;
    }
  }
  constructor({ value, debounceDelay, subscribe: subscribe3, unsubscribe }) {
    _defineProperty28(this, "activeSubscriptions", new Set);
    _defineProperty28(this, "nextSubscriptions", new Set);
    _defineProperty28(this, "activeOptions", new Map);
    _defineProperty28(this, "nextOptions", new Map);
    _defineProperty28(this, "subscribeToName", undefined);
    _defineProperty28(this, "unsubscribeFromName", undefined);
    _defineProperty28(this, "pendingEvent", true);
    _defineProperty28(this, "pendingError", undefined);
    _defineProperty28(this, "pendingEvents", []);
    _defineProperty28(this, "value", undefined);
    _defineProperty28(this, "resolveNext", null);
    _defineProperty28(this, "rejectNext", null);
    _defineProperty28(this, "stopped", false);
    _defineProperty28(this, "debounceDelay", null);
    _defineProperty28(this, "debounceRef", null);
    this.subscribeToName = subscribe3;
    this.unsubscribeFromName = unsubscribe;
    this.value = value;
    this.debounceDelay = debounceDelay !== null && debounceDelay !== undefined ? debounceDelay : null;
  }
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/resolve-with-cache.js
function resolveWithCache(cache2, subscribe3, resolve, canRefetch, parent, args, context, info) {
  const key = cache2.cacheKey(info.path);
  const existingCacheNode = cache2.get(key, true);
  if (existingCacheNode) {
    return existingCacheNode.value;
  }
  const parentSubscriber = cache2.getTypeSubscriber(info.parentType.name);
  if (parentSubscriber) {
    const parentManager = cache2.managerForParentType(info);
    if (parentManager) {
      parentSubscriber(parentManager, parent, context, info);
    }
  }
  const resultOrPromise = resolve(parent, args, context, info);
  function cacheResult(result) {
    const cacheNode = cache2.add(info, key, canRefetch, result);
    subscribe3 === null || subscribe3 === undefined || subscribe3(cacheNode.managerForField(), parent, args, context, info);
    return result;
  }
  return isThenable(resultOrPromise) ? resultOrPromise.then(cacheResult) : cacheResult(resultOrPromise);
}

// ../../node_modules/@pothos/plugin-smart-subscriptions/esm/index.js
var DEFAULT_DEBOUNCE_DELAY = 10;
var pluginName6 = "smartSubscriptions";
var esm_default7 = pluginName6;

class PothosSmartSubscriptionsPlugin extends BasePlugin {
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "Query" && fieldConfig.pothosOptions.smartSubscription) {
      this.smartSubscriptionsToQueryField.set(fieldConfig.name, fieldConfig);
      var _fieldConfig_resolve;
      this.builder.subscriptionField(fieldConfig.name, (t) => t.field({
        ...fieldConfig.pothosOptions,
        resolve: (parent, args, context, info) => ((_fieldConfig_resolve = fieldConfig.resolve) !== null && _fieldConfig_resolve !== undefined ? _fieldConfig_resolve : defaultFieldResolver)(parent, args, context, info),
        subscribe: (parent, args, context, info) => {
          const manager2 = new SubscriptionManager({
            value: parent,
            debounceDelay: this.debounceDelay,
            subscribe: (subName, cb) => this.subscribe(subName, context, cb),
            unsubscribe: (subName) => this.unsubscribe(subName, context)
          });
          const cache3 = new SubscriptionCache(manager2, this.buildCache);
          this.requestData(context).cache = cache3;
          return {
            [Symbol.asyncIterator]() {
              return {
                async next() {
                  return manager2.next().then((next) => {
                    cache3.next();
                    return next;
                  });
                },
                async return() {
                  return manager2.return();
                },
                async throw(error8) {
                  return manager2.throw(error8);
                }
              };
            }
          };
        }
      }));
    }
    return fieldConfig;
  }
  createRequestData(context) {
    return {};
  }
  wrapResolve(resolve, field3) {
    let canRefetch = false;
    if (field3.graphqlKind === "Object" && field3.kind !== "Query" && field3.kind !== "Subscription" && field3.kind !== "Mutation") {
      var _field_pothosOptions_canRefetch;
      canRefetch = (_field_pothosOptions_canRefetch = field3.pothosOptions.canRefetch) !== null && _field_pothosOptions_canRefetch !== undefined ? _field_pothosOptions_canRefetch : false;
    }
    const subscribe3 = getFieldSubscribe(field3, this);
    return (parent, args, context, info) => {
      const { cache: cache3 } = this.requestData(context);
      if (!cache3) {
        return resolve(parent, args, context, info);
      }
      return resolveWithCache(cache3, subscribe3, resolve, canRefetch, parent, args, context, info);
    };
  }
  wrapResolveType(resolveType) {
    return resolveType;
  }
  constructor(buildCache) {
    super(buildCache, pluginName6);
    _defineProperty29(this, "debounceDelay", undefined);
    _defineProperty29(this, "smartSubscriptionsToQueryField", new Map);
    _defineProperty29(this, "subscribe", undefined);
    _defineProperty29(this, "unsubscribe", undefined);
    this.subscribe = this.builder.options.smartSubscriptions.subscribe;
    this.unsubscribe = this.builder.options.smartSubscriptions.unsubscribe;
    var _this_builder_options_smartSubscriptions_debounceDelay;
    this.debounceDelay = (_this_builder_options_smartSubscriptions_debounceDelay = this.builder.options.smartSubscriptions.debounceDelay) !== null && _this_builder_options_smartSubscriptions_debounceDelay !== undefined ? _this_builder_options_smartSubscriptions_debounceDelay : DEFAULT_DEBOUNCE_DELAY;
  }
}
esm_default.registerPlugin(pluginName6, PothosSmartSubscriptionsPlugin);

// ../../node_modules/@pothos/plugin-simple-objects/esm/index.js
var pluginName7 = "simpleObjects";
var esm_default8 = pluginName7;

class PothosSimpleObjectsPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName7, PothosSimpleObjectsPlugin);
var proto = esm_default.prototype;
proto.simpleObject = function simpleObject(name, options, extraFields) {
  const ref = new ObjectRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t) => {
      const fields2 = originalFields(t);
      Object.keys(fields2).forEach((key) => {
        this.configStore.onFieldUse(fields2[key], (config) => {
          if (config.kind === "Object") {
            config.resolve = (parent) => parent[key];
          }
        });
      });
      return fields2;
    };
  }
  this.objectType(ref, options);
  if (extraFields) {
    this.objectFields(ref, extraFields);
  }
  return ref;
};
proto.simpleInterface = function simpleInterface(name, options, extraFields) {
  const ref = new InterfaceRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t) => {
      const fields2 = originalFields(t);
      Object.keys(fields2).forEach((key) => {
        this.configStore.onFieldUse(fields2[key], (config) => {
          if (config.kind === "Interface") {
            config.resolve = (parent) => parent[key];
          }
        });
      });
      return fields2;
    };
  }
  this.interfaceType(ref, options);
  if (extraFields) {
    this.interfaceFields(ref, extraFields);
  }
  return ref;
};

// /Users/richardguerre/Projects/flow/node_modules/@flowdev/common/index.ts
var decodeGlobalId = (globalId) => {
  const [typename, ...idElements] = globalId.split("_");
  const id = idElements.join("_");
  if (!typename || !id)
    return null;
  return { typename, id };
};
var encodeGlobalId = (typename, id) => {
  return `${typename}_${id}`;
};
var map2 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var htmlEscape = (str) => {
  return str.replace(/[&<>"']/g, (m) => map2[m] ?? m);
};
var htmlUnescape = (str) => {
  return str.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
};

// src/graphql/builder.ts
function u(input6) {
  return input6 ?? undefined;
}
function uParseInt(input6) {
  return input6 ? parseInt(input6) : undefined;
}
var decodeGlobalId2 = (globalId) => {
  const id = decodeGlobalId(globalId);
  if (!id)
    throw new Error("Invalid Relay ID");
  return id;
};
var builder5 = new esm_default({
  plugins: [
    esm_default2,
    esm_default6,
    esm_default3,
    esm_default4,
    esm_default5,
    esm_default7,
    esm_default8
  ],
  relayOptions: {
    clientMutationId: "omit",
    cursorType: "ID",
    edgesFieldOptions: {
      nullable: false
    },
    nodeFieldOptions: {
      nullable: false
    },
    encodeGlobalID: encodeGlobalId,
    decodeGlobalID: decodeGlobalId2
  },
  prisma: {
    client: prisma,
    exposeDescriptions: true,
    filterConnectionTotalCount: true
  },
  authScopes: async (context) => {
    return {
      public: true,
      authenticated: () => context.isSessionValid()
    };
  },
  scopeAuthOptions: {
    unauthorizedError: (_, __, info) => {
      const errors17 = {
        query: "You need to be logged in to see this.",
        mutation: "You need to be logged in to do this.",
        subscription: "You need to be logged in to see this.",
        _default: "You need to be logged in to do this."
      };
      return new GraphQLError(errors17[info.operation.operation] ?? errors17._default, {
        extensions: {
          code: "UNAUTHENTICATED",
          userFriendlyMessage: errors17[info.operation.operation] ?? errors17._default
        }
      });
    }
  },
  smartSubscriptions: {
    subscribe: async ($name, context, callback) => {
      const name = $name;
      if (!context.subscriptions[name])
        context.subscriptions[name] = pubsub.subscribe(name);
      for await (const data of context.subscriptions[name]) {
        callback(undefined, data);
      }
    },
    unsubscribe: ($name, context) => {
      const name = $name;
      context.subscriptions[name]?.return?.();
      delete context.subscriptions[name];
    }
  }
});
builder5.queryType({ authScopes: { authenticated: true } });
builder5.mutationType({ authScopes: { authenticated: true } });
builder5.subscriptionType({ authScopes: { authenticated: true } });
builder5.addScalarType("Date", GraphQLDate, {});
builder5.addScalarType("DateTime", GraphQLDateTime, {});
builder5.addScalarType("PositiveInt", GraphQLPositiveInt, {});
builder5.addScalarType("JSON", GraphQLJSON, {});
builder5.addScalarType("JSONObject", GraphQLJSONObject, {});
builder5.scalarType("Time", {
  description: "A time of day, represented as a string in the format `HH:mm`. For example, `16:20`.",
  serialize: (value) => dayjs(value).utc(false).format("HH:mm"),
  parseValue: (value) => {
    const dayjsObj = dayjs(`1970-01-01 ${value}`, "YYYY-MM-DD HH:mm", true).utc(true);
    if (!dayjsObj.isValid()) {
      throw new GraphQLError(`Invalid time "${value}". Should be in the format \`HH:mm\`. For example, \`16:20\`.`);
    }
    return dayjsObj.toDate();
  }
});

// src/graphql/Color.ts
var values3 = {
  slate: { value: "slate" },
  gray: { value: "gray" },
  zinc: { value: "zinc" },
  neutral: { value: "neutral" },
  stone: { value: "stone" },
  red: { value: "red" },
  orange: { value: "orange" },
  amber: { value: "amber" },
  yellow: { value: "yellow" },
  lime: { value: "lime" },
  green: { value: "green" },
  emerald: { value: "emerald" },
  teal: { value: "teal" },
  cyan: { value: "cyan" },
  sky: { value: "sky" },
  blue: { value: "blue" },
  indigo: { value: "indigo" },
  violet: { value: "violet" },
  purple: { value: "purple" },
  fuchsia: { value: "fuchsia" },
  pink: { value: "pink" },
  rose: { value: "rose" }
};
var ColorEnum = builder5.enumType("Color", { values: values3 });

// src/utils/getDays.ts
var getStartFromConnectionArgs = ({ after, before, last }) => {
  let start = new Date;
  if (after) {
    const afterDate = new Date(after);
    start = addDays(afterDate, 1);
  } else if (last) {
    const beforeDate = new Date(before ?? start);
    start = addDays(beforeDate, (before ? 0 : 1) - last);
  }
  return startOfDay(start);
};
var startOfDay = (day2 = new Date) => {
  return new Date(day2.setUTCHours(0, 0, 0, 0));
};
var endOfDay = (day2 = new Date) => {
  return new Date(day2.setUTCHours(23, 59, 59, 999));
};
var addDays = (day2 = new Date, days) => {
  return new Date(day2.setDate(day2.getDate() + days));
};
var getDayOfWeek = (date) => {
  return dayOfWeekArr[date.getDay()];
};
var dayOfWeekArr = [
  "SUNDAY",
  "MONDAY",
  "TUESDAY",
  "WEDNESDAY",
  "THURSDAY",
  "FRIDAY",
  "SATURDAY"
];
var toDateOnly = (date) => {
  const dateString = date.toJSON();
  return dateString.split("T")[0] ?? dateString;
};

// src/graphql/Day.ts
var DayType = builder5.prismaNode("Day", {
  id: { resolve: (day2) => toDateOnly(day2.date) },
  findUnique: (date) => ({ date: new Date(date) }),
  nullable: true,
  extensions: {
    resolveWhenNull: (findUniqueRes) => createEmptyNode(findUniqueRes)
  },
  fields: (t) => ({
    date: t.expose("date", { type: "Date", description: "The date of the day." }),
    notes: t.relation("notes"),
    tasks: t.prismaField({
      type: ["Task"],
      resolve: async (query3, day2) => {
        const dayInfo = await prisma.day.findUnique({
          where: { date: day2.date },
          select: { tasksOrder: true }
        });
        const order = dayInfo?.tasksOrder ?? day2.tasksOrder;
        const tasks = await prisma.task.findMany({
          ...query3,
          where: { date: day2.date, parentTaskId: null }
        });
        const tasksOrdered = tasks.sort((a, b) => {
          return order.indexOf(a.id) - order.indexOf(b.id);
        });
        return tasksOrdered;
      }
    }),
    routines: t.prismaField({
      type: ["Routine"],
      description: "The routines for the day in chronological order.",
      select: { date: true, routinesCompleted: { select: { id: true } } },
      resolve: async (query3, day2) => {
        const completedRoutineIds = new Set(day2.routinesCompleted.map((routine) => routine.id));
        const routines = await prisma.routine.findMany({
          ...query3,
          orderBy: { time: "asc" },
          where: {
            isActive: true,
            repeats: { has: getDayOfWeek(day2.date) },
            firstDay: { lte: day2.date },
            OR: [{ lastDay: null }, { lastDay: { gte: day2.date } }]
          }
        });
        return routines.map((routine) => ({
          ...routine,
          _done: completedRoutineIds.has(routine.id)
        }));
      }
    })
  })
});
builder5.queryField("days", (t) => t.connection({
  type: DayType,
  extensions: {
    pothosPrismaFallback: () => console.log("fallback")
  },
  description: `Get days using a Relay connection.

If no arguments are provided, it will return the current day.

If \`first\` (Int) is provided, it will return the current day and the following days.

If \`after\` (Date*) is provided, it will return the days after the given date.

If \`last\` (Int) is provided, it will return the current day and the previous days.

If \`before\` (Date*) is provided, it will return the days before the given date.

*Ignore that the GraphQL type is ID as Pothos (the library used to build the GraphQL API) doesn't support overriding the type of the connection fields.
Please input a Date in the format: YYYY-MM-DD`,
  resolve: async (_, args, context, info) => {
    const start = getStartFromConnectionArgs(args);
    const totalDays = args.first ?? args.last ?? 1;
    const end = endOfDay(new Date(start));
    end.setDate(end.getDate() + totalDays - 1);
    const days = await prisma.day.findMany({
      ...queryFromInfo({ context, info, typeName: "Day", path: ["edges", "node"] }),
      where: { date: { gte: start, lte: end } }
    });
    const dayMap = new Map(days.map((day2) => [toDateOnly(day2.date), day2]));
    const dayEdges = [];
    const dateCursor = new Date(start);
    for (const _2 of Array.from({ length: totalDays })) {
      const day2 = toDateOnly(dateCursor);
      dayEdges.push({
        cursor: day2,
        node: dayMap.get(day2) ?? createEmptyNode({ date: new Date(dateCursor) })
      });
      dateCursor.setDate(dateCursor.getDate() + 1);
    }
    return {
      edges: dayEdges,
      pageInfo: {
        hasNextPage: true,
        hasPreviousPage: true,
        startCursor: toDateOnly(start),
        endCursor: toDateOnly(end)
      }
    };
  }
}));
var createEmptyNode = ({ date }) => ({
  __typename: "Day",
  id: `Day_${toDateOnly(date)}`,
  date,
  tasksOrder: [],
  notes: [],
  routines: [],
  routinesCompleted: [],
  tasks: []
});

// src/graphql/ItemPluginData.ts
var ItemPluginDataType = builder5.prismaNode("ItemPluginData", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    min: t.expose("min", { type: "JSON" }),
    full: t.expose("full", { type: "JSON" }),
    pluginSlug: t.exposeString("pluginSlug")
  })
});
var ItemPluginDataInput = builder5.inputType(builder5.inputRef("ItemPluginDataInput"), {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    originalId: t.string({ required: false }),
    min: t.field({ type: "JSON", required: true }),
    full: t.field({ type: "JSON", required: true })
  })
});

// src/graphql/PrismaFilters.ts
var DateFilter = builder5.prismaFilter("Date", {
  name: "PrismaDateFilter",
  description: "Filter input of Date",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var DateTimeFilter = builder5.prismaFilter("DateTime", {
  name: "PrismaDateTimeFilter",
  description: "Filter input of DateTime",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var IntFilter = builder5.prismaFilter("Int", {
  name: "PrismaIntFilter",
  description: "Filter input of Int",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var JsonFilter = builder5.prismaFilter("JSON", {
  name: "PrismaJsonFilter",
  description: "Filter input of JSON",
  ops: ["equals", "path", "array_contains", "array_starts_with", "array_ends_with"]
});

// src/utils/getPlugins.ts
import fs from "fs/promises";
import path from "path";

// src/utils/pgBoss.ts
var import_pg_boss = __toESM(require_src(), 1);
var pgBoss = new import_pg_boss.default(env.DATABASE_URL ?? "postgresql://postgres@localhost:5432/flow");
pgBoss.on("error", (error8) => {
  console.log("pg-boss error:", error8);
});

// /Users/richardguerre/Projects/flow/node_modules/@flowdev/nearest-color/src/index.ts
var hexToRgb = function(hex) {
  if (hex.length === 4) {
    hex = hex.replace(/#([a-f0-9])/i, "$1$1");
  }
  const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return {
    r: parseInt(res[1], 16),
    g: parseInt(res[2], 16),
    b: parseInt(res[3], 16)
  };
};
var nearestColor = (colorPallette, color) => {
  if (typeof color === "string") {
    color = hexToRgb(color);
  }
  const rgbColor = color;
  const colorKeys = Object.keys(colorPallette);
  const colorValues = colorKeys.map((key) => hexToRgb(colorPallette[key]));
  const colorDistances = colorValues.map((value) => {
    return Math.sqrt(Math.pow(value.r - rgbColor.r, 2) + Math.pow(value.g - rgbColor.g, 2) + Math.pow(value.b - rgbColor.b, 2));
  });
  const minDistance = Math.min(...colorDistances);
  const minDistanceIndex = colorDistances.indexOf(minDistance);
  return colorKeys[minDistanceIndex];
};
var colorPalette = {
  slate: "#cbd5e1",
  gray: "#d1d5db",
  zinc: "#d4d4d8",
  neutral: "#d4d4d4",
  stone: "#d6d3d1",
  red: "#fca5a5",
  orange: "#fdba74",
  amber: "#fcd34d",
  yellow: "#fde047",
  lime: "#bef264",
  green: "#86efac",
  emerald: "#6ee7b7",
  teal: "#5eead4",
  cyan: "#67e8f9",
  sky: "#7dd3fc",
  blue: "#93c5fd",
  indigo: "#a5b4fc",
  violet: "#c4b5fd",
  purple: "#d8b4fe",
  fuchsia: "#f0abfc",
  pink: "#f9a8d4",
  rose: "#fda4af"
};
var nearestTailwindColor = (color) => nearestColor(colorPalette, color);

// src/utils/renderTemplate.ts
var import_handlebars = __toESM(require_lib5(), 1);
var import_handlebars_async_helpers = __toESM(require_handlebars_async_helpers(), 1);

// src/graphql/Store.ts
var FlowPluginSlug = "flow";
var StoreKeys = {
  INSTALLED_PLUGINS: "installed-plugins",
  PASSWORD_HASH: "password-hash",
  AUTH_SESSION_PREFIX: "session-",
  TIMEZONE: "timezone"
};
var StoreType = builder5.prismaNode("Store", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    key: t.exposeString("key"),
    pluginSlug: t.exposeString("pluginSlug"),
    isSecret: t.exposeBoolean("isSecret"),
    isServerOnly: t.exposeBoolean("isServerOnly"),
    value: t.field({
      type: "JSON",
      nullable: true,
      description: "The value of the store item.",
      resolve: (store) => store.isSecret || store.isServerOnly ? null : store.value
    })
  })
});
builder5.queryField("storeItems", (t) => t.prismaFieldWithInput({
  type: ["Store"],
  description: `Get store items.

Pass the \`pluginSlug\` if you want to get items created by a specific plugin. Not passing the \`pluginSlug\` will return items created by flow.`,
  input: {
    pluginSlug: t.input.string({ required: false }),
    keys: t.input.stringList({ required: false })
  },
  argOptions: {
    required: false,
    name: "where"
  },
  resolve: (query3, _, args) => {
    return prisma.store.findMany({
      ...query3,
      where: {
        ...args.where?.pluginSlug ? { pluginSlug: args.where?.pluginSlug } : {},
        ...args.where?.keys?.length ? { key: { in: args.where.keys } } : {}
      }
    });
  }
}));
builder5.queryField("isPasswordSet", (t) => t.field({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "Boolean",
  description: "Whether the password is set.",
  resolve: async () => {
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    }).catch(() => null);
    return !!passwordSetting;
  }
}));
builder5.queryField("timezoneSet", (t) => t.field({
  type: "String",
  description: "The timezone set for the Flow instance. `null` if no timezone is set.",
  nullable: true,
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: async () => {
    const timezoneSetting = await prisma.store.findUnique({
      where: { pluginSlug_key_unique: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug } }
    }).catch(() => null);
    return timezoneSetting?.value ?? null;
  }
}));
builder5.queryField("isFullySetup", (t) => t.field({
  type: "Boolean",
  description: "Whether the Flow instance is fully setup.",
  nullable: false,
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: async () => {
    const storeItems = await prisma.store.findMany({
      where: {
        key: { in: [StoreKeys.PASSWORD_HASH, StoreKeys.TIMEZONE] },
        pluginSlug: FlowPluginSlug
      }
    });
    return storeItems.length === 2;
  }
}));
builder5.queryField("isSessionValid", (t) => t.field({
  type: "Boolean",
  description: "Whether the session is valid.",
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: (_, __, context) => context.isSessionValid()
}));
builder5.queryField("installedPlugins", (t) => t.field({
  type: [PluginInstallationType],
  description: "Get all installed plugins.",
  resolve: getPluginsInStore
}));
var PluginInstallationType = builder5.objectType(builder5.objectRef("PluginInstallation"), {
  fields: (t) => ({
    slug: t.exposeString("slug"),
    url: t.exposeString("url"),
    hasWebRuntime: t.exposeBoolean("web"),
    hasMobileRuntime: t.exposeBoolean("mobile"),
    hasServerRuntime: t.exposeBoolean("server")
  })
});
builder5.mutationField("upsertStoreItem", (t) => t.prismaFieldWithInput({
  type: "Store",
  description: `Creates a store item. If a store item with the same key exists, only its value will be updated (\`isSecret\` and \`isServerOnly\` will not be updated).

If the \`pluginSlug\` is passed, it will create/update a store item for that plugin. Otherwise, it will create/update a store item for flow.

If \`isSecret\` is set to true, \`isServerOnly\` will also be set to true and will not be returned in the \`storeItems\` query (it will be \`null\`). The item will only be accessible by plugin with the same \`pluginSlug\` in the server.

If \`isServerOnly\` is set to true, the store item will not be returned in the \`storeItems\` query (it will be \`null\`). The item will be accessible by all plugins in the server.`,
  input: {
    key: t.input.string({ required: true }),
    value: t.input.field({ type: "JSON", required: true }),
    pluginSlug: t.input.string({ required: true }),
    isSecret: t.input.boolean({ required: false }),
    isServerOnly: t.input.boolean({ required: false })
  },
  resolve: async (query3, _, args) => {
    if (args.input.pluginSlug === "flow") {
      throw new GraphQLError("The slug 'flow' is reserved for internal use. Please use your plugin's slug.", {
        extensions: {
          code: "KEY_RESERVED",
          userFriendlyMessage: "The item couldn't be saved. Please ask the plugin author for more information."
        }
      });
    }
    const res = await prisma.store.upsert({
      ...query3,
      where: {
        pluginSlug_key_unique: { key: args.input.key, pluginSlug: args.input.pluginSlug }
      },
      update: { value: args.input.value },
      create: {
        key: args.input.key,
        value: args.input.value,
        pluginSlug: args.input.pluginSlug,
        isSecret: args.input.isSecret ?? false,
        isServerOnly: args.input.isServerOnly ?? args.input.isSecret ?? false
      }
    });
    const plugins4 = await getPlugins2();
    const plugin3 = plugins4[args.input.pluginSlug];
    await plugin3?.onStoreItemUpsert?.(args.input.key).catch((e) => console.log(`Error plugin.onStoreItemUpsert for ${args.input.pluginSlug}`, e));
    return res;
  }
}));
builder5.mutationField("installPlugin", (t) => t.fieldWithInput({
  type: [PluginInstallationType],
  description: "Install a plugin. If a plugin with the same slug exists, it will throw an error, unless `override` is set to true.",
  input: {
    url: t.input.string({ required: true }),
    override: t.input.boolean({ required: false })
  },
  resolve: async (_, args) => {
    let installedPlugins = await getPluginsInStore();
    const newPluginJson = await getPluginJson({ url: args.input.url });
    if (!args.input.override && !!installedPlugins.find((p) => p.slug === newPluginJson.slug)) {
      throw new GraphQLError(`A plugin with the slug "${newPluginJson.slug}" is already installed. Use the \`override\` option to override the existing plugin.`, {
        extensions: {
          code: "PLUGIN_WITH_SAME_SLUG",
          userFriendlyMessage: "There is a problem with the plugin you are trying to install (Error: PLUGIN_WITH_SAME_SLUG). Please contact the plugin author for more information."
        }
      });
    }
    if (newPluginJson.slug.includes("_")) {
      throw new GraphQLError(`The plugin slug "${newPluginJson.slug}" is invalid. Plugin slugs cannot contain underscores.`, {
        extensions: {
          code: "PLUGIN_SLUG_INVALID",
          userFriendlyMessage: "There is a problem with the plugin you are trying to install (Err: PLUGIN_SLUG_INVALID). Please contact the plugin author for more information."
        }
      });
    }
    if (newPluginJson.server) {
      await installServerPlugin({
        url: args.input.url,
        slug: newPluginJson.slug,
        override: args.input.override ?? false
      });
    }
    installedPlugins = installedPlugins.filter((p) => p.slug !== newPluginJson.slug);
    installedPlugins.push({
      url: args.input.url,
      slug: newPluginJson.slug,
      web: newPluginJson.web ?? false,
      mobile: newPluginJson.mobile ?? false,
      server: newPluginJson.server ?? false
    });
    const newSetting = await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.INSTALLED_PLUGINS, pluginSlug: FlowPluginSlug }
      },
      update: { value: installedPlugins },
      create: {
        key: StoreKeys.INSTALLED_PLUGINS,
        pluginSlug: FlowPluginSlug,
        value: installedPlugins,
        isSecret: false,
        isServerOnly: false
      }
    });
    return newSetting.value;
  }
}));
builder5.mutationField("uninstallPlugin", (t) => t.fieldWithInput({
  type: [PluginInstallationType],
  description: "Uninstall a plugin.",
  input: {
    slug: t.input.string({ required: true })
  },
  resolve: async (_, args) => {
    let installedPlugins = await getPluginsInStore();
    await uninstallServerPlugin(args.input.slug);
    installedPlugins = installedPlugins.filter((p) => p.slug !== args.input.slug);
    const newSetting = await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.INSTALLED_PLUGINS, pluginSlug: FlowPluginSlug }
      },
      update: { value: installedPlugins },
      create: {
        key: StoreKeys.INSTALLED_PLUGINS,
        pluginSlug: FlowPluginSlug,
        value: installedPlugins,
        isSecret: false,
        isServerOnly: false
      }
    });
    return newSetting.value;
  }
}));
var generatePasswordHash = async (password) => {
  return Bun.password.hash(password, "bcrypt");
};
var generateSessionToken = () => {
  return new Bun.CryptoHasher("sha256").digest("base64");
};
builder5.mutationField("setPassword", (t) => t.fieldWithInput({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "String",
  description: "Set password for the Flow instance and get a session token to make authenticated requests.",
  input: {
    password: t.input.string({ required: true, description: "The password to set (unhashed)." })
  },
  resolve: async (_, args, context) => {
    if (args.input.password.length < 8) {
      throw new GraphQLError("The password must be at least 8 characters long.", {
        extensions: { code: "PASSWORD_TOO_SHORT" }
      });
    }
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (passwordSetting) {
      throw new GraphQLError("The password can only be set once. Use the `changePassword` mutation to change the password.", { extensions: { code: "PASSWORD_ALREADY_SET" } });
    }
    const passwordHash = await generatePasswordHash(args.input.password);
    await prisma.store.create({
      data: {
        key: StoreKeys.PASSWORD_HASH,
        pluginSlug: FlowPluginSlug,
        value: passwordHash,
        isSecret: true,
        isServerOnly: true
      }
    }).catch((e) => {
      console.error(e);
      throw new GraphQLError(e.message ?? "Something went wrong while setting the password.", {
        extensions: {
          code: "PASSWORD_SET_ERROR",
          userFriendlyMessage: "Something went wrong while setting the password."
        }
      });
    });
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    return sessionToken;
  }
}));
builder5.mutationField("changePassword", (t) => t.fieldWithInput({
  type: "String",
  description: "Change password for the Flow instance and get a new session token to make authenticated requests.",
  input: {
    oldPassword: t.input.string({ required: true, description: "The old password (unhashed)." }),
    newPassword: t.input.string({ required: true, description: "The new password (unhashed)." })
  },
  resolve: async (_, args, context) => {
    if (args.input.newPassword.length < 8) {
      throw new GraphQLError("The new password must be at least 8 characters.", {
        extensions: { code: "PASSWORD_TOO_SHORT" }
      });
    }
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (!passwordSetting) {
      throw new GraphQLError("The password is not set. Use the `setPassword` mutation to set the password.", {
        extensions: {
          code: "PASSWORD_NOT_SET",
          userFriendlyMessage: "No password was set for your Flow yet. Please refresh the page to set the password."
        }
      });
    }
    const isOldPasswordCorrect = await Bun.password.verify(args.input.oldPassword, passwordSetting.value);
    if (!isOldPasswordCorrect) {
      throw new GraphQLError("The old password is incorrect.", {
        extensions: { code: "PASSWORD_INCORRECT" }
      });
    }
    const newPasswordHash = await generatePasswordHash(args.input.newPassword);
    await prisma.store.update({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      },
      data: { value: newPasswordHash }
    }).catch((e) => {
      console.error(e);
      throw new GraphQLError(e.message ?? "Something went wrong while changing the password.", {
        extensions: {
          code: "PASSWORD_CHANGE_ERROR",
          userFriendlyMessage: "Something went wrong while changing the password."
        }
      });
    });
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    await prisma.store.deleteMany({
      where: { pluginSlug: FlowPluginSlug, key: { not: authSessionKey } }
    });
    return sessionToken;
  }
}));
builder5.mutationField("login", (t) => t.fieldWithInput({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "String",
  description: "Login to the Flow instance and get a session token to make authenticated requests.",
  input: {
    password: t.input.string({ required: true, description: "The password (unhashed)." })
  },
  resolve: async (_, args, context) => {
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (!passwordSetting) {
      throw new GraphQLError("The password is not set. Use the `setPassword` mutation to set the password.", {
        extensions: {
          code: "PASSWORD_NOT_SET",
          userFriendlyMessage: "No password was set for your Flow yet. Please refresh the page to set the password."
        }
      });
    }
    const isPasswordCorrect = await Bun.password.verify(args.input.password, passwordSetting.value);
    if (!isPasswordCorrect) {
      throw new GraphQLError("The password is incorrect.", {
        extensions: { code: "PASSWORD_INCORRECT" }
      });
    }
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    return sessionToken;
  }
}));
builder5.mutationField("logout", (t) => t.field({
  authScopes: { authenticated: true },
  skipTypeScopes: true,
  type: "Boolean",
  description: "Logout from the Flow instance using the session token set in the Authorization header.",
  resolve: async (_, __, { sessionToken }) => {
    await prisma.store.deleteMany({
      where: {
        pluginSlug: FlowPluginSlug,
        key: { startsWith: StoreKeys.AUTH_SESSION_PREFIX },
        value: { path: ["token"], equals: sessionToken }
      }
    });
    return true;
  }
}));
builder5.mutationField("setTimezone", (t) => t.fieldWithInput({
  type: "String",
  description: 'Set the timezone using a [dayjs timezone string](https://day.js.org/docs/en/plugin/timezone) (e.g. "America/New_York") for the Flow instance. This will affect the time the tasks are synced (default is 04:00 in the timezone set)',
  input: {
    timezone: t.input.string({
      required: true,
      description: 'The timezone to set as a [dayjs timezone string](https://day.js.org/docs/en/plugin/timezone) (e.g. "America/New_York").'
    })
  },
  resolve: async (_, args) => {
    try {
      dayjs().tz(args.input.timezone);
    } catch {
      throw new GraphQLError('The timezone is invalid. Please use a correct timezone identifier (e.g. "America/New_York") from this list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.', { extensions: { code: "TIMEZONE_INVALID" } });
    }
    await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug }
      },
      update: { value: args.input.timezone },
      create: {
        key: StoreKeys.TIMEZONE,
        pluginSlug: FlowPluginSlug,
        value: args.input.timezone,
        isSecret: false,
        isServerOnly: false
      }
    });
    await scheduleRolloverTasks(args.input.timezone);
    return args.input.timezone;
  }
}));

// src/utils/index.ts
var ROLLOVER_TASKS_JOB_NAME = "rollover-tasks-to-today";
var DELETE_PGBOSS_ARCHIVE_JOB_NAME = "delete-pgboss-archive";
var CALENDAR_ITEM_CREATED_JOB_NAME = "calendar-item-created";
var DEFAULT_4AM_CRON = "0 4 * * *";
var ROLLOVER_TASKS_CRON = DEFAULT_4AM_CRON;
var syncTasks = async () => {
  console.log("-- Syncing tasks...");
  const usersTimezone = await getTimezone();
  const usersToday = dayjs().tz(usersTimezone).utc(true).startOf("day").toDate();
  await prisma.day.upsert({
    where: { date: usersToday },
    create: { date: usersToday },
    update: {}
  });
  const res = await prisma.task.updateMany({
    where: {
      status: { notIn: ["DONE", "CANCELED"] },
      date: { lt: usersToday },
      OR: [{ item: null }, { item: { scheduledAt: null } }]
    },
    data: { date: usersToday }
  });
  console.log(`\u2705 Synced ${res.count} tasks.`);
};
var scheduleRolloverTasks = async (timezone3 = "Etc/GMT-11") => {
  await pgBoss.schedule(ROLLOVER_TASKS_JOB_NAME, ROLLOVER_TASKS_CRON, undefined, {
    tz: timezone3,
    singletonKey: ROLLOVER_TASKS_JOB_NAME
  });
  console.log(`\u2705 Scheduled "${ROLLOVER_TASKS_JOB_NAME}" job.`);
};
var deletePgBossArchive = async () => {
  console.log("\uD83D\uDDD1\uFE0F Deleting pgboss archive...");
  await prisma.$executeRawUnsafe(`TRUNCATE pgboss.archive;`);
  console.log("\u2705 Deleted pgboss archive.");
};
var scheduleDeletePgBossArchive = async (timezone3 = "Etc/GMT-11") => {
  await pgBoss.schedule(DELETE_PGBOSS_ARCHIVE_JOB_NAME, DEFAULT_4AM_CRON, undefined, {
    tz: timezone3,
    singletonKey: DELETE_PGBOSS_ARCHIVE_JOB_NAME
  });
  console.log(`\u2705 Scheduled ${DELETE_PGBOSS_ARCHIVE_JOB_NAME} job.`);
};
var isSessionTokenValid = async (sessionToken) => {
  if (!sessionToken) {
    return false;
  } else {
    const sessionItem = await prisma.store.findFirst({
      where: {
        pluginSlug: FlowPluginSlug,
        key: { startsWith: StoreKeys.AUTH_SESSION_PREFIX },
        AND: [
          { value: { path: ["token"], equals: sessionToken } },
          { value: { path: ["expiresAt"], gt: new Date().toISOString() } }
        ]
      }
    });
    if (!sessionItem) {
      return false;
    }
  }
  return true;
};
var getTimezone = async () => {
  const timezoneItem = await prisma.store.findFirst({
    where: {
      pluginSlug: FlowPluginSlug,
      key: StoreKeys.TIMEZONE
    }
  });
  const timezone3 = timezoneItem?.value;
  try {
    dayjs().tz(timezone3);
    return timezone3;
  } catch {
    return;
  }
};
var createExternalCalendarItem = async ({ data: item }) => {
  console.log("\uD83D\uDCC5 Creating calendar event for item", item.id);
  const plugins4 = await getPlugins2();
  for (const plugin3 of Object.values(plugins4)) {
    if (!plugin3.onCreateCalendarItem)
      continue;
    await plugin3.onCreateCalendarItem({ item });
  }
};
var pluginPgBossWorkers = async (props) => {
  const plugins4 = props?.plugins ?? await getPlugins2();
  for (const [pluginSlug, plugin3] of Object.entries(plugins4)) {
    const handlers = plugin3.handlePgBossWork?.((name, ...args) => {
      const workerName = `${pluginSlug}-${name}`;
      console.log(`Starting worker \`${workerName}\``);
      return pgBoss.work(workerName, ...args);
    }) ?? [];
    await Promise.all(handlers);
  }
};
var reloadPluginPgBossWorkers = async (props) => {
  pgBoss.offWork(props.pluginSlug);
  await pluginPgBossWorkers(props);
};
var pgBossWorkers = async () => {
  if (env.NODE_ENV !== "development") {
    await pgBoss.work(ROLLOVER_TASKS_JOB_NAME, syncTasks);
    console.log("Started worker to sync tasks");
  }
  if (env.NODE_ENV !== "development") {
    await pgBoss.work(DELETE_PGBOSS_ARCHIVE_JOB_NAME, deletePgBossArchive);
    console.log("Started worker to delete pgboss archive");
  }
  await pgBoss.work(CALENDAR_ITEM_CREATED_JOB_NAME, createExternalCalendarItem);
  console.log("Started worker to create calendar events");
};
var getUsersTimezone = async () => {
  const timezoneItem = await prisma.store.findFirst({
    where: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug }
  });
  return timezoneItem?.value ?? null;
};

// src/utils/renderTemplate.ts
var import_node_html_parser = __toESM(require_dist3(), 1);
var registerHelper = function(name, helper) {
  return Handlebars.registerHelper(name, async function(...args) {
    return helper.bind(this)(args.at(-1), ...args);
  });
};
var Handlebars = import_handlebars_async_helpers.default(import_handlebars.default);
var renderTemplate = async (template, data) => {
  console.log("renderTemplate()");
  const plugins4 = await getPlugins2();
  const helpers2 = {};
  for (const [pluginSlug, plugin3] of Object.entries(plugins4)) {
    if (plugin3.handlebars?.helpers) {
      for (const [helperName, helper] of Object.entries(plugin3.handlebars.helpers)) {
        helpers2[`${pluginSlug}-${helperName}`] = function(...args) {
          return helper.bind(this)(args.at(-1), ...args);
        };
      }
    }
  }
  Handlebars.registerHelper(helpers2);
  const usersTimezone = await getUsersTimezone() ?? undefined;
  await registerFlowsDefaultHelpers({
    usersTimezone,
    include: {
      "title-without-tags": template.includes("title-without-tags"),
      tasks: template.includes("tasks"),
      yesterday: template.includes("yesterday"),
      today: template.includes("today"),
      tomorrow: template.includes("tomorrow")
    }
  });
  console.log("-- Handlebars.helpers", Handlebars.helpers);
  const defaultData = await getFlowsDefaultData({
    include: {}
  });
  console.log("-- defaultData", defaultData);
  const result = await Handlebars.compile(template)({
    ...defaultData,
    ...data
  });
  return result;
};
var getFlowsDefaultData = async (_opts) => {
  return {};
};
var registerFlowsDefaultHelpers = async (opts) => {
  const usersTimezone = opts?.usersTimezone ?? await getUsersTimezone();
  const today = dayjs().tz(usersTimezone ?? undefined).utc(true).startOf("day");
  if (opts?.include?.yesterday) {
    registerHelper("yesterday", async function(options) {
      const format = options?.hash?.format ?? "MMMM D, YYYY";
      const yesterday = today.subtract(1, "day");
      if (format === "ISO")
        return yesterday.toISOString();
      return yesterday.format(format);
    });
  }
  if (opts?.include?.today) {
    registerHelper("today", async function(options) {
      const format = options?.hash?.format ?? "MMMM D, YYYY";
      if (format === "ISO")
        return today.toISOString();
      return today.format(format);
    });
  }
  if (opts?.include?.tomorrow) {
    registerHelper("tomorrow", async function(options) {
      const format = options?.hash?.format ?? "MMMM D, YYYY";
      const tomorrow = today.add(1, "day");
      if (format === "ISO")
        return tomorrow.toISOString();
      return tomorrow.format(format);
    });
  }
  if (opts?.include?.["title-without-tags"]) {
    registerHelper("title-without-tags", async function() {
      if (!("title" in this))
        return "";
      const titleParsed = import_node_html_parser.default.parse(this.title);
      titleParsed.querySelectorAll("p").forEach((tag) => {
        tag.replaceWith(tag.innerHTML);
      });
      titleParsed.querySelectorAll("span[data-tasktag-id]").forEach((tag) => {
        tag.replaceWith("");
      });
      return new Handlebars.SafeString(titleParsed.toString());
    });
  }
  if (opts?.include?.tasks) {
    registerHelper("tasks", async function(options) {
      const filter2 = options?.hash?.filter ?? {};
      const prismaArgsRendered = !isHandlebarsCtx(filter2) ? await Handlebars.compile(JSON.stringify(filter2))(options?.data?.root ?? this ?? {}) : "{}";
      const prismaArgs = JSON.parse(prismaArgsRendered) ?? {};
      const tasks = await prisma.task.findMany({
        ...prismaArgs,
        where: { date: today.toISOString(), ...prismaArgs.where },
        include: { tags: true, pluginDatas: true, item: { select: { id: true } } }
      }).then((tasks2) => tasks2.map((task) => {
        const titleParsed = import_node_html_parser.default.parse(task.title);
        titleParsed.querySelectorAll("p").forEach((tag) => {
          tag.replaceWith(tag.innerHTML);
        });
        return {
          ...task,
          title: new Handlebars.SafeString(titleParsed.toString())
        };
      }));
      if (!options) {
        if (!tasks.length)
          return `No tasks.`;
        return new Handlebars.SafeString(`<ul>${tasks.map((task) => `<li>${task.title}</li>`).join("")}</ul>`);
      }
      if (!tasks.length) {
        return options.inverse(this);
      }
      let res = "";
      for (const task of tasks) {
        res += await options.fn(task);
      }
      return res;
    });
  }
};
var isHandlebarsCtx = (arg) => {
  return arg && typeof arg === "object" && "lookupProperty" in arg;
};

// src/utils/getPluginOptions.ts
var import_node_html_parser2 = __toESM(require_dist3(), 1);

// ../../node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0)));

// ../../node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0)));

// ../../node_modules/entities/lib/esm/decode_codepoint.js
function replaceCodePoint(codePoint) {
  var _a;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a = decodeMap.get(codePoint)) !== null && _a !== undefined ? _a : codePoint;
}
var _a;
var decodeMap = new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
  let output2 = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output2 += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output2 += String.fromCharCode(codePoint);
  return output2;
};

// ../../node_modules/entities/lib/esm/decode.js
var isNumber = function(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
};
var isHexadecimalCharacter = function(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
};
var isAsciiAlphaNumeric = function(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
};
var isEntityInAttributeInvalidEnd = function(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
};
var getDecoder = function(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
};
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors17) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors17;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base18) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base18, digitCount) + parseInt(str.substr(start, digitCount), base18);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === undefined || _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === undefined || _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === undefined || _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// ../../node_modules/htmlparser2/lib/esm/Tokenizer.js
var isWhitespace = function(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
};
var isEndOfTagSection = function(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
};
var isASCIIAlpha = function(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
};
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["BeforeSpecialT"] = 23] = "BeforeSpecialT";
  State2[State2["SpecialStartSequence"] = 24] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 25] = "InSpecialTag";
  State2[State2["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
};

class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new EntityDecoder(xmlMode ? decode_data_xml_default : decode_data_html_default, (cp, consumed) => this.emitCodePoint(cp, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (this.xmlMode) {
        this.state = State.InTagName;
      } else if (lower === Sequences.ScriptEnd[2]) {
        this.state = State.BeforeSpecialS;
      } else if (lower === Sequences.TitleEnd[2]) {
        this.state = State.BeforeSpecialT;
      } else {
        this.state = State.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = this.index;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    const lower = c | 32;
    if (lower === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (lower === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
  }
  stateInEntity() {
    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
    if (length >= 0) {
      this.state = this.baseState;
      if (length === 0) {
        this.index = this.entityStart;
      }
    } else {
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.BeforeSpecialT: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp, this.sectionStart);
    }
  }
}

// ../../node_modules/htmlparser2/lib/esm/Parser.js
var formTags = new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
  ["tr", new Set(["tr", "th", "td"])],
  ["th", new Set(["th"])],
  ["td", new Set(["thead", "th", "td"])],
  ["body", new Set(["head", "link", "script"])],
  ["li", new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", new Set(["option"])],
  ["optgroup", new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;

class Parser2 {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e, _f;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== undefined ? _a2 : this.htmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : this.htmlMode;
    this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== undefined ? _c : !this.htmlMode;
    this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== undefined ? _d : Tokenizer)(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_f = (_e = this.cbs).onparserinit) === null || _f === undefined || _f.call(_e, this);
  }
  ontext(start, endIndex) {
    var _a2, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === undefined || _b.call(_a2, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === undefined || _b.call(_a2, fromCodePoint(cp));
    this.startIndex = endIndex;
  }
  isVoidElement(name) {
    return this.htmlMode && voidElements.has(name);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = this.htmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.unshift(name);
      if (this.htmlMode) {
        if (foreignContextElements.has(name)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === undefined || _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.indexOf(name);
      if (pos !== -1) {
        for (let index = 0;index <= pos; index++) {
          const element = this.stack.shift();
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, element, index !== pos);
        }
      } else if (this.htmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name === "br") {
      (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, "br");
      (_f = (_e = this.cbs).onopentag) === null || _f === undefined || _f.call(_e, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === undefined || _h.call(_g, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[0] === name) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, name, !isOpenImplied);
      this.stack.shift();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === undefined || _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === undefined || _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = 0;index < this.stack.length; index++) {
        this.cbs.onclosetag(this.stack[index], true);
      }
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === undefined || _b.call(_a2);
  }
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === undefined || _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === undefined || _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === undefined || _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}

// ../../node_modules/domelementtype/lib/esm/index.js
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// ../../node_modules/domhandler/lib/esm/node.js
function isTag2(node3) {
  return isTag(node3);
}
function isCDATA(node3) {
  return node3.type === ElementType.CDATA;
}
function isText(node3) {
  return node3.type === ElementType.Text;
}
function isComment(node3) {
  return node3.type === ElementType.Comment;
}
function isDirective2(node3) {
  return node3.type === ElementType.Directive;
}
function isDocument(node3) {
  return node3.type === ElementType.Root;
}
function hasChildren(node3) {
  return Object.prototype.hasOwnProperty.call(node3, "children");
}
function cloneNode(node3, recursive = false) {
  let result;
  if (isText(node3)) {
    result = new Text2(node3.data);
  } else if (isComment(node3)) {
    result = new Comment2(node3.data);
  } else if (isTag2(node3)) {
    const children = recursive ? cloneChildren(node3.children) : [];
    const clone = new Element(node3.name, { ...node3.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node3.namespace != null) {
      clone.namespace = node3.namespace;
    }
    if (node3["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node3["x-attribsNamespace"] };
    }
    if (node3["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node3["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node3)) {
    const children = recursive ? cloneChildren(node3.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node3)) {
    const children = recursive ? cloneChildren(node3.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node3["x-mode"]) {
      clone["x-mode"] = node3["x-mode"];
    }
    result = clone;
  } else if (isDirective2(node3)) {
    const instruction = new ProcessingInstruction(node3.name, node3.data);
    if (node3["x-name"] != null) {
      instruction["x-name"] = node3["x-name"];
      instruction["x-publicId"] = node3["x-publicId"];
      instruction["x-systemId"] = node3["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node3.type}`);
  }
  result.startIndex = node3.startIndex;
  result.endIndex = node3.endIndex;
  if (node3.sourceCodeLocation != null) {
    result.sourceCodeLocation = node3.sourceCodeLocation;
  }
  return result;
}
var cloneChildren = function(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1;i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
};

class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}

class DataNode extends Node {
  constructor(data) {
    super();
    this.data = data;
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}

class Text2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}

class Comment2 extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}

class ProcessingInstruction extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}

class NodeWithChildren extends Node {
  constructor(children) {
    super();
    this.children = children;
  }
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== undefined ? _a2 : null;
  }
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}

class CDATA2 extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}

class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}

class Element extends NodeWithChildren {
  constructor(name, attribs, children = [], type2 = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type2;
  }
  get nodeType() {
    return 1;
  }
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a2, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === undefined ? undefined : _a2[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
      };
    });
  }
}

// ../../node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};

class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error8) {
    this.handleCallback(error8);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type2 = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element(name, attribs, undefined, type2);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node5 = new Text2(data);
      this.addNode(node5);
      this.lastNode = node5;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node5 = new Comment2(data);
    this.addNode(node5);
    this.lastNode = node5;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node5 = new CDATA2([text]);
    this.addNode(node5);
    text.parent = node5;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node5 = new ProcessingInstruction(name, data);
    this.addNode(node5);
  }
  handleCallback(error8) {
    if (typeof this.callback === "function") {
      this.callback(error8, this.dom);
    } else if (error8) {
      throw error8;
    }
  }
  addNode(node5) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node5.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node5.endIndex = this.parser.endIndex;
    }
    parent.children.push(node5);
    if (previousSibling) {
      node5.prev = previousSibling;
      previousSibling.next = node5;
    }
    node5.parent = parent;
    this.lastNode = null;
  }
}

// ../../node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser2(handler, options).end(data);
  return handler.root;
}
// ../../node_modules/domutils/lib/esm/index.js
var exports_esm2 = {};
__export(exports_esm2, {
  uniqueSort: () => {
    {
      return uniqueSort;
    }
  },
  textContent: () => {
    {
      return textContent;
    }
  },
  testElement: () => {
    {
      return testElement;
    }
  },
  replaceElement: () => {
    {
      return replaceElement;
    }
  },
  removeSubsets: () => {
    {
      return removeSubsets;
    }
  },
  removeElement: () => {
    {
      return removeElement;
    }
  },
  prevElementSibling: () => {
    {
      return prevElementSibling;
    }
  },
  prependChild: () => {
    {
      return prependChild;
    }
  },
  prepend: () => {
    {
      return prepend;
    }
  },
  nextElementSibling: () => {
    {
      return nextElementSibling;
    }
  },
  isText: () => {
    {
      return isText;
    }
  },
  isTag: () => {
    {
      return isTag2;
    }
  },
  isDocument: () => {
    {
      return isDocument;
    }
  },
  isComment: () => {
    {
      return isComment;
    }
  },
  isCDATA: () => {
    {
      return isCDATA;
    }
  },
  innerText: () => {
    {
      return innerText;
    }
  },
  hasChildren: () => {
    {
      return hasChildren;
    }
  },
  hasAttrib: () => {
    {
      return hasAttrib;
    }
  },
  getText: () => {
    {
      return getText;
    }
  },
  getSiblings: () => {
    {
      return getSiblings;
    }
  },
  getParent: () => {
    {
      return getParent;
    }
  },
  getOuterHTML: () => {
    {
      return getOuterHTML;
    }
  },
  getName: () => {
    {
      return getName;
    }
  },
  getInnerHTML: () => {
    {
      return getInnerHTML;
    }
  },
  getFeed: () => {
    {
      return getFeed;
    }
  },
  getElementsByTagType: () => {
    {
      return getElementsByTagType;
    }
  },
  getElementsByTagName: () => {
    {
      return getElementsByTagName;
    }
  },
  getElements: () => {
    {
      return getElements;
    }
  },
  getElementById: () => {
    {
      return getElementById;
    }
  },
  getChildren: () => {
    {
      return getChildren;
    }
  },
  getAttributeValue: () => {
    {
      return getAttributeValue;
    }
  },
  findOneChild: () => {
    {
      return findOneChild;
    }
  },
  findOne: () => {
    {
      return findOne;
    }
  },
  findAll: () => {
    {
      return findAll;
    }
  },
  find: () => {
    {
      return find;
    }
  },
  filter: () => {
    {
      return filter2;
    }
  },
  existsOne: () => {
    {
      return existsOne;
    }
  },
  compareDocumentPosition: () => {
    {
      return compareDocumentPosition;
    }
  },
  appendChild: () => {
    {
      return appendChild;
    }
  },
  append: () => {
    {
      return append;
    }
  },
  DocumentPosition: () => {
    {
      return DocumentPosition;
    }
  }
});

// ../../node_modules/dom-serializer/node_modules/entities/lib/esm/escape.js
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
var getEscaper = function(regex, map3) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map3.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
};
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
// ../../node_modules/dom-serializer/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// ../../node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// ../../node_modules/dom-serializer/lib/esm/index.js
var replaceQuotes = function(value) {
  return value.replace(/"/g, "&quot;");
};
var formatAttributes = function(attributes, opts) {
  var _a2;
  if (!attributes)
    return;
  const encode = ((_a2 = opts.encodeEntities) !== null && _a2 !== undefined ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes[key]) !== null && _a3 !== undefined ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
};
function render(node5, options = {}) {
  const nodes = "length" in node5 ? node5 : [node5];
  let output2 = "";
  for (let i = 0;i < nodes.length; i++) {
    output2 += renderNode(nodes[i], options);
  }
  return output2;
}
var renderNode = function(node5, options) {
  switch (node5.type) {
    case Root:
      return render(node5.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node5);
    case Comment:
      return renderComment(node5);
    case CDATA:
      return renderCdata(node5);
    case Script:
    case Style:
    case Tag:
      return renderTag(node5, options);
    case Text:
      return renderText(node5, options);
  }
};
var renderTag = function(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== undefined ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
};
var renderDirective = function(elem) {
  return `<${elem.data}>`;
};
var renderText = function(elem, opts) {
  var _a2;
  let data = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== undefined ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
};
var renderCdata = function(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
};
var renderComment = function(elem) {
  return `<!--${elem.data}-->`;
};
var unencodedElements = new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
var singleTag = new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var esm_default9 = render;
var foreignModeIntegrationPoints = new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = new Set(["svg", "math"]);

// ../../node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node5, options) {
  return esm_default9(node5, options);
}
function getInnerHTML(node5, options) {
  return hasChildren(node5) ? node5.children.map((node6) => getOuterHTML(node6, options)).join("") : "";
}
function getText(node5) {
  if (Array.isArray(node5))
    return node5.map(getText).join("");
  if (isTag2(node5))
    return node5.name === "br" ? "\n" : getText(node5.children);
  if (isCDATA(node5))
    return getText(node5.children);
  if (isText(node5))
    return node5.data;
  return "";
}
function textContent(node5) {
  if (Array.isArray(node5))
    return node5.map(textContent).join("");
  if (hasChildren(node5) && !isComment(node5)) {
    return textContent(node5.children);
  }
  if (isText(node5))
    return node5.data;
  return "";
}
function innerText(node5) {
  if (Array.isArray(node5))
    return node5.map(innerText).join("");
  if (hasChildren(node5) && (node5.type === ElementType.Tag || isCDATA(node5))) {
    return innerText(node5.children);
  }
  if (isText(node5))
    return node5.data;
  return "";
}
// ../../node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue(elem, name) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === undefined ? undefined : _a2[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag2(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag2(prev))
    ({ prev } = prev);
  return prev;
}
// ../../node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
// ../../node_modules/domutils/lib/esm/querying.js
function filter2(test, node5, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node5) ? node5 : [node5], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (;; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  let elem = null;
  for (let i = 0;i < nodes.length && !elem; i++) {
    const node5 = nodes[i];
    if (!isTag2(node5)) {
      continue;
    } else if (test(node5)) {
      elem = node5;
    } else if (recurse && node5.children.length > 0) {
      elem = findOne(test, node5.children, true);
    }
  }
  return elem;
}
function existsOne(test, nodes) {
  return nodes.some((checked) => isTag2(checked) && (test(checked) || existsOne(test, checked.children)));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (;; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag2(elem))
      continue;
    if (test(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
// ../../node_modules/domutils/lib/esm/legacy.js
var getAttribCheck = function(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
};
var combineFuncs = function(a, b) {
  return (elem) => a(elem) || b(elem);
};
var compileTest = function(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
};
function testElement(options, node5) {
  const test = compileTest(options);
  return test ? test(node5) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter2(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter2(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type2, nodes, recurse = true, limit = Infinity) {
  return filter2(Checks["tag_type"](type2), nodes, recurse, limit);
}
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type2) {
    if (typeof type2 === "function") {
      return (elem) => type2(elem.type);
    }
    return (elem) => elem.type === type2;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
// ../../node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node5 = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node5, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node5.parent;ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node5, i, arr) => !arr.includes(node5, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
// ../../node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
var getAtomFeed = function(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a3 = getOneElement("link", children)) === null || _a3 === undefined ? undefined : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description3 = fetch6("summary", children) || fetch6("content", children);
      if (description3) {
        entry.description = description3;
      }
      const pubDate = fetch6("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === undefined ? undefined : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch6("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
};
var getRssFeed = function(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === undefined ? undefined : _a2.children) !== null && _b !== undefined ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch6("pubDate", children) || fetch6("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch6("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
};
var getMediaElements = function(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
};
var getOneElement = function(tagName, node5) {
  return getElementsByTagName(tagName, node5, true, 1)[0];
};
var fetch6 = function(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
};
var addConditionally = function(obj, prop, tagName, where, recurse = false) {
  const val = fetch6(tagName, where, recurse);
  if (val)
    obj[prop] = val;
};
var isValidFeed = function(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
};
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
// ../../node_modules/html-to-slack/dist/utils/index.js
function linearizeLists(input6) {
  const document2 = parseDocument(input6);
  const result = [];
  function processList(listElement, indentLevel) {
    const listType = listElement.tagName;
    const listItems = [];
    exports_esm2.getChildren(listElement).forEach((child) => {
      if (exports_esm2.isTag(child) && child.tagName === "li") {
        const listItemContent = exports_esm2.getInnerHTML(child).trim().replace(/<ul[\s\S]*?<\/ul>/g, "").replace(/<ol[\s\S]*?<\/ol>/g, "").replace(/<li[\s\S]*?<\/li>/g, "");
        listItems.push(`<li>${listItemContent}</li>`);
        const nestedList = exports_esm2.getChildren(child).find((nestedChild) => exports_esm2.isTag(nestedChild) && (nestedChild.tagName === "ul" || nestedChild.tagName === "ol"));
        if (nestedList) {
          result.push(`<${listType} indent=${indentLevel}>${listItems.join("")}</${listType}>`);
          listItems.length = 0;
          processList(nestedList, indentLevel + 1);
        }
      }
    });
    if (listItems.length > 0) {
      result.push(`<${listType} indent=${indentLevel}>${listItems.join("")}</${listType}>`);
    }
  }
  exports_esm2.getElementsByTagName("ul", document2).concat(exports_esm2.getElementsByTagName("ol", document2)).forEach((element) => {
    const parent = exports_esm2.getParent(element);
    if (parent && exports_esm2.isTag(parent) && (parent.tagName === "li" || parent.tagName === "ul" || parent.tagName === "ol"))
      return;
    processList(element, 0);
    const newElement = result.join("");
    input6 = input6.replace(exports_esm2.getOuterHTML(element), newElement);
    result.length = 0;
  });
  return input6;
}
function blockBuilder(array) {
  const blocks = [];
  let richTextBlocks = {
    type: "rich_text",
    elements: []
  };
  for (let i = 0;i < array.length; i++) {
    const block2 = array[i];
    if (block2.type === "image" || block2.type === "header") {
      if (richTextBlocks.elements.length > 0) {
        blocks.push(richTextBlocks);
        richTextBlocks = {
          type: "rich_text",
          elements: []
        };
      }
      blocks.push(block2);
    } else {
      richTextBlocks.elements.push(block2);
    }
  }
  if (richTextBlocks.elements.length > 0) {
    blocks.push(richTextBlocks);
  }
  return blocks;
}

// ../../node_modules/html-to-slack/dist/parsers/index.js
var findDomElementsByTagName = function(dom, tag) {
  return exports_esm2.findAll((node5) => node5.type === "tag" && node5.name === tag, dom);
};
var parseNodeElement = function(node5) {
  const block2 = {};
  switch (node5.type) {
    case "tag": {
      switch (node5.name) {
        case "b":
        case "strong":
        case "i":
        case "em":
        case "s":
        case "del":
        case "code":
        case "a":
          return parseText(node5);
        default:
          break;
      }
      break;
    }
    case "text":
      return parseText(node5);
  }
  return block2;
};
var parseNode = function(node5) {
  let block2 = {};
  switch (node5.type) {
    case "tag": {
      switch (node5.name) {
        case "ul":
        case "ol":
          block2 = {
            type: "rich_text_list",
            style: node5.name === "ul" ? "bullet" : "ordered",
            elements: [],
            indent: parseInt(node5.attribs["indent"])
          };
          break;
        case "li":
          block2 = {
            type: "rich_text_section",
            elements: []
          };
          break;
        case "pre":
          block2 = {
            type: "rich_text_preformatted",
            elements: []
          };
          break;
        case "blockquote":
          block2 = {
            type: "rich_text_quote",
            elements: []
          };
          break;
        case "img":
          block2 = {
            type: "image",
            image_url: node5.attribs.src,
            alt_text: node5.attribs.alt || ""
          };
          if (node5.attribs.title) {
            block2.title = {
              type: "plain_text",
              text: node5.attribs.title
            };
          }
          break;
        case "p":
          block2 = {
            type: "rich_text_section",
            elements: []
          };
          break;
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return parseHeader(node5);
      }
      if (block2 && node5.children) {
        for (const child of node5.children) {
          const childObj = child.type === "tag" && nodes.includes(child.name) ? parseNode(child) : parseNodeElement(child);
          if (childObj && "elements" in block2) {
            if (!Array.isArray(childObj)) {
              block2.elements.push(...[childObj]);
            } else {
              block2.elements.push(...childObj);
            }
            block2.elements = block2.elements.filter((element) => Object.keys(element).length !== 0);
          }
        }
      }
      break;
    }
  }
  return block2;
};
var parseHeader = function(node5) {
  const header = {};
  if (node5.children && node5.children[0] && node5.children[0].type === "text" && node5.children[0].data) {
    header.type = "header";
    header.text = {
      type: "plain_text",
      text: node5.children[0].data
    };
  }
  return header;
};
var parseText = function(node5, style = {}) {
  const texts = [];
  if (node5.type === "tag") {
    switch (node5.name) {
      case "b":
      case "strong":
        style.bold = true;
        break;
      case "i":
      case "em":
        style.italic = true;
        break;
      case "s":
      case "del":
        style.strike = true;
        break;
      case "code":
        style.code = true;
        break;
      default:
        break;
    }
    if (node5.name === "a") {
      const textElement = {
        type: "link",
        url: node5.attribs.href
      };
      if (Object.keys(style).length > 0) {
        textElement.style = Object.assign({}, style);
      }
      if (node5.children) {
        if (node5.children[0].type === "text") {
          textElement.text = node5.children[0].data;
        }
      }
      texts.push(textElement);
    } else {
      for (const child of node5.children) {
        texts.push(...parseText(child, Object.assign({}, style)));
      }
    }
  } else if (node5.type === "text") {
    const textElement = {
      type: "text",
      text: node5.data.replace(/<br ?\/?>/g, "\n").replace(/^\s*$/, "")
    };
    if (Object.keys(style).length > 0) {
      textElement.style = Object.assign({}, style);
    }
    texts.push(textElement);
  }
  return texts;
};
var compressHTML = function(html) {
  const document2 = parseDocument(html);
  const correctedHtml = exports_esm2.getOuterHTML(document2);
  html = correctedHtml;
  const preTags = [];
  const preLeadingSpaces = [];
  html = html.replace(/([ \t]*)<pre>([\s\S]*?)<\/pre>/g, (match, leadingSpaces, content) => {
    preTags.push(content.replace(/^\n/, ""));
    preLeadingSpaces.push(leadingSpaces);
    return `<pre>${preTags.length - 1}</pre>`;
  });
  const tagAttributes = [];
  html = html.replace(/<(\w+)([^>]*)>/g, (match, tagName, attributes) => {
    tagAttributes.push(attributes);
    return `<${tagName} data-tag-attr="${tagAttributes.length - 1}">`;
  });
  html = html.replace(/\n[\n ]*/g, "");
  html = html.replace(/<(\w+) data-tag-attr="(\d+)">/g, (match, tagName, index) => {
    return `<${tagName}${tagAttributes[parseInt(index)]}>`;
  });
  html = html.replace(/<pre>(\d+)<\/pre>/g, (match, index) => {
    const content = preTags[parseInt(index)];
    const leadingSpaces = preLeadingSpaces[parseInt(index)];
    const adjustedContent = content.replace(new RegExp("^" + leadingSpaces, "mg"), "");
    return `<pre>${adjustedContent}</pre>`;
  });
  html = html.replace(/<br ?\/?>/g, "\n").replace(/<\/?span[^>]*>/g, "").replace(/<\/?div[^>]*>/g, "");
  html = html.replace(/<p>([\s\S]*?)<\/p>/g, (match, content) => {
    content = content.replace(/(\S)(<b>|<i>|<code>)/g, "$1 $2");
    return `<p>${content}</p>`;
  });
  return html;
};
function parseHtml(html) {
  html = compressHTML(html);
  html = linearizeLists(html);
  const dom = parseDocument(html);
  const body = findDomElementsByTagName(dom.children, "body")[0] || dom;
  const blocks = [];
  body.children.forEach((node5) => {
    blocks.push(parseNode(node5));
  });
  const blocksObj = blockBuilder(blocks);
  return blocksObj;
}
var nodes = [
  "ul",
  "ol",
  "li",
  "pre",
  "blockquote",
  "img",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "p"
];

// ../../node_modules/html-to-slack/dist/index.js
var convertHtmlToSlackBlocks = function(html) {
  if (typeof html !== "string") {
    console.error("Invalid input: HTML content should be a string.");
    return [];
  }
  try {
    return parseHtml(html);
  } catch (error8) {
    console.error("Error converting HTML to Slack blocks:", error8);
    return [];
  }
};
var dist_default = convertHtmlToSlackBlocks;

// src/utils/getPluginOptions.ts
var getPluginOptions = (pluginSlug) => ({
  pluginSlug,
  serverOrigin: env.ORIGIN,
  dayjs,
  pgBoss: {
    send: pgBoss.send,
    sendAfter: pgBoss.sendAfter,
    sendOnce: pgBoss.sendOnce,
    sendSingleton: pgBoss.sendSingleton,
    sendThrottled: pgBoss.sendThrottled,
    sendDebounced: pgBoss.sendDebounced,
    schedule: pgBoss.schedule,
    unschedule: pgBoss.unschedule,
    cancel: pgBoss.cancel
  },
  prisma: {
    day: {
      findUnique: prisma.day.findUnique,
      findUniqueOrThrow: prisma.day.findUniqueOrThrow,
      findFirst: prisma.day.findFirst,
      findFirstOrThrow: prisma.day.findFirstOrThrow,
      findMany: prisma.day.findMany,
      count: prisma.day.count,
      aggregate: prisma.day.aggregate,
      groupBy: prisma.day.groupBy
    },
    note: prisma.note,
    noteTag: prisma.noteTag,
    task: prisma.task,
    taskPluginData: prisma.taskPluginData,
    taskTag: prisma.taskTag,
    item: prisma.item,
    itemPluginData: prisma.itemPluginData,
    list: prisma.list,
    routine: prisma.routine,
    routineStep: prisma.routineStep,
    template: prisma.template
  },
  store: {
    setItem: async (key, value) => {
      if (typeof value === "symbol" || typeof value === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value },
        create: { pluginSlug, key, value }
      });
      return result;
    },
    setSecretItem: async (key, value) => {
      if (typeof value === "symbol" || typeof value === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value },
        create: { pluginSlug, key, value, isSecret: true, isServerOnly: true }
      });
      return result;
    },
    setServerOnlyItem: async (key, value) => {
      if (typeof value === "symbol" || typeof value === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value },
        create: { pluginSlug, key, value, isServerOnly: true }
      });
      return result;
    },
    deleteItem: async (key) => {
      const result = await prisma.store.delete({
        where: { pluginSlug_key_unique: { pluginSlug, key } }
      });
      return result;
    },
    getPluginItem: async (key) => {
      const result = await prisma.store.findFirst({
        where: { key, pluginSlug }
      });
      return result;
    },
    getItem: async (key, opts) => {
      const result = await prisma.store.findFirst({
        where: { key, pluginSlug: opts?.pluginSlug, isSecret: false }
      });
      return result;
    }
  },
  getUsersTimezone,
  getInstalledPlugins: async () => {
    const plugins4 = await getPlugins2();
    return Object.keys(plugins4).map((slug) => ({ slug }));
  },
  getNearestItemColor: (hex) => nearestTailwindColor(hex),
  GraphQLError,
  renderTemplate,
  Handlebars: { SafeString: Handlebars.SafeString },
  html: {
    parse: import_node_html_parser2.default.parse,
    toSlack: dist_default,
    escape: htmlEscape,
    unescape: htmlUnescape
  },
  decodeGlobalId,
  encodeGlobalId
});

// src/utils/getPlugins.ts
async function installServerPlugin(opts) {
  const res = await fetch(`${opts.url}/server.js`).catch((err) => {
    if (err.message === "fetch failed") {
      throw new GraphQLError(`Got no response. Make sure the URL is correct: "${opts.url}/server.js"`);
    }
    throw new GraphQLError(err.message);
  });
  if (!res.ok) {
    throw new GraphQLError(`Got status code ${res.status} from "${opts.url}/server.js"`);
  }
  const text = await res.text();
  if (text.startsWith("Couldn't find the requested file")) {
    throw new GraphQLError(`Couldn't find the plugin at "${opts.url}/server.js"`);
  }
  try {
    await fs.readdir(pathToPlugins);
  } catch (err) {
    if (err.code !== "ENOENT") {
      throw err;
    }
    await fs.mkdir(pathToPlugins, { recursive: true });
  }
  if (/Bun|require(?=\(|\/\*)|eval|setTimeout|setInterval|setImmidiate|process\.|__dirname|__filename|spawnSync|spawn|write|import\.meta| ffi|transpile|transform| \$`/.test(text)) {
    throw new GraphQLError(`The plugin is unsafe to install as it can gain access to sensitive data. Contact the plugin author or install a different plugin.`);
  }
  await Bun.write(pathToTemp, text);
  delete import.meta.require.cache[pathToTemp];
  let exported;
  try {
    exported = import.meta.require(pathToTemp);
  } catch (e) {
    console.log(e);
    throw new GraphQLError(`Couldn't install the server part of the plugin. Contact the plugin author to fix this.`);
  }
  if (typeof exported !== "object") {
    throw new GraphQLError(`Couldn't find any exports at "${opts.url}/server.js"`);
  }
  if ("default" in exported) {
    exported = exported.default;
  }
  if (typeof exported.plugin !== "function") {
    throw new GraphQLError(`The exports of "${opts.url}/server.js" must have a \`plugin\` property which is a function. Please use \`definePlugin\` from \`@flowdev/plugin/server\`.`);
  }
  if (!opts.override && cache3.has(opts.slug)) {
    throw new GraphQLError(`PLUGIN_WITH_SAME_SLUG: A plugin with the slug "${opts.slug}" is already installed. Use the \`override\` option to override the existing plugin.`);
  }
  await fs.rename(pathToTemp, path.join(pathToPlugins, `${opts.slug}.js`));
  const plugin3 = exported.plugin(getPluginOptions(opts.slug));
  cache3.set(opts.slug, plugin3);
  await reloadPluginPgBossWorkers({
    pluginSlug: opts.slug,
    plugins: Object.fromEntries(cache3.entries())
  });
  await plugin3.onInstall?.();
}
async function uninstallServerPlugin(slug) {
  await cache3.get(slug)?.onUninstall?.();
  await fs.unlink(path.join(pathToPlugins, `${slug}.js`));
  cache3.delete(slug);
}
var cache3 = new Map;
var pathToPlugins = path.join(import.meta.dir, env.PATH_TO_PLUGINS ?? "../../plugins");
var pathToTemp = path.join(pathToPlugins, "__temp.js");
var getPlugins2 = async () => {
  const plugins4 = (await fs.readdir(pathToPlugins).catch(() => [])).filter((p) => p.endsWith(".js") && p !== "__temp.js").map((p) => p.replace(".js", ""));
  const unCachedPlugins = plugins4.filter((plugin3) => !cache3.has(plugin3));
  if (unCachedPlugins.length === 0) {
    return Object.fromEntries(cache3);
  }
  for (const pluginSlug of unCachedPlugins) {
    let exported = import.meta.require(path.join(pathToPlugins, pluginSlug));
    if ("default" in exported) {
      exported = exported.default;
    }
    cache3.set(pluginSlug, exported.plugin(getPluginOptions(pluginSlug)));
  }
  return Object.fromEntries(cache3);
};
var getPluginsInStore = async () => {
  const storeItem = await prisma.store.findFirst({
    where: {
      key: StoreKeys.INSTALLED_PLUGINS,
      isSecret: false,
      isServerOnly: false,
      pluginSlug: FlowPluginSlug
    }
  });
  return storeItem?.value ?? [];
};
var getPluginJson = async (opts) => {
  const res = await fetch(`${opts.url}/plugin.json`).catch((err) => {
    if (err.message === "fetch failed") {
      throw new GraphQLError(`Got no response. Make sure the URL is correct: "${opts.url}/plugin.json"`);
    }
    throw new GraphQLError(err.message);
  });
  if (!res.ok) {
    throw new GraphQLError(`Got status code ${res.status} from "${opts.url}/plugin.json"`);
  }
  const text = await res.text();
  if (text.startsWith("Couldn't find the requested file")) {
    throw new GraphQLError(`Couldn't find the plugin at "${opts.url}/server.js"`);
  }
  try {
    return JSON.parse(text);
  } catch (err) {
    throw new GraphQLError(`Couldn't parse JSON of "${opts.url}/plugin.json"`);
  }
};

// src/utils/urlSafe.ts
var urlSafe = (str) => {
  return str.replace(/[^a-zA-Z0-9-_]/g, "").toLowerCase().replace(/-+/g, "-");
};
var verifyUrlSafe = (str) => {
  return str.match(/^[a-zA-Z0-9-_]+$/);
};

// src/graphql/TaskTag.ts
var TaskTagType = builder5.prismaNode("TaskTag", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    slug: t.exposeString("slug"),
    color: t.expose("color", { type: ColorEnum }),
    tasks: t.relatedConnection("tasks", { cursor: "id" }),
    isPrivate: t.exposeBoolean("isPrivate")
  })
});
builder5.queryField("taskTags", (t) => t.prismaConnection({
  type: "TaskTag",
  cursor: "id",
  description: "Get all task tags ordered by usage in descending order. `before` and `after` cursors are ignored, and `first` and `last` act the same and are limited to 100.",
  args: {
    where: t.arg({
      type: TaskTagWhereInput,
      required: false,
      description: "Filters to use when querying task tags."
    })
  },
  resolve: (query3, _, args) => {
    const where = args.where;
    return prisma.taskTag.findMany({
      ...query3,
      where: {
        ...where?.nameIsLike ? { name: { contains: where.nameIsLike, mode: "insensitive" } } : {},
        ...where?.isPrivate ? { isPrivate: { equals: where.isPrivate } } : {}
      },
      orderBy: { tasks: { _count: "desc" } },
      take: Math.min(args.first ?? args.last ?? 100, 100)
    });
  }
}));
var TaskTagWhereInput = builder5.inputType("TaskTagWhereInput", {
  fields: (t) => ({
    nameIsLike: t.string({
      required: false,
      description: "Filter by name. Case insensitive."
    }),
    isPrivate: t.boolean({
      required: false,
      description: "Filter by whether the tag is for private use."
    })
  })
});
var CreateTaskTagInput = builder5.inputType("CreateTaskTagInput", {
  fields: (t) => ({
    name: t.string({ required: true, description: "The name of the task tag." }),
    color: t.field({
      type: ColorEnum,
      required: true,
      description: "The color of the task tag."
    }),
    isPrivate: t.boolean({
      required: true,
      description: "Whether tasks with this tag will be considered private."
    })
  })
});
builder5.mutationField("createTaskTag", (t) => t.prismaFieldWithInput({
  type: "TaskTag",
  description: "Create a new task tag.",
  input: {
    name: t.input.string({ required: true, description: "The name of the task tag." }),
    color: t.input.field({
      type: ColorEnum,
      required: true,
      description: "The color of the task tag."
    }),
    isPrivate: t.input.boolean({
      required: true,
      description: "Whether tasks with this tag will be considered private."
    })
  },
  resolve: async (query3, _, args) => {
    const slug = createTaskTagSlug(args.input.name);
    return prisma.taskTag.create({
      ...query3,
      data: {
        name: args.input.name,
        color: args.input.color,
        isPrivate: args.input.isPrivate,
        slug
      }
    });
  }
}));
var createTaskTagSlug = (name) => urlSafe(name);
builder5.mutationField("updateTaskTag", (t) => t.prismaFieldWithInput({
  type: "TaskTag",
  description: "Update a task tag.",
  input: {
    id: t.input.globalID({
      required: true,
      description: "The Relay ID of the task tag to update."
    }),
    name: t.input.string({ required: false, description: "The new name of the task tag." }),
    color: t.input.field({
      type: ColorEnum,
      required: false,
      description: "The new color of the task tag."
    }),
    isPrivate: t.input.boolean({
      required: false,
      description: "Whether tasks with this tag will be considered private."
    })
  },
  resolve: async (query3, _, args) => {
    const tag = await prisma.taskTag.findUnique({
      where: { id: parseInt(args.input.id.id) }
    });
    if (!tag) {
      throw new GraphQLError(`Tag with ID ${args.input.id.id} not found.`, {
        extensions: {
          code: "TAG_NOT_FOUND",
          userFriendlyMessage: "The tag was not found. Please try refreshing the page and try again."
        }
      });
    }
    const slug = args.input.name?.toLowerCase().replaceAll(" ", "-");
    return prisma.taskTag.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: {
        name: u(args.input.name),
        color: u(args.input.color),
        isPrivate: u(args.input.isPrivate),
        slug: u(slug)
      }
    });
  }
}));
builder5.mutationField("deleteTaskTag", (t) => t.prismaFieldWithInput({
  type: "TaskTag",
  description: "Delete a task tag.",
  input: {
    id: t.input.globalID({
      required: true,
      description: "The Relay ID of the task tag to delete."
    })
  },
  resolve: async (query3, _, args) => {
    const tag = await prisma.taskTag.findUnique({
      where: { id: parseInt(args.input.id.id) }
    });
    if (!tag) {
      throw new GraphQLError(`Tag with ID ${args.input.id.id} not found.`, {
        extensions: {
          code: "TAG_NOT_FOUND",
          userFriendlyMessage: "The tag was not found. Please try refreshing the page and try again."
        }
      });
    }
    return prisma.taskTag.delete({
      ...query3,
      where: { id: parseInt(args.input.id.id) }
    });
  }
}));

// src/graphql/Task.ts
var TaskType = builder5.prismaNode("Task", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    title: t.exposeString("title"),
    status: t.expose("status", { type: TaskStatusEnum }),
    completedAt: t.expose("completedAt", { type: "DateTime", nullable: true }),
    date: t.expose("date", { type: "Date" }),
    itemId: t.id({
      nullable: true,
      resolve: (task) => task.itemId ? `Item_${task.itemId}` : null
    }),
    item: t.relation("item", { nullable: true }),
    durationInMinutes: t.int({
      nullable: true,
      description: "The length of time the task is expected to take.",
      select: { item: { select: { durationInMinutes: true } } },
      resolve: (task) => {
        return task.durationInMinutes ?? task.item?.durationInMinutes;
      }
    }),
    tags: t.relation("tags"),
    pluginDatas: t.relation("pluginDatas"),
    subtasks: t.prismaField({
      type: ["Task"],
      description: "The subtasks of the task.",
      resolve: async (query3, task) => {
        const order = task.subtasksOrder ?? [];
        const subtasks = await prisma.task.findMany({ ...query3, where: { parentTaskId: task.id } });
        return subtasks.sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id));
      }
    })
  })
});
var TaskStatusEnum = builder5.enumType("TaskStatus", {
  values: {
    TODO: {
      description: "When the task is planned or in progress.",
      value: "TODO"
    },
    CANCELED: {
      description: "When the task was decided not to be done anymore.",
      value: "CANCELED"
    },
    DONE: {
      description: "When the task is done.",
      value: "DONE"
    }
  }
});
var TaskStatusFilter = builder5.prismaFilter(TaskStatusEnum, {
  ops: ["equals", "not", "in", "notIn"]
});
var TaskWhereInputType = builder5.prismaWhere("Task", {
  fields: {
    status: TaskStatusFilter,
    date: DateFilter,
    completedAt: DateTimeFilter
  }
});
var TaskListWhereInputType = builder5.prismaListFilter(TaskWhereInputType, {
  ops: ["every", "some", "none"]
});
builder5.mutationField("createTask", (t) => t.prismaFieldWithInput({
  type: "Task",
  description: `Create a new task.`,
  input: {
    title: t.input.string({ required: true, description: "The title of the task." }),
    status: t.input.field({
      type: TaskStatusEnum,
      defaultValue: "TODO",
      description: "The initial status of the task. Defaults to `TODO`."
    }),
    durationInMinutes: t.input.field({
      type: "PositiveInt",
      description: "The length of time (in minutes) the task is expected to take."
    }),
    date: t.input.field({
      type: "Date",
      description: "The day (no time required) the task is planned for."
    }),
    itemId: t.input.globalID({
      description: "The Relay ID of the Item that should be linked to the task."
    }),
    atIndex: t.input.int({
      description: "The position in the day the task should be placed at. If not specified, it will be placed at the beginning."
    }),
    pluginDatas: t.input.field({
      description: "The plugin data to be linked to the task.",
      type: [TaskPluginDataInput]
    }),
    actionDatas: t.input.field({
      description: "Additional data separate from the pluginDatas to be passed to the plugins when creating the task.",
      type: [TaskActionDataInput]
    }),
    tags: t.input.globalIDList({
      required: false,
      description: "The IDs of exsiting tags to be linked to the task. If you want to create a new tag, use the `newTags` input."
    }),
    newTags: t.input.field({
      type: [CreateTaskTagInput],
      required: false,
      description: "Create new tags and link them to the task."
    })
  },
  resolve: async (query3, _, args) => {
    const date = args.input.date ?? startOfDay(new Date);
    const index = args.input.atIndex ?? 0;
    const plugins4 = await getPlugins2();
    const pluginDatas = [];
    let item;
    if (args.input.itemId) {
      item = await prisma.item.findUnique({
        where: { id: parseInt(args.input.itemId?.id) },
        include: { pluginDatas: true }
      });
    }
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      const actionData = args.input.actionDatas?.find((actionData2) => actionData2.pluginSlug === pluginSlug)?.data;
      const webPluginData = args.input.pluginDatas?.find((pluginData) => pluginData.pluginSlug === pluginSlug);
      const result = await plugin3.onCreateTask?.({
        actionData,
        task: {
          title: args.input.title,
          status: args.input.status,
          durationInMinutes: args.input.durationInMinutes,
          date,
          item,
          pluginData: {
            originalId: webPluginData?.originalId,
            min: webPluginData?.min,
            full: webPluginData?.full
          }
        }
      }).catch((e) => {
        console.log(`Error plugin.onCreateTask for ${pluginSlug}`, e);
        return null;
      });
      if (result?.pluginData) {
        pluginDatas.push({
          pluginSlug,
          originalId: result.pluginData.originalId,
          min: result.pluginData.min,
          full: result.pluginData.full
        });
      }
    }
    return prisma.$transaction(async (tx) => {
      const tags = {
        connect: args.input.tags?.map((globalId) => ({ id: parseInt(globalId.id) })) ?? [],
        create: args.input.newTags?.map((tag) => ({
          name: tag.name,
          slug: createTaskTagSlug(tag.name),
          color: tag.color,
          isPrivate: tag.isPrivate
        }))
      };
      const task = await tx.task.create({
        ...query3,
        data: {
          title: args.input.title,
          status: u(args.input.status),
          durationInMinutes: args.input.durationInMinutes,
          day: { connectOrCreate: { where: { date }, create: { date } } },
          ...args.input.itemId ? { item: { connect: { id: parseInt(args.input.itemId.id) } } } : {},
          pluginDatas: { createMany: { data: pluginDatas } },
          tags
        }
      });
      const day2 = await tx.day.findUnique({ where: { date }, select: { tasksOrder: true } });
      const newTasksOrder = [
        ...day2.tasksOrder.slice(0, index),
        task.id,
        ...day2.tasksOrder.slice(index)
      ];
      await tx.day.update({ where: { date }, data: { tasksOrder: { set: newTasksOrder } } });
      return task;
    });
  }
}));
var TaskPluginDataInput = builder5.inputType("TaskPluginDataInput", {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    originalId: t.string({ required: false }),
    min: t.field({ type: "JSON" }),
    full: t.field({ type: "JSON" })
  })
});
var TaskActionDataInput = builder5.inputType("TaskActionDataInput", {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    data: t.field({ type: "JSON" })
  })
});
builder5.mutationField("updateTask", (t) => t.prismaFieldWithInput({
  type: "Task",
  description: `Update a task.`,
  input: {
    id: t.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    title: t.input.string({ description: "The title of the task." }),
    durationInMinutes: t.input.field({
      type: "PositiveInt",
      description: "The length of time (in minutes) the task is expected to take."
    }),
    tags: t.input.globalIDList({
      required: false,
      description: "The IDs of exsiting tags to be linked to the task. If you want to create a new tag, use the `newTags` input."
    }),
    newTags: t.input.field({
      type: [CreateTaskTagInput],
      required: false,
      description: "Create new tags and link them to the task."
    }),
    removeTags: t.input.globalIDList({
      required: false,
      description: "The IDs of tags to be unlinked from the task. If you want to create a new tag, use the `newTags` input."
    })
  },
  resolve: async (query3, _, args) => {
    const updatedTask = await prisma.task.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      include: { ...query3.include, pluginDatas: true },
      data: {
        title: u(args.input.title),
        durationInMinutes: args.input.durationInMinutes,
        tags: {
          connect: args.input.tags?.map((globalId) => ({ id: parseInt(globalId.id) })) ?? [],
          create: args.input.newTags?.map((tag) => ({
            name: tag.name,
            slug: createTaskTagSlug(tag.name),
            color: tag.color,
            isPrivate: tag.isPrivate
          })),
          disconnect: args.input.removeTags?.map((globalId) => ({ id: parseInt(globalId.id) })) ?? []
        }
      }
    });
    const plugins4 = await getPlugins2();
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      await plugin3.onUpdateTaskEnd?.({ task: updatedTask }).catch(console.error);
    }
    return updatedTask;
  }
}));
builder5.mutationField("deleteTask", (t) => t.prismaField({
  type: "Task",
  description: `Delete a task.`,
  args: {
    id: t.arg.globalID({ required: true, description: "The Relay ID of the task to delete." })
  },
  resolve: async (query3, _, args) => {
    const task = await prisma.task.delete({ ...query3, where: { id: parseInt(args.id.id) } });
    return task;
  }
}));
builder5.mutationField("updateTaskStatus", (t) => t.prismaFieldWithInput({
  type: ["Day"],
  description: `Update the status of a task and get the updated days (as a list in chronological order).

When the task is:
- already in the desired status, it does nothing and returns an empty list.
- for today, it updates the status and returns the day.
- for a previous day and changing to \`TODO\`, it updates the status and
  returns the original day and today.
- for a future day and changing to \`DONE\` or \`CANCELED\`, it updates the status and
  returns the original day and today.

Any other scenario is not possible by nature of the app, where tasks:
- in the past can only be \`DONE\` or \`CANCELED\` 
- in the future can only be in \`TODO\`
    `,
  input: {
    id: t.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    status: t.input.field({
      type: TaskStatusEnum,
      required: true,
      description: "The new status of the task."
    }),
    actionData: t.input.field({
      type: [TaskActionDataInput],
      description: "The action data to be passed to the plugin."
    })
  },
  resolve: async (query3, _, args) => {
    const days = [];
    const plugins4 = await getPlugins2();
    await prisma.$transaction(async (tx) => {
      const newStatus = args.input.status;
      let updatedTask;
      const task = updatedTask = await tx.task.findUniqueOrThrow({
        where: { id: parseInt(args.input.id.id) },
        include: { day: { select: { date: true, tasksOrder: true } }, pluginDatas: true }
      });
      for (const pluginSlug in plugins4) {
        const plugin3 = plugins4[pluginSlug];
        await plugin3.onUpdateTaskStatus?.({
          actionData: args.input.actionData,
          task,
          newStatus
        });
      }
      const originalDay = task.day;
      const startOfToday = startOfDay();
      const endOfToday = endOfDay();
      if (task.status === newStatus) {
      } else if (task.date >= startOfToday && task.date <= endOfToday) {
        updatedTask = await tx.task.update({
          where: { id: task.id },
          include: { pluginDatas: true },
          data: {
            status: newStatus,
            completedAt: newStatus === "DONE" ? new Date : null,
            subtasks: {
              updateMany: {
                where: { parentTaskId: task.id },
                data: {
                  status: newStatus,
                  completedAt: newStatus === "DONE" ? new Date : null
                }
              }
            }
          }
        });
        const newTasksOrder = originalDay.tasksOrder.filter((id) => id !== task.id);
        if (newStatus === "TODO") {
          newTasksOrder.splice(0, 0, task.id);
        } else {
          newTasksOrder.push(task.id);
        }
        await tx.day.update({
          where: { date: startOfToday },
          data: { tasksOrder: { set: newTasksOrder } }
        });
        days.push(task.date);
      } else if (task.date > endOfToday && (newStatus === "DONE" || newStatus === "CANCELED")) {
        updatedTask = await tx.task.update({
          where: { id: task.id },
          include: { pluginDatas: true },
          data: {
            status: newStatus,
            completedAt: newStatus === "DONE" ? new Date : null,
            day: {
              connectOrCreate: {
                where: { date: startOfToday },
                create: { date: startOfToday }
              }
            },
            subtasks: {
              updateMany: {
                where: { parentTaskId: task.id },
                data: {
                  status: newStatus,
                  completedAt: newStatus === "DONE" ? new Date : null,
                  date: startOfToday
                }
              }
            }
          }
        });
        await tx.day.update({
          where: { date: startOfToday },
          data: { tasksOrder: { push: task.id } }
        });
        days.push(startOfToday);
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
        });
        days.push(originalDay.date);
      } else if (task.date < startOfToday) {
        if (newStatus === "TODO") {
          const $updatedTask = updatedTask = await tx.task.update({
            where: { id: task.id },
            data: {
              status: newStatus,
              completedAt: null,
              day: {
                connectOrCreate: {
                  where: { date: startOfToday },
                  create: { date: startOfToday }
                }
              },
              subtasks: {
                updateMany: {
                  where: { parentTaskId: task.id },
                  data: {
                    status: newStatus,
                    completedAt: null,
                    date: startOfToday
                  }
                }
              }
            },
            include: {
              pluginDatas: true,
              day: {
                select: { tasks: { select: { id: true, status: true } }, tasksOrder: true }
              }
            }
          });
          await tx.day.update({
            where: { date: originalDay.date },
            data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
          });
          days.push(task.date);
          const tasksOrdered = $updatedTask.day.tasks.sort((a, b) => $updatedTask.day.tasksOrder.indexOf(a.id) - $updatedTask.day.tasksOrder.indexOf(b.id));
          const lastTodoIndex = tasksOrdered.findIndex((t2) => t2.status === "TODO");
          const newTasksOrder = $updatedTask.day.tasksOrder.splice(lastTodoIndex + 1, 0, task.id);
          await tx.day.update({
            where: { date: startOfToday },
            data: { tasksOrder: { set: newTasksOrder } }
          });
          days.push(startOfToday);
        } else {
          updatedTask = await tx.task.update({
            where: { id: task.id },
            include: { pluginDatas: true },
            data: {
              status: newStatus,
              completedAt: newStatus === "DONE" ? dayjs(task.date).endOf("day").toDate() : null,
              subtasks: {
                updateMany: {
                  where: { parentTaskId: task.id },
                  data: {
                    status: newStatus,
                    completedAt: newStatus === "DONE" ? dayjs(task.date).endOf("day").toDate() : null
                  }
                }
              }
            }
          });
          days.push(task.date);
        }
      }
      for (const pluginSlug in plugins4) {
        const plugin3 = plugins4[pluginSlug];
        await plugin3.onUpdateTaskStatusEnd?.({ task: updatedTask, newStatus }).catch(console.error);
      }
    });
    return prisma.day.findMany({
      ...query3,
      where: { date: { in: days } },
      orderBy: { date: "asc" }
    });
  }
}));
builder5.mutationField("updateTaskDate", (t) => t.fieldWithInput({
  type: [DayType],
  description: `Update the date of a task and/or position of the task in the day, and get the updated days (as a list in chronological order).

Input:
- \`id\`: The ID of the task to update.
- \`date\`: The new date of the task.
- \`after\`: The ID of the task to place the task after. If \`null\`, the task will be placed at the beginning of the day.

When the task is:
- already in the desired date, it updates the order and returns the day.
- moved to today, it updates the date and order but not the status, and returns the original day and today.
- moved into the past, it updates the date and order, updates the status to \`DONE\` (if not already),
  and returns the original day and the new day.
- moved into the future, it updates the date and order, updates the status to \`TODO\` (if not already),
  and returns the original day and the new day.`,
  input: {
    id: t.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    date: t.input.field({
      type: "Date",
      required: true,
      description: "The new date of the task."
    }),
    newTasksOrder: t.input.globalIDList({
      required: true,
      description: "The new order of the tasks in the day the task is moved into."
    })
  },
  resolve: async (_, args) => {
    const plugins4 = await getPlugins2();
    return prisma.$transaction(async (tx) => {
      const days = [];
      const newDate = args.input.date;
      const task = await tx.task.findUniqueOrThrow({
        where: { id: parseInt(args.input.id.id) },
        include: { day: { select: { date: true, tasksOrder: true } }, pluginDatas: true }
      });
      const originalDay = task.day;
      const isSameDay = dayjs(task.date).isSame(newDate, "day");
      const newDayTasksOrder = args.input.newTasksOrder.filter((id) => id.typename === "Task").map((id) => parseInt(id.id));
      const startOfToday = startOfDay();
      const endOfToday = endOfDay();
      let newStatus = null;
      if (isSameDay) {
        newStatus = null;
        days.push(task.date);
      } else if (newDate >= startOfToday && newDate <= endOfToday) {
        newStatus = null;
        days.push(task.date, newDate);
      } else if (newDate < startOfToday) {
        if (task.status !== "CANCELED") {
          newStatus = "DONE";
        }
        days.push(task.date, newDate);
      } else if (newDate > endOfToday) {
        newStatus = "TODO";
        days.push(task.date, newDate);
      }
      if (newStatus === task.status) {
        newStatus = null;
      }
      if (newStatus) {
        for (const pluginSlug in plugins4) {
          const plugin3 = plugins4[pluginSlug];
          await plugin3.onUpdateTaskStatus?.({ newStatus, task });
        }
      }
      await tx.task.update({
        where: { id: task.id },
        data: {
          day: { connectOrCreate: { where: { date: newDate }, create: { date: newDate } } },
          ...newStatus ? {
            status: newStatus,
            completedAt: newStatus === "DONE" ? dayjs(newDate).endOf("day").toDate() : null,
            subtasks: {
              updateMany: {
                where: { parentTaskId: task.id },
                data: {
                  status: newStatus,
                  completedAt: newStatus === "DONE" ? dayjs(newDate).endOf("day").toDate() : null
                }
              }
            }
          } : {}
        }
      });
      if (newStatus) {
        for (const pluginSlug in plugins4) {
          const plugin3 = plugins4[pluginSlug];
          await plugin3.onUpdateTaskStatusEnd?.({ task, newStatus }).catch(console.error);
        }
      }
      if (isSameDay) {
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: newDayTasksOrder } }
        });
      } else {
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
        });
        await tx.day.update({
          where: { date: newDate },
          data: { tasksOrder: { set: newDayTasksOrder } }
        });
      }
      return prisma.day.findMany({
        where: { date: { in: days } },
        orderBy: { date: "asc" }
      });
    });
  }
}));
builder5.mutationField("createSubtask", (t) => t.prismaFieldWithInput({
  type: "Task",
  description: `Create a new subtask.`,
  input: {
    title: t.input.string({ required: true, description: "The title of the subtask." }),
    parentTaskId: t.input.globalID({
      required: true,
      description: "The Relay ID of the parent task."
    })
  },
  resolve: async (query3, _, args) => {
    const parentTask = await prisma.task.findUnique({
      where: { id: parseInt(args.input.parentTaskId.id) }
    });
    if (!parentTask) {
      throw new GraphQLError(`Parent task with ID ${args.input.parentTaskId.id} not found.`, {
        extensions: {
          code: "PARENT_TASK_NOT_FOUND",
          userFriendlyMessage: "The parent task was not found. Please try refreshing the page and try again."
        }
      });
    }
    return prisma.task.create({
      ...query3,
      data: {
        title: args.input.title,
        status: "TODO",
        parentTask: { connect: { id: parseInt(args.input.parentTaskId.id) } },
        day: { connect: { date: parentTask.date } }
      }
    });
  }
}));
builder5.mutationField("makeTaskSubtaskOf", (t) => t.prismaFieldWithInput({
  type: "Task",
  description: `Make a task a subtask of another task.`,
  input: {
    taskId: t.input.globalID({
      required: true,
      description: "The Relay ID of the task to update."
    }),
    parentTaskId: t.input.globalID({
      required: true,
      description: "The Relay ID of the parent task."
    })
  },
  resolve: async (query3, _, args) => {
    const parentTask = await prisma.task.findUnique({
      where: { id: parseInt(args.input.parentTaskId.id) }
    });
    if (!parentTask) {
      throw new GraphQLError(`Parent task with ID ${args.input.parentTaskId.id} not found.`, {
        extensions: {
          code: "PARENT_TASK_NOT_FOUND",
          userFriendlyMessage: "The parent task was not found. Please try refreshing the page and try again."
        }
      });
    }
    return prisma.task.update({
      ...query3,
      where: { id: parseInt(args.input.taskId.id) },
      data: {
        day: { connect: { date: parentTask.date } },
        parentTask: { connect: { id: parseInt(args.input.parentTaskId.id) } }
      }
    });
  }
}));

// src/graphql/Item.ts
var ItemType = builder5.prismaNode("Item", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    title: t.exposeString("title"),
    isRelevant: t.exposeBoolean("isRelevant"),
    inboxPoints: t.exposeInt("inboxPoints", { nullable: true }),
    scheduledAt: t.expose("scheduledAt", { type: "DateTime", nullable: true }),
    durationInMinutes: t.exposeInt("durationInMinutes", { nullable: true }),
    isAllDay: t.exposeBoolean("isAllDay", { nullable: true }),
    color: t.expose("color", { type: ColorEnum, nullable: true }),
    pluginDatas: t.relation("pluginDatas"),
    tasks: t.relation("tasks"),
    listId: t.id({
      nullable: true,
      resolve: (item) => item.listId ? `List_${item.listId}` : null
    }),
    list: t.relation("list", { nullable: true })
  })
});
var ItemPluginDataWhereInputTypeFields = {
  originalId: "String",
  pluginSlug: "String",
  min: JsonFilter,
  full: JsonFilter
};
var ItemPluginDataWhereInputType = builder5.prismaWhere("ItemPluginData", {
  fields: {
    ...ItemPluginDataWhereInputTypeFields,
    AND: true,
    OR: true
  }
});
var ItemWhereInputType = builder5.prismaWhere("Item", {
  fields: {
    isRelevant: "Boolean",
    scheduledAt: DateTimeFilter,
    inboxPoints: IntFilter,
    tasks: TaskListWhereInputType,
    pluginDatas: builder5.prismaListFilter(ItemPluginDataWhereInputType, {
      ops: ["every", "some", "none"]
    })
  }
});
var ItemOrderByType = builder5.prismaOrderBy("Item", {
  fields: {
    inboxPoints: true,
    scheduledAt: true,
    createdAt: true,
    updatedAt: true
  }
});
builder5.queryField("items", (t) => t.prismaConnection({
  type: "Item",
  cursor: "id",
  description: `Get all external items. Useuful to get list of items for a specific day to show in a calendar, or get items with inboxPoints to show in the inbox.
By default, only items where \`isRelevant\` is true.
Pass the \`where\` argument to override these defaults.`,
  args: {
    where: t.arg({ type: ItemWhereInputType, required: false }),
    orderBy: t.arg({ type: ItemOrderByType, required: false })
  },
  smartSubscription: true,
  subscribe: (subs) => {
    subs.register("itemsCreated");
    subs.register("itemsUpdated");
    subs.register("itemsDeleted");
  },
  resolve: (query3, _, args) => {
    return prisma.item.findMany({
      ...query3,
      take: undefined,
      where: args.where ?? undefined,
      orderBy: args.orderBy ?? undefined
    });
  }
}));
builder5.queryField("canRefreshCalendarItems", (t) => t.field({
  type: "Boolean",
  resolve: async () => {
    const plugins4 = await getPlugins2();
    for (const plugin3 of Object.values(plugins4)) {
      if (plugin3.onRefreshCalendarItems)
        return true;
    }
    return false;
  }
}));
builder5.mutationField("createItem", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Create an item.`,
  input: {
    title: t.input.string({ required: true, description: `The title of the item.` }),
    isRelevant: t.input.boolean({
      required: false,
      description: `If set to true, it will return items where \`isRelevant\` is true. 

\`isRelevant\` is used in the List component to only show relevant items. If the item becomes irrelevant (e.g. because the trello task was already completed), you can update the item to make this \`isRelevant = false\``
    }),
    scheduledAt: t.input.field({ type: "DateTime", required: false }),
    durationInMinutes: t.input.int({ required: false }),
    isAllDay: t.input.boolean({ required: false }),
    color: t.input.field({ type: ColorEnum, required: false }),
    inboxPoints: t.input.int({ required: false }),
    listId: t.input.globalID({ required: false }),
    pluginDatas: t.input.field({ type: [ItemPluginDataInput], required: false })
  },
  resolve: (query3, _, { input: input6 }) => {
    return prisma.item.create({
      ...query3,
      data: {
        title: input6.title,
        isRelevant: u(input6.isRelevant),
        scheduledAt: u(input6.scheduledAt),
        durationInMinutes: u(input6.durationInMinutes),
        isAllDay: u(input6.isAllDay),
        color: u(input6.color),
        inboxPoints: u(input6.inboxPoints),
        list: input6.listId && input6.listId.typename === "List" ? { connect: { id: parseInt(input6.listId.id) } } : undefined,
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {}
      }
    });
  }
}));
builder5.mutationField("createCalendarItem", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Create an item in the calendar.`,
  input: {
    title: t.input.string({ required: true, description: "The title of the item." }),
    scheduledAt: t.input.field({ type: "DateTime", required: true }),
    durationInMinutes: t.input.int({ required: false }),
    isAllDay: t.input.boolean({ required: false }),
    color: t.input.field({ type: ColorEnum, required: false }),
    pluginDatas: t.input.field({ type: [ItemPluginDataInput], required: false }),
    fromTaskId: t.input.globalID({ required: false })
  },
  resolve: async (query3, _, { input: input6 }) => {
    const fromTask = input6.fromTaskId ? await prisma.task.findUniqueOrThrow({ where: { id: parseInt(input6.fromTaskId.id) } }).catch(() => {
      throw new GraphQLError("Task not found.", { extensions: { code: "TASK_NOT_FOUND" } });
    }) : null;
    if (fromTask?.itemId) {
      throw new GraphQLError(`Task (${fromTask.id}) already linked to an item (${fromTask.itemId}).`, {
        extensions: {
          code: "TASK_ALREADY_LINKED_TO_ITEM",
          userFriendlyMessage: `This task is already linked to an item in your calendar.`
        }
      });
    }
    const item = await prisma.item.create({
      ...query3,
      data: {
        title: input6.title,
        scheduledAt: u(input6.scheduledAt),
        durationInMinutes: u(input6.durationInMinutes),
        isAllDay: u(input6.isAllDay),
        color: u(input6.color),
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {},
        ...fromTask ? { tasks: { connect: { id: fromTask.id } } } : {}
      },
      include: { tasks: { select: { id: true } } }
    });
    await pgBoss.send(CALENDAR_ITEM_CREATED_JOB_NAME, item);
    console.log("Sent job to create calendar event", item.id);
    return item;
  }
}));
builder5.mutationField("updateItem", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Update an item.`,
  input: {
    id: t.input.globalID({ required: true }),
    title: t.input.string({ required: false }),
    isRelevant: t.input.boolean({
      required: false,
      description: `If set to true, it will return items where \`isRelevant\` is true.

\`isRelevant\` is used in the List component to only show relevant items. If the item becomes irrelevant (e.g. because the trello task was already completed), you can update the item to make this \`isRelevant = false\``
    }),
    scheduledAt: t.input.field({ type: "DateTime", required: false }),
    durationInMinutes: t.input.int({ required: false }),
    isAllDay: t.input.boolean({ required: false }),
    color: t.input.field({ type: ColorEnum, required: false }),
    inboxPoints: t.input.int({ required: false }),
    listId: t.input.globalID({ required: false }),
    pluginDatas: t.input.field({ type: [ItemPluginDataInput], required: false })
  },
  resolve: (query3, _, { input: input6 }) => {
    return prisma.item.update({
      ...query3,
      where: { id: parseInt(input6.id.id) },
      data: {
        title: u(input6.title),
        isRelevant: u(input6.isRelevant),
        scheduledAt: u(input6.scheduledAt),
        durationInMinutes: u(input6.durationInMinutes),
        isAllDay: u(input6.isAllDay),
        color: u(input6.color),
        inboxPoints: u(input6.inboxPoints),
        list: input6.listId && input6.listId.typename === "List" ? { connect: { id: parseInt(input6.listId.id) } } : undefined,
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {}
      }
    });
  }
}));
builder5.mutationField("updateItemStatus", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Mark an item as done or not done. Plugins can use this to mark the item as done or not done in the external system. For example, if the item is a trello task and is marked as done in Flow, it will be marked as done in trello (by the Trello plugin).`,
  input: {
    id: t.input.globalID({ required: true, description: "The ID of the item." }),
    done: t.input.boolean({ required: true, description: "Whether the item is done or not." })
  },
  resolve: async (query3, _, args) => {
    const plugins4 = await getPlugins2();
    const item = await prisma.item.findUnique({
      where: { id: parseInt(args.input.id.id) },
      include: { pluginDatas: true }
    });
    if (!item)
      throw new Error(`Item with id ${args.input.id} not found.`);
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      if (plugin3.onUpdateItemStatus) {
        await plugin3.onUpdateItemStatus({
          settingToDone: args.input.done,
          item
        });
      }
    }
    return await prisma.item.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: { isRelevant: !args.input.done }
    });
  }
}));
builder5.mutationField("deleteItem", (t) => t.prismaField({
  type: "Item",
  description: `Delete an item.`,
  args: {
    id: t.arg.globalID({ required: true })
  },
  resolve: (query3, _, args) => {
    return prisma.item.delete({ ...query3, where: { id: parseInt(args.id.id) } });
  }
}));
builder5.mutationField("dismissItemFromInbox", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Dismiss an item from the inbox. This effectively sets \`inboxPoints = null\` for the item.`,
  input: {
    id: t.input.globalID({ required: true })
  },
  resolve: (query3, _, args) => {
    return prisma.item.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: { inboxPoints: null }
    });
  }
}));
builder5.mutationField("refreshCalendarItems", (t) => t.field({
  type: "Boolean",
  resolve: async () => {
    const plugins4 = await getPlugins2();
    await Promise.all(Object.values(plugins4).map((plugin3) => plugin3.onRefreshCalendarItems?.()));
    return true;
  }
}));

// src/graphql/List.ts
var ListType = builder5.prismaNode("List", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    slug: t.exposeString("slug"),
    description: t.exposeString("description", { nullable: true }),
    items: t.relatedConnection("items", {
      cursor: "id",
      args: { where: t.arg({ type: ItemWhereInputType, required: false }) },
      query: (args) => ({
        where: args.where ?? undefined,
        orderBy: { updatedAt: "desc" }
      })
    })
  })
});
builder5.queryField("lists", (t) => t.prismaField({
  type: ["List"],
  description: "Get all lists.",
  args: {
    first: t.arg({
      type: "PositiveInt",
      required: false,
      description: "The number of lists to return. If not provided, all lists will be returned."
    })
  },
  resolve: (query3, _, args) => {
    return prisma.list.findMany({
      ...query3,
      take: u(args.first),
      orderBy: { createdAt: "asc" }
    });
  }
}));
builder5.queryField("list", (t) => t.prismaField({
  type: "List",
  description: "Get a list by its id or slug.",
  nullable: true,
  smartSubscription: true,
  subscribe: (subs) => {
    subs.register("itemsCreated");
    subs.register("itemsUpdated");
    subs.register("itemsDeleted");
  },
  args: {
    id: t.arg.globalID({ required: false }),
    slug: t.arg.string({ required: false })
  },
  resolve: (query3, _, args) => {
    return prisma.list.findFirst({
      ...query3,
      where: { id: uParseInt(args.id?.id), slug: args.slug ?? undefined }
    });
  }
}));

// src/graphql/NoteTag.ts
var NoteTagType = builder5.prismaNode("NoteTag", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    slug: t.exposeString("slug"),
    color: t.expose("color", { type: ColorEnum }),
    notes: t.relatedConnection("notes", { cursor: "id" }),
    isPrivate: t.exposeBoolean("isPrivate")
  })
});
builder5.queryField("noteTags", (t) => t.prismaConnection({
  type: "NoteTag",
  cursor: "id",
  description: "Get all note tags ordered by usage in descending order. `before` and `after` cursors are ignored, and `first` and `last` act the same and are limited to 100.",
  args: {
    where: t.arg({
      type: NoteTagWhereInput,
      required: false,
      description: "Filters to use when querying note tags."
    })
  },
  resolve: (query3, _, args) => {
    const where = args.where;
    return prisma.noteTag.findMany({
      ...query3,
      where: {
        ...where?.nameIsLike ? { name: { contains: where.nameIsLike, mode: "insensitive" } } : {},
        ...where?.isPrivate ? { isPrivate: { equals: where.isPrivate } } : {}
      },
      orderBy: { notes: { _count: "desc" } },
      take: Math.min(args.first ?? args.last ?? 100, 100)
    });
  }
}));
var NoteTagWhereInput = builder5.inputType("NoteTagWhereInput", {
  fields: (t) => ({
    nameIsLike: t.string({
      required: false,
      description: "Filter by name. Case insensitive."
    }),
    isPrivate: t.boolean({
      required: false,
      description: "Filter by whether the tag is for private use."
    })
  })
});
var CreateNoteTagInputType = builder5.inputType("CreateNoteTagInput", {
  fields: (t) => ({
    name: t.string({ required: true, description: "The name of the tag." }),
    slug: t.string({
      required: false,
      description: "The slug of the tag. Defaults to dashcase version of the name."
    }),
    color: t.string({ required: true, description: "The color of the tag." })
  })
});

// src/graphql/Note.ts
var NoteType = builder5.prismaNode("Note", {
  id: { field: "slug" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    date: t.expose("date", { type: "Date" }),
    slug: t.exposeString("slug"),
    title: t.exposeString("title"),
    content: t.exposeString("content"),
    tags: t.relation("tags")
  })
});
builder5.queryField("note", (t) => t.prismaField({
  type: "Note",
  description: "Get a note by its `slug`.",
  nullable: true,
  args: {
    slug: t.arg.string({ required: true, description: "The slug of the note." })
  },
  resolve: (query3, _, { slug }) => {
    return prisma.note.findUnique({ ...query3, where: { slug } });
  }
}));
builder5.mutationField("createOrUpdateNote", (t) => t.prismaFieldWithInput({
  type: "Note",
  description: "Updates a note if one exists with the passed in `slug`, otherwise creates a new note.",
  input: {
    date: t.input.field({ type: "Date", required: true, description: "The date of the note." }),
    slug: t.input.string({
      required: true,
      description: "The slug of the note. Used for retrieving the note back."
    }),
    title: t.input.string({ required: true, description: "The title of the note." }),
    content: t.input.string({ required: true, description: "The content of the note." }),
    tags: t.input.globalIDList({
      required: false,
      description: "The IDs of exsiting tags to be linked to the note. If you want to create a new tag, use the `newTags` input."
    }),
    newTags: t.input.field({
      type: [CreateNoteTagInputType],
      required: false,
      description: "Create new tags and link them to the note."
    }),
    removedTags: t.input.globalIDList({
      required: false,
      description: "The IDs of tags to be unlinked from the note."
    })
  },
  resolve: (query3, _, args) => {
    const date = args.input.date;
    const tags = {
      connect: args.input.tags?.map((globalId) => ({ id: parseInt(globalId.id) })) ?? [],
      create: args.input.newTags?.map((tag) => ({
        name: tag.name,
        slug: tag.slug ?? tag.name.toLowerCase().replace(/ /g, "-"),
        color: tag.color
      })) ?? []
    };
    return prisma.note.upsert({
      ...query3,
      where: { slug: args.input.slug },
      update: {
        title: args.input.title,
        content: args.input.content,
        tags: {
          ...tags,
          disconnect: args.input.removedTags?.map((globalId) => ({
            id: parseInt(globalId.id)
          })) ?? []
        }
      },
      create: {
        day: { connectOrCreate: { where: { date }, create: { date } } },
        slug: args.input.slug,
        title: args.input.title,
        content: args.input.content,
        tags
      }
    });
  }
}));

// src/graphql/Notifications.ts
var NotificationsType = builder5.simpleObject("Notifications", {
  fields: (t) => ({
    itemsCreated: t.field({ type: [ItemType] }),
    itemsUpdated: t.field({ type: [ItemType] }),
    itemsDeleted: t.field({ type: [ItemType] }),
    tasksCreated: t.field({ type: [TaskType] }),
    tasksUpdated: t.field({ type: [TaskType] }),
    tasksDeleted: t.field({ type: [TaskType] })
  })
});
builder5.subscriptionField("notifications", (t) => t.field({
  type: NotificationsType,
  subscribe(_parent, _args, _context, _info) {
    return Repeater.merge([
      undefined,
      pipe(pubsub.subscribe("ItemsCreated"), map((items) => ({ ItemsCreated: items }))),
      pipe(pubsub.subscribe("ItemsUpdated"), map((items) => ({ ItemsUpdated: items }))),
      pipe(pubsub.subscribe("ItemsDeleted"), map((items) => ({ ItemsDeleted: items }))),
      pipe(pubsub.subscribe("TasksCreated"), map((tasks) => ({ TasksCreated: tasks }))),
      pipe(pubsub.subscribe("TasksUpdated"), map((tasks) => ({ TasksUpdated: tasks }))),
      pipe(pubsub.subscribe("TasksDeleted"), map((tasks) => ({ TasksDeleted: tasks })))
    ]);
  },
  resolve: (payload) => {
    return {
      itemsCreated: getArrayInObj(payload, "ItemsCreated"),
      itemsUpdated: getArrayInObj(payload, "ItemsUpdated"),
      itemsDeleted: getArrayInObj(payload, "ItemsDeleted"),
      tasksCreated: getArrayInObj(payload, "TasksCreated"),
      tasksUpdated: getArrayInObj(payload, "TasksUpdated"),
      tasksDeleted: getArrayInObj(payload, "TasksDeleted")
    };
  }
}));
var getArrayInObj = (payload, type2) => {
  if (!payload)
    return [];
  if (type2 in payload) {
    return payload[type2];
  }
  return [];
};

// src/graphql/PluginOperation.ts
var PluginOperationType = builder5.node(builder5.objectRef("PluginOperation"), {
  id: { resolve: (op) => op.id },
  loadOne: async (id) => {
    const [pluginSlug, operationName] = id.split("_");
    if (!pluginSlug || !operationName) {
      throw new GraphQLError(`Invalid plugin operation id: PluginOperation_${id}. It should be in the format of PluginOperation_pluginSlug_operationName.`);
    }
    return await loadOneWithInput(pluginSlug, operationName, {});
  },
  fields: (t) => ({
    data: t.field({ type: "JSON", resolve: (op) => op.data, nullable: true })
  }),
  description: `A plugin operation similar to making a request to /api/plugin/:pluginSlug/:operation, but it can be cached by Relay.

This is the recommended way to interact with the plugin's from the web app.

If you want to do a GET-like request, you can do it through \`node\` field if there are no parameters to pass. For example:
\`\`\`graphql
query {
  node(id: "PluginOperation_pluginSlug_operationName") {
    ... on PluginOperation {
      id
      data
    }
  }
}
\`\`\`
Or you can do it through \`pluginOperation\` field if there are parameters to pass. For example:
\`\`\`graphql
query {
  pluginOperation(
    input: {
      pluginSlug: "pluginSlug",
      operationName: "operationName",
      data: { param1: "value1"}
    }
  ) {
    id
    data
  }
}
\`\`\`

If you want to do a POST-like request, you can do it through \`pluginOperation\` field in the Mutation type. For example:
\`\`\`graphql
mutation {
  pluginOperation(
    input: {
      pluginSlug: "pluginSlug",
      operationName: "operationName",
      data: { param1: "value1"}
    }
  ) {
    id
    data
  }
}

What's the difference between \`pluginOperation\` field in the Query type and the Mutation type?
- \`pluginOperation\` field in the Query type is used for GET-like requests and will get cached by Relay in the web app.
- \`pluginOperation\` field in the Mutation type is used for POST-like requests and will invalidate any cached data from the \`pluginOperation\` field in the Query type and Relay will automatically update it's store.
`
});
var loadOneWithInput = async (pluginSlug, operationName, input6) => {
  const plugins4 = await getPlugins2();
  const plugin3 = plugins4[pluginSlug];
  if (!plugin3) {
    throw new GraphQLError(`Plugin ${pluginSlug} not found.`);
  }
  const operation = plugin3.operations?.[operationName];
  if (!operation) {
    throw new GraphQLError(`Operation ${operationName} not found in plugin ${pluginSlug}.`);
  }
  try {
    const result = await operation(input6);
    if (!result)
      return null;
    return {
      id: `${pluginSlug}_${result.operationName ?? operationName}`,
      data: result.data ?? null
    };
  } catch (e) {
    if (e instanceof GraphQLError)
      throw e;
    if (e instanceof Error) {
      throw new GraphQLError(e.message);
    }
    throw new GraphQLError(JSON.stringify(e));
  }
};
builder5.queryField("pluginOperation", (t) => t.fieldWithInput({
  type: PluginOperationType,
  nullable: true,
  input: {
    pluginSlug: t.input.string({ required: true }),
    operationName: t.input.string({ required: true }),
    data: t.input.field({ type: "JSON", required: false })
  },
  resolve: async (_, args) => {
    return await loadOneWithInput(args.input.pluginSlug, args.input.operationName, args.input.data ?? {});
  }
}));
builder5.mutationField("pluginOperation", (t) => t.fieldWithInput({
  type: PluginOperationType,
  nullable: true,
  input: {
    pluginSlug: t.input.string({ required: true }),
    operationName: t.input.string({ required: true }),
    data: t.input.field({ type: "JSON", required: false })
  },
  resolve: async (_, args) => {
    return await loadOneWithInput(args.input.pluginSlug, args.input.operationName, args.input.data ?? {});
  }
}));

// src/graphql/RepetitionPattern.ts
var values4 = {
  MONDAY: { value: "MONDAY" },
  TUESDAY: { value: "TUESDAY" },
  WEDNESDAY: { value: "WEDNESDAY" },
  THURSDAY: { value: "THURSDAY" },
  FRIDAY: { value: "FRIDAY" },
  SATURDAY: { value: "SATURDAY" },
  SUNDAY: { value: "SUNDAY" }
};
var RepetitionPatternEnum = builder5.enumType("RepetitionPattern", { values: values4 });

// src/graphql/Template.ts
var TemplateType = builder5.prismaNode("Template", {
  id: { field: "slug" },
  fields: (t) => ({
    slug: t.exposeString("slug"),
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    metadata: t.expose("metadata", { type: "JSON", nullable: true }),
    routineStep: t.relation("routineStep"),
    routineStepId: t.exposeID("routineStepId", { nullable: true }),
    raw: t.exposeString("template"),
    rendered: t.fieldWithInput({
      type: "String",
      description: "The rendered template given the data as input. If no data is given, the template will be rendered with the default metadata.",
      argOptions: { required: false },
      input: {
        data: t.input.field({ type: "JSONObject", required: false })
      },
      resolve: async (template, args) => {
        const data = template.metadata && typeof template.metadata === "object" ? template.metadata : {};
        const result = await renderTemplate(template.template, args.input?.data ?? data);
        return result;
      }
    })
  })
});
builder5.queryField("template", (t) => t.prismaField({
  type: "Template",
  description: `Get a template by its slug.`,
  nullable: true,
  args: { slug: t.arg.string({ required: true, description: "The slug of the template." }) },
  resolve: async (_, __, args) => {
    return prisma.template.findUnique({ where: { slug: urlSafe(args.slug) } });
  }
}));
var TemplateInput = builder5.inputType(builder5.inputRef("TemplateInput"), {
  fields: (t) => ({
    id: t.globalID({
      required: false,
      description: "The ID of the template to update. Not required when creating a new template."
    }),
    slug: t.string({ required: true }),
    template: t.string({ required: true }),
    metadata: t.field({ type: "JSONObject", required: false }),
    routineStepId: t.globalID({
      required: false,
      description: "The ID of the routine step to link the template to."
    })
  })
});
builder5.mutationField("createTemplate", (t) => t.prismaField({
  type: "Template",
  description: `Create a new template and link it to a routine step.`,
  args: {
    input: t.arg({ type: TemplateInput, required: true })
  },
  resolve: async (_, __, args) => {
    const routineStep = args.input.routineStepId?.id && !Number.isNaN(parseInt(args.input.routineStepId.id)) ? await prisma.routineStep.findUnique({
      where: { id: parseInt(args.input.routineStepId.id) },
      include: { routine: true }
    }) : null;
    if (!routineStep && args.input.routineStepId?.id) {
      throw new GraphQLError("Routine step not found.", {
        extensions: {
          code: "ROUTINE_STEP_NOT_FOUND",
          userFriendlyMessage: "No routine step was found to link the template to. Please try refreshing the page and try again."
        }
      });
    }
    const slug = urlSafe(args.input.slug);
    if (!verifyUrlSafe(slug)) {
      throw new GraphQLError("Slug is not URL safe.", {
        extensions: {
          code: "SLUG_NOT_URL_SAFE",
          userFriendlyMessage: "The slug is not URL safe. Please try again with a different slug."
        }
      });
    }
    const data = args.input.metadata && typeof args.input.metadata === "object" ? args.input.metadata : {};
    await renderTemplate(args.input.template, data).catch((err) => {
      throw new GraphQLError(err.message, {
        extensions: {
          code: "INVALID_TEMPLATE",
          userFriendlyMessage: "The template is not valid. Please try again with a different template."
        }
      });
    });
    return prisma.template.create({
      data: {
        slug,
        template: args.input.template,
        metadata: u(args.input.metadata),
        routineStepId: routineStep?.id
      }
    });
  }
}));
builder5.mutationField("updateTemplate", (t) => t.prismaFieldWithInput({
  type: "Template",
  description: `Update a template.`,
  input: {
    id: t.input.globalID({
      required: true,
      description: "The Relay ID of the template to update."
    }),
    newSlug: t.input.string({ required: false }),
    raw: t.input.string({ required: false }),
    metadata: t.input.field({ type: "JSON", required: false }),
    routineStepId: t.input.globalID({
      required: false,
      description: "The Relay ID of the routine step to link the template to."
    })
  },
  resolve: async (_, __, args) => {
    const routineStep = args.input.routineStepId?.id && !Number.isNaN(parseInt(args.input.routineStepId.id)) ? await prisma.routineStep.findUnique({
      where: { id: parseInt(args.input.routineStepId.id) },
      include: { routine: true }
    }) : null;
    if (!routineStep && args.input.routineStepId?.id) {
      throw new GraphQLError("Routine step not found.", {
        extensions: {
          code: "ROUTINE_STEP_NOT_FOUND",
          userFriendlyMessage: "No routine step was found to link the template to. Please try refreshing the page and try again."
        }
      });
    }
    const slug = args.input.newSlug ? urlSafe(args.input.newSlug) : undefined;
    if (slug && !verifyUrlSafe(slug)) {
      throw new GraphQLError("Slug is not URL safe.", {
        extensions: {
          code: "SLUG_NOT_URL_SAFE",
          userFriendlyMessage: "The slug is not URL safe. Please try again with a different slug."
        }
      });
    }
    if (args.input.raw) {
      const data = args.input.metadata && typeof args.input.metadata === "object" ? args.input.metadata : {};
      await renderTemplate(args.input.raw, data).catch((err) => {
        throw new GraphQLError(err.message, {
          extensions: {
            code: "INVALID_TEMPLATE",
            userFriendlyMessage: "The template is not valid. Please try again with a different template."
          }
        });
      });
    }
    return prisma.template.update({
      where: { slug: args.input.id.id },
      data: {
        slug,
        template: u(args.input.raw),
        metadata: u(args.input.metadata),
        routineStepId: routineStep?.id
      }
    });
  }
}));
builder5.mutationField("createOrUpdateTemplate", (t) => t.prismaFieldWithInput({
  type: "Template",
  description: `Create or update a template.`,
  input: {
    slug: t.input.string({ required: true }),
    raw: t.input.string({ required: true }),
    metadata: t.input.field({ type: "JSON", required: false }),
    routineStepId: t.input.globalID({
      required: false,
      description: "The Relay ID of the routine step to link the template to."
    })
  },
  resolve: async (_, __, args) => {
    const routineStep = args.input.routineStepId?.id && !Number.isNaN(parseInt(args.input.routineStepId.id)) ? await prisma.routineStep.findUnique({
      where: { id: parseInt(args.input.routineStepId.id) },
      include: { routine: true }
    }) : null;
    if (!routineStep && args.input.routineStepId?.id) {
      throw new GraphQLError("Routine step not found.", {
        extensions: {
          code: "ROUTINE_STEP_NOT_FOUND",
          userFriendlyMessage: "No routine step was found to link the template to. Please try refreshing the page and try again."
        }
      });
    }
    const slug = urlSafe(args.input.slug);
    if (!verifyUrlSafe(slug)) {
      throw new GraphQLError("Slug is not URL safe.", {
        extensions: {
          code: "SLUG_NOT_URL_SAFE",
          userFriendlyMessage: "The slug is not URL safe. Please try again with a different slug."
        }
      });
    }
    const data = args.input.metadata && typeof args.input.metadata === "object" ? args.input.metadata : {};
    await renderTemplate(args.input.raw, data).catch((err) => {
      throw new GraphQLError(err.message, {
        extensions: {
          code: "INVALID_TEMPLATE",
          userFriendlyMessage: "The template is not valid. Please try again with a different template."
        }
      });
    });
    return prisma.template.upsert({
      where: { slug: args.input.slug },
      create: {
        slug,
        template: args.input.raw,
        metadata: u(args.input.metadata),
        routineStepId: routineStep?.id
      },
      update: {
        template: args.input.raw,
        metadata: u(args.input.metadata),
        routineStepId: routineStep?.id
      }
    });
  }
}));
builder5.mutationField("deleteTemplate", (t) => t.prismaField({
  type: "Template",
  description: `Delete a template.`,
  args: {
    id: t.arg.globalID({
      required: true,
      description: "The Relay ID of the template to delete."
    })
  },
  resolve: async (_, __, args) => {
    const template = await prisma.template.delete({
      where: { slug: args.id.id }
    });
    return template;
  }
}));

// src/graphql/RoutineStep.ts
var RoutineStepType = builder5.prismaNode("RoutineStep", {
  id: { field: "id", description: "The ID of the step" },
  fields: (t) => ({
    pluginSlug: t.exposeString("pluginSlug"),
    stepSlug: t.exposeString("stepSlug"),
    shouldSkip: t.exposeBoolean("shouldSkip"),
    config: t.expose("config", { type: "JSON", nullable: true }),
    routine: t.relation("routine"),
    routineId: t.exposeID("routineId"),
    templates: t.relation("templates")
  })
});
var RoutineStepInput = builder5.inputType(builder5.inputRef("RoutineStepInput"), {
  fields: (t) => ({
    id: t.globalID({
      required: false,
      description: "The ID of the step if it exists. Leave empty or null to create a new step."
    }),
    pluginSlug: t.string({ required: true }),
    stepSlug: t.string({ required: true }),
    shouldSkip: t.boolean({ required: true }),
    config: t.field({ type: "JSONObject", required: false })
  })
});
builder5.mutationField("updateRoutineStep", (t) => t.prismaFieldWithInput({
  type: "RoutineStep",
  input: {
    id: t.input.globalID({
      description: "The ID of the routine step. It must exist.",
      required: true
    }),
    shouldSkip: t.input.boolean({
      description: "Whether the step should be skipped or not.",
      required: false
    }),
    config: t.input.field({
      description: "The config of the step. This can be any JSONObject",
      type: "JSONObject",
      required: false
    }),
    templates: t.input.field({
      description: "The templates linked to the step.",
      type: [TemplateInput],
      required: false
    })
  },
  resolve: async (_, __, args) => {
    const routineStep = await prisma.routineStep.findUnique({
      where: { id: parseInt(args.input.id.id) },
      include: { templates: true }
    });
    const res = await prisma.routineStep.update({
      where: { id: parseInt(args.input.id.id) },
      data: {
        shouldSkip: u(args.input.shouldSkip),
        config: u(args.input.config),
        ...args.input.templates ? {
          templates: {
            upsert: args.input.templates.map((template) => ({
              where: { slug: template.slug },
              create: {
                ...template,
                metadata: u(template.metadata)
              },
              update: {
                ...template,
                metadata: u(template.metadata)
              }
            })),
            delete: routineStep?.templates.filter((template) => !args.input.templates?.some((t2) => t2.slug === template.slug)).map((template) => ({ slug: template.slug }))
          }
        } : {}
      }
    });
    return res;
  }
}));

// src/graphql/Routine.ts
var RoutineType = builder5.prismaNode("Routine", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    actionName: t.exposeString("actionName"),
    time: t.expose("time", { type: "Time" }),
    repeats: t.expose("repeats", { type: [RepetitionPatternEnum] }),
    steps: t.prismaField({
      type: ["RoutineStep"],
      description: "The steps of the routine.",
      resolve: async (query3, routine) => {
        const order = routine.stepsOrder ?? [];
        const steps2 = await prisma.routineStep.findMany({
          ...query3,
          where: { routineId: routine.id }
        });
        const stepsOrdered = steps2.sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id));
        return stepsOrdered;
      }
    }),
    isActive: t.exposeBoolean("isActive"),
    firstStep: t.prismaField({
      type: "RoutineStep",
      nullable: true,
      description: "Returns the first step in the routine. If there are no steps in the routine, it returns `null`.",
      resolve: async (query3, routine) => {
        const order = routine.stepsOrder ?? [];
        const steps2 = await prisma.routineStep.findMany({
          ...query3,
          where: { routineId: routine.id }
        });
        const stepsOrdered = steps2.sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id));
        return stepsOrdered[0] ?? null;
      }
    }),
    done: t.boolean({
      description: "Whether the routine was done for the day. This can be null if the routine is queried outside of a day.",
      nullable: true,
      resolve: async (routine) => {
        if (!("_done" in routine) || typeof routine._done !== "boolean")
          return null;
        return routine._done;
      }
    })
  })
});
builder5.queryField("routines", (t) => t.prismaField({
  type: ["Routine"],
  description: "Get all routines.",
  resolve: (query3) => {
    return prisma.routine.findMany(query3);
  }
}));
builder5.mutationField("createRoutine", (t) => t.prismaFieldWithInput({
  type: "Routine",
  input: {
    name: t.input.string({ required: true }),
    actionName: t.input.string({ required: true }),
    time: t.input.field({ type: "Time", required: true }),
    repeats: t.input.field({ type: [RepetitionPatternEnum], required: true }),
    steps: t.input.field({ type: [RoutineStepInput], required: true })
  },
  resolve: async (query3, _, args) => {
    const { routine, stepsOrdered } = await prisma.$transaction(async (tx) => {
      const routine2 = await tx.routine.create({
        select: { id: true },
        data: {
          name: args.input.name,
          actionName: args.input.actionName,
          time: args.input.time,
          repeats: args.input.repeats,
          firstDay: new Date,
          isActive: true
        }
      });
      const stepsOrdered2 = [];
      for (const step of args.input.steps) {
        const routineStep = await tx.routineStep.create({
          data: {
            pluginSlug: step.pluginSlug,
            stepSlug: step.stepSlug,
            shouldSkip: step.shouldSkip,
            routineId: routine2.id
          }
        });
        stepsOrdered2.push(routineStep);
      }
      return {
        routine: await tx.routine.update({
          ...query3,
          where: { id: routine2.id },
          data: { stepsOrder: { set: stepsOrdered2.map((step) => step.id) } }
        }),
        stepsOrdered: stepsOrdered2
      };
    });
    const plugins4 = await getPlugins2();
    for (const step of stepsOrdered) {
      if (!step.id)
        continue;
      const plugin3 = plugins4[step.pluginSlug];
      if (!plugin3)
        continue;
      await plugin3.onAddRoutineStepEnd?.({ routine, step });
    }
    return routine;
  }
}));
builder5.mutationField("updateRoutine", (t) => t.prismaFieldWithInput({
  type: "Routine",
  input: {
    routineId: t.input.globalID({
      description: "The ID of the routine to update.",
      required: true
    }),
    isActive: t.input.boolean({
      description: "Whether the routine is active.",
      required: false
    }),
    name: t.input.string({
      description: "The name to update the routine with.",
      required: false
    }),
    actionName: t.input.string({
      description: "The action name to update the routine with.",
      required: false
    }),
    time: t.input.field({
      type: "Time",
      description: "The time to use the routine with.",
      required: false
    }),
    steps: t.input.field({
      type: [RoutineStepInput],
      description: "The steps to update the routine with.",
      required: false
    }),
    repeats: t.input.field({
      type: [RepetitionPatternEnum],
      description: "The repetition patterns to update the routine with.",
      required: false
    })
  },
  resolve: async (query3, _, args) => {
    const { routine, newSteps } = await prisma.$transaction(async (tx) => {
      await tx.routineStep.deleteMany({
        where: {
          routineId: parseInt(args.input.routineId.id),
          id: {
            notIn: args.input.steps?.filter((s) => s.id?.typename === "RoutineStep").map((s) => parseInt(s.id.id))
          }
        }
      });
      const stepsOrdered = [];
      const newSteps2 = [];
      for (const step of args.input.steps ?? []) {
        if (step.id?.typename === "NewStep") {
          const routineStep = await tx.routineStep.create({
            data: {
              pluginSlug: step.pluginSlug,
              stepSlug: step.stepSlug,
              shouldSkip: step.shouldSkip,
              config: u(step.config),
              routine: { connect: { id: parseInt(args.input.routineId.id) } }
            }
          });
          stepsOrdered.push(routineStep.id);
          newSteps2.push(routineStep);
        } else if (step.id?.typename === "RoutineStep") {
          const routineStep = await tx.routineStep.update({
            select: { id: true },
            where: { id: parseInt(step.id.id) },
            data: {
              pluginSlug: step.pluginSlug,
              stepSlug: step.stepSlug,
              shouldSkip: step.shouldSkip,
              config: u(step.config)
            }
          });
          stepsOrdered.push(routineStep.id);
        } else {
          throw new GraphQLError("Invalid step ID type.", {
            extensions: {
              code: "INVALID_STEP_ID_TYPE",
              userFriendlyMessage: "The step ID type is invalid. Please try again with a different step."
            }
          });
        }
      }
      const updatedRoutine = await tx.routine.update({
        ...query3,
        where: { id: parseInt(args.input.routineId.id) },
        data: {
          isActive: u(args.input.isActive),
          name: u(args.input.name),
          actionName: u(args.input.actionName),
          time: u(args.input.time),
          repeats: u(args.input.repeats),
          ...args.input.steps ? { stepsOrder: { set: stepsOrdered } } : {}
        }
      });
      return {
        routine: updatedRoutine,
        newSteps: newSteps2
      };
    });
    const plugins4 = await getPlugins2();
    for (const step of newSteps) {
      if (!step.id)
        continue;
      const plugin3 = plugins4[step.pluginSlug];
      if (!plugin3)
        continue;
      await plugin3.onAddRoutineStepEnd?.({ routine, step });
    }
    return routine;
  }
}));
builder5.mutationField("completeRoutine", (t) => t.fieldWithInput({
  type: "Boolean",
  input: {
    routineId: t.input.globalID({
      description: "The ID of the routine that was completed.",
      required: true
    }),
    date: t.input.field({
      type: "Date",
      description: "The date the routine was completed.",
      required: true
    })
  },
  resolve: async (_, args) => {
    try {
      await prisma.day.update({
        where: { date: args.input.date },
        data: { routinesCompleted: { connect: { id: parseInt(args.input.routineId.id) } } }
      });
    } catch (e) {
      new GraphQLError(e.message);
    }
    return true;
  }
}));

// src/graphql/TaskPluginData.ts
var TaskPluginDataType = builder5.prismaNode("TaskPluginData", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    min: t.expose("min", { type: "JSON" }),
    full: t.expose("full", { type: "JSON" }),
    pluginSlug: t.exposeString("pluginSlug")
  })
});

// src/graphql/Util.ts
builder5.queryField("renderTemplate", (t) => t.fieldWithInput({
  type: "String",
  description: "Render a template string with the given data. Plugin helpers and partials can be used in the template.",
  input: {
    template: t.input.string({ required: true }),
    data: t.input.field({ type: "JSON", required: true })
  },
  resolve: async (_, args) => {
    const template = args.input.template;
    const data = args.input.data;
    if (typeof data !== "object")
      throw new GraphQLError("Data must be an object.");
    return renderTemplate(template, data);
  }
}));

// src/graphql/index.ts
var schema3 = builder5.toSchema();
if (env.NODE_ENV === "development") {
  const schemaAsString = printSchema(schema3);
  const path2 = await Bun.resolve("../../../../packages/relay/schema.graphql", import.meta.dir);
  await Bun.write(path2, "# @generated\n" + schemaAsString);
  console.log(`
\u2705 GraphQL schema generated into apps/web/src/relay/schema.graphql`);
}

// src/index.ts
var PORT = env.PORT ?? 4000;
var yogaHandler = async (request) => {
  const res = await createYoga({
    schema: schema3,
    cors: { origin: undefined },
    context: async (req) => {
      const sessionToken = req.request.headers.get("authorization")?.replace("Bearer ", "");
      return {
        userAgent: req.request.headers.get("user-agent") ?? undefined,
        sessionToken,
        isSessionValid: () => isSessionTokenValid(sessionToken),
        subscriptions: {}
      };
    },
    graphiql: {
      title: "Flow API",
      headers: JSON.stringify({
        Authorization: `Bearer COPY_TOKEN_FROM_BROWSER_CONSOLE_OR_LOGIN_MUTATION`
      })
    }
  }).handle(request);
  res.headers.delete("Access-Control-Allow-Origin");
  return res;
};
var app = new c$().use(cors()).get("/graphql", async ({ request }) => yogaHandler(request)).post("/graphql", async ({ request }) => yogaHandler(request), {
  type: "none"
}).all("/api/plugin/:pluginSlug/*", async (req) => {
  const pluginSlug = req.params.pluginSlug;
  const installedPlugins = await getPlugins2();
  const plugin3 = installedPlugins[pluginSlug];
  if (!plugin3) {
    return new Response(`Plugin ${pluginSlug} not found. It may be in the process of being installed. Please try again later.`, { status: 404 });
  }
  if (!plugin3.onRequest) {
    return new Response(`Plugin ${pluginSlug} has no \`onRequest\` function to handle the request.`, { status: 404 });
  }
  req.path = req.path.replace(`/api/plugin/${pluginSlug}`, "");
  const maybePromise = plugin3.onRequest(req);
  if (maybePromise instanceof Response)
    return maybePromise;
  const res = await maybePromise?.catch(() => null);
  if (res)
    return res;
  return new Response(`Plugin ${pluginSlug} has no endpoint for ${req.path}.`, { status: 404 });
});
app.all("*", async (req) => {
  if (env.NODE_ENV === "development") {
    const developmentPath = `http://localhost:3000${req.path}`;
    try {
      const result = await fetch(developmentPath);
      if (result.ok) {
        return Response.redirect(developmentPath);
      }
    } catch {
      return new Response("Local frontend is not running on port 3000.", { status: 404 });
    }
  }
  if (req.headers["user-agent"]?.includes("Mobile")) {
    const mobilePwaDir = "./mobile-pwa";
    try {
      const path2 = await Bun.resolve(`${mobilePwaDir}${req.path}`, import.meta.dir);
      return new Response(Bun.file(path2));
    } catch {
      try {
        const path2 = await Bun.resolve(`${mobilePwaDir}/index.html`, import.meta.dir);
        return new Response(Bun.file(path2));
      } catch {
        console.error("index.html not found in mobile-pwa directory.");
        return new Response("Not sure how you got here. Contact Richard Guerre (through Slack or @richardguerre_ on Twitter) with a screenshot of this screen with the URL.", { status: 404 });
      }
    }
  }
  const webDir = "./web";
  try {
    const path2 = await Bun.resolve(`${webDir}${req.path}`, import.meta.dir);
    return new Response(Bun.file(path2));
  } catch {
    try {
      const path2 = await Bun.resolve(`${webDir}/index.html`, import.meta.dir);
      return new Response(Bun.file(path2));
    } catch {
      console.error("index.html not found in web directory.");
      return new Response("Not sure how you got here. Contact Richard Guerre (through Slack or @richardguerre_ on Twitter) with a screenshot of this screen with the URL.", { status: 404 });
    }
  }
});
if (env.NODE_ENV !== "test") {
  const plugins4 = await getPlugins2();
  if (env.NODE_ENV !== "development") {
    try {
      const installedPlugins = await getPluginsInStore().catch(() => {
        console.log("Failed to get plugins from DB.");
        return [];
      });
      for (const pluginInfo of installedPlugins) {
        const pluginJson = await getPluginJson(pluginInfo).catch(() => null);
        if (!pluginJson) {
          console.log(`Invalid plugin.json for "${pluginInfo.slug}".`);
          continue;
        }
        if (Object.keys(plugins4).find((p) => p === pluginJson.slug)) {
          console.log(`Plugin "${pluginJson.slug}" already installed on server.`);
          continue;
        }
        if (!pluginJson.server) {
          console.log(`Plugin "${pluginJson.slug}" has no server entrypoint.`);
          continue;
        }
        await installServerPlugin(pluginInfo).catch((e) => {
          if (e.message.includes("PLUGIN_WITH_SAME_SLUG")) {
            console.log(`Plugin "${pluginInfo.slug}" already installed on server.`);
            return;
          }
          console.log(`Failed to install "${pluginInfo.slug}": ${e}`);
        });
      }
    } catch (e) {
      console.log("Failed to install plugins from DB.");
      console.error(e);
    }
  }
  app.listen(PORT, () => {
    console.log(`\u2705 Server started at: http://localhost:${PORT}`);
    console.log(`\uD83D\uDFE3 GraphQL API: http://localhost:${PORT}/graphql`);
  });
  await pgBoss.start();
  console.log("\u2705 PgBoss started.");
  await pluginPgBossWorkers({ plugins: plugins4 });
  await pgBossWorkers();
  if (env.NODE_ENV !== "development") {
    const timezone3 = await getTimezone();
    await scheduleRolloverTasks(timezone3);
    await scheduleDeletePgBossArchive(timezone3);
    await syncTasks();
  }
} else {
  app.listen(0);
}
process.on("SIGINT", () => {
  Promise.allSettled([
    prisma.$disconnect().then(() => console.log("\u2705 Prisma disconnected.")),
    pgBoss.stop().then(() => console.log("\u2705 PgBoss stopped."))
  ]).then(() => {
    process.exit(0);
  }).catch((e) => {
    console.error(e);
    process.exit(1);
  });
});
export {
  app
};
