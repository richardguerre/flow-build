// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// /Users/richardguerre/Projects/flow/node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS((exports, module) => {
  var we = function(e2, t2) {
    return (t2 ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e2);
  };
  var D = function(e2, t2 = false) {
    let r = [], n2 = 0;
    for (;n2 < e2.length; ) {
      let a2 = e2[n2], c2 = function(l2) {
        if (!t2)
          throw new TypeError(l2);
        r.push({ type: "INVALID_CHAR", index: n2, value: e2[n2++] });
      };
      if (a2 === "*") {
        r.push({ type: "ASTERISK", index: n2, value: e2[n2++] });
        continue;
      }
      if (a2 === "+" || a2 === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n2, value: e2[n2++] });
        continue;
      }
      if (a2 === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n2++, value: e2[n2++] });
        continue;
      }
      if (a2 === "{") {
        r.push({ type: "OPEN", index: n2, value: e2[n2++] });
        continue;
      }
      if (a2 === "}") {
        r.push({ type: "CLOSE", index: n2, value: e2[n2++] });
        continue;
      }
      if (a2 === ":") {
        let l2 = "", s2 = n2 + 1;
        for (;s2 < e2.length; ) {
          let i = e2.substr(s2, 1);
          if (s2 === n2 + 1 && Te.test(i) || s2 !== n2 + 1 && Ae.test(i)) {
            l2 += e2[s2++];
            continue;
          }
          break;
        }
        if (!l2) {
          c2(`Missing parameter name at ${n2}`);
          continue;
        }
        r.push({ type: "NAME", index: n2, value: l2 }), n2 = s2;
        continue;
      }
      if (a2 === "(") {
        let l2 = 1, s2 = "", i = n2 + 1, o2 = false;
        if (e2[i] === "?") {
          c2(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e2.length; ) {
          if (!we(e2[i], false)) {
            c2(`Invalid character '${e2[i]}' at ${i}.`), o2 = true;
            break;
          }
          if (e2[i] === "\\") {
            s2 += e2[i++] + e2[i++];
            continue;
          }
          if (e2[i] === ")") {
            if (l2--, l2 === 0) {
              i++;
              break;
            }
          } else if (e2[i] === "(" && (l2++, e2[i + 1] !== "?")) {
            c2(`Capturing groups are not allowed at ${i}`), o2 = true;
            break;
          }
          s2 += e2[i++];
        }
        if (o2)
          continue;
        if (l2) {
          c2(`Unbalanced pattern at ${n2}`);
          continue;
        }
        if (!s2) {
          c2(`Missing pattern at ${n2}`);
          continue;
        }
        r.push({ type: "REGEX", index: n2, value: s2 }), n2 = i;
        continue;
      }
      r.push({ type: "CHAR", index: n2, value: e2[n2++] });
    }
    return r.push({ type: "END", index: n2, value: "" }), r;
  };
  var F = function(e2, t2 = {}) {
    let r = D(e2);
    t2.delimiter ??= "/#?", t2.prefixes ??= "./";
    let n2 = `[^${x(t2.delimiter)}]+?`, a2 = [], c2 = 0, l2 = 0, s2 = "", i = new Set, o2 = (f) => {
      if (l2 < r.length && r[l2].type === f)
        return r[l2++].value;
    }, h2 = () => o2("OTHER_MODIFIER") ?? o2("ASTERISK"), p2 = (f) => {
      let u2 = o2(f);
      if (u2 !== undefined)
        return u2;
      let { type: d2, index: T } = r[l2];
      throw new TypeError(`Unexpected ${d2} at ${T}, expected ${f}`);
    }, O = () => {
      let f = "", u2;
      for (;u2 = o2("CHAR") ?? o2("ESCAPED_CHAR"); )
        f += u2;
      return f;
    }, be = (f) => f, L2 = t2.encodePart || be, I = "", H2 = (f) => {
      I += f;
    }, $ = () => {
      I.length && (a2.push(new k2(3, "", "", L2(I), "", 3)), I = "");
    }, X = (f, u2, d2, T, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u2 && !d2 && g === 3) {
        H2(f);
        return;
      }
      if ($(), !u2 && !d2) {
        if (!f)
          return;
        a2.push(new k2(3, "", "", L2(f), "", g));
        return;
      }
      let m2;
      d2 ? d2 === "*" ? m2 = v : m2 = d2 : m2 = n2;
      let R = 2;
      m2 === n2 ? (R = 1, m2 = "") : m2 === v && (R = 0, m2 = "");
      let S2;
      if (u2 ? S2 = u2 : d2 && (S2 = c2++), i.has(S2))
        throw new TypeError(`Duplicate name '${S2}'.`);
      i.add(S2), a2.push(new k2(R, S2, L2(f), m2, L2(T), g));
    };
    for (;l2 < r.length; ) {
      let f = o2("CHAR"), u2 = o2("NAME"), d2 = o2("REGEX");
      if (!u2 && !d2 && (d2 = o2("ASTERISK")), u2 || d2) {
        let g = f ?? "";
        t2.prefixes.indexOf(g) === -1 && (H2(g), g = ""), $();
        let m2 = h2();
        X(g, u2, d2, "", m2);
        continue;
      }
      let T = f ?? o2("ESCAPED_CHAR");
      if (T) {
        H2(T);
        continue;
      }
      if (o2("OPEN")) {
        let g = O(), m2 = o2("NAME"), R = o2("REGEX");
        !m2 && !R && (R = o2("ASTERISK"));
        let S2 = O();
        p2("CLOSE");
        let Pe = h2();
        X(g, m2, R, S2, Pe);
        continue;
      }
      $(), p2("END");
    }
    return a2;
  };
  var x = function(e2) {
    return e2.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e2) {
    return e2 && e2.ignoreCase ? "ui" : "u";
  };
  var q = function(e2, t2, r) {
    return W(F(e2, r), t2, r);
  };
  var y2 = function(e2) {
    switch (e2) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e2, t2, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n2 = r.start ? "^" : "";
    for (let s2 of e2) {
      if (s2.type === 3) {
        s2.modifier === 3 ? n2 += x(s2.value) : n2 += `(?:${x(s2.value)})${y2(s2.modifier)}`;
        continue;
      }
      t2 && t2.push(s2.name);
      let i = `[^${x(r.delimiter)}]+?`, o2 = s2.value;
      if (s2.type === 1 ? o2 = i : s2.type === 0 && (o2 = v), !s2.prefix.length && !s2.suffix.length) {
        s2.modifier === 3 || s2.modifier === 1 ? n2 += `(${o2})${y2(s2.modifier)}` : n2 += `((?:${o2})${y2(s2.modifier)})`;
        continue;
      }
      if (s2.modifier === 3 || s2.modifier === 1) {
        n2 += `(?:${x(s2.prefix)}(${o2})${x(s2.suffix)})`, n2 += y2(s2.modifier);
        continue;
      }
      n2 += `(?:${x(s2.prefix)}`, n2 += `((?:${o2})(?:`, n2 += x(s2.suffix), n2 += x(s2.prefix), n2 += `(?:${o2}))*)${x(s2.suffix)})`, s2.modifier === 0 && (n2 += "?");
    }
    let a2 = `[${x(r.endsWith)}]|\$`, c2 = `[${x(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n2 += `${c2}?`), r.endsWith.length ? n2 += `(?=${a2})` : n2 += "$", new RegExp(n2, B(r));
    r.strict || (n2 += `(?:${c2}(?=${a2}))?`);
    let l2 = false;
    if (e2.length) {
      let s2 = e2[e2.length - 1];
      s2.type === 3 && s2.modifier === 3 && (l2 = r.delimiter.indexOf(s2) > -1);
    }
    return l2 || (n2 += `(?=${c2}|${a2})`), new RegExp(n2, B(r));
  };
  var ee = function(e2, t2) {
    return e2.length ? e2[0] === "/" ? true : !t2 || e2.length < 2 ? false : (e2[0] == "\\" || e2[0] == "{") && e2[1] == "/" : false;
  };
  var te = function(e2, t2) {
    return e2.startsWith(t2) ? e2.substring(t2.length, e2.length) : e2;
  };
  var Ce = function(e2, t2) {
    return e2.endsWith(t2) ? e2.substr(0, e2.length - t2.length) : e2;
  };
  var _ = function(e2) {
    return !e2 || e2.length < 2 ? false : e2[0] === "[" || (e2[0] === "\\" || e2[0] === "{") && e2[1] === "[";
  };
  var N = function(e2) {
    if (!e2)
      return true;
    for (let t2 of re)
      if (e2.test(t2))
        return true;
    return false;
  };
  var ne = function(e2, t2) {
    if (e2 = te(e2, "#"), t2 || e2 === "")
      return e2;
    let r = new URL("https://example.com");
    return r.hash = e2, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e2, t2) {
    if (e2 = te(e2, "?"), t2 || e2 === "")
      return e2;
    let r = new URL("https://example.com");
    return r.search = e2, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e2, t2) {
    return t2 || e2 === "" ? e2 : _(e2) ? K(e2) : j(e2);
  };
  var ae = function(e2, t2) {
    if (t2 || e2 === "")
      return e2;
    let r = new URL("https://example.com");
    return r.password = e2, r.password;
  };
  var oe = function(e2, t2) {
    if (t2 || e2 === "")
      return e2;
    let r = new URL("https://example.com");
    return r.username = e2, r.username;
  };
  var ce = function(e2, t2, r) {
    if (r || e2 === "")
      return e2;
    if (t2 && !re.includes(t2))
      return new URL(`${t2}:${e2}`).pathname;
    let n2 = e2[0] == "/";
    return e2 = new URL(n2 ? e2 : "/-" + e2, "https://example.com").pathname, n2 || (e2 = e2.substring(2, e2.length)), e2;
  };
  var le = function(e2, t2, r) {
    return z(t2) === e2 && (e2 = ""), r || e2 === "" ? e2 : V(e2);
  };
  var he = function(e2, t2) {
    return e2 = Ce(e2, ":"), t2 || e2 === "" ? e2 : A(e2);
  };
  var z = function(e2) {
    switch (e2) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var A = function(e2) {
    if (e2 === "")
      return e2;
    if (/^[-+.A-Za-z0-9]*$/.test(e2))
      return e2.toLowerCase();
    throw new TypeError(`Invalid protocol '${e2}'.`);
  };
  var fe = function(e2) {
    if (e2 === "")
      return e2;
    let t2 = new URL("https://example.com");
    return t2.username = e2, t2.username;
  };
  var ue = function(e2) {
    if (e2 === "")
      return e2;
    let t2 = new URL("https://example.com");
    return t2.password = e2, t2.password;
  };
  var j = function(e2) {
    if (e2 === "")
      return e2;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e2))
      throw new TypeError(`Invalid hostname '${e2}'`);
    let t2 = new URL("https://example.com");
    return t2.hostname = e2, t2.hostname;
  };
  var K = function(e2) {
    if (e2 === "")
      return e2;
    if (/[^0-9a-fA-F[\]:]/g.test(e2))
      throw new TypeError(`Invalid IPv6 hostname '${e2}'`);
    return e2.toLowerCase();
  };
  var V = function(e2) {
    if (e2 === "" || /^[0-9]*$/.test(e2) && parseInt(e2) <= 65535)
      return e2;
    throw new TypeError(`Invalid port '${e2}'.`);
  };
  var pe = function(e2) {
    if (e2 === "")
      return e2;
    let t2 = new URL("https://example.com");
    return t2.pathname = e2[0] !== "/" ? "/-" + e2 : e2, e2[0] !== "/" ? t2.pathname.substring(2, t2.pathname.length) : t2.pathname;
  };
  var de = function(e2) {
    return e2 === "" ? e2 : new URL(`data:${e2}`).pathname;
  };
  var ge = function(e2) {
    if (e2 === "")
      return e2;
    let t2 = new URL("https://example.com");
    return t2.search = e2, t2.search.substring(1, t2.search.length);
  };
  var me = function(e2) {
    if (e2 === "")
      return e2;
    let t2 = new URL("https://example.com");
    return t2.hash = e2, t2.hash.substring(1, t2.hash.length);
  };
  var xe = function(e2, t2) {
    if (typeof e2 != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e2, t2);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var P = function(e2, t2) {
    return t2 ? C(e2) : e2;
  };
  var w2 = function(e2, t2, r) {
    let n2;
    if (typeof t2.baseURL == "string")
      try {
        n2 = new URL(t2.baseURL), e2.protocol = P(n2.protocol.substring(0, n2.protocol.length - 1), r), e2.username = P(n2.username, r), e2.password = P(n2.password, r), e2.hostname = P(n2.hostname, r), e2.port = P(n2.port, r), e2.pathname = P(n2.pathname, r), e2.search = P(n2.search.substring(1, n2.search.length), r), e2.hash = P(n2.hash.substring(1, n2.hash.length), r);
      } catch {
        throw new TypeError(`invalid baseURL '${t2.baseURL}'.`);
      }
    if (typeof t2.protocol == "string" && (e2.protocol = he(t2.protocol, r)), typeof t2.username == "string" && (e2.username = oe(t2.username, r)), typeof t2.password == "string" && (e2.password = ae(t2.password, r)), typeof t2.hostname == "string" && (e2.hostname = ie(t2.hostname, r)), typeof t2.port == "string" && (e2.port = le(t2.port, e2.protocol, r)), typeof t2.pathname == "string") {
      if (e2.pathname = t2.pathname, n2 && !ee(e2.pathname, r)) {
        let a2 = n2.pathname.lastIndexOf("/");
        a2 >= 0 && (e2.pathname = P(n2.pathname.substring(0, a2 + 1), r) + e2.pathname);
      }
      e2.pathname = ce(e2.pathname, e2.protocol, r);
    }
    return typeof t2.search == "string" && (e2.search = se(t2.search, r)), typeof t2.hash == "string" && (e2.hash = ne(t2.hash, r)), e2;
  };
  var C = function(e2) {
    return e2.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e2) {
    return e2.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e2, t2) {
    t2.delimiter ??= "/#?", t2.prefixes ??= "./", t2.sensitive ??= false, t2.strict ??= false, t2.end ??= true, t2.start ??= true, t2.endsWith = "";
    let r = ".*", n2 = `[^${Le(t2.delimiter)}]+?`, a2 = /[$_\u200C\u200D\p{ID_Continue}]/u, c2 = "";
    for (let l2 = 0;l2 < e2.length; ++l2) {
      let s2 = e2[l2];
      if (s2.type === 3) {
        if (s2.modifier === 3) {
          c2 += C(s2.value);
          continue;
        }
        c2 += `{${C(s2.value)}}${y2(s2.modifier)}`;
        continue;
      }
      let i = s2.hasCustomName(), o2 = !!s2.suffix.length || !!s2.prefix.length && (s2.prefix.length !== 1 || !t2.prefixes.includes(s2.prefix)), h2 = l2 > 0 ? e2[l2 - 1] : null, p2 = l2 < e2.length - 1 ? e2[l2 + 1] : null;
      if (!o2 && i && s2.type === 1 && s2.modifier === 3 && p2 && !p2.prefix.length && !p2.suffix.length)
        if (p2.type === 3) {
          let O = p2.value.length > 0 ? p2.value[0] : "";
          o2 = a2.test(O);
        } else
          o2 = !p2.hasCustomName();
      if (!o2 && !s2.prefix.length && h2 && h2.type === 3) {
        let O = h2.value[h2.value.length - 1];
        o2 = t2.prefixes.includes(O);
      }
      o2 && (c2 += "{"), c2 += C(s2.prefix), i && (c2 += `:${s2.name}`), s2.type === 2 ? c2 += `(${s2.value})` : s2.type === 1 ? i || (c2 += `(${n2})`) : s2.type === 0 && (!i && (!h2 || h2.type === 3 || h2.modifier !== 3 || o2 || s2.prefix !== "") ? c2 += "*" : c2 += `(${r})`), s2.type === 1 && i && s2.suffix.length && a2.test(s2.suffix[0]) && (c2 += "\\"), c2 += C(s2.suffix), o2 && (c2 += "}"), s2.modifier !== 3 && (c2 += y2(s2.modifier));
    }
    return c2;
  };
  var M = Object.defineProperty;
  var Se = Object.getOwnPropertyDescriptor;
  var ke = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Re = (e2, t2) => {
    for (var r in t2)
      M(e2, r, { get: t2[r], enumerable: true });
  };
  var ye = (e2, t2, r, n2) => {
    if (t2 && typeof t2 == "object" || typeof t2 == "function")
      for (let a2 of ke(t2))
        !Ee.call(e2, a2) && a2 !== r && M(e2, a2, { get: () => t2[a2], enumerable: !(n2 = Se(t2, a2)) || n2.enumerable });
    return e2;
  };
  var Oe = (e2) => ye(M({}, "__esModule", { value: true }), e2);
  var Ne = {};
  Re(Ne, { URLPattern: () => Y });
  module.exports = Oe(Ne);
  var k2 = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t2, r, n2, a2, c2, l2) {
      this.type = t2, this.name = r, this.prefix = n2, this.value = a2, this.suffix = c2, this.modifier = l2;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Te = /[$_\p{ID_Start}]/u;
  var Ae = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var b2 = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var U = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #u = 0;
    #c = 0;
    #p = 0;
    #d = 0;
    #g = false;
    constructor(t2) {
      this.#i = t2;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#c === 0) {
            this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = "") : (this.#r(7, 0), this.#t.search = "", this.#t.hash = "");
            continue;
          } else if (this.#c === 2) {
            this.#f(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#p > 0)
          if (this.#T())
            this.#p -= 1;
          else
            continue;
        if (this.#O()) {
          this.#p += 1;
          continue;
        }
        switch (this.#c) {
          case 0:
            this.#S() && (this.#t.username = "", this.#t.password = "", this.#t.hostname = "", this.#t.port = "", this.#t.pathname = "", this.#t.search = "", this.#t.hash = "", this.#f(1));
            break;
          case 1:
            if (this.#S()) {
              this.#C();
              let t2 = 7, r = 1;
              this.#g && (this.#t.pathname = "/"), this.#E() ? (t2 = 2, r = 3) : this.#g && (t2 = 2), this.#r(t2, r);
            }
            break;
          case 2:
            this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);
            break;
          case 3:
            this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);
            break;
          case 4:
            this.#x() && this.#r(5, 1);
            break;
          case 5:
            this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 6:
            this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 8:
            this.#l() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
    }
    #r(t2, r) {
      switch (this.#c) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#o();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#o();
          break;
        case 4:
          this.#t.password = this.#o();
          break;
        case 5:
          this.#t.hostname = this.#o();
          break;
        case 6:
          this.#t.port = this.#o();
          break;
        case 7:
          this.#t.pathname = this.#o();
          break;
        case 8:
          this.#t.search = this.#o();
          break;
        case 9:
          this.#t.hash = this.#o();
          break;
        case 10:
          break;
      }
      this.#k(t2, r);
    }
    #k(t2, r) {
      this.#c = t2, this.#u = this.#e + r, this.#e += r, this.#s = 0;
    }
    #P() {
      this.#e = this.#u, this.#s = 0;
    }
    #f(t2) {
      this.#P(), this.#c = t2;
    }
    #m(t2) {
      return t2 < 0 && (t2 = this.#n.length - t2), t2 < this.#n.length ? this.#n[t2] : this.#n[this.#n.length - 1];
    }
    #a(t2, r) {
      let n2 = this.#m(t2);
      return n2.value === r && (n2.type === "CHAR" || n2.type === "ESCAPED_CHAR" || n2.type === "INVALID_CHAR");
    }
    #S() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #x() {
      return this.#a(this.#e, "@");
    }
    #R() {
      return this.#a(this.#e, ":");
    }
    #y() {
      return this.#a(this.#e, ":");
    }
    #b() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t2 = this.#m(this.#e - 1);
      return t2.type !== "NAME" && t2.type !== "REGEX" && t2.type !== "CLOSE" && t2.type !== "ASTERISK";
    }
    #l() {
      return this.#a(this.#e, "#");
    }
    #O() {
      return this.#n[this.#e].type == "OPEN";
    }
    #T() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #A() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #o() {
      let t2 = this.#n[this.#e], r = this.#m(this.#u).index;
      return this.#i.substring(r, t2.index);
    }
    #C() {
      let t2 = {};
      Object.assign(t2, b2), t2.encodePart = A;
      let r = q(this.#o(), undefined, t2);
      this.#g = N(r);
    }
  };
  var G = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    constructor(t2 = {}, r, n2) {
      try {
        let a2;
        if (typeof r == "string" ? a2 = r : n2 = r, typeof t2 == "string") {
          let i = new U(t2);
          if (i.parse(), t2 = i.result, a2 === undefined && typeof t2.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t2.baseURL = a2;
        } else {
          if (!t2 || typeof t2 != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a2)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n2 > "u" && (n2 = { ignoreCase: false });
        let c2 = { ignoreCase: n2.ignoreCase === true }, l2 = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w2(l2, t2, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s2;
        for (s2 of G) {
          if (!(s2 in this.#i))
            continue;
          let i = {}, o2 = this.#i[s2];
          switch (this.#t[s2] = [], s2) {
            case "protocol":
              Object.assign(i, b2), i.encodePart = A;
              break;
            case "username":
              Object.assign(i, b2), i.encodePart = fe;
              break;
            case "password":
              Object.assign(i, b2), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o2) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, b2), i.encodePart = V;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c2), i.encodePart = pe) : (Object.assign(i, b2, c2), i.encodePart = de);
              break;
            case "search":
              Object.assign(i, b2, c2), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, b2, c2), i.encodePart = me;
              break;
          }
          try {
            this.#s[s2] = F(o2, i), this.#n[s2] = W(this.#s[s2], this.#t[s2], i), this.#e[s2] = Ie(this.#s[s2], i);
          } catch {
            throw new TypeError(`invalid ${s2} pattern '${this.#i[s2]}'.`);
          }
        }
      } catch (a2) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a2.message}`);
      }
    }
    test(t2 = {}, r) {
      let n2 = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t2 != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t2 > "u")
        return false;
      try {
        typeof t2 == "object" ? n2 = w2(n2, t2, false) : n2 = w2(n2, xe(t2, r), false);
      } catch {
        return false;
      }
      let a2;
      for (a2 of G)
        if (!this.#n[a2].exec(n2[a2]))
          return false;
      return true;
    }
    exec(t2 = {}, r) {
      let n2 = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t2 != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t2 > "u")
        return;
      try {
        typeof t2 == "object" ? n2 = w2(n2, t2, false) : n2 = w2(n2, xe(t2, r), false);
      } catch {
        return null;
      }
      let a2 = {};
      r ? a2.inputs = [t2, r] : a2.inputs = [t2];
      let c2;
      for (c2 of G) {
        let l2 = this.#n[c2].exec(n2[c2]);
        if (!l2)
          return null;
        let s2 = {};
        for (let [i, o2] of this.#t[c2].entries())
          if (typeof o2 == "string" || typeof o2 == "number") {
            let h2 = l2[i + 1];
            s2[o2] = h2;
          }
        a2[c2] = { input: n2[c2] ?? "", groups: s2 };
      }
      return a2;
    }
    static compareComponent(t2, r, n2) {
      let a2 = (i, o2) => {
        for (let h2 of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[h2] < o2[h2])
            return -1;
          if (i[h2] === o2[h2])
            continue;
          return 1;
        }
        return 0;
      }, c2 = new k2(3, "", "", "", "", 3), l2 = new k2(0, "", "", "", "", 3), s2 = (i, o2) => {
        let h2 = 0;
        for (;h2 < Math.min(i.length, o2.length); ++h2) {
          let p2 = a2(i[h2], o2[h2]);
          if (p2)
            return p2;
        }
        return i.length === o2.length ? 0 : a2(i[h2] ?? c2, o2[h2] ?? c2);
      };
      return !r.#e[t2] && !n2.#e[t2] ? 0 : r.#e[t2] && !n2.#e[t2] ? s2(r.#s[t2], [l2]) : !r.#e[t2] && n2.#e[t2] ? s2([l2], n2.#s[t2]) : s2(r.#s[t2], n2.#s[t2]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillAbortError = undefined;

  class PonyfillAbortError extends Error {
    constructor(reason) {
      let message = "The operation was aborted";
      if (reason) {
        message += ` reason: ${reason}`;
      }
      super(message, {
        cause: reason
      });
      this.name = "AbortError";
    }
    get reason() {
      return this.cause;
    }
  }
  exports.PonyfillAbortError = PonyfillAbortError;
});

// /Users/richardguerre/Projects/flow/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    __extends = function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
    __assign = Object.assign || function(t2) {
      for (var s2, i = 1, n2 = arguments.length;i < n2; i++) {
        s2 = arguments[i];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    __rest = function(s2, e2) {
      var t2 = {};
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s2);i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
            t2[p2[i]] = s2[p2[i]];
        }
      return t2;
    };
    __decorate = function(decorators, target, key, desc) {
      var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d2 = decorators[i])
            r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
      return c2 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p2 in contextIn)
          context[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context.access[p2] = contextIn.access[p2];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value14) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value14 = useValue ? initializers[i].call(thisArg, value14) : initializers[i].call(thisArg);
      }
      return useValue ? value14 : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value14) {
        return value14 instanceof P ? value14 : new P(function(resolve) {
          resolve(value14);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value14) {
          try {
            step(generator.next(value14));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value14) {
          try {
            step(generator["throw"](value14));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f, y2, t2, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t2[1]) {
                  _.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _.label < t2[2]) {
                  _.label = t2[2];
                  _.ops.push(op);
                  break;
                }
                if (t2[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m2, o2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
          __createBinding(o2, m2, p2);
    };
    __createBinding = Object.create ? function(o2, m2, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      o2[k22] = m2[k2];
    };
    __values = function(o2) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i >= o2.length)
              o2 = undefined;
            return { value: o2 && o2[i++], done: !o2 };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i = m2.call(o2), r, ar = [], e2;
      try {
        while ((n2 === undefined || n2-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error21) {
        e2 = { error: error21 };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s2 = 0, i = 0, il = arguments.length;i < il; i++)
        s2 += arguments[i].length;
      for (var r = Array(s2), k2 = 0, i = 0;i < il; i++)
        for (var a2 = arguments[i], j = 0, jl = a2.length;j < jl; j++, k2++)
          r[k2] = a2[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l2 = from.length, ar;i < l2; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n2) {
        if (g[n2])
          i[n2] = function(v) {
            return new Promise(function(a2, b2) {
              q.push([n2, v, a2, b2]) > 1 || resume(n2, v);
            });
          };
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e2) {
          settle(q[0][3], e2);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value14) {
        resume("next", value14);
      }
      function reject(value14) {
        resume("throw", value14);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i, p2;
      return i = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n2, f) {
        i[n2] = o2[n2] ? function(v) {
          return (p2 = !p2) ? { value: __await(o2[n2](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o2[Symbol.asyncIterator], i;
      return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n2) {
        i[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o2[n2](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d2, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d2 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value14, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value14) : f ? f.value = value14 : state.set(receiver, value14), value14;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value14, async) {
      if (value14 !== null && value14 !== undefined) {
        if (typeof value14 !== "object" && typeof value14 !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value14[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value14[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value: value14, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value14;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error21, suppressed, message) {
      var e2 = new Error(message);
      return e2.name = "SuppressedError", e2.error = error21, e2.suppressed = suppressed, e2;
    };
    __disposeResources = function(env) {
      function fail(e2) {
        env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e2) {
                fail(e2);
                return next();
              });
          } catch (e2) {
            fail(e2);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type73 = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type: type73, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value14 = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value14 += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value14 += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value14 = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value14;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type73 = str.slice(0, i).toLowerCase();
    return { type: type73, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value14 = "";
      let valueStart;
      let charset;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode2 = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value14 += str.slice(valueStart, i);
                value14 += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode2 = 2;
                else if (encode2 === 0)
                  encode2 = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value14 += str.slice(valueStart, i);
        value14 = convertToUTF8(value14, charset, encode2);
        if (value14 === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value14 += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value14 += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value14 = str.slice(valueStart, i);
        }
        value14 = defDecoder(value14, 2);
        if (value14 === undefined)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value14;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode2 = getDecoder(charset);
    if (decode2)
      return decode2(data, hint);
  };
  var basename = function(path) {
    if (typeof path !== "string")
      return "";
    for (let i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// /Users/richardguerre/Projects/flow/node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = import.meta.require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n2) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = import.meta.require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type73 of TYPES) {
      const matched = type73.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type73(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error21) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error21);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = import.meta.require("stream");

  class PonyfillReadableStream {
    constructor(underlyingSource) {
      this.locked = false;
      if (underlyingSource instanceof PonyfillReadableStream) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        let reader;
        let started = false;
        this.readable = new stream_1.Readable({
          read() {
            if (!started) {
              started = true;
              reader = underlyingSource.getReader();
            }
            reader.read().then(({ value: value14, done }) => {
              if (done) {
                this.push(null);
              } else {
                this.push(value14);
              }
            }).catch((err) => {
              this.destroy(err);
            });
          },
          destroy(err, callback) {
            reader.cancel(err).then(() => callback(err), callback);
          }
        });
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          async destroy(err, callback) {
            try {
              await underlyingSource?.cancel?.(err);
              callback(null);
            } catch (err2) {
              callback(err2);
            }
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return Promise.resolve();
    }
    getReader(_options) {
      const iterator4 = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator4.next();
        },
        releaseLock: () => {
          iterator4.return?.();
          this.locked = false;
        },
        cancel: async (reason) => {
          await iterator4.return?.(reason);
          this.locked = false;
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    async pipeTo(destination) {
      const writer = destination.getWriter();
      await writer.ready;
      for await (const chunk of this.readable) {
        await writer.write(chunk);
      }
      await writer.ready;
      return writer.close();
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils2 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value14, key) => {
      obj[key] = value14;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value14, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value14);
      }
      headerArray.push(`${key}: ${value14}`);
    });
    return headerArray;
  };
  var isPromise4 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value14) {
    if (isPromise4(value14)) {
      return value14;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value14);
          if (isPromise4(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise4(callbackResult)) {
            return callbackResult.then(() => value14);
          }
          return fakePromise(value14);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadable = exports.isArrayBufferView = exports.fakePromise = exports.defaultHeadersSerializer = exports.getHeadersObj = undefined;
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var isBlob = function(obj) {
    return obj != null && obj.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();

  class PonyfillBlob {
    constructor(blobParts, options) {
      this.blobParts = blobParts;
      this._size = null;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && isBlob(blobParts[0])) {
        return blobParts[0];
      }
    }
    arrayBuffer() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.arrayBuffer();
        }
        return (0, utils_js_1.fakePromise)(getBlobPartAsBuffer(blobPart));
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (isBlob(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    text() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          return (0, utils_js_1.fakePromise)(blobPart);
        }
        if (isBlob(blobPart)) {
          return blobPart.text();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(buf.toString(this.encoding));
      }
      return this.arrayBuffer().then((buf) => buf.toString(this.encoding));
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (isBlob(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    constructor(fileBits, name, options) {
      super(fileBits, options);
      this.name = name;
      this.webkitRelativePath = "";
      this.lastModified = options?.lastModified || Date.now();
    }
  }
  exports.PonyfillFile = PonyfillFile;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value14, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value14]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value14] = entry;
          if (typeof value14 === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value14));
          } else {
            let filenamePart = "";
            if (value14.name) {
              filenamePart = `; filename="${value14.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value14.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value14.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name, blob, fileName) {
    blob.name = fileName || blob.name || name;
    return blob;
  };
  var isBlob = function(value14) {
    return value14?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamFromFormData = exports.PonyfillFormData = undefined;
  var ReadableStream_js_1 = require_ReadableStream();

  class PonyfillFormData {
    constructor() {
      this.map = new Map;
    }
    append(name, value14, fileName) {
      let values3 = this.map.get(name);
      if (!values3) {
        values3 = [];
        this.map.set(name, values3);
      }
      const entry = isBlob(value14) ? getNormalizedFile(name, value14, fileName) : value14;
      values3.push(entry);
    }
    delete(name) {
      this.map.delete(name);
    }
    get(name) {
      const values3 = this.map.get(name);
      return values3 ? values3[0] : null;
    }
    getAll(name) {
      return this.map.get(name) || [];
    }
    has(name) {
      return this.map.has(name);
    }
    set(name, value14, fileName) {
      const entry = isBlob(value14) ? getNormalizedFile(name, value14, fileName) : value14;
      this.map.set(name, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values3] of this.map) {
        for (const value14 of values3) {
          yield [key, value14];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values3 of this.map.values()) {
        for (const value14 of values3) {
          yield value14;
        }
      }
    }
    forEach(callback) {
      for (const [key, value14] of this) {
        callback(value14, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
  exports.getStreamFromFormData = getStreamFromFormData;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value14) {
    return value14?.forEach != null;
  };
  var isBlob = function(value14) {
    return value14?.stream != null;
  };
  var isURLSearchParams = function(value14) {
    return value14?.sort != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = import.meta.require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob();
  var File_js_1 = require_File();
  var FormData_js_1 = require_FormData();
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      this.bodyUsed = false;
      this.contentType = null;
      this.contentLength = null;
      this._bodyFactory = () => null;
      this._generatedBody = null;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    generateBody() {
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _collectChunksFromReadable() {
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      const chunks = [];
      _body.readable.on("data", (chunk) => {
        chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(chunks);
        });
        _body.readable.once("error", (e2) => {
          reject(e2);
        });
      });
    }
    blob() {
      if (this.bodyType === BodyInitType.Blob) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      if (this._buffer) {
        const blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
      });
    }
    formData(opts) {
      if (this.bodyType === BodyInitType.FormData) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      const formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name, value14, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          formData.set(name, value14);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            formData.set(name, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(formData);
        });
        bb.on("error", (err) => {
          reject(err);
        });
        _body?.readable.pipe(bb);
      });
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
          return this.bodyInit.arrayBuffer();
        }
        const bodyInitTyped = this.bodyInit;
        return bodyInitTyped.arrayBuffer().then((arrayBuffer) => Buffer.from(arrayBuffer, undefined, bodyInitTyped.size));
      }
      return this._collectChunksFromReadable().then((chunks) => {
        if (chunks.length === 1) {
          return chunks[0];
        }
        return Buffer.concat(chunks);
      });
    }
    json() {
      return this.text().then((text) => JSON.parse(text));
    }
    text() {
      if (this.bodyType === BodyInitType.String) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      return this.arrayBuffer().then((buffer) => buffer.toString("utf-8"));
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  var splitSetCookieHeader = function(setCookieHeader) {
    const setCookieHeaders = [];
    let currentStr = "";
    let ignoreComma = false;
    for (const ch of setCookieHeader) {
      if (currentStr.endsWith("Expires=")) {
        ignoreComma = true;
      }
      if (ignoreComma) {
        if (ch === ";") {
          ignoreComma = false;
        }
        if (ch === "," && currentStr.split("Expires=")[1].length > 3) {
          ignoreComma = false;
        }
      }
      if (ch === "," && !ignoreComma) {
        setCookieHeaders.push(currentStr.trim());
        currentStr = "";
      } else {
        currentStr += ch;
      }
    }
    if (currentStr) {
      setCookieHeaders.push(currentStr.trim());
    }
    return setCookieHeaders;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitSetCookieHeader = exports.PonyfillHeaders = exports.isHeadersLike = undefined;
  var node_util_1 = import.meta.require("util");
  exports.isHeadersLike = isHeadersLike;

  class PonyfillHeaders {
    constructor(headersInit) {
      this.headersInit = headersInit;
      this.objectNormalizedKeysOfHeadersInit = [];
      this.objectOriginalKeysOfHeadersInit = [];
    }
    _get(key) {
      if (this._map) {
        return this._map.get(key.toLowerCase()) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      const normalized = key.toLowerCase();
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k2) => {
            this.objectOriginalKeysOfHeadersInit.push(k2);
            this.objectNormalizedKeysOfHeadersInit.push(k2.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map(this.headersInit);
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value14, key) => {
              this._map.set(key, value14);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name, value14) {
      const key = name.toLowerCase();
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value14}` : value14;
      this.getMap().set(key, finalValue);
    }
    get(name) {
      const value14 = this._get(name);
      if (value14 == null) {
        return null;
      }
      return value14;
    }
    has(name) {
      return !!this._get(name);
    }
    set(name, value14) {
      const key = name.toLowerCase();
      this.getMap().set(key, value14);
    }
    delete(name) {
      const key = name.toLowerCase();
      this.getMap().delete(key);
    }
    forEach(callback) {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value14]) => {
              callback(value14, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value14]) => {
            if (value14 != null) {
              callback(value14, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value14, key) => {
        callback(value14, key, this);
      });
    }
    keys() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit.map(([key]) => key)[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.keys();
          }
          return Object.keys(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().keys();
    }
    values() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit.map(([, value14]) => value14)[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.values();
          }
          return Object.values(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().values();
    }
    entries() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.entries();
          }
          return Object.entries(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().entries();
    }
    getSetCookie() {
      const setCookieHeader = this.get("set-cookie");
      if (!setCookieHeader) {
        return [];
      }
      return splitSetCookieHeader(setCookieHeader);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record3 = {};
      this.forEach((value14, key) => {
        if (key === "set-cookie") {
          record3["set-cookie"] = this.getSetCookie();
        } else {
          record3[key] = value14.includes(",") ? value14.split(",").map((el) => el.trim()) : value14;
        }
      });
      return `Headers ${(0, node_util_1.inspect)(record3)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
  exports.splitSetCookieHeader = splitSetCookieHeader;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = import.meta.require("http");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    clone() {
      return new PonyfillResponse(this.body, this);
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 301) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlCode, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    curlHandle.setOpt("SSL_VERIFYPEER", false);
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value14) => {
      size = Number(value14);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    return new Promise(function promiseResolver(resolve, reject) {
      let streamResolved = false;
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          if (streamResolved) {
            curlHandle.pause(CurlPause.Recv);
          } else {
            reject(new AbortError_js_1.PonyfillAbortError);
            curlHandle.close();
          }
        };
      }
      curlHandle.once("end", function endListener() {
        curlHandle.close();
      });
      curlHandle.once("error", function errorListener(error21) {
        if (error21.isCurlError && error21.code === CurlCode.CURLE_ABORTED_BY_CALLBACK) {
        } else {
          reject(error21);
        }
        curlHandle.close();
      });
      curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
        const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
          if (headerFilter && !headerFilter.startsWith("HTTP/")) {
            if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
              reject(new Error("redirect is not allowed"));
            }
            return true;
          }
          return false;
        });
        const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
        resolve(new Response_js_1.PonyfillResponse(stream, {
          status,
          headers: headersInit,
          url: fetchRequest.url
        }));
        streamResolved = true;
      });
      curlHandle.perform();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = undefined;
  var node_stream_1 = import.meta.require("stream");
  var AbortError_js_1 = require_AbortError();
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  exports.fetchCurl = fetchCurl;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
    }
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return new PonyfillRequest(this);
    }
  }
  exports.PonyfillRequest = PonyfillRequest;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type73 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type73];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type73];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c2, shift) {
    var i = HEX[c2];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse5 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value14 = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c2 = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c2 = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c2 === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value14 = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value14 = value14.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value14 = fastDecode(value14) || value14;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value14;
          } else {
            if (currentValue.pop) {
              currentValue.push(value14);
            } else {
              result[key] = [currentValue, value14];
            }
          }
        }
        value14 = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c2 === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c2 === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c2 === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse5;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c2 = str.charCodeAt(i);
        while (c2 < 128) {
          if (noEscape[c2] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c2];
          }
          if (++i === len)
            break outer;
          c2 = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c2 < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c22 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c2 = 65536 + ((c2 & 1023) << 10 | c22);
        out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value14) {
    const type73 = typeof value14;
    if (type73 === "string") {
      return encodeString(value14);
    } else if (type73 === "bigint") {
      return value14.toString();
    } else if (type73 === "boolean") {
      return value14 ? "true" : "false";
    } else if (type73 === "number" && Number.isFinite(value14)) {
      return value14 < 1000000000000000000000 ? "" + value14 : encodeString("" + value14);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value14 = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value14)) {
        valueLength = value14.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value14[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value14);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse5 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse5,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse5;
  module.exports.stringify = stringify;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS((exports, module) => {
  var Url = function() {
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
  };
  var _escapePath = function(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var _escapeSearch = function(search) {
    return search.replace(/#/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var containsCharacter = function(string6, char1, fromIndex, stopCharacterTable) {
    var len2 = string6.length;
    for (var i2 = fromIndex;i2 < len2; ++i2) {
      var ch = string6.charCodeAt(i2);
      if (ch === char1) {
        return true;
      } else if (stopCharacterTable[ch] === 1) {
        return false;
      }
    }
    return false;
  };
  var containsCharacter2 = function(string6, char1, char2) {
    for (var i2 = 0, len2 = string6.length;i2 < len2; ++i2) {
      var ch = string6.charCodeAt(i2);
      if (ch === char1 || ch === char2)
        return true;
    }
    return false;
  };
  var makeAsciiTable = function(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item) {
      if (typeof item === "number") {
        ret[item] = 1;
      } else {
        var start = item[0];
        var end = item[1];
        for (var j = start;j <= end; ++j) {
          ret[j] = 1;
        }
      }
    });
    return ret;
  };
  var f = function() {
  };
  var querystring = import.meta.require("querystring");
  Url.queryString = querystring;
  Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    while (str.charCodeAt(start) <= 32)
      start++;
    while (str.charCodeAt(end) <= 32)
      end--;
    start = this._parseProtocol(str, start, end);
    if (this._protocol !== "javascript") {
      start = this._parseHost(str, start, end, hostDenotesSlash);
      var proto = this._protocol;
      if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
        this.hostname = this.host = "";
      }
    }
    if (start <= end) {
      var ch = str.charCodeAt(start);
      if (ch === 47 || ch === 92) {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else if (ch === 63) {
        this._parseQuery(str, start, end, disableAutoEscapeChars);
      } else if (ch === 35) {
        this._parseHash(str, start, end, disableAutoEscapeChars);
      } else if (this._protocol !== "javascript") {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else {
        this.pathname = str.slice(start, end + 1);
      }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
      this.pathname = "/";
    }
    if (parseQueryString) {
      var search = this.search;
      if (search == null) {
        search = this.search = "";
      }
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      this.query = Url.queryString.parse(search);
    }
  };
  Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
  };
  Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash6 = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    var q = this.query;
    if (q && typeof q === "object") {
      query = Url.queryString.stringify(q);
    }
    if (!search) {
      search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
      protocol += ":";
    if (this.host) {
      host = auth + this.host;
    } else if (hostname) {
      var ip6 = hostname.indexOf(":") > -1;
      if (ip6)
        hostname = "[" + hostname + "]";
      host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol)
      scheme = protocol + (slashes ? "//" : "");
    else if (slashes)
      scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
      pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 63)
      search = "?" + search;
    if (hash6 && hash6.charCodeAt(0) !== 35)
      hash6 = "#" + hash6;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash6;
  };
  Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
      relative = Url.parse(relative, false, true);
    var result = this._clone();
    result.hash = relative.hash;
    if (!relative.href) {
      result._href = "";
      return result;
    }
    if (relative.slashes && !relative._protocol) {
      relative._copyPropsTo(result, true);
      if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
      }
      result._href = "";
      return result;
    }
    if (relative._protocol && relative._protocol !== result._protocol) {
      if (!slashProtocols[relative._protocol]) {
        relative._copyPropsTo(result, false);
        result._href = "";
        return result;
      }
      result._protocol = relative._protocol;
      if (!relative.host && relative._protocol !== "javascript") {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result._port = relative._port;
      result.slashes = result.slashes || relative.slashes;
      result._href = "";
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
    var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    if (psychotic) {
      result.hostname = "";
      result._port = -1;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative._protocol) {
        relative.hostname = "";
        relative._port = -1;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = "";
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host ? relative.host : result.host;
      result.hostname = relative.hostname ? relative.hostname : result.hostname;
      result.search = relative.search;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
    } else if (relative.search) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result._href = "";
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      result._href = "";
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--) {
      last = srcPath[i2];
      if (last === ".") {
        srcPath.splice(i2, 1);
      } else if (last === "..") {
        srcPath.splice(i2, 1);
        up++;
      } else if (up) {
        srcPath.splice(i2, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (;up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
  };
  var punycode = import.meta.require("punycode");
  Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    return punycode.toASCII(hostname);
  };
  var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 35, 63)) {
      return pathname;
    }
    return _escapePath(pathname);
  };
  var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 35, -1))
      return search;
    return _escapeSearch(search);
  };
  Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        var protocol = str.slice(start, i2);
        if (doLowerCase)
          protocol = protocol.toLowerCase();
        this._protocol = protocol;
        return i2 + 1;
      } else if (protocolCharacters[ch] === 1) {
        if (ch < 97)
          doLowerCase = true;
      } else {
        return start;
      }
    }
    return start;
  };
  Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode2) {
    var auth = str.slice(start, end + 1);
    if (decode2) {
      auth = decodeURIComponent(auth);
    }
    this.auth = auth;
  };
  Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    var port = 0;
    var hadChars = false;
    var validPort = true;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (48 <= ch && ch <= 57) {
        port = 10 * port + (ch - 48);
        hadChars = true;
      } else {
        validPort = false;
        if (ch === 92 || ch === 47) {
          validPort = true;
        }
        break;
      }
    }
    if (port === 0 && !hadChars || !validPort) {
      if (!validPort) {
        this._port = -2;
      }
      return 0;
    }
    this._port = port;
    return i2 - start;
  };
  Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
      this.slashes = true;
      if (start === 0) {
        if (end < 2)
          return start;
        var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
        if (!hasAuth && !slashesDenoteHost) {
          this.slashes = null;
          return start;
        }
      }
      start += 2;
    } else if (!this._protocol || slashProtocols[this._protocol]) {
      return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 64) {
        j = i2;
      } else if (ch === 37) {
        authNeedsDecoding = true;
      } else if (hostEndingCharacters[ch] === 1) {
        break;
      }
    }
    if (j > -1) {
      this._parseAuth(str, start, j - 1, authNeedsDecoding);
      start = hostNameStart = j + 1;
    }
    if (str.charCodeAt(start) === 91) {
      for (var i2 = start + 1;i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 93) {
          if (str.charCodeAt(i2 + 1) === 58) {
            portLength = this._parsePort(str, i2 + 2, end) + 1;
          }
          var hostname = str.slice(start + 1, i2).toLowerCase();
          this.hostname = hostname;
          this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
          this.pathname = "/";
          return i2 + portLength + 1;
        }
      }
      return start;
    }
    for (var i2 = start;i2 <= end; ++i2) {
      if (charsAfterDot > 62) {
        this.hostname = this.host = str.slice(start, i2);
        return i2;
      }
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        portLength = this._parsePort(str, i2 + 1, end) + 1;
        hostNameEnd = i2 - 1;
        break;
      } else if (ch < 97) {
        if (ch === 46) {
          charsAfterDot = -1;
        } else if (65 <= ch && ch <= 90) {
          doLowerCase = true;
        } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
          if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
      } else if (ch >= 123) {
        if (ch <= 126) {
          if (this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
        idna = true;
      }
      lastCh = ch;
      charsAfterDot++;
    }
    if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
      var hostname = str.slice(hostNameStart, hostNameEnd + 1);
      if (doLowerCase)
        hostname = hostname.toLowerCase();
      if (idna)
        hostname = this._hostIdna(hostname);
      this.hostname = hostname;
      this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
  };
  Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
      input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
  };
  Url.prototype._clone = function Url$_clone() {
    var ret = new Url;
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
  };
  Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i2 = start;
    var ret = "";
    var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      var escaped = autoEscapeMap2[ch];
      if (escaped !== "" && escaped !== undefined) {
        if (cur < i2)
          ret += str.slice(cur, i2);
        ret += escaped;
        cur = i2 + 1;
      }
    }
    if (cur < i2 + 1)
      ret += str.slice(cur, i2);
    return ret;
  };
  Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (ch === 63) {
        this._parseQuery(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (pathStart > pathEnd) {
      this.pathname = prePath === "" ? "/" : prePath;
      return;
    }
    var path;
    if (escape2) {
      path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
      path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
  };
  Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        queryEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (queryStart > queryEnd) {
      this.search = "";
      return;
    }
    var query;
    if (escape2) {
      query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
      query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
  };
  Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
      this.hash = "";
      return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
  };
  Object.defineProperty(Url.prototype, "port", {
    get: function() {
      if (this._port >= 0) {
        return "" + this._port;
      }
      return null;
    },
    set: function(v) {
      if (v == null) {
        this._port = -1;
      } else {
        this._port = parseInt(v, 10);
      }
    }
  });
  Object.defineProperty(Url.prototype, "query", {
    get: function() {
      var query = this._query;
      if (query != null) {
        return query;
      }
      var search = this.search;
      if (search) {
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        if (search !== "") {
          this._query = search;
          return search;
        }
      }
      return search;
    },
    set: function(v) {
      this._query = v;
    }
  });
  Object.defineProperty(Url.prototype, "path", {
    get: function() {
      var p2 = this.pathname || "";
      var s2 = this.search || "";
      if (p2 || s2) {
        return p2 + s2;
      }
      return p2 == null && s2 ? "/" + s2 : null;
    },
    set: function() {
    }
  });
  Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
      var proto = this._protocol;
      return proto ? proto + ":" : proto;
    },
    set: function(v) {
      if (typeof v === "string") {
        var end = v.length - 1;
        if (v.charCodeAt(end) === 58) {
          this._protocol = v.slice(0, end);
        } else {
          this._protocol = v;
        }
      } else if (v == null) {
        this._protocol = null;
      }
    }
  });
  Object.defineProperty(Url.prototype, "href", {
    get: function() {
      var href = this._href;
      if (!href) {
        href = this._href = this.format();
      }
      return href;
    },
    set: function(v) {
      this._href = v;
    }
  });
  Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url)
      return str;
    var ret = new Url;
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
  };
  Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
      obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  };
  Url.resolve = function Url$Resolve(source2, relative) {
    return Url.parse(source2, false, true).resolve(relative);
  };
  Url.resolveObject = function Url$ResolveObject(source2, relative) {
    if (!source2)
      return relative;
    return Url.parse(source2, false, true).resolveObject(relative);
  };
  var autoEscape = [
    "<",
    ">",
    "\"",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
  ];
  var autoEscapeMap = new Array(128);
  for (i = 0, len = autoEscapeMap.length;i < len; ++i) {
    autoEscapeMap[i] = "";
  }
  var i;
  var len;
  for (i = 0, len = autoEscape.length;i < len; ++i) {
    c2 = autoEscape[i];
    esc = encodeURIComponent(c2);
    if (esc === c2) {
      esc = escape(c2);
    }
    autoEscapeMap[c2.charCodeAt(0)] = esc;
  }
  var c2;
  var esc;
  var i;
  var len;
  var afterQueryAutoEscapeMap = autoEscapeMap.slice();
  autoEscapeMap[92] = "/";
  var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
  };
  f.prototype = slashProtocols;
  Url.prototype._protocolCharacters = makeAsciiTable([
    [97, 122],
    [65, 90],
    46,
    43,
    45
  ]);
  Url.prototype._hostEndingCharacters = makeAsciiTable([
    35,
    63,
    47,
    92
  ]);
  Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "^",
    "`",
    "\"",
    "%",
    ";"
  ].map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._autoEscapeMap = autoEscapeMap;
  Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
  module.exports = Url;
  Url.replace = function Url$Replace() {
    require.cache.url = {
      exports: Url
    };
  };
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var isURLSearchParams = function(value14) {
    return value14?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value14] of init) {
            this.params[key] = value14;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value14] of init.entries()) {
            this.params[key] = value14;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name, value14) {
      const existingValue = this.params[name];
      const finalValue = existingValue ? `${existingValue},${value14}` : value14;
      this.params[name] = finalValue;
    }
    delete(name) {
      delete this.params[name];
    }
    get(name) {
      const value14 = this.params[name];
      if (Array.isArray(value14)) {
        return value14[0] || null;
      }
      return value14 || null;
    }
    getAll(name) {
      const value14 = this.params[name];
      if (!Array.isArray(value14)) {
        return value14 ? [value14] : [];
      }
      return value14;
    }
    has(name) {
      return name in this.params;
    }
    set(name, value14) {
      this.params[name] = value14;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value14 = this.params[key];
        if (Array.isArray(value14)) {
          for (const item of value14) {
            yield [key, item];
          }
        } else {
          yield [key, value14];
        }
      }
    }
    *values() {
      for (const [, value14] of this) {
        yield value14;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value14] of this) {
        callback(value14, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value14) {
      this.auth = `${value14}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value14) {
      this.auth = `${this.username}:${value14}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.PonyfillURL = PonyfillURL;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        fetchRequest["_signal"]?.addEventListener("abort", () => {
          if (!nodeRequest.aborted) {
            nodeRequest.abort();
          }
        });
        nodeRequest.once("abort", (reason) => {
          reject(new AbortError_js_1.PonyfillAbortError(reason));
        });
        nodeRequest.once("response", (nodeResponse) => {
          let responseBody = nodeResponse;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
              break;
            case "x-deflate":
            case "deflate":
              responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
              break;
            case "br":
              responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
              break;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e2) {
        reject(e2);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = undefined;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var stream_1 = import.meta.require("stream");
  var zlib_1 = import.meta.require("zlib");
  var AbortError_js_1 = require_AbortError();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  exports.fetchNodeHttp = fetchNodeHttp;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = undefined;
  var fs_1 = import.meta.require("fs");
  var url_1 = import.meta.require("url");
  var fetchCurl_js_1 = require_fetchCurl();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  var BASE64_SUFFIX = ";base64";
  exports.fetchPonyfill = fetchPonyfill;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBtoa = exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  var utils_js_1 = require_utils2();

  class PonyfillTextEncoder {
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source2, destination) {
      const buffer = this.encode(source2);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      this.fatal = false;
      this.ignoreBOM = false;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
  exports.PonyfillBtoa = PonyfillBtoa;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS((exports, module) => {
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    if (!ponyfills.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill();
      ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (globalThis.Deno || process.versions.bun) {
      return globalThis;
    }
    const newNodeFetch = require_cjs();
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = globalThis.WritableStream;
    ponyfills.TransformStream = globalThis.TransformStream;
    if (!ponyfills.WritableStream) {
      const streamsWeb = import.meta.require("stream/web");
      ponyfills.WritableStream = streamsWeb.WritableStream;
      ponyfills.TransformStream = streamsWeb.TransformStream;
    }
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Request = class Request2 extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Response = class Response2 extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills.crypto) {
      const cryptoModule = import.meta.require("crypto");
      ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var to = function(e2) {
    return typeof e2 == "function" ? e2 : (t2) => t2.$extends(e2);
  };
  var ro = function(e2) {
    return e2;
  };
  var no = function(...e2) {
    return (t2) => t2;
  };
  var lo = function(e2) {
    return e2.substring(0, 1).toLowerCase() + e2.substring(1);
  };
  var In = function(e2, t2) {
    return t2 ? `${t2}.${e2}` : e2;
  };
  var mu = function(e2) {
    let t2 = (0, vr.default)(e2), r = Object.assign((...n2) => (t2.log = r.log, n2.length !== 0 && It.push([e2, ...n2]), It.length > du && It.shift(), t2("", ...n2)), t2);
    return r;
  };
  var bo = function(e2 = 7500) {
    let t2 = It.map((r) => r.map((n2) => typeof n2 == "string" ? n2 : JSON.stringify(n2)).join(" ")).join(`
`);
    return t2.length < e2 ? t2 : t2.slice(-e2);
  };
  var Eo = function() {
    It.length = 0;
  };
  var _ = function(e2, t2) {
    let r = new RegExp(`\\x1b\\[${t2}m`, "g"), n2 = `\x1B[${e2}m`, i = `\x1B[${t2}m`;
    return function(o2) {
      return !fu.enabled || o2 == null ? o2 : n2 + (~("" + o2).indexOf(i) ? o2.replace(r, i + n2) : o2) + i;
    };
  };
  var Vn = function() {
    let e2 = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e2 && Co.default.existsSync(e2)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var jn = function(e2, t2) {
    let r = t2 === "url";
    return e2.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${e2}.dll.node` : e2.includes("darwin") ? r ? `${Cr}.dylib.node` : `${Cr}-${e2}.dylib.node` : r ? `${Cr}.so.node` : `${Cr}-${e2}.so.node`;
  };
  var Je = function(e2) {
    var t2;
    return (t2 = {})[Ar] = function() {
      return { match: function(r) {
        return { matched: !!e2(r) };
      } };
    }, t2;
  };
  var st = function(e2) {
    return new yu(e2, []);
  };
  var Ot = function(e2) {
    return (0, _o.default)(e2, e2, { fallback: te });
  };
  var Dt = function(e2, ...t2) {
    Eu.warn() && console.warn(`${bu.warn} ${e2}`, ...t2);
  };
  async function Vo() {
    let e2 = Sr.default.platform(), t2 = process.arch;
    if (e2 === "freebsd") {
      let s2 = await Ir("freebsd-version");
      if (s2 && s2.trim().length > 0) {
        let l2 = /^(\d+)\.?/.exec(s2);
        if (l2)
          return { platform: "freebsd", targetDistro: `freebsd${l2[1]}`, arch: t2 };
      }
    }
    if (e2 !== "linux")
      return { platform: e2, arch: t2 };
    let r = await Tu(), n2 = await Fu(), i = Au({ arch: t2, archFromUname: n2, familyDistro: r.familyDistro }), { libssl: o2 } = await Ru(i);
    return { platform: "linux", libssl: o2, arch: t2, archFromUname: n2, ...r };
  }
  var vu = function(e2) {
    let t2 = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n2 = t2.exec(e2), i = n2 && n2[1] && n2[1].toLowerCase() || "", o2 = r.exec(e2), s2 = o2 && o2[1] && o2[1].toLowerCase() || "", a2 = st({ id: i, idLike: s2 }).with({ id: "alpine" }, ({ id: l2 }) => ({ targetDistro: "musl", familyDistro: l2, originalDistro: l2 })).with({ id: "raspbian" }, ({ id: l2 }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l2 })).with({ id: "nixos" }, ({ id: l2 }) => ({ targetDistro: "nixos", originalDistro: l2, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l2 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l2 })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l2 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l2 })).when(({ idLike: l2 }) => l2.includes("debian") || l2.includes("ubuntu"), ({ id: l2 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l2 })).when(({ idLike: l2 }) => i === "arch" || l2.includes("arch"), ({ id: l2 }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l2 })).when(({ idLike: l2 }) => l2.includes("centos") || l2.includes("fedora") || l2.includes("rhel") || l2.includes("suse"), ({ id: l2 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l2 })).otherwise(({ id: l2 }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l2 }));
    return ie(`Found distro info:
${JSON.stringify(a2, null, 2)}`), a2;
  };
  async function Tu() {
    let e2 = "/etc/os-release";
    try {
      let t2 = await Gn.default.readFile(e2, { encoding: "utf-8" });
      return vu(t2);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var Cu = function(e2) {
    let t2 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e2);
    if (t2) {
      let r = `${t2[1]}.x`;
      return jo(r);
    }
  };
  var No = function(e2) {
    let t2 = /libssl\.so\.(\d)(\.\d)?/.exec(e2);
    if (t2) {
      let r = `${t2[1]}${t2[2] ?? ".0"}.x`;
      return jo(r);
    }
  };
  var jo = function(e2) {
    let t2 = (() => {
      if (Uo(e2))
        return e2;
      let r = e2.split(".");
      return r[1] = "0", r.join(".");
    })();
    if (Pu.includes(t2))
      return t2;
  };
  var Au = function(e2) {
    return st(e2).with({ familyDistro: "musl" }, () => (ie('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t2 }) => (ie('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t2}-linux-gnu`, `/lib/${t2}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ie('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t2, arch: r, archFromUname: n2 }) => (ie(`Don't know any platform-specific paths for "${t2}" on ${r} (${n2})`), []));
  };
  async function Ru(e2) {
    let t2 = 'grep -v "libssl.so.0"', r = await Lo(e2);
    if (r) {
      ie(`Found libssl.so file using platform-specific paths: ${r}`);
      let o2 = No(r);
      if (ie(`The parsed libssl version is: ${o2}`), o2)
        return { libssl: o2, strategy: "libssl-specific-path" };
    }
    ie('Falling back to "ldconfig" and other generic paths');
    let n2 = await Ir(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t2}`);
    if (n2 || (n2 = await Lo(["/lib64", "/usr/lib64", "/lib"])), n2) {
      ie(`Found libssl.so file using "ldconfig" or other generic paths: ${n2}`);
      let o2 = No(n2);
      if (ie(`The parsed libssl version is: ${o2}`), o2)
        return { libssl: o2, strategy: "ldconfig" };
    }
    let i = await Ir("openssl version -v");
    if (i) {
      ie(`Found openssl binary with version: ${i}`);
      let o2 = Cu(i);
      if (ie(`The parsed openssl version is: ${o2}`), o2)
        return { libssl: o2, strategy: "openssl-binary" };
    }
    return ie("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Lo(e2) {
    for (let t2 of e2) {
      let r = await Mu(t2);
      if (r)
        return r;
    }
  }
  async function Mu(e2) {
    try {
      return (await Gn.default.readdir(e2)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
    } catch (t2) {
      if (t2.code === "ENOENT")
        return;
      throw t2;
    }
  }
  async function ut() {
    let { binaryTarget: e2 } = await Bo();
    return e2;
  }
  var Su = function(e2) {
    return e2.binaryTarget !== undefined;
  };
  async function Jn() {
    let { memoized: e2, ...t2 } = await Bo();
    return t2;
  }
  async function Bo() {
    if (Su(Mr))
      return Promise.resolve({ ...Mr, memoized: true });
    let e2 = await Vo(), t2 = Iu(e2);
    return Mr = { ...e2, binaryTarget: t2 }, { ...Mr, memoized: false };
  }
  var Iu = function(e2) {
    let { platform: t2, arch: r, archFromUname: n2, libssl: i, targetDistro: o2, familyDistro: s2, originalDistro: a2 } = e2;
    t2 === "linux" && !["x64", "arm64"].includes(r) && Dt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n2}".`);
    let l2 = "1.1.x";
    if (t2 === "linux" && i === undefined) {
      let c2 = st({ familyDistro: s2 }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Dt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l2}".
${c2}`);
    }
    let u2 = "debian";
    if (t2 === "linux" && o2 === undefined && Dt(`Prisma doesn't know which engines to download for the Linux distro "${a2}". Falling back to Prisma engines built "${u2}".
Please report your experience by creating an issue at ${Ot("https://github.com/prisma/prisma/issues")} so we can add your distro to the list of known supported distros.`), t2 === "darwin" && r === "arm64")
      return "darwin-arm64";
    if (t2 === "darwin")
      return "darwin";
    if (t2 === "win32")
      return "windows";
    if (t2 === "freebsd")
      return o2;
    if (t2 === "openbsd")
      return "openbsd";
    if (t2 === "netbsd")
      return "netbsd";
    if (t2 === "linux" && o2 === "nixos")
      return "linux-nixos";
    if (t2 === "linux" && r === "arm64")
      return `${o2 === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l2}`;
    if (t2 === "linux" && r === "arm")
      return `linux-arm-openssl-${i || l2}`;
    if (t2 === "linux" && o2 === "musl") {
      let c2 = "linux-musl";
      return !i || Uo(i) ? c2 : `${c2}-openssl-${i}`;
    }
    return t2 === "linux" && o2 && i ? `${o2}-openssl-${i}` : (t2 !== "linux" && Dt(`Prisma detected unknown OS "${t2}" and may not work as expected. Defaulting to "linux".`), i ? `${u2}-openssl-${i}` : o2 ? `${o2}-openssl-${l2}` : `${u2}-openssl-${l2}`);
  };
  async function ku(e2) {
    try {
      return await e2();
    } catch {
      return;
    }
  }
  var Ir = function(e2) {
    return ku(async () => {
      let t2 = await wu(e2);
      return ie(`Command "${e2}" successfully returned "${t2.stdout}"`), t2.stdout;
    });
  };
  async function Fu() {
    return typeof Sr.default.machine == "function" ? Sr.default.machine() : (await Ir("uname -m"))?.trim();
  }
  var Uo = function(e2) {
    return e2.startsWith("1.");
  };
  var Jo = function(e2) {
    let t2 = e2.ignoreProcessEnv ? {} : process.env, r = (n2) => n2.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o2, s2) {
      let a2 = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s2);
      if (!a2)
        return o2;
      let l2 = a2[1], u2, c2;
      if (l2 === "\\")
        c2 = a2[0], u2 = c2.replace("\\$", "$");
      else {
        let p2 = a2[2];
        c2 = a2[0].substring(l2.length), u2 = Object.hasOwnProperty.call(t2, p2) ? t2[p2] : e2.parsed[p2] || "", u2 = r(u2);
      }
      return o2.replace(c2, u2);
    }, n2) ?? n2;
    for (let n2 in e2.parsed) {
      let i = Object.hasOwnProperty.call(t2, n2) ? t2[n2] : e2.parsed[n2];
      e2.parsed[n2] = r(i);
    }
    for (let n2 in e2.parsed)
      t2[n2] = e2.parsed[n2];
    return e2;
  };
  var _t = function({ rootEnvPath: e2, schemaEnvPath: t2 }, r = { conflictCheck: "none" }) {
    let n2 = Ho(e2);
    r.conflictCheck !== "none" && Bu(n2, t2, r.conflictCheck);
    let i = null;
    return Wo(n2?.path, t2) || (i = Ho(t2)), !n2 && !i && zn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(me(ne("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n2?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n2?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var Bu = function(e2, t2, r) {
    let n2 = e2?.dotenvResult.parsed, i = !Wo(e2?.path, t2);
    if (n2 && t2 && i && Or2.default.existsSync(t2)) {
      let o2 = Yn.default.parse(Or2.default.readFileSync(t2)), s2 = [];
      for (let a2 in o2)
        n2[a2] === o2[a2] && s2.push(a2);
      if (s2.length > 0) {
        let a2 = ct.default.relative(process.cwd(), e2.path), l2 = ct.default.relative(process.cwd(), t2);
        if (r === "error") {
          let u2 = `There is a conflict between env var${s2.length > 1 ? "s" : ""} in ${te(a2)} and ${te(l2)}
Conflicting env vars:
${s2.map((c2) => `  ${ne(c2)}`).join(`
`)}

We suggest to move the contents of ${te(l2)} to ${te(a2)} to consolidate your env vars.
`;
          throw new Error(u2);
        } else if (r === "warn") {
          let u2 = `Conflict for env var${s2.length > 1 ? "s" : ""} ${s2.map((c2) => ne(c2)).join(", ")} in ${te(a2)} and ${te(l2)}
Env vars from ${te(l2)} overwrite the ones from ${te(a2)}
      `;
          console.warn(`${he("warn(prisma)")} ${u2}`);
        }
      }
    }
  };
  var Ho = function(e2) {
    return Uu(e2) ? (zn(`Environment variables loaded from ${e2}`), { dotenvResult: Jo(Yn.default.config({ path: e2, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined })), message: Fe(`Environment variables loaded from ${ct.default.relative(process.cwd(), e2)}`), path: e2 }) : (zn(`Environment variables not found at ${e2}`), null);
  };
  var Wo = function(e2, t2) {
    return e2 && t2 && ct.default.resolve(e2) === ct.default.resolve(t2);
  };
  var Uu = function(e2) {
    return !!(e2 && Or2.default.existsSync(e2));
  };
  var Zn = function(e2) {
    let t2 = Ku();
    return t2 || (e2?.config.engineType === "library" ? "library" : e2?.config.engineType === "binary" ? "binary" : zo);
  };
  var Ku = function() {
    let e2 = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e2 === "library" ? "library" : e2 === "binary" ? "binary" : undefined;
  };
  var rs = function() {
    return N.default.join(import.meta.dir, "../");
  };
  var ti = function(e2) {
    if (process.platform === "win32")
      return;
    let t2 = ei.default.statSync(e2), r = t2.mode | 64 | 8 | 1;
    if (t2.mode === r) {
      ns(`Execution permissions of ${e2} are fine`);
      return;
    }
    let n2 = r.toString(8).slice(-3);
    ns(`Have to call chmodPlusX on ${e2}`), ei.default.chmodSync(e2, n2);
  };
  var ri = function(e2) {
    let t2 = e2.e, r = (a2) => `Prisma cannot find the required \`${a2}\` system library in your system`, n2 = t2.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Ot("https://pris.ly/d/system-requirements")}`, o2 = `Unable to require(\`${Fe(e2.id)}\`).`, s2 = st({ message: t2.message, code: t2.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a2 }) => n2 && a2.includes("libz"), () => `${r("libz")}. Please install it and try again.`).when(({ message: a2 }) => n2 && a2.includes("libgcc_s"), () => `${r("libgcc_s")}. Please install it and try again.`).when(({ message: a2 }) => n2 && a2.includes("libssl"), () => {
      let a2 = e2.platformInfo.libssl ? `openssl-${e2.platformInfo.libssl}` : "openssl";
      return `${r("libssl")}. Please install ${a2} and try again.`;
    }).when(({ message: a2 }) => a2.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a2 }) => e2.platformInfo.platform === "linux" && a2.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e2.platformInfo.originalDistro} on (${e2.platformInfo.archFromUname}) which uses the \`${e2.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o2}
${s2}

Details: ${t2.message}`;
  };
  var ni = function(e2) {
    return Nt.default.sep === Nt.default.posix.sep ? e2 : e2.split(Nt.default.sep).join(Nt.default.posix.sep);
  };
  var si = function(e2) {
    return String(new oi(e2));
  };
  var Wu = function(e2) {
    let t2;
    if (e2.length > 0) {
      let r = e2.find((n2) => n2.fromEnvVar !== null);
      r ? t2 = `env("${r.fromEnvVar}")` : t2 = e2.map((n2) => n2.native ? "native" : n2.value);
    } else
      t2 = undefined;
    return t2;
  };
  var zu = function(e2) {
    let t2 = Object.keys(e2).reduce((r, n2) => Math.max(r, n2.length), 0);
    return Object.entries(e2).map(([r, n2]) => `${r.padEnd(t2)} = ${Yu(n2)}`).join(`
`);
  };
  var Yu = function(e2) {
    return JSON.parse(JSON.stringify(e2, (t2, r) => Array.isArray(r) ? `[${r.map((n2) => JSON.stringify(n2)).join(", ")}]` : JSON.stringify(r)));
  };
  var Zu = function(...e2) {
    console.log(...e2);
  };
  var ai = function(e2, ...t2) {
    ss.warn() && console.warn(`${Lt.warn} ${e2}`, ...t2);
  };
  var Xu = function(e2, ...t2) {
    console.info(`${Lt.info} ${e2}`, ...t2);
  };
  var ec = function(e2, ...t2) {
    console.error(`${Lt.error} ${e2}`, ...t2);
  };
  var tc = function(e2, ...t2) {
    console.log(`${Lt.query} ${e2}`, ...t2);
  };
  var _r = function(e2, t2) {
    if (!e2)
      throw new Error(`${t2}. This should never happen. If you see this error, please, open an issue at https://github.com/prisma/prisma/issues/new?assignees=&labels=kind%2Fbug&projects=&template=bug_report.yml`);
  };
  var He = function(e2, t2) {
    throw new Error(t2);
  };
  var ui = function(e2, t2) {
    return Object.prototype.hasOwnProperty.call(e2, t2);
  };
  var pt = function(e2, t2) {
    let r = {};
    for (let n2 of Object.keys(e2))
      r[n2] = t2(e2[n2], n2);
    return r;
  };
  var pi = function(e2, t2) {
    if (e2.length === 0)
      return;
    let r = e2[0];
    for (let n2 = 1;n2 < e2.length; n2++)
      t2(r, e2[n2]) < 0 && (r = e2[n2]);
    return r;
  };
  var E = function(e2, t2) {
    Object.defineProperty(e2, "name", { value: t2, configurable: true });
  };
  var Vt = function(e2) {
    let t2;
    return { get() {
      return t2 || (t2 = { value: e2() }), t2.value;
    } };
  };
  var ms = function(e2, t2) {
    let r = Vt(() => nc(t2));
    Object.defineProperty(e2, "dmmf", { get: () => r.get() });
  };
  var nc = function(e2) {
    return { datamodel: { models: di(e2.models), enums: di(e2.enums), types: di(e2.types) } };
  };
  var di = function(e2) {
    return Object.entries(e2).map(([t2, r]) => ({ name: t2, ...r }));
  };
  var fi = function(e2, t2) {
    Object.defineProperty(e2, "name", { value: t2, configurable: true });
  };
  var qr = function(e2) {
    return { ok: false, error: e2, map() {
      return qr(e2);
    }, flatMap() {
      return qr(e2);
    } };
  };
  var De = function(e2, t2) {
    return async (...r) => {
      try {
        return await t2(...r);
      } catch (n2) {
        let i = e2.registerNewError(n2);
        return qr({ kind: "GenericJsError", id: i });
      }
    };
  };
  var ac = function(e2, t2) {
    return (...r) => {
      try {
        return t2(...r);
      } catch (n2) {
        let i = e2.registerNewError(n2);
        return qr({ kind: "GenericJsError", id: i });
      }
    };
  };
  var gs = function(e2, t2 = ",", r = "", n2 = "") {
    if (e2.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([r, ...Array(e2.length - 1).fill(t2), n2], e2);
  };
  var gi = function(e2) {
    return new oe([e2], []);
  };
  var yi = function(e2, ...t2) {
    return new oe(e2, t2);
  };
  var Qt = function(e2) {
    return { getKeys() {
      return Object.keys(e2);
    }, getPropertyValue(t2) {
      return e2[t2];
    } };
  };
  var re = function(e2, t2) {
    return { getKeys() {
      return [e2];
    }, getPropertyValue() {
      return t2();
    } };
  };
  var We = function(e2) {
    let t2 = new be;
    return { getKeys() {
      return e2.getKeys();
    }, getPropertyValue(r) {
      return t2.getOrCreate(r, () => e2.getPropertyValue(r));
    }, getPropertyDescriptor(r) {
      return e2.getPropertyDescriptor?.(r);
    } };
  };
  var jr = function(e2) {
    let t2 = new Set(e2);
    return { getOwnPropertyDescriptor: () => Vr, has: (r, n2) => t2.has(n2), set: (r, n2, i) => t2.add(n2) && Reflect.set(r, n2, i), ownKeys: () => [...t2] };
  };
  var Ee = function(e2, t2) {
    let r = uc(t2), n2 = new Set, i = new Proxy(e2, { get(o2, s2) {
      if (n2.has(s2))
        return o2[s2];
      let a2 = r.get(s2);
      return a2 ? a2.getPropertyValue(s2) : o2[s2];
    }, has(o2, s2) {
      if (n2.has(s2))
        return true;
      let a2 = r.get(s2);
      return a2 ? a2.has?.(s2) ?? true : Reflect.has(o2, s2);
    }, ownKeys(o2) {
      let s2 = xs(Reflect.ownKeys(o2), r), a2 = xs(Array.from(r.keys()), r);
      return [...new Set([...s2, ...a2, ...n2])];
    }, set(o2, s2, a2) {
      return r.get(s2)?.getPropertyDescriptor?.(s2)?.writable === false ? false : (n2.add(s2), Reflect.set(o2, s2, a2));
    }, getOwnPropertyDescriptor(o2, s2) {
      let a2 = Reflect.getOwnPropertyDescriptor(o2, s2);
      if (a2 && !a2.configurable)
        return a2;
      let l2 = r.get(s2);
      return l2 ? l2.getPropertyDescriptor ? { ...Vr, ...l2?.getPropertyDescriptor(s2) } : Vr : a2;
    }, defineProperty(o2, s2, a2) {
      return n2.add(s2), Reflect.defineProperty(o2, s2, a2);
    } });
    return i[hs] = function(o2, s2, a2 = bs.inspect) {
      let l2 = { ...this };
      return delete l2[hs], a2(l2, s2);
    }, i;
  };
  var uc = function(e2) {
    let t2 = new Map;
    for (let r of e2) {
      let n2 = r.getKeys();
      for (let i of n2)
        t2.set(i, r);
    }
    return t2;
  };
  var xs = function(e2, t2) {
    return e2.filter((r) => t2.get(r)?.has?.(r) ?? true);
  };
  var Gt = function(e2) {
    return { getKeys() {
      return e2;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var ft = function(e2) {
    return e2 instanceof Date || Object.prototype.toString.call(e2) === "[object Date]";
  };
  var Br = function(e2) {
    return e2.toString() !== "Invalid Date";
  };
  var W = function(e2) {
    var t2, r, n2, i = e2.length - 1, o2 = "", s2 = e2[0];
    if (i > 0) {
      for (o2 += s2, t2 = 1;t2 < i; t2++)
        n2 = e2[t2] + "", r = b2 - n2.length, r && (o2 += _e(r)), o2 += n2;
      s2 = e2[t2], n2 = s2 + "", r = b2 - n2.length, r && (o2 += _e(r));
    } else if (s2 === 0)
      return "0";
    for (;s2 % 10 === 0; )
      s2 /= 10;
    return o2 + s2;
  };
  var se = function(e2, t2, r) {
    if (e2 !== ~~e2 || e2 < t2 || e2 > r)
      throw Error(Le + e2);
  };
  var Jt = function(e2, t2, r, n2) {
    var i, o2, s2, a2;
    for (o2 = e2[0];o2 >= 10; o2 /= 10)
      --t2;
    return --t2 < 0 ? (t2 += b2, i = 0) : (i = Math.ceil((t2 + 1) / b2), t2 %= b2), o2 = j(10, b2 - t2), a2 = e2[i] % o2 | 0, n2 == null ? t2 < 3 ? (t2 == 0 ? a2 = a2 / 100 | 0 : t2 == 1 && (a2 = a2 / 10 | 0), s2 = r < 4 && a2 == 99999 || r > 3 && a2 == 49999 || a2 == 50000 || a2 == 0) : s2 = (r < 4 && a2 + 1 == o2 || r > 3 && a2 + 1 == o2 / 2) && (e2[i + 1] / o2 / 100 | 0) == j(10, t2 - 2) - 1 || (a2 == o2 / 2 || a2 == 0) && (e2[i + 1] / o2 / 100 | 0) == 0 : t2 < 4 ? (t2 == 0 ? a2 = a2 / 1000 | 0 : t2 == 1 ? a2 = a2 / 100 | 0 : t2 == 2 && (a2 = a2 / 10 | 0), s2 = (n2 || r < 4) && a2 == 9999 || !n2 && r > 3 && a2 == 4999) : s2 = ((n2 || r < 4) && a2 + 1 == o2 || !n2 && r > 3 && a2 + 1 == o2 / 2) && (e2[i + 1] / o2 / 1000 | 0) == j(10, t2 - 3) - 1, s2;
  };
  var Ur = function(e2, t2, r) {
    for (var n2, i = [0], o2, s2 = 0, a2 = e2.length;s2 < a2; ) {
      for (o2 = i.length;o2--; )
        i[o2] *= t2;
      for (i[0] += hi.indexOf(e2.charAt(s2++)), n2 = 0;n2 < i.length; n2++)
        i[n2] > r - 1 && (i[n2 + 1] === undefined && (i[n2 + 1] = 0), i[n2 + 1] += i[n2] / r | 0, i[n2] %= r);
    }
    return i.reverse();
  };
  var gc = function(e2, t2) {
    var r, n2, i;
    if (t2.isZero())
      return t2;
    n2 = t2.d.length, n2 < 32 ? (r = Math.ceil(n2 / 3), i = (1 / Wr(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e2.precision += r, t2 = yt(e2, 1, t2.times(i), new e2(1));
    for (var o2 = r;o2--; ) {
      var s2 = t2.times(t2);
      t2 = s2.times(s2).minus(s2).times(8).plus(1);
    }
    return e2.precision -= r, t2;
  };
  var h2 = function(e2, t2, r, n2) {
    var i, o2, s2, a2, l2, u2, c2, p2, d2, f = e2.constructor;
    e:
      if (t2 != null) {
        if (p2 = e2.d, !p2)
          return e2;
        for (i = 1, a2 = p2[0];a2 >= 10; a2 /= 10)
          i++;
        if (o2 = t2 - i, o2 < 0)
          o2 += b2, s2 = t2, c2 = p2[d2 = 0], l2 = c2 / j(10, i - s2 - 1) % 10 | 0;
        else if (d2 = Math.ceil((o2 + 1) / b2), a2 = p2.length, d2 >= a2)
          if (n2) {
            for (;a2++ <= d2; )
              p2.push(0);
            c2 = l2 = 0, i = 1, o2 %= b2, s2 = o2 - b2 + 1;
          } else
            break e;
        else {
          for (c2 = a2 = p2[d2], i = 1;a2 >= 10; a2 /= 10)
            i++;
          o2 %= b2, s2 = o2 - b2 + i, l2 = s2 < 0 ? 0 : c2 / j(10, i - s2 - 1) % 10 | 0;
        }
        if (n2 = n2 || t2 < 0 || p2[d2 + 1] !== undefined || (s2 < 0 ? c2 : c2 % j(10, i - s2 - 1)), u2 = r < 4 ? (l2 || n2) && (r == 0 || r == (e2.s < 0 ? 3 : 2)) : l2 > 5 || l2 == 5 && (r == 4 || n2 || r == 6 && (o2 > 0 ? s2 > 0 ? c2 / j(10, i - s2) : 0 : p2[d2 - 1]) % 10 & 1 || r == (e2.s < 0 ? 8 : 7)), t2 < 1 || !p2[0])
          return p2.length = 0, u2 ? (t2 -= e2.e + 1, p2[0] = j(10, (b2 - t2 % b2) % b2), e2.e = -t2 || 0) : p2[0] = e2.e = 0, e2;
        if (o2 == 0 ? (p2.length = d2, a2 = 1, d2--) : (p2.length = d2 + 1, a2 = j(10, b2 - o2), p2[d2] = s2 > 0 ? (c2 / j(10, i - s2) % j(10, s2) | 0) * a2 : 0), u2)
          for (;; )
            if (d2 == 0) {
              for (o2 = 1, s2 = p2[0];s2 >= 10; s2 /= 10)
                o2++;
              for (s2 = p2[0] += a2, a2 = 1;s2 >= 10; s2 /= 10)
                a2++;
              o2 != a2 && (e2.e++, p2[0] == ge && (p2[0] = 1));
              break;
            } else {
              if (p2[d2] += a2, p2[d2] != ge)
                break;
              p2[d2--] = 0, a2 = 1;
            }
        for (o2 = p2.length;p2[--o2] === 0; )
          p2.pop();
      }
    return w2 && (e2.e > f.maxE ? (e2.d = null, e2.e = NaN) : e2.e < f.minE && (e2.e = 0, e2.d = [0])), e2;
  };
  var we = function(e2, t2, r) {
    if (!e2.isFinite())
      return ks(e2);
    var n2, i = e2.e, o2 = W(e2.d), s2 = o2.length;
    return t2 ? (r && (n2 = r - s2) > 0 ? o2 = o2.charAt(0) + "." + o2.slice(1) + _e(n2) : s2 > 1 && (o2 = o2.charAt(0) + "." + o2.slice(1)), o2 = o2 + (e2.e < 0 ? "e" : "e+") + e2.e) : i < 0 ? (o2 = "0." + _e(-i - 1) + o2, r && (n2 = r - s2) > 0 && (o2 += _e(n2))) : i >= s2 ? (o2 += _e(i + 1 - s2), r && (n2 = r - i - 1) > 0 && (o2 = o2 + "." + _e(n2))) : ((n2 = i + 1) < s2 && (o2 = o2.slice(0, n2) + "." + o2.slice(n2)), r && (n2 = r - s2) > 0 && (i + 1 === s2 && (o2 += "."), o2 += _e(n2))), o2;
  };
  var Hr = function(e2, t2) {
    var r = e2[0];
    for (t2 *= b2;r >= 10; r /= 10)
      t2++;
    return t2;
  };
  var Gr = function(e2, t2, r) {
    if (t2 > fc)
      throw w2 = true, r && (e2.precision = r), Error(Ts);
    return h2(new e2(Kr), t2, 1, true);
  };
  var fe = function(e2, t2, r) {
    if (t2 > bi)
      throw Error(Ts);
    return h2(new e2(Qr), t2, r, true);
  };
  var Ms = function(e2) {
    var t2 = e2.length - 1, r = t2 * b2 + 1;
    if (t2 = e2[t2], t2) {
      for (;t2 % 10 == 0; t2 /= 10)
        r--;
      for (t2 = e2[0];t2 >= 10; t2 /= 10)
        r++;
    }
    return r;
  };
  var _e = function(e2) {
    for (var t2 = "";e2--; )
      t2 += "0";
    return t2;
  };
  var Ss = function(e2, t2, r, n2) {
    var i, o2 = new e2(1), s2 = Math.ceil(n2 / b2 + 4);
    for (w2 = false;; ) {
      if (r % 2 && (o2 = o2.times(t2), ws(o2.d, s2) && (i = true)), r = ee(r / 2), r === 0) {
        r = o2.d.length - 1, i && o2.d[r] === 0 && ++o2.d[r];
        break;
      }
      t2 = t2.times(t2), ws(t2.d, s2);
    }
    return w2 = true, o2;
  };
  var Es = function(e2) {
    return e2.d[e2.d.length - 1] & 1;
  };
  var Is = function(e2, t2, r) {
    for (var n2, i = new e2(t2[0]), o2 = 0;++o2 < t2.length; )
      if (n2 = new e2(t2[o2]), n2.s)
        i[r](n2) && (i = n2);
      else {
        i = n2;
        break;
      }
    return i;
  };
  var Ei = function(e2, t2) {
    var r, n2, i, o2, s2, a2, l2, u2 = 0, c2 = 0, p2 = 0, d2 = e2.constructor, f = d2.rounding, y2 = d2.precision;
    if (!e2.d || !e2.d[0] || e2.e > 17)
      return new d2(e2.d ? e2.d[0] ? e2.s < 0 ? 0 : 1 / 0 : 1 : e2.s ? e2.s < 0 ? 0 : e2 : 0 / 0);
    for (t2 == null ? (w2 = false, l2 = y2) : l2 = t2, a2 = new d2(0.03125);e2.e > -2; )
      e2 = e2.times(a2), p2 += 5;
    for (n2 = Math.log(j(2, p2)) / Math.LN10 * 2 + 5 | 0, l2 += n2, r = o2 = s2 = new d2(1), d2.precision = l2;; ) {
      if (o2 = h2(o2.times(e2), l2, 1), r = r.times(++c2), a2 = s2.plus(O(o2, r, l2, 1)), W(a2.d).slice(0, l2) === W(s2.d).slice(0, l2)) {
        for (i = p2;i--; )
          s2 = h2(s2.times(s2), l2, 1);
        if (t2 == null)
          if (u2 < 3 && Jt(s2.d, l2 - n2, f, u2))
            d2.precision = l2 += 10, r = o2 = a2 = new d2(1), c2 = 0, u2++;
          else
            return h2(s2, d2.precision = y2, f, w2 = true);
        else
          return d2.precision = y2, s2;
      }
      s2 = a2;
    }
  };
  var Ne = function(e2, t2) {
    var r, n2, i, o2, s2, a2, l2, u2, c2, p2, d2, f = 1, y2 = 10, g = e2, P = g.d, T = g.constructor, C = T.rounding, x = T.precision;
    if (g.s < 0 || !P || !P[0] || !g.e && P[0] == 1 && P.length == 1)
      return new T(P && !P[0] ? -1 / 0 : g.s != 1 ? NaN : P ? 0 : g);
    if (t2 == null ? (w2 = false, c2 = x) : c2 = t2, T.precision = c2 += y2, r = W(P), n2 = r.charAt(0), Math.abs(o2 = g.e) < 1500000000000000) {
      for (;n2 < 7 && n2 != 1 || n2 == 1 && r.charAt(1) > 3; )
        g = g.times(e2), r = W(g.d), n2 = r.charAt(0), f++;
      o2 = g.e, n2 > 1 ? (g = new T("0." + r), o2++) : g = new T(n2 + "." + r.slice(1));
    } else
      return u2 = Gr(T, c2 + 2, x).times(o2 + ""), g = Ne(new T(n2 + "." + r.slice(1)), c2 - y2).plus(u2), T.precision = x, t2 == null ? h2(g, x, C, w2 = true) : g;
    for (p2 = g, l2 = s2 = g = O(g.minus(1), g.plus(1), c2, 1), d2 = h2(g.times(g), c2, 1), i = 3;; ) {
      if (s2 = h2(s2.times(d2), c2, 1), u2 = l2.plus(O(s2, new T(i), c2, 1)), W(u2.d).slice(0, c2) === W(l2.d).slice(0, c2))
        if (l2 = l2.times(2), o2 !== 0 && (l2 = l2.plus(Gr(T, c2 + 2, x).times(o2 + ""))), l2 = O(l2, new T(f), c2, 1), t2 == null)
          if (Jt(l2.d, c2 - y2, C, a2))
            T.precision = c2 += y2, u2 = s2 = g = O(p2.minus(1), p2.plus(1), c2, 1), d2 = h2(g.times(g), c2, 1), i = a2 = 1;
          else
            return h2(l2, T.precision = x, C, w2 = true);
        else
          return T.precision = x, l2;
      l2 = u2, i += 2;
    }
  };
  var ks = function(e2) {
    return String(e2.s * e2.s / 0);
  };
  var wi = function(e2, t2) {
    var r, n2, i;
    for ((r = t2.indexOf(".")) > -1 && (t2 = t2.replace(".", "")), (n2 = t2.search(/e/i)) > 0 ? (r < 0 && (r = n2), r += +t2.slice(n2 + 1), t2 = t2.substring(0, n2)) : r < 0 && (r = t2.length), n2 = 0;t2.charCodeAt(n2) === 48; n2++)
      ;
    for (i = t2.length;t2.charCodeAt(i - 1) === 48; --i)
      ;
    if (t2 = t2.slice(n2, i), t2) {
      if (i -= n2, e2.e = r = r - n2 - 1, e2.d = [], n2 = (r + 1) % b2, r < 0 && (n2 += b2), n2 < i) {
        for (n2 && e2.d.push(+t2.slice(0, n2)), i -= b2;n2 < i; )
          e2.d.push(+t2.slice(n2, n2 += b2));
        t2 = t2.slice(n2), n2 = b2 - t2.length;
      } else
        n2 -= i;
      for (;n2--; )
        t2 += "0";
      e2.d.push(+t2), w2 && (e2.e > e2.constructor.maxE ? (e2.d = null, e2.e = NaN) : e2.e < e2.constructor.minE && (e2.e = 0, e2.d = [0]));
    } else
      e2.e = 0, e2.d = [0];
    return e2;
  };
  var yc = function(e2, t2) {
    var r, n2, i, o2, s2, a2, l2, u2, c2;
    if (t2.indexOf("_") > -1) {
      if (t2 = t2.replace(/(\d)_(?=\d)/g, "$1"), Rs.test(t2))
        return wi(e2, t2);
    } else if (t2 === "Infinity" || t2 === "NaN")
      return +t2 || (e2.s = NaN), e2.e = NaN, e2.d = null, e2;
    if (pc.test(t2))
      r = 16, t2 = t2.toLowerCase();
    else if (cc.test(t2))
      r = 2;
    else if (dc.test(t2))
      r = 8;
    else
      throw Error(Le + t2);
    for (o2 = t2.search(/p/i), o2 > 0 ? (l2 = +t2.slice(o2 + 1), t2 = t2.substring(2, o2)) : t2 = t2.slice(2), o2 = t2.indexOf("."), s2 = o2 >= 0, n2 = e2.constructor, s2 && (t2 = t2.replace(".", ""), a2 = t2.length, o2 = a2 - o2, i = Ss(n2, new n2(r), o2, o2 * 2)), u2 = Ur(t2, r, ge), c2 = u2.length - 1, o2 = c2;u2[o2] === 0; --o2)
      u2.pop();
    return o2 < 0 ? new n2(e2.s * 0) : (e2.e = Hr(u2, c2), e2.d = u2, w2 = false, s2 && (e2 = O(e2, i, a2 * 4)), l2 && (e2 = e2.times(Math.abs(l2) < 54 ? j(2, l2) : ze.pow(2, l2))), w2 = true, e2);
  };
  var hc = function(e2, t2) {
    var r, n2 = t2.d.length;
    if (n2 < 3)
      return t2.isZero() ? t2 : yt(e2, 2, t2, t2);
    r = 1.4 * Math.sqrt(n2), r = r > 16 ? 16 : r | 0, t2 = t2.times(1 / Wr(5, r)), t2 = yt(e2, 2, t2, t2);
    for (var i, o2 = new e2(5), s2 = new e2(16), a2 = new e2(20);r--; )
      i = t2.times(t2), t2 = t2.times(o2.plus(i.times(s2.times(i).minus(a2))));
    return t2;
  };
  var yt = function(e2, t2, r, n2, i) {
    var o2, s2, a2, l2, u2 = 1, c2 = e2.precision, p2 = Math.ceil(c2 / b2);
    for (w2 = false, l2 = r.times(r), a2 = new e2(n2);; ) {
      if (s2 = O(a2.times(l2), new e2(t2++ * t2++), c2, 1), a2 = i ? n2.plus(s2) : n2.minus(s2), n2 = O(s2.times(l2), new e2(t2++ * t2++), c2, 1), s2 = a2.plus(n2), s2.d[p2] !== undefined) {
        for (o2 = p2;s2.d[o2] === a2.d[o2] && o2--; )
          ;
        if (o2 == -1)
          break;
      }
      o2 = a2, a2 = n2, n2 = s2, s2 = o2, u2++;
    }
    return w2 = true, s2.d.length = p2 + 1, s2;
  };
  var Wr = function(e2, t2) {
    for (var r = e2;--t2; )
      r *= e2;
    return r;
  };
  var Fs = function(e2, t2) {
    var r, n2 = t2.s < 0, i = fe(e2, e2.precision, 1), o2 = i.times(0.5);
    if (t2 = t2.abs(), t2.lte(o2))
      return Me = n2 ? 4 : 1, t2;
    if (r = t2.divToInt(i), r.isZero())
      Me = n2 ? 3 : 2;
    else {
      if (t2 = t2.minus(r.times(i)), t2.lte(o2))
        return Me = Es(r) ? n2 ? 2 : 3 : n2 ? 4 : 1, t2;
      Me = Es(r) ? n2 ? 1 : 4 : n2 ? 3 : 2;
    }
    return t2.minus(i).abs();
  };
  var Pi = function(e2, t2, r, n2) {
    var i, o2, s2, a2, l2, u2, c2, p2, d2, f = e2.constructor, y2 = r !== undefined;
    if (y2 ? (se(r, 1, $e), n2 === undefined ? n2 = f.rounding : se(n2, 0, 8)) : (r = f.precision, n2 = f.rounding), !e2.isFinite())
      c2 = ks(e2);
    else {
      for (c2 = we(e2), s2 = c2.indexOf("."), y2 ? (i = 2, t2 == 16 ? r = r * 4 - 3 : t2 == 8 && (r = r * 3 - 2)) : i = t2, s2 >= 0 && (c2 = c2.replace(".", ""), d2 = new f(1), d2.e = c2.length - s2, d2.d = Ur(we(d2), 10, i), d2.e = d2.d.length), p2 = Ur(c2, 10, i), o2 = l2 = p2.length;p2[--l2] == 0; )
        p2.pop();
      if (!p2[0])
        c2 = y2 ? "0p+0" : "0";
      else {
        if (s2 < 0 ? o2-- : (e2 = new f(e2), e2.d = p2, e2.e = o2, e2 = O(e2, d2, r, n2, 0, i), p2 = e2.d, o2 = e2.e, u2 = vs), s2 = p2[r], a2 = i / 2, u2 = u2 || p2[r + 1] !== undefined, u2 = n2 < 4 ? (s2 !== undefined || u2) && (n2 === 0 || n2 === (e2.s < 0 ? 3 : 2)) : s2 > a2 || s2 === a2 && (n2 === 4 || u2 || n2 === 6 && p2[r - 1] & 1 || n2 === (e2.s < 0 ? 8 : 7)), p2.length = r, u2)
          for (;++p2[--r] > i - 1; )
            p2[r] = 0, r || (++o2, p2.unshift(1));
        for (l2 = p2.length;!p2[l2 - 1]; --l2)
          ;
        for (s2 = 0, c2 = "";s2 < l2; s2++)
          c2 += hi.charAt(p2[s2]);
        if (y2) {
          if (l2 > 1)
            if (t2 == 16 || t2 == 8) {
              for (s2 = t2 == 16 ? 4 : 3, --l2;l2 % s2; l2++)
                c2 += "0";
              for (p2 = Ur(c2, i, t2), l2 = p2.length;!p2[l2 - 1]; --l2)
                ;
              for (s2 = 1, c2 = "1.";s2 < l2; s2++)
                c2 += hi.charAt(p2[s2]);
            } else
              c2 = c2.charAt(0) + "." + c2.slice(1);
          c2 = c2 + (o2 < 0 ? "p" : "p+") + o2;
        } else if (o2 < 0) {
          for (;++o2; )
            c2 = "0" + c2;
          c2 = "0." + c2;
        } else if (++o2 > l2)
          for (o2 -= l2;o2--; )
            c2 += "0";
        else
          o2 < l2 && (c2 = c2.slice(0, o2) + "." + c2.slice(o2));
      }
      c2 = (t2 == 16 ? "0x" : t2 == 2 ? "0b" : t2 == 8 ? "0o" : "") + c2;
    }
    return e2.s < 0 ? "-" + c2 : c2;
  };
  var ws = function(e2, t2) {
    if (e2.length > t2)
      return e2.length = t2, true;
  };
  var xc = function(e2) {
    return new this(e2).abs();
  };
  var bc = function(e2) {
    return new this(e2).acos();
  };
  var Ec = function(e2) {
    return new this(e2).acosh();
  };
  var wc = function(e2, t2) {
    return new this(e2).plus(t2);
  };
  var Pc = function(e2) {
    return new this(e2).asin();
  };
  var vc = function(e2) {
    return new this(e2).asinh();
  };
  var Tc = function(e2) {
    return new this(e2).atan();
  };
  var Cc = function(e2) {
    return new this(e2).atanh();
  };
  var Ac = function(e2, t2) {
    e2 = new this(e2), t2 = new this(t2);
    var r, n2 = this.precision, i = this.rounding, o2 = n2 + 4;
    return !e2.s || !t2.s ? r = new this(NaN) : !e2.d && !t2.d ? (r = fe(this, o2, 1).times(t2.s > 0 ? 0.25 : 0.75), r.s = e2.s) : !t2.d || e2.isZero() ? (r = t2.s < 0 ? fe(this, n2, i) : new this(0), r.s = e2.s) : !e2.d || t2.isZero() ? (r = fe(this, o2, 1).times(0.5), r.s = e2.s) : t2.s < 0 ? (this.precision = o2, this.rounding = 1, r = this.atan(O(e2, t2, o2, 1)), t2 = fe(this, o2, 1), this.precision = n2, this.rounding = i, r = e2.s < 0 ? r.minus(t2) : r.plus(t2)) : r = this.atan(O(e2, t2, o2, 1)), r;
  };
  var Rc = function(e2) {
    return new this(e2).cbrt();
  };
  var Mc = function(e2) {
    return h2(e2 = new this(e2), e2.e + 1, 2);
  };
  var Sc = function(e2, t2, r) {
    return new this(e2).clamp(t2, r);
  };
  var Ic = function(e2) {
    if (!e2 || typeof e2 != "object")
      throw Error(Jr + "Object expected");
    var t2, r, n2, i = e2.defaults === true, o2 = ["precision", 1, $e, "rounding", 0, 8, "toExpNeg", -gt, 0, "toExpPos", 0, gt, "maxE", 0, gt, "minE", -gt, 0, "modulo", 0, 9];
    for (t2 = 0;t2 < o2.length; t2 += 3)
      if (r = o2[t2], i && (this[r] = xi[r]), (n2 = e2[r]) !== undefined)
        if (ee(n2) === n2 && n2 >= o2[t2 + 1] && n2 <= o2[t2 + 2])
          this[r] = n2;
        else
          throw Error(Le + r + ": " + n2);
    if (r = "crypto", i && (this[r] = xi[r]), (n2 = e2[r]) !== undefined)
      if (n2 === true || n2 === false || n2 === 0 || n2 === 1)
        if (n2)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r] = true;
          else
            throw Error(Cs);
        else
          this[r] = false;
      else
        throw Error(Le + r + ": " + n2);
    return this;
  };
  var kc = function(e2) {
    return new this(e2).cos();
  };
  var Fc = function(e2) {
    return new this(e2).cosh();
  };
  var Os = function(e2) {
    var t2, r, n2;
    function i(o2) {
      var s2, a2, l2, u2 = this;
      if (!(u2 instanceof i))
        return new i(o2);
      if (u2.constructor = i, Ps(o2)) {
        u2.s = o2.s, w2 ? !o2.d || o2.e > i.maxE ? (u2.e = NaN, u2.d = null) : o2.e < i.minE ? (u2.e = 0, u2.d = [0]) : (u2.e = o2.e, u2.d = o2.d.slice()) : (u2.e = o2.e, u2.d = o2.d ? o2.d.slice() : o2.d);
        return;
      }
      if (l2 = typeof o2, l2 === "number") {
        if (o2 === 0) {
          u2.s = 1 / o2 < 0 ? -1 : 1, u2.e = 0, u2.d = [0];
          return;
        }
        if (o2 < 0 ? (o2 = -o2, u2.s = -1) : u2.s = 1, o2 === ~~o2 && o2 < 1e7) {
          for (s2 = 0, a2 = o2;a2 >= 10; a2 /= 10)
            s2++;
          w2 ? s2 > i.maxE ? (u2.e = NaN, u2.d = null) : s2 < i.minE ? (u2.e = 0, u2.d = [0]) : (u2.e = s2, u2.d = [o2]) : (u2.e = s2, u2.d = [o2]);
          return;
        } else if (o2 * 0 !== 0) {
          o2 || (u2.s = NaN), u2.e = NaN, u2.d = null;
          return;
        }
        return wi(u2, o2.toString());
      } else if (l2 !== "string")
        throw Error(Le + o2);
      return (a2 = o2.charCodeAt(0)) === 45 ? (o2 = o2.slice(1), u2.s = -1) : (a2 === 43 && (o2 = o2.slice(1)), u2.s = 1), Rs.test(o2) ? wi(u2, o2) : yc(u2, o2);
    }
    if (i.prototype = m2, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Ic, i.clone = Os, i.isDecimal = Ps, i.abs = xc, i.acos = bc, i.acosh = Ec, i.add = wc, i.asin = Pc, i.asinh = vc, i.atan = Tc, i.atanh = Cc, i.atan2 = Ac, i.cbrt = Rc, i.ceil = Mc, i.clamp = Sc, i.cos = kc, i.cosh = Fc, i.div = Oc, i.exp = Dc, i.floor = _c, i.hypot = Nc, i.ln = Lc, i.log = $c, i.log10 = Vc, i.log2 = qc, i.max = jc, i.min = Bc, i.mod = Uc, i.mul = Kc, i.pow = Qc, i.random = Gc, i.round = Jc, i.sign = Hc, i.sin = Wc, i.sinh = zc, i.sqrt = Yc, i.sub = Zc, i.sum = Xc, i.tan = ep, i.tanh = tp, i.trunc = rp, e2 === undefined && (e2 = {}), e2 && e2.defaults !== true)
      for (n2 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t2 = 0;t2 < n2.length; )
        e2.hasOwnProperty(r = n2[t2++]) || (e2[r] = this[r]);
    return i.config(e2), i;
  };
  var Oc = function(e2, t2) {
    return new this(e2).div(t2);
  };
  var Dc = function(e2) {
    return new this(e2).exp();
  };
  var _c = function(e2) {
    return h2(e2 = new this(e2), e2.e + 1, 3);
  };
  var Nc = function() {
    var e2, t2, r = new this(0);
    for (w2 = false, e2 = 0;e2 < arguments.length; )
      if (t2 = new this(arguments[e2++]), t2.d)
        r.d && (r = r.plus(t2.times(t2)));
      else {
        if (t2.s)
          return w2 = true, new this(1 / 0);
        r = t2;
      }
    return w2 = true, r.sqrt();
  };
  var Ps = function(e2) {
    return e2 instanceof ze || e2 && e2.toStringTag === As || false;
  };
  var Lc = function(e2) {
    return new this(e2).ln();
  };
  var $c = function(e2, t2) {
    return new this(e2).log(t2);
  };
  var qc = function(e2) {
    return new this(e2).log(2);
  };
  var Vc = function(e2) {
    return new this(e2).log(10);
  };
  var jc = function() {
    return Is(this, arguments, "lt");
  };
  var Bc = function() {
    return Is(this, arguments, "gt");
  };
  var Uc = function(e2, t2) {
    return new this(e2).mod(t2);
  };
  var Kc = function(e2, t2) {
    return new this(e2).mul(t2);
  };
  var Qc = function(e2, t2) {
    return new this(e2).pow(t2);
  };
  var Gc = function(e2) {
    var t2, r, n2, i, o2 = 0, s2 = new this(1), a2 = [];
    if (e2 === undefined ? e2 = this.precision : se(e2, 1, $e), n2 = Math.ceil(e2 / b2), this.crypto)
      if (crypto.getRandomValues)
        for (t2 = crypto.getRandomValues(new Uint32Array(n2));o2 < n2; )
          i = t2[o2], i >= 4290000000 ? t2[o2] = crypto.getRandomValues(new Uint32Array(1))[0] : a2[o2++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (t2 = crypto.randomBytes(n2 *= 4);o2 < n2; )
          i = t2[o2] + (t2[o2 + 1] << 8) + (t2[o2 + 2] << 16) + ((t2[o2 + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(t2, o2) : (a2.push(i % 1e7), o2 += 4);
        o2 = n2 / 4;
      } else
        throw Error(Cs);
    else
      for (;o2 < n2; )
        a2[o2++] = Math.random() * 1e7 | 0;
    for (n2 = a2[--o2], e2 %= b2, n2 && e2 && (i = j(10, b2 - e2), a2[o2] = (n2 / i | 0) * i);a2[o2] === 0; o2--)
      a2.pop();
    if (o2 < 0)
      r = 0, a2 = [0];
    else {
      for (r = -1;a2[0] === 0; r -= b2)
        a2.shift();
      for (n2 = 1, i = a2[0];i >= 10; i /= 10)
        n2++;
      n2 < b2 && (r -= b2 - n2);
    }
    return s2.e = r, s2.d = a2, s2;
  };
  var Jc = function(e2) {
    return h2(e2 = new this(e2), e2.e + 1, this.rounding);
  };
  var Hc = function(e2) {
    return e2 = new this(e2), e2.d ? e2.d[0] ? e2.s : 0 * e2.s : e2.s || NaN;
  };
  var Wc = function(e2) {
    return new this(e2).sin();
  };
  var zc = function(e2) {
    return new this(e2).sinh();
  };
  var Yc = function(e2) {
    return new this(e2).sqrt();
  };
  var Zc = function(e2, t2) {
    return new this(e2).sub(t2);
  };
  var Xc = function() {
    var e2 = 0, t2 = arguments, r = new this(t2[e2]);
    for (w2 = false;r.s && ++e2 < t2.length; )
      r = r.plus(t2[e2]);
    return w2 = true, h2(r, this.precision, this.rounding);
  };
  var ep = function(e2) {
    return new this(e2).tan();
  };
  var tp = function(e2) {
    return new this(e2).tanh();
  };
  var rp = function(e2) {
    return h2(e2 = new this(e2), e2.e + 1, 1);
  };
  var ht = function(e2) {
    return ze.isDecimal(e2) ? true : e2 !== null && typeof e2 == "object" && typeof e2.s == "number" && typeof e2.e == "number" && typeof e2.toFixed == "function" && Array.isArray(e2.d);
  };
  var xt = function(e2) {
    return e2 instanceof Ht;
  };
  var en = function(e2) {
    return new vi(Ns(e2));
  };
  var Ns = function(e2) {
    let t2 = new Q;
    for (let [r, n2] of Object.entries(e2)) {
      let i = new Xr(r, Ls(n2));
      t2.addField(i);
    }
    return t2;
  };
  var Ls = function(e2) {
    if (typeof e2 == "string")
      return new G(JSON.stringify(e2));
    if (typeof e2 == "number" || typeof e2 == "boolean")
      return new G(String(e2));
    if (typeof e2 == "bigint")
      return new G(`${e2}n`);
    if (e2 === null)
      return new G("null");
    if (e2 === undefined)
      return new G("undefined");
    if (ht(e2))
      return new G(`new Prisma.Decimal("${e2.toFixed()}")`);
    if (e2 instanceof Uint8Array)
      return Buffer.isBuffer(e2) ? new G(`Buffer.alloc(${e2.byteLength})`) : new G(`new Uint8Array(${e2.byteLength})`);
    if (e2 instanceof Date) {
      let t2 = Br(e2) ? e2.toISOString() : "Invalid Date";
      return new G(`new Date("${t2}")`);
    }
    return e2 instanceof xe ? new G(`Prisma.${e2._getName()}`) : xt(e2) ? new G(`prisma.${lo(e2.modelName)}.\$fields.${e2.name}`) : Array.isArray(e2) ? ip(e2) : typeof e2 == "object" ? Ns(e2) : new G(Object.prototype.toString.call(e2));
  };
  var ip = function(e2) {
    let t2 = new Et;
    for (let r of e2)
      t2.addItem(Ls(r));
    return t2;
  };
  var $s = function(e2) {
    if (e2 === undefined)
      return "";
    let t2 = en(e2);
    return new mt(0, { colors: Zr }).write(t2).toString();
  };
  var qs = function(e2) {
    var t2 = e2.split(`
`);
    return t2.reduce(function(r, n2) {
      var i = ap(n2) || up(n2) || dp(n2) || yp(n2) || fp(n2);
      return i && r.push(i), r;
    }, []);
  };
  var ap = function(e2) {
    var t2 = op.exec(e2);
    if (!t2)
      return null;
    var r = t2[2] && t2[2].indexOf("native") === 0, n2 = t2[2] && t2[2].indexOf("eval") === 0, i = sp.exec(t2[2]);
    return n2 && i != null && (t2[2] = i[1], t2[3] = i[2], t2[4] = i[3]), { file: r ? null : t2[2], methodName: t2[1] || Wt, arguments: r ? [t2[2]] : [], lineNumber: t2[3] ? +t2[3] : null, column: t2[4] ? +t2[4] : null };
  };
  var up = function(e2) {
    var t2 = lp.exec(e2);
    return t2 ? { file: t2[2], methodName: t2[1] || Wt, arguments: [], lineNumber: +t2[3], column: t2[4] ? +t2[4] : null } : null;
  };
  var dp = function(e2) {
    var t2 = cp.exec(e2);
    if (!t2)
      return null;
    var r = t2[3] && t2[3].indexOf(" > eval") > -1, n2 = pp.exec(t2[3]);
    return r && n2 != null && (t2[3] = n2[1], t2[4] = n2[2], t2[5] = null), { file: t2[3], methodName: t2[1] || Wt, arguments: t2[2] ? t2[2].split(",") : [], lineNumber: t2[4] ? +t2[4] : null, column: t2[5] ? +t2[5] : null };
  };
  var fp = function(e2) {
    var t2 = mp.exec(e2);
    return t2 ? { file: t2[3], methodName: t2[1] || Wt, arguments: [], lineNumber: +t2[4], column: t2[5] ? +t2[5] : null } : null;
  };
  var yp = function(e2) {
    var t2 = gp.exec(e2);
    return t2 ? { file: t2[2], methodName: t2[1] || Wt, arguments: [], lineNumber: +t2[3], column: t2[4] ? +t2[4] : null } : null;
  };
  var Ve = function(e2) {
    return e2 === "minimal" ? new Ti : new Ci;
  };
  var wt = function(e2 = {}) {
    let t2 = xp(e2);
    return Object.entries(t2).reduce((n2, [i, o2]) => (Vs[i] !== undefined ? n2.select[i] = { select: o2 } : n2[i] = o2, n2), { select: {} });
  };
  var xp = function(e2 = {}) {
    return typeof e2._count == "boolean" ? { ...e2, _count: { _all: e2._count } } : e2;
  };
  var tn = function(e2 = {}) {
    return (t2) => (typeof e2._count == "boolean" && (t2._count = t2._count._all), t2);
  };
  var js = function(e2, t2) {
    let r = tn(e2);
    return t2({ action: "aggregate", unpacker: r, argsMapper: wt })(e2);
  };
  var bp = function(e2 = {}) {
    let { select: t2, ...r } = e2;
    return typeof t2 == "object" ? wt({ ...r, _count: t2 }) : wt({ ...r, _count: { _all: true } });
  };
  var Ep = function(e2 = {}) {
    return typeof e2.select == "object" ? (t2) => tn(e2)(t2)._count : (t2) => tn(e2)(t2)._count._all;
  };
  var Bs = function(e2, t2) {
    return t2({ action: "count", unpacker: Ep(e2), argsMapper: bp })(e2);
  };
  var wp = function(e2 = {}) {
    let t2 = wt(e2);
    if (Array.isArray(t2.by))
      for (let r of t2.by)
        typeof r == "string" && (t2.select[r] = true);
    else
      typeof t2.by == "string" && (t2.select[t2.by] = true);
    return t2;
  };
  var Pp = function(e2 = {}) {
    return (t2) => (typeof e2?._count == "boolean" && t2.forEach((r) => {
      r._count = r._count._all;
    }), t2);
  };
  var Us = function(e2, t2) {
    return t2({ action: "groupBy", unpacker: Pp(e2), argsMapper: wp })(e2);
  };
  var Ks = function(e2, t2, r) {
    if (t2 === "aggregate")
      return (n2) => js(n2, r);
    if (t2 === "count")
      return (n2) => Bs(n2, r);
    if (t2 === "groupBy")
      return (n2) => Us(n2, r);
  };
  var Qs = function(e2, t2) {
    let r = t2.fields.filter((i) => !i.relationName), n2 = ci(r, (i) => i.name);
    return new Proxy({}, { get(i, o2) {
      if ((o2 in i) || typeof o2 == "symbol")
        return i[o2];
      let s2 = n2[o2];
      if (s2)
        return new Ht(e2, o2, s2.type, s2.isList, s2.kind === "enum");
    }, ...jr(Object.keys(n2)) });
  };
  var vp = function(e2, t2) {
    return e2 === undefined || t2 === undefined ? [] : [...t2, "select", e2];
  };
  var Tp = function(e2, t2, r) {
    return t2 === undefined ? e2 ?? {} : Js(t2, r, e2 || true);
  };
  var Ri = function(e2, t2, r, n2, i, o2) {
    let a2 = e2._runtimeDataModel.models[t2].fields.reduce((l2, u2) => ({ ...l2, [u2.name]: u2 }), {});
    return (l2) => {
      let u2 = Ve(e2._errorFormat), c2 = vp(n2, i), p2 = Tp(l2, o2, c2), d2 = r({ dataPath: c2, callsite: u2 })(p2), f = Cp(e2, t2);
      return new Proxy(d2, { get(y2, g) {
        if (!f.includes(g))
          return y2[g];
        let T = [a2[g].type, r, g], C = [c2, p2];
        return Ri(e2, ...T, ...C);
      }, ...jr([...f, ...Object.getOwnPropertyNames(d2)]) });
    };
  };
  var Cp = function(e2, t2) {
    return e2._runtimeDataModel.models[t2].fields.filter((r) => r.kind === "object").map((r) => r.name);
  };
  var ye = function(e2, t2, r, n2, i) {
    this.type = e2, this.content = t2, this.alias = r, this.length = (n2 || "").length | 0, this.greedy = !!i;
  };
  var Mp = function(e2) {
    return Hs[e2] || Ap;
  };
  var Ws = function(e2) {
    return Sp(e2, v.languages.javascript);
  };
  var Sp = function(e2, t2) {
    return v.tokenize(e2, t2).map((n2) => ye.stringify(n2)).join("");
  };
  var Ys = function(e2) {
    return (0, zs.default)(e2);
  };
  var Fp = function({ callsite: e2, message: t2, originalMethod: r, isPanic: n2, callArguments: i }, o2) {
    let s2 = { functionName: `prisma.${r}()`, message: t2, isPanic: n2 ?? false, callArguments: i };
    if (!e2 || typeof window < "u" || false)
      return s2;
    let a2 = e2.getLocation();
    if (!a2 || !a2.lineNumber || !a2.columnNumber)
      return s2;
    let l2 = Math.max(1, a2.lineNumber - 3), u2 = nn.read(a2.fileName)?.slice(l2, a2.lineNumber), c2 = u2?.lineAt(a2.lineNumber);
    if (u2 && c2) {
      let p2 = Dp(c2), d2 = Op(c2);
      if (!d2)
        return s2;
      s2.functionName = `${d2.code})`, s2.location = a2, n2 || (u2 = u2.mapLineAt(a2.lineNumber, (y2) => y2.slice(0, d2.openingBraceIndex))), u2 = o2.highlightSource(u2);
      let f = String(u2.lastLineNumber).length;
      if (s2.contextLines = u2.mapLines((y2, g) => o2.gray(String(g).padStart(f)) + " " + y2).mapLines((y2) => o2.dim(y2)).prependSymbolAt(a2.lineNumber, o2.bold(o2.red("\u2192"))), i) {
        let y2 = p2 + f + 1;
        y2 += 2, s2.callArguments = (0, Xs.default)(i, y2).slice(y2);
      }
    }
    return s2;
  };
  var Op = function(e2) {
    let t2 = Object.keys(pe.ModelAction).join("|"), n2 = new RegExp(String.raw`\.(${t2})\(`).exec(e2);
    if (n2) {
      let i = n2.index + n2[0].length, o2 = e2.lastIndexOf(" ", n2.index) + 1;
      return { code: e2.slice(o2, i), openingBraceIndex: i };
    }
    return null;
  };
  var Dp = function(e2) {
    let t2 = 0;
    for (let r = 0;r < e2.length; r++) {
      if (e2.charAt(r) !== " ")
        return t2;
      t2++;
    }
    return t2;
  };
  var _p = function({ functionName: e2, location: t2, message: r, isPanic: n2, contextLines: i, callArguments: o2 }, s2) {
    let a2 = [""], l2 = t2 ? " in" : ":";
    if (n2 ? (a2.push(s2.red(`Oops, an unknown error occurred! This is ${s2.bold("on us")}, you did nothing wrong.`)), a2.push(s2.red(`It occurred in the ${s2.bold(`\`${e2}\``)} invocation${l2}`))) : a2.push(s2.red(`Invalid ${s2.bold(`\`${e2}\``)} invocation${l2}`)), t2 && a2.push(s2.underline(Np(t2))), i) {
      a2.push("");
      let u2 = [i.toString()];
      o2 && (u2.push(o2), u2.push(s2.dim(")"))), a2.push(u2.join("")), o2 && a2.push("");
    } else
      a2.push(""), o2 && a2.push(o2), a2.push("");
    return a2.push(r), a2.join(`
`);
  };
  var Np = function(e2) {
    let t2 = [e2.fileName];
    return e2.lineNumber && t2.push(String(e2.lineNumber)), e2.columnNumber && t2.push(String(e2.columnNumber)), t2.join(":");
  };
  var Pt = function(e2) {
    let t2 = e2.showColors ? Ip : kp, r = Fp(e2, t2);
    return _p(r, t2);
  };
  var ea = function(e2, t2, r, n2) {
    return e2 === pe.ModelAction.findFirstOrThrow || e2 === pe.ModelAction.findUniqueOrThrow ? Lp(t2, r, n2) : n2;
  };
  var Lp = function(e2, t2, r) {
    return async (n2) => {
      if ("rejectOnNotFound" in n2.args) {
        let o2 = Pt({ originalMethod: n2.clientMethod, callsite: n2.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new X(o2, { clientVersion: t2 });
      }
      return await r(n2).catch((o2) => {
        throw o2 instanceof U && o2.code === "P2025" ? new Re(`No ${e2} found`, t2) : o2;
      });
    };
  };
  var Te = function(e2) {
    return e2.replace(/^./, (t2) => t2.toLowerCase());
  };
  var Mi = function(e2, t2) {
    let r = e2._extensions.getAllModelExtensions(t2) ?? {}, n2 = [Vp(e2, t2), Bp(e2, t2), Qt(r), re("name", () => t2), re("$name", () => t2), re("$parent", () => e2._appliedParent)];
    return Ee({}, n2);
  };
  var Vp = function(e2, t2) {
    let r = Te(t2), n2 = Object.keys(pe.ModelAction).concat("count");
    return { getKeys() {
      return n2;
    }, getPropertyValue(i) {
      let o2 = i, s2 = (l2) => e2._request(l2);
      s2 = ea(o2, t2, e2._clientVersion, s2);
      let a2 = (l2) => (u2) => {
        let c2 = Ve(e2._errorFormat);
        return e2._createPrismaPromise((p2) => {
          let d2 = { args: u2, dataPath: [], action: o2, model: t2, clientMethod: `${r}.${i}`, jsModelName: r, transaction: p2, callsite: c2 };
          return s2({ ...d2, ...l2 });
        });
      };
      return $p.includes(o2) ? Ri(e2, t2, a2) : jp(i) ? Ks(e2, i, a2) : a2({});
    } };
  };
  var jp = function(e2) {
    return qp.includes(e2);
  };
  var Bp = function(e2, t2) {
    return We(re("fields", () => {
      let r = e2._runtimeDataModel.models[t2];
      return Qs(t2, r);
    }));
  };
  var ta = function(e2) {
    return e2.replace(/^./, (t2) => t2.toUpperCase());
  };
  var zt = function(e2) {
    let t2 = [Up(e2), re(Si, () => e2), re("$parent", () => e2._appliedParent)], r = e2._extensions.getAllClientExtensions();
    return r && t2.push(Qt(r)), Ee(e2, t2);
  };
  var Up = function(e2) {
    let t2 = Object.keys(e2._runtimeDataModel.models), r = t2.map(Te), n2 = [...new Set(t2.concat(r))];
    return We({ getKeys() {
      return n2;
    }, getPropertyValue(i) {
      let o2 = ta(i);
      if (e2._runtimeDataModel.models[o2] !== undefined)
        return Mi(e2, o2);
      if (e2._runtimeDataModel.models[i] !== undefined)
        return Mi(e2, i);
    }, getPropertyDescriptor(i) {
      if (!r.includes(i))
        return { enumerable: false };
    } });
  };
  var on = function(e2) {
    return e2[Si] ? e2[Si] : e2;
  };
  var ra = function(e2) {
    if (typeof e2 == "function")
      return e2(this);
    let t2 = on(this), r = Object.create(t2, { _extensions: { value: this._extensions.append(e2) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return zt(r);
  };
  var na = function({ result: e2, modelName: t2, select: r, extensions: n2 }) {
    let i = n2.getAllComputedFields(t2);
    if (!i)
      return e2;
    let o2 = [], s2 = [];
    for (let a2 of Object.values(i)) {
      if (r) {
        if (!r[a2.name])
          continue;
        let l2 = a2.needs.filter((u2) => !r[u2]);
        l2.length > 0 && s2.push(Gt(l2));
      }
      Kp(e2, a2.needs) && o2.push(Qp(a2, Ee(e2, o2)));
    }
    return o2.length > 0 || s2.length > 0 ? Ee(e2, [...o2, ...s2]) : e2;
  };
  var Kp = function(e2, t2) {
    return t2.every((r) => ui(e2, r));
  };
  var Qp = function(e2, t2) {
    return We(re(e2.name, () => e2.compute(t2)));
  };
  var sn = function({ visitor: e2, result: t2, args: r, runtimeDataModel: n2, modelName: i }) {
    if (Array.isArray(t2)) {
      for (let s2 = 0;s2 < t2.length; s2++)
        t2[s2] = sn({ result: t2[s2], args: r, modelName: i, runtimeDataModel: n2, visitor: e2 });
      return t2;
    }
    let o2 = e2(t2, i, r) ?? t2;
    return r.include && ia({ includeOrSelect: r.include, result: o2, parentModelName: i, runtimeDataModel: n2, visitor: e2 }), r.select && ia({ includeOrSelect: r.select, result: o2, parentModelName: i, runtimeDataModel: n2, visitor: e2 }), o2;
  };
  var ia = function({ includeOrSelect: e2, result: t2, parentModelName: r, runtimeDataModel: n2, visitor: i }) {
    for (let [o2, s2] of Object.entries(e2)) {
      if (!s2 || t2[o2] == null)
        continue;
      let l2 = n2.models[r].fields.find((c2) => c2.name === o2);
      if (!l2 || l2.kind !== "object" || !l2.relationName)
        continue;
      let u2 = typeof s2 == "object" ? s2 : {};
      t2[o2] = sn({ visitor: i, result: t2[o2], args: u2, modelName: l2.type, runtimeDataModel: n2 });
    }
  };
  var oa = function({ result: e2, modelName: t2, args: r, extensions: n2, runtimeDataModel: i }) {
    return n2.isEmpty() || e2 == null || typeof e2 != "object" || !i.models[t2] ? e2 : sn({ result: e2, args: r ?? {}, modelName: t2, runtimeDataModel: i, visitor: (s2, a2, l2) => na({ result: s2, modelName: Te(a2), select: l2.select, extensions: n2 }) });
  };
  var sa = function(e2) {
    if (e2 instanceof oe)
      return Gp(e2);
    if (Array.isArray(e2)) {
      let r = [e2[0]];
      for (let n2 = 1;n2 < e2.length; n2++)
        r[n2] = Yt(e2[n2]);
      return r;
    }
    let t2 = {};
    for (let r in e2)
      t2[r] = Yt(e2[r]);
    return t2;
  };
  var Gp = function(e2) {
    return new oe(e2.strings, e2.values);
  };
  var Yt = function(e2) {
    if (typeof e2 != "object" || e2 == null || e2 instanceof xe || xt(e2))
      return e2;
    if (ht(e2))
      return new Pe(e2.toFixed());
    if (ft(e2))
      return new Date(+e2);
    if (ArrayBuffer.isView(e2))
      return e2.slice(0);
    if (Array.isArray(e2)) {
      let t2 = e2.length, r;
      for (r = Array(t2);t2--; )
        r[t2] = Yt(e2[t2]);
      return r;
    }
    if (typeof e2 == "object") {
      let t2 = {};
      for (let r in e2)
        r === "__proto__" ? Object.defineProperty(t2, r, { value: Yt(e2[r]), configurable: true, enumerable: true, writable: true }) : t2[r] = Yt(e2[r]);
      return t2;
    }
    He(e2, "Unknown value");
  };
  var la = function(e2, t2, r, n2 = 0) {
    return e2._createPrismaPromise((i) => {
      let o2 = t2.customDataProxyFetch;
      return ("transaction" in t2) && i !== undefined && (t2.transaction?.kind === "batch" && t2.transaction.lock.then(), t2.transaction = i), n2 === r.length ? e2._executeRequest(t2) : r[n2]({ model: t2.model, operation: t2.model ? t2.action : t2.clientMethod, args: sa(t2.args ?? {}), __internalParams: t2, query: (s2, a2 = t2) => {
        let l2 = a2.customDataProxyFetch;
        return a2.customDataProxyFetch = da(o2, l2), a2.args = s2, la(e2, a2, r, n2 + 1);
      } });
    });
  };
  var ua = function(e2, t2) {
    let { jsModelName: r, action: n2, clientMethod: i } = t2, o2 = r ? n2 : i;
    if (e2._extensions.isEmpty())
      return e2._executeRequest(t2);
    let s2 = e2._extensions.getAllQueryCallbacks(r ?? "$none", o2);
    return la(e2, t2, s2);
  };
  var ca = function(e2) {
    return (t2) => {
      let r = { requests: t2 }, n2 = t2[0].extensions.getAllBatchQueryCallbacks();
      return n2.length ? pa(r, n2, 0, e2) : e2(r);
    };
  };
  var pa = function(e2, t2, r, n2) {
    if (r === t2.length)
      return n2(e2);
    let i = e2.customDataProxyFetch, o2 = e2.requests[0].transaction;
    return t2[r]({ args: { queries: e2.requests.map((s2) => ({ model: s2.modelName, operation: s2.action, args: s2.args })), transaction: o2 ? { isolationLevel: o2.kind === "batch" ? o2.isolationLevel : undefined } : undefined }, __internalParams: e2, query(s2, a2 = e2) {
      let l2 = a2.customDataProxyFetch;
      return a2.customDataProxyFetch = da(i, l2), pa(a2, t2, r + 1, n2);
    } });
  };
  var da = function(e2 = aa, t2 = aa) {
    return (r) => e2(t2(r));
  };
  var fa = function(e2, t2, r) {
    let n2 = Te(r);
    return !t2.result || !(t2.result.$allModels || t2.result[n2]) ? e2 : Jp({ ...e2, ...ma(t2.name, e2, t2.result.$allModels), ...ma(t2.name, e2, t2.result[n2]) });
  };
  var Jp = function(e2) {
    let t2 = new be, r = (n2, i) => t2.getOrCreate(n2, () => i.has(n2) ? [n2] : (i.add(n2), e2[n2] ? e2[n2].needs.flatMap((o2) => r(o2, i)) : [n2]));
    return pt(e2, (n2) => ({ ...n2, needs: r(n2.name, new Set) }));
  };
  var ma = function(e2, t2, r) {
    return r ? pt(r, ({ needs: n2, compute: i }, o2) => ({ name: o2, needs: n2 ? Object.keys(n2).filter((s2) => n2[s2]) : [], compute: Hp(t2, o2, i) })) : {};
  };
  var Hp = function(e2, t2, r) {
    let n2 = e2?.[t2]?.compute;
    return n2 ? (i) => r({ ...i, [t2]: n2(i) }) : r;
  };
  var ga = function(e2, t2) {
    if (!t2)
      return e2;
    let r = { ...e2 };
    for (let n2 of Object.values(t2))
      if (e2[n2.name])
        for (let i of n2.needs)
          r[i] = true;
    return r;
  };
  var xa = function({ postinstall: e2, ciName: t2, clientVersion: r }) {
    if (ya("checkPlatformCaching:postinstall", e2), ya("checkPlatformCaching:ciName", t2), e2 === true && t2 && (t2 in ha)) {
      let n2 = `Prisma has detected that this project was built on ${t2}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ha[t2]}-build`;
      throw console.error(n2), new F(n2, r);
    }
  };
  var ba = function(e2, t2) {
    return e2 ? e2.datasources ? e2.datasources : e2.datasourceUrl ? { [t2[0]]: { url: e2.datasourceUrl } } : {} : {};
  };
  var Zt = function({ error: e2, user_facing_error: t2 }, r) {
    return t2.error_code ? new U(t2.message, { code: t2.error_code, clientVersion: r, meta: t2.meta, batchRequestIdx: t2.batch_request_idx }) : new K(e2, { clientVersion: r, batchRequestIdx: t2.batch_request_idx });
  };
  var un = function(e2) {
    let { runtimeBinaryTarget: t2 } = e2;
    return `Add "${t2}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Wp(e2)}`;
  };
  var Wp = function(e2) {
    let { generator: t2, generatorBinaryTargets: r, runtimeBinaryTarget: n2 } = e2, i = { fromEnvVar: null, value: n2 }, o2 = [...r, i];
    return si({ ...t2, binaryTargets: o2 });
  };
  var je = function(e2) {
    let { runtimeBinaryTarget: t2 } = e2;
    return `Prisma Client could not locate the Query Engine for runtime "${t2}".`;
  };
  var Be = function(e2) {
    let { searchedLocations: t2 } = e2;
    return `The following locations have been searched:
${[...new Set(t2)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var Ea = function(e2) {
    let { runtimeBinaryTarget: t2 } = e2;
    return `${je(e2)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t2}".
${un(e2)}

${Be(e2)}`;
  };
  var cn = function(e2) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e2}`;
  };
  var wa = function(e2) {
    let { queryEngineName: t2 } = e2;
    return `${je(e2)}

This is likely caused by a bundler that has not copied "${t2}" next to the resulting bundle.
Ensure that "${t2}" has been copied next to the bundle or in "${e2.expectedLocation}".

${cn("engine-not-found-bundler-investigation")}

${Be(e2)}`;
  };
  var Pa = function(e2) {
    let { runtimeBinaryTarget: t2, generatorBinaryTargets: r } = e2, n2 = r.find((i) => i.native);
    return `${je(e2)}

This happened because Prisma Client was generated for "${n2?.value ?? "unknown"}", but the actual deployment required "${t2}".
${un(e2)}

${Be(e2)}`;
  };
  var va = function(e2) {
    let { queryEngineName: t2 } = e2;
    return `${je(e2)}

This is likely caused by tooling that has not copied "${t2}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t2}" has been copied to "${e2.expectedLocation}".

${cn("engine-not-found-tooling-investigation")}

${Be(e2)}`;
  };
  async function Ca(e2, t2) {
    let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e2] ?? t2.prismaPath;
    if (r !== undefined)
      return r;
    let { enginePath: n2, searchedLocations: i } = await Zp(e2, t2);
    if (zp("enginePath", n2), n2 !== undefined && e2 === "binary" && ti(n2), n2 !== undefined)
      return t2.prismaPath = n2;
    let o2 = await ut(), s2 = t2.generator?.binaryTargets ?? [], a2 = s2.some((d2) => d2.native), l2 = !s2.some((d2) => d2.value === o2), u2 = import.meta.file.match(Yp()) === null, c2 = { searchedLocations: i, generatorBinaryTargets: s2, generator: t2.generator, runtimeBinaryTarget: o2, queryEngineName: Aa(e2, o2), expectedLocation: Xt.default.relative(process.cwd(), t2.dirname) }, p2;
    throw a2 && l2 ? p2 = Pa(c2) : l2 ? p2 = Ea(c2) : u2 ? p2 = wa(c2) : p2 = va(c2), new F(p2, t2.clientVersion);
  }
  async function Zp(engineType, config) {
    let binaryTarget = await ut(), searchedLocations = [], dirname = import.meta.dir, searchLocations = [config.dirname, Xt.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, Xt.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    import.meta.file.includes("resolveEnginePath") && searchLocations.push(rs());
    for (let e2 of searchLocations) {
      let t2 = Aa(engineType, binaryTarget), r = Xt.default.join(e2, t2);
      if (searchedLocations.push(e2), Ta.default.existsSync(r))
        return { enginePath: r, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  var Aa = function(e2, t2) {
    return e2 === "library" ? jn(t2, "fs") : `query-engine-${t2}${t2 === "windows" ? ".exe" : ""}`;
  };
  var pn = function(e2, t2) {
    return { batch: e2, transaction: t2?.kind === "batch" ? { isolationLevel: t2.options.isolationLevel } : undefined };
  };
  var Ra = function(e2) {
    return e2 ? e2.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t2) => `${t2[0]}5`) : "";
  };
  var Ma = function(e2) {
    return e2.split(`
`).map((t2) => t2.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  };
  var Ia = function({ title: e2, user: t2 = "prisma", repo: r = "prisma", template: n2 = "bug_report.md", body: i }) {
    return (0, Sa.default)({ user: t2, repo: r, template: n2, title: e2, body: i });
  };
  var ka = function({ version: e2, platform: t2, title: r, description: n2, engineVersion: i, database: o2, query: s2 }) {
    let a2 = bo(6000 - (s2?.length ?? 0)), l2 = Ma((0, Ii.default)(a2)), u2 = n2 ? `# Description
\`\`\`
${n2}
\`\`\`` : "", c2 = (0, Ii.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t2?.padEnd(19)}|
| Prisma Client   | ${e2?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o2?.padEnd(19)}|

${u2}

## Logs
\`\`\`
${l2}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s2 ? Ra(s2) : ""}
\`\`\`
`), p2 = Ia({ title: r, body: c2 });
    return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${te(p2)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  };
  var dn = function({ inlineDatasources: e2, overrideDatasources: t2, env: r, clientVersion: n2 }) {
    let i, o2 = Object.keys(e2)[0], s2 = e2[o2]?.url, a2 = t2[o2]?.url;
    if (o2 === undefined ? i = undefined : a2 ? i = a2 : s2?.value ? i = s2.value : s2?.fromEnvVar && (i = r[s2.fromEnvVar]), s2?.fromEnvVar !== undefined && i === undefined)
      throw new F(`error: Environment variable not found: ${s2.fromEnvVar}.`, n2);
    if (i === undefined)
      throw new F("error: Missing URL environment variable, value, or override.", n2);
    return i;
  };
  var M = function(e2, t2) {
    return { ...e2, isRetryable: t2 };
  };
  async function td(e2) {
    let t2;
    try {
      t2 = await e2.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r = JSON.parse(t2);
      if (typeof r == "string")
        switch (r) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r };
          default:
            return { type: "UnknownTextError", body: r };
        }
      if (typeof r == "object" && r !== null) {
        if (("is_panic" in r) && ("message" in r) && ("error_code" in r))
          return { type: "QueryEngineError", body: r };
        if (("EngineNotStarted" in r) || ("InteractiveTransactionMisrouted" in r) || ("InvalidRequestError" in r)) {
          let n2 = Object.values(r)[0].reason;
          return typeof n2 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n2) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
        }
      }
      return { type: "UnknownJsonError", body: r };
    } catch {
      return t2 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t2 };
    }
  }
  async function cr(e2, t2) {
    if (e2.ok)
      return;
    let r = { clientVersion: t2, response: e2 }, n2 = await td(e2);
    if (n2.type === "QueryEngineError")
      throw new U(n2.body.message, { code: n2.body.error_code, clientVersion: t2 });
    if (n2.type === "DataProxyError") {
      if (n2.body === "InternalDataProxyError")
        throw new Ct(r, "Internal Data Proxy error");
      if ("EngineNotStarted" in n2.body) {
        if (n2.body.EngineNotStarted.reason === "SchemaMissing")
          return new Xe(r);
        if (n2.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new nr(r);
        if ("EngineStartupError" in n2.body.EngineNotStarted.reason) {
          let { msg: i, logs: o2 } = n2.body.EngineNotStarted.reason.EngineStartupError;
          throw new rr(r, i, o2);
        }
        if ("KnownEngineStartupError" in n2.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o2 } = n2.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new F(i, t2, o2);
        }
        if ("HealthcheckTimeout" in n2.body.EngineNotStarted.reason) {
          let { logs: i } = n2.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new tr(r, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n2.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new or(r, i[n2.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n2.body)
        throw new sr(r, n2.body.InvalidRequestError.reason);
    }
    if (e2.status === 401 || e2.status === 403)
      throw new lr(r, At(_i, n2));
    if (e2.status === 404)
      return new ar(r, At(Oi, n2));
    if (e2.status === 429)
      throw new ur(r, At(Ni, n2));
    if (e2.status === 504)
      throw new ir(r, At(Fi, n2));
    if (e2.status >= 500)
      throw new Ct(r, At(Di, n2));
    if (e2.status >= 400)
      throw new er(r, At(ki, n2));
  }
  var At = function(e2, t2) {
    return t2.type === "EmptyError" ? e2 : `${e2}: ${JSON.stringify(t2)}`;
  };
  var Fa = function(e2) {
    let t2 = Math.pow(2, e2) * 50, r = Math.ceil(Math.random() * t2) - Math.ceil(t2 / 2), n2 = t2 + r;
    return new Promise((i) => setTimeout(() => i(n2), n2));
  };
  var Oa = function(e2) {
    if (!!e2.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics")))
      throw new F("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e2.clientVersion);
  };
  async function et(e2, t2, r = (n2) => n2) {
    let n2 = t2.clientVersion;
    try {
      return typeof fetch == "function" ? await r(fetch)(e2, t2) : await r(Li)(e2, t2);
    } catch (i) {
      console.log(e2);
      let o2 = i.message ?? "Unknown error";
      throw new pr(o2, { clientVersion: n2 });
    }
  }
  var nd = function(e2) {
    return { ...e2.headers, "Content-Type": "application/json" };
  };
  var id = function(e2) {
    return { method: e2.method, headers: nd(e2) };
  };
  var od = function(e2, t2) {
    return { text: () => Promise.resolve(Buffer.concat(e2).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e2).toString())), ok: t2.statusCode >= 200 && t2.statusCode <= 299, status: t2.statusCode, url: t2.url, headers: new $i(t2.headers) };
  };
  async function Li(e2, t2 = {}) {
    let r = sd("https"), n2 = id(t2), i = [], { origin: o2 } = new URL(e2);
    return new Promise((s2, a2) => {
      let l2 = r.request(e2, n2, (u2) => {
        let { statusCode: c2, headers: { location: p2 } } = u2;
        c2 >= 301 && c2 <= 399 && p2 && (p2.startsWith("http") === false ? s2(Li(`${o2}${p2}`, t2)) : s2(Li(p2, t2))), u2.on("data", (d2) => i.push(d2)), u2.on("end", () => s2(od(i, u2))), u2.on("error", a2);
      });
      l2.on("error", a2), l2.end(t2.body ?? "");
    });
  }
  async function ld(e2, t2) {
    let r = Da["@prisma/engines-version"], n2 = t2.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e2.includes("accelerate") && n2 !== "0.0.0" && n2 !== "in-memory")
      return n2;
    let [i, o2] = n2?.split("-") ?? [];
    if (o2 === undefined && ad.test(i))
      return i;
    if (o2 !== undefined || n2 === "0.0.0" || n2 === "in-memory") {
      if (e2.startsWith("localhost") || e2.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s2] = r.split("-") ?? [], [a2, l2, u2] = s2.split("."), c2 = ud(`<=${a2}.${l2}.${u2}`), p2 = await et(c2, { clientVersion: n2 });
      if (!p2.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p2.status} ${p2.statusText}, response body: ${await p2.text() || "<empty body>"}`);
      let d2 = await p2.text();
      _a("length of body fetched from unpkg.com", d2.length);
      let f;
      try {
        f = JSON.parse(d2);
      } catch (y2) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d2), y2;
      }
      return f.version;
    }
    throw new Ze("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n2 });
  }
  async function Na(e2, t2) {
    let r = await ld(e2, t2);
    return _a("version", r), r;
  }
  var ud = function(e2) {
    return encodeURI(`https://unpkg.com/prisma@${e2}/package.json`);
  };
  var $a = function(e2) {
    if (e2?.kind === "itx")
      return e2.options.id;
  };
  var cd = function() {
    let e2 = globalThis;
    return e2[ji] === undefined && (e2[ji] = {}), e2[ji];
  };
  var pd = function(e2) {
    let t2 = cd();
    if (t2[e2] !== undefined)
      return t2[e2];
    let r = qa.default.toNamespacedPath(e2), n2 = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Bi.default.constants.dlopen.RTLD_LAZY | Bi.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n2, r, i), t2[e2] = n2.exports, n2.exports;
  };
  var md = function(e2) {
    return e2.item_type === "query" && ("query" in e2);
  };
  var fd = function(e2) {
    return "level" in e2 ? e2.level === "error" && e2.message === "PANIC" : false;
  };
  var Ua = function(e2, t2) {
    let r;
    try {
      r = dn({ inlineDatasources: t2.inlineDatasources, overrideDatasources: t2.overrideDatasources, env: { ...t2.env, ...process.env }, clientVersion: t2.clientVersion });
    } catch {
    }
    e2.noEngine !== true && r?.startsWith("prisma://") && qt("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n2 = Zn(t2.generator);
    if (r?.startsWith("prisma://") || e2.noEngine)
      return new dr(t2);
    if (n2 === "library")
      return new mr(t2);
    throw "binary", new X("Invalid client engine type, please use `library` or `binary`", { clientVersion: t2.clientVersion });
  };
  var gn = function({ generator: e2 }) {
    return e2?.previewFeatures ?? [];
  };
  var Ja = function(e2, t2) {
    let r = Ha(e2), n2 = gd(r), i = hd(n2);
    i ? yn(i, t2) : t2.addErrorMessage(() => "Unknown error");
  };
  var Ha = function(e2) {
    return e2.errors.flatMap((t2) => t2.kind === "Union" ? Ha(t2) : [t2]);
  };
  var gd = function(e2) {
    let t2 = new Map, r = [];
    for (let n2 of e2) {
      if (n2.kind !== "InvalidArgumentType") {
        r.push(n2);
        continue;
      }
      let i = `${n2.selectionPath.join(".")}:${n2.argumentPath.join(".")}`, o2 = t2.get(i);
      o2 ? t2.set(i, { ...n2, argument: { ...n2.argument, typeNames: yd(o2.argument.typeNames, n2.argument.typeNames) } }) : t2.set(i, n2);
    }
    return r.push(...t2.values()), r;
  };
  var yd = function(e2, t2) {
    return [...new Set(e2.concat(t2))];
  };
  var hd = function(e2) {
    return pi(e2, (t2, r) => {
      let n2 = Qa(t2), i = Qa(r);
      return n2 !== i ? n2 - i : Ga(t2) - Ga(r);
    });
  };
  var Qa = function(e2) {
    let t2 = 0;
    return Array.isArray(e2.selectionPath) && (t2 += e2.selectionPath.length), Array.isArray(e2.argumentPath) && (t2 += e2.argumentPath.length), t2;
  };
  var Ga = function(e2) {
    switch (e2.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  };
  var yn = function(e2, t2) {
    switch (e2.kind) {
      case "IncludeAndSelect":
        xd(e2, t2);
        break;
      case "IncludeOnScalar":
        bd(e2, t2);
        break;
      case "EmptySelection":
        Ed(e2, t2);
        break;
      case "UnknownSelectionField":
        wd(e2, t2);
        break;
      case "UnknownArgument":
        Pd(e2, t2);
        break;
      case "UnknownInputField":
        vd(e2, t2);
        break;
      case "RequiredArgumentMissing":
        Td(e2, t2);
        break;
      case "InvalidArgumentType":
        Cd(e2, t2);
        break;
      case "InvalidArgumentValue":
        Ad(e2, t2);
        break;
      case "ValueTooLarge":
        Rd(e2, t2);
        break;
      case "SomeFieldsMissing":
        Md(e2, t2);
        break;
      case "TooManyFieldsGiven":
        Sd(e2, t2);
        break;
      case "Union":
        Ja(e2, t2);
        break;
      default:
        throw new Error("not implemented: " + e2.kind);
    }
  };
  var xd = function(e2, t2) {
    let r = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    r && r instanceof Q && (r.getField("include")?.markAsError(), r.getField("select")?.markAsError()), t2.addErrorMessage((n2) => `Please ${n2.bold("either")} use ${n2.green("`include`")} or ${n2.green("`select`")}, but ${n2.red("not both")} at the same time.`);
  };
  var bd = function(e2, t2) {
    let [r, n2] = xn(e2.selectionPath), i = e2.outputType, o2 = t2.arguments.getDeepSelectionParent(r)?.value;
    if (o2 && (o2.getField(n2)?.markAsError(), i))
      for (let s2 of i.fields)
        s2.isRelation && o2.addSuggestion(new Se(s2.name, "true"));
    t2.addErrorMessage((s2) => {
      let a2 = `Invalid scalar field ${s2.red(`\`${n2}\``)} for ${s2.bold("include")} statement`;
      return i ? a2 += ` on model ${s2.bold(i.name)}. ${fr(s2)}` : a2 += ".", a2 += `
Note that ${s2.bold("include")} statements only accept relation fields.`, a2;
    });
  };
  var Ed = function(e2, t2) {
    let r = e2.outputType, n2 = t2.arguments.getDeepSelectionParent(e2.selectionPath)?.value, i = n2?.isEmpty() ?? false;
    n2 && (n2.removeAllFields(), Za(n2, r)), t2.addErrorMessage((o2) => i ? `The ${o2.red("`select`")} statement for type ${o2.bold(r.name)} must not be empty. ${fr(o2)}` : `The ${o2.red("`select`")} statement for type ${o2.bold(r.name)} needs ${o2.bold("at least one truthy value")}.`);
  };
  var wd = function(e2, t2) {
    let [r, n2] = xn(e2.selectionPath), i = t2.arguments.getDeepSelectionParent(r);
    i && (i.value.getField(n2)?.markAsError(), Za(i.value, e2.outputType)), t2.addErrorMessage((o2) => {
      let s2 = [`Unknown field ${o2.red(`\`${n2}\``)}`];
      return i && s2.push(`for ${o2.bold(i.kind)} statement`), s2.push(`on model ${o2.bold(`\`${e2.outputType.name}\``)}.`), s2.push(fr(o2)), s2.join(" ");
    });
  };
  var Pd = function(e2, t2) {
    let r = e2.argumentPath[0], n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    n2 instanceof Q && (n2.getField(r)?.markAsError(), Id(n2, e2.arguments)), t2.addErrorMessage((i) => za(i, r, e2.arguments.map((o2) => o2.name)));
  };
  var vd = function(e2, t2) {
    let [r, n2] = xn(e2.argumentPath), i = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    if (i instanceof Q) {
      i.getDeepField(e2.argumentPath)?.markAsError();
      let o2 = i.getDeepFieldValue(r);
      o2 instanceof Q && Xa(o2, e2.inputType);
    }
    t2.addErrorMessage((o2) => za(o2, n2, e2.inputType.fields.map((s2) => s2.name)));
  };
  var za = function(e2, t2, r) {
    let n2 = [`Unknown argument \`${e2.red(t2)}\`.`], i = Fd(t2, r);
    return i && n2.push(`Did you mean \`${e2.green(i)}\`?`), r.length > 0 && n2.push(fr(e2)), n2.join(" ");
  };
  var Td = function(e2, t2) {
    let r;
    t2.addErrorMessage((l2) => r?.value instanceof G && r.value.text === "null" ? `Argument \`${l2.green(o2)}\` must not be ${l2.red("null")}.` : `Argument \`${l2.green(o2)}\` is missing.`);
    let n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    if (!(n2 instanceof Q))
      return;
    let [i, o2] = xn(e2.argumentPath), s2 = new hn, a2 = n2.getDeepFieldValue(i);
    if (a2 instanceof Q)
      if (r = a2.getField(o2), r && a2.removeField(o2), e2.inputTypes.length === 1 && e2.inputTypes[0].kind === "object") {
        for (let l2 of e2.inputTypes[0].fields)
          s2.addField(l2.name, l2.typeNames.join(" | "));
        a2.addSuggestion(new Se(o2, s2).makeRequired());
      } else {
        let l2 = e2.inputTypes.map(Ya).join(" | ");
        a2.addSuggestion(new Se(o2, l2).makeRequired());
      }
  };
  var Ya = function(e2) {
    return e2.kind === "list" ? `${Ya(e2.elementType)}[]` : e2.name;
  };
  var Cd = function(e2, t2) {
    let r = e2.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    n2 instanceof Q && n2.getDeepFieldValue(e2.argumentPath)?.markAsError(), t2.addErrorMessage((i) => {
      let o2 = bn("or", e2.argument.typeNames.map((s2) => i.green(s2)));
      return `Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o2}, provided ${i.red(e2.inferredType)}.`;
    });
  };
  var Ad = function(e2, t2) {
    let r = e2.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    n2 instanceof Q && n2.getDeepFieldValue(e2.argumentPath)?.markAsError(), t2.addErrorMessage((i) => {
      let o2 = [`Invalid value for argument \`${i.bold(r)}\``];
      if (e2.underlyingError && o2.push(`: ${e2.underlyingError}`), o2.push("."), e2.argument.typeNames.length > 0) {
        let s2 = bn("or", e2.argument.typeNames.map((a2) => i.green(a2)));
        o2.push(` Expected ${s2}.`);
      }
      return o2.join("");
    });
  };
  var Rd = function(e2, t2) {
    let r = e2.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath), i;
    if (n2 instanceof Q) {
      let s2 = n2.getDeepField(e2.argumentPath)?.value;
      s2?.markAsError(), s2 instanceof G && (i = s2.text);
    }
    t2.addErrorMessage((o2) => {
      let s2 = ["Unable to fit value"];
      return i && s2.push(o2.red(i)), s2.push(`into a 64-bit signed integer for field \`${o2.bold(r)}\``), s2.join(" ");
    });
  };
  var Md = function(e2, t2) {
    let r = e2.argumentPath[e2.argumentPath.length - 1], n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath);
    if (n2 instanceof Q) {
      let i = n2.getDeepFieldValue(e2.argumentPath);
      i instanceof Q && Xa(i, e2.inputType);
    }
    t2.addErrorMessage((i) => {
      let o2 = [`Argument \`${i.bold(r)}\` of type ${i.bold(e2.inputType.name)} needs`];
      return e2.constraints.minFieldCount === 1 ? e2.constraints.requiredFields ? o2.push(`${i.green("at least one of")} ${bn("or", e2.constraints.requiredFields.map((s2) => `\`${i.bold(s2)}\``))} arguments.`) : o2.push(`${i.green("at least one")} argument.`) : o2.push(`${i.green(`at least ${e2.constraints.minFieldCount}`)} arguments.`), o2.push(fr(i)), o2.join(" ");
    });
  };
  var Sd = function(e2, t2) {
    let r = e2.argumentPath[e2.argumentPath.length - 1], n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath), i = [];
    if (n2 instanceof Q) {
      let o2 = n2.getDeepFieldValue(e2.argumentPath);
      o2 instanceof Q && (o2.markAsError(), i = Object.keys(o2.getFields()));
    }
    t2.addErrorMessage((o2) => {
      let s2 = [`Argument \`${o2.bold(r)}\` of type ${o2.bold(e2.inputType.name)} needs`];
      return e2.constraints.minFieldCount === 1 && e2.constraints.maxFieldCount == 1 ? s2.push(`${o2.green("exactly one")} argument,`) : e2.constraints.maxFieldCount == 1 ? s2.push(`${o2.green("at most one")} argument,`) : s2.push(`${o2.green(`at most ${e2.constraints.maxFieldCount}`)} arguments,`), s2.push(`but you provided ${bn("and", i.map((a2) => o2.red(a2)))}. Please choose`), e2.constraints.maxFieldCount === 1 ? s2.push("one.") : s2.push(`${e2.constraints.maxFieldCount}.`), s2.join(" ");
    });
  };
  var Za = function(e2, t2) {
    for (let r of t2.fields)
      e2.hasField(r.name) || e2.addSuggestion(new Se(r.name, "true"));
  };
  var Id = function(e2, t2) {
    for (let r of t2)
      e2.hasField(r.name) || e2.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var Xa = function(e2, t2) {
    if (t2.kind === "object")
      for (let r of t2.fields)
        e2.hasField(r.name) || e2.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var xn = function(e2) {
    let t2 = [...e2], r = t2.pop();
    if (!r)
      throw new Error("unexpected empty path");
    return [t2, r];
  };
  var fr = function({ green: e2, enabled: t2 }) {
    return "Available options are " + (t2 ? `listed in ${e2("green")}` : "marked with ?") + ".";
  };
  var bn = function(e2, t2) {
    if (t2.length === 1)
      return t2[0];
    let r = [...t2], n2 = r.pop();
    return `${r.join(", ")} ${e2} ${n2}`;
  };
  var Fd = function(e2, t2) {
    let r = 1 / 0, n2;
    for (let i of t2) {
      let o2 = (0, Wa.default)(e2, i);
      o2 > kd || o2 < r && (r = o2, n2 = i);
    }
    return n2;
  };
  var En = function({ args: e2, errors: t2, errorFormat: r, callsite: n2, originalMethod: i, clientVersion: o2 }) {
    let s2 = en(e2);
    for (let p2 of t2)
      yn(p2, s2);
    let a2 = r === "pretty" ? Ds : Zr, l2 = s2.renderAllMessages(a2), u2 = new mt(0, { colors: a2 }).write(s2).toString(), c2 = Pt({ message: l2, callsite: n2, originalMethod: i, showColors: r === "pretty", callArguments: u2 });
    throw new X(c2, { clientVersion: o2 });
  };
  var el = function({ modelName: e2, action: t2, args: r, runtimeDataModel: n2, extensions: i, callsite: o2, clientMethod: s2, errorFormat: a2, clientVersion: l2 }) {
    let u2 = new Ki({ runtimeDataModel: n2, modelName: e2, action: t2, rootArgs: r, callsite: o2, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s2, errorFormat: a2, clientVersion: l2 });
    return { modelName: e2, action: Od[t2], query: Qi(r, u2) };
  };
  var Qi = function({ select: e2, include: t2, ...r } = {}, n2) {
    return { arguments: rl(r, n2), selection: Dd(e2, t2, n2) };
  };
  var Dd = function(e2, t2, r) {
    return e2 && t2 && r.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r.getSelectionPath() }), e2 ? Ld(e2, r) : _d(r, t2);
  };
  var _d = function(e2, t2) {
    let r = {};
    return e2.model && !e2.isRawAction() && (r.$composites = true, r.$scalars = true), t2 && Nd(r, t2, e2), r;
  };
  var Nd = function(e2, t2, r) {
    for (let [n2, i] of Object.entries(t2)) {
      let o2 = r.findField(n2);
      o2 && o2?.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n2), outputType: r.getOutputTypeDescription() }), i === true ? e2[n2] = true : typeof i == "object" && (e2[n2] = Qi(i, r.nestSelection(n2)));
    }
  };
  var Ld = function(e2, t2) {
    let r = {}, n2 = t2.getComputedFields(), i = ga(e2, n2);
    for (let [o2, s2] of Object.entries(i)) {
      let a2 = t2.findField(o2);
      n2?.[o2] && !a2 || (s2 === true ? r[o2] = true : typeof s2 == "object" && (r[o2] = Qi(s2, t2.nestSelection(o2))));
    }
    return r;
  };
  var tl = function(e2, t2) {
    if (e2 === null)
      return null;
    if (typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean")
      return e2;
    if (typeof e2 == "bigint")
      return { $type: "BigInt", value: String(e2) };
    if (ft(e2)) {
      if (Br(e2))
        return { $type: "DateTime", value: e2.toISOString() };
      t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (xt(e2))
      return { $type: "FieldRef", value: { _ref: e2.name, _container: e2.modelName } };
    if (Array.isArray(e2))
      return $d(e2, t2);
    if (ArrayBuffer.isView(e2))
      return { $type: "Bytes", value: Buffer.from(e2).toString("base64") };
    if (qd(e2))
      return e2.values;
    if (ht(e2))
      return { $type: "Decimal", value: e2.toFixed() };
    if (e2 instanceof xe) {
      if (e2 !== $r.instances[e2._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e2._getName() };
    }
    if (Vd(e2))
      return e2.toJSON();
    if (typeof e2 == "object")
      return rl(e2, t2);
    t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e2)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  };
  var rl = function(e2, t2) {
    if (e2.$type)
      return { $type: "Json", value: JSON.stringify(e2) };
    let r = {};
    for (let n2 in e2) {
      let i = e2[n2];
      i !== undefined && (r[n2] = tl(i, t2.nestArgument(n2)));
    }
    return r;
  };
  var $d = function(e2, t2) {
    let r = [];
    for (let n2 = 0;n2 < e2.length; n2++) {
      let i = t2.nestArgument(String(n2)), o2 = e2[n2];
      o2 === undefined && t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t2.getArgumentName()}[${n2}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r.push(tl(o2, i));
    }
    return r;
  };
  var qd = function(e2) {
    return typeof e2 == "object" && e2 !== null && e2.__prismaRawParameters__ === true;
  };
  var Vd = function(e2) {
    return typeof e2 == "object" && e2 !== null && typeof e2.toJSON == "function";
  };
  var gr = function(e2) {
    try {
      return ol(e2, "fast");
    } catch {
      return ol(e2, "slow");
    }
  };
  var ol = function(e2, t2) {
    return JSON.stringify(e2.map((r) => jd(r, t2)));
  };
  var jd = function(e2, t2) {
    return typeof e2 == "bigint" ? { prisma__type: "bigint", prisma__value: e2.toString() } : ft(e2) ? { prisma__type: "date", prisma__value: e2.toJSON() } : Pe.isDecimal(e2) ? { prisma__type: "decimal", prisma__value: e2.toJSON() } : Buffer.isBuffer(e2) ? { prisma__type: "bytes", prisma__value: e2.toString("base64") } : Bd(e2) || ArrayBuffer.isView(e2) ? { prisma__type: "bytes", prisma__value: Buffer.from(e2).toString("base64") } : typeof e2 == "object" && t2 === "slow" ? al(e2) : e2;
  };
  var Bd = function(e2) {
    return e2 instanceof ArrayBuffer || e2 instanceof SharedArrayBuffer ? true : typeof e2 == "object" && e2 !== null ? e2[Symbol.toStringTag] === "ArrayBuffer" || e2[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  };
  var al = function(e2) {
    if (typeof e2 != "object" || e2 === null)
      return e2;
    if (typeof e2.toJSON == "function")
      return e2.toJSON();
    if (Array.isArray(e2))
      return e2.map(sl);
    let t2 = {};
    for (let r of Object.keys(e2))
      t2[r] = sl(e2[r]);
    return t2;
  };
  var sl = function(e2) {
    return typeof e2 == "bigint" ? e2.toString() : al(e2);
  };
  var Gi = function(e2, t2, r, n2) {
    if (!(e2 !== "postgresql" && e2 !== "cockroachdb") && r.length > 0 && Ud.exec(t2))
      throw new Error(`Running ALTER using ${n2} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  };
  var Hi = function(e2) {
    return function(r) {
      let n2, i = (o2 = e2) => {
        try {
          return o2 === undefined || o2?.kind === "itx" ? n2 ?? (n2 = pl(r(o2))) : pl(r(o2));
        } catch (s2) {
          return Promise.reject(s2);
        }
      };
      return { then(o2, s2) {
        return i().then(o2, s2);
      }, catch(o2) {
        return i().catch(o2);
      }, finally(o2) {
        return i().finally(o2);
      }, requestTransaction(o2) {
        let s2 = i(o2);
        return s2.requestTransaction ? s2.requestTransaction(o2) : s2;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  };
  var pl = function(e2) {
    return typeof e2.then == "function" ? e2 : Promise.resolve(e2);
  };
  var ml = function(e2) {
    return e2.includes("tracing") ? new Wi : dl;
  };
  var fl = function(e2, t2 = () => {
  }) {
    let r, n2 = new Promise((i) => r = i);
    return { then(i) {
      return --e2 === 0 && r(t2()), i?.(n2);
    } };
  };
  var gl = function(e2) {
    return typeof e2 == "string" ? e2 : e2.reduce((t2, r) => {
      let n2 = typeof r == "string" ? r : r.level;
      return n2 === "query" ? t2 : t2 && (r === "info" || t2 === "info") ? "info" : n2;
    }, undefined);
  };
  var Pn = function(e2) {
    return typeof e2.batchRequestIdx == "number";
  };
  var vn = function(e2) {
    return e2 === null ? e2 : Array.isArray(e2) ? e2.map(vn) : typeof e2 == "object" ? Qd(e2) ? Gd(e2) : pt(e2, vn) : e2;
  };
  var Qd = function(e2) {
    return e2 !== null && typeof e2 == "object" && typeof e2.$type == "string";
  };
  var Gd = function({ $type: e2, value: t2 }) {
    switch (e2) {
      case "BigInt":
        return BigInt(t2);
      case "Bytes":
        return Buffer.from(t2, "base64");
      case "DateTime":
        return new Date(t2);
      case "Decimal":
        return new Pe(t2);
      case "Json":
        return JSON.parse(t2);
      default:
        He(t2, "Unknown tagged value");
    }
  };
  var yl = function(e2) {
    if (e2.action !== "findUnique" && e2.action !== "findUniqueOrThrow")
      return;
    let t2 = [];
    return e2.modelName && t2.push(e2.modelName), e2.query.arguments && t2.push(Yi(e2.query.arguments)), t2.push(Yi(e2.query.selection)), t2.join("");
  };
  var Yi = function(e2) {
    return `(${Object.keys(e2).sort().map((r) => {
      let n2 = e2[r];
      return typeof n2 == "object" && n2 !== null ? `(${r} ${Yi(n2)})` : r;
    }).join(" ")})`;
  };
  var Zi = function(e2) {
    return Jd[e2];
  };
  var Wd = function(e2) {
    if (e2) {
      if (e2.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e2.isolationLevel } };
      if (e2.kind === "itx")
        return { kind: "itx", options: xl(e2) };
      He(e2, "Unknown transaction kind");
    }
  };
  var xl = function(e2) {
    return { id: e2.id, payload: e2.payload };
  };
  var zd = function(e2, t2) {
    return Pn(e2) && t2?.kind === "batch" && e2.batchRequestIdx !== t2.index;
  };
  var Yd = function(e2) {
    return e2.code === "P2009" || e2.code === "P2012";
  };
  var bl = function(e2) {
    if (e2.kind === "Union")
      return { kind: "Union", errors: e2.errors.map(bl) };
    if (Array.isArray(e2.selectionPath)) {
      let [, ...t2] = e2.selectionPath;
      return { ...e2, selectionPath: t2 };
    }
    return e2;
  };
  var Pl = function(e2) {
    return e2.map((t2) => {
      let r = {};
      for (let n2 of Object.keys(t2))
        r[n2] = vl(t2[n2]);
      return r;
    });
  };
  var vl = function({ prisma__type: e2, prisma__value: t2 }) {
    switch (e2) {
      case "bigint":
        return BigInt(t2);
      case "bytes":
        return Buffer.from(t2, "base64");
      case "decimal":
        return new Pe(t2);
      case "datetime":
      case "date":
        return new Date(t2);
      case "time":
        return new Date(`1970-01-01T${t2}Z`);
      case "array":
        return t2.map(vl);
      default:
        return t2;
    }
  };
  var Ml = function(e2, t2) {
    for (let [r, n2] of Object.entries(e2)) {
      if (!Tl.includes(r)) {
        let i = Rt(r, Tl);
        throw new q(`Unknown property ${r} provided to PrismaClient constructor.${i}`);
      }
      Xd[r](n2, t2);
    }
    if (e2.datasourceUrl && e2.datasources)
      throw new q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  };
  var Rt = function(e2, t2) {
    if (t2.length === 0 || typeof e2 != "string")
      return "";
    let r = em(e2, t2);
    return r ? ` Did you mean "${r}"?` : "";
  };
  var em = function(e2, t2) {
    if (t2.length === 0)
      return null;
    let r = t2.map((i) => ({ value: i, distance: (0, Rl.default)(e2, i) }));
    r.sort((i, o2) => i.distance < o2.distance ? -1 : 1);
    let n2 = r[0];
    return n2.distance < 3 ? n2.value : null;
  };
  var Sl = function(e2) {
    return e2.length === 0 ? Promise.resolve([]) : new Promise((t2, r) => {
      let n2 = new Array(e2.length), i = null, o2 = false, s2 = 0, a2 = () => {
        o2 || (s2++, s2 === e2.length && (o2 = true, i ? r(i) : t2(n2)));
      }, l2 = (u2) => {
        o2 || (o2 = true, r(u2));
      };
      for (let u2 = 0;u2 < e2.length; u2++)
        e2[u2].then((c2) => {
          n2[u2] = c2, a2();
        }, (c2) => {
          if (!Pn(c2)) {
            l2(c2);
            return;
          }
          c2.batchRequestIdx === u2 ? l2(c2) : (i || (i = c2), a2());
        });
    });
  };
  var Dl = function(e2) {

    class t2 {
      constructor(n2) {
        this._middlewares = new wn;
        this._createPrismaPromise = Hi();
        this.$extends = ra;
        xa(e2), n2 && Ml(n2, e2);
        let i = n2?.adapter ? fs(n2.adapter) : undefined, o2 = new Fl.EventEmitter().on("error", () => {
        });
        this._extensions = ln.empty(), this._previewFeatures = gn(e2), this._clientVersion = e2.clientVersion ?? wl, this._activeProvider = e2.activeProvider, this._tracingHelper = ml(this._previewFeatures);
        let s2 = { rootEnvPath: e2.relativeEnvPaths.rootEnvPath && yr.default.resolve(e2.dirname, e2.relativeEnvPaths.rootEnvPath), schemaEnvPath: e2.relativeEnvPaths.schemaEnvPath && yr.default.resolve(e2.dirname, e2.relativeEnvPaths.schemaEnvPath) }, a2 = !i && _t(s2, { conflictCheck: "none" }) || e2.injectableEdgeEnv?.();
        try {
          let l2 = n2 ?? {}, u2 = l2.__internal ?? {}, c2 = u2.debug === true;
          c2 && D.enable("prisma:client");
          let p2 = yr.default.resolve(e2.dirname, e2.relativePath);
          Ol.default.existsSync(p2) || (p2 = e2.dirname), Ue("dirname", e2.dirname), Ue("relativePath", e2.relativePath), Ue("cwd", p2);
          let d2 = u2.engine || {};
          if (l2.errorFormat ? this._errorFormat = l2.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e2.runtimeDataModel, this._engineConfig = { cwd: p2, dirname: e2.dirname, enableDebugLogs: c2, allowTriggerPanic: d2.allowTriggerPanic, datamodelPath: yr.default.join(e2.dirname, e2.filename ?? "schema.prisma"), prismaPath: d2.binaryPath ?? undefined, engineEndpoint: d2.endpoint, generator: e2.generator, showColors: this._errorFormat === "pretty", logLevel: l2.log && gl(l2.log), logQueries: l2.log && !!(typeof l2.log == "string" ? l2.log === "query" : l2.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a2?.parsed ?? {}, flags: [], clientVersion: e2.clientVersion, engineVersion: e2.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e2.activeProvider, inlineSchema: e2.inlineSchema, overrideDatasources: ba(l2, e2.datasourceNames), inlineDatasources: e2.inlineDatasources, inlineSchemaHash: e2.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: o2, isBundled: e2.isBundled, adapter: i }, Ue("clientVersion", e2.clientVersion), this._engine = Ua(e2, this._engineConfig), this._requestHandler = new Cn(this, o2), l2.log)
            for (let f of l2.log) {
              let y2 = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              y2 && this.$on(y2, (g) => {
                $t.log(`${$t.tags[y2] ?? ""}`, g.message || g.query);
              });
            }
          this._metrics = new dt(this._engine);
        } catch (l2) {
          throw l2.clientVersion = this._clientVersion, l2;
        }
        return this._appliedParent = zt(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n2) {
        this._middlewares.use(n2);
      }
      $on(n2, i) {
        n2 === "beforeExit" ? this._engine.on("beforeExit", i) : this._engine.on(n2, (o2) => {
          let s2 = o2.fields;
          return i(n2 === "query" ? { timestamp: o2.timestamp, query: s2?.query ?? o2.query, params: s2?.params ?? o2.params, duration: s2?.duration_ms ?? o2.duration, target: o2.target } : { timestamp: o2.timestamp, message: s2?.message ?? o2.message, target: o2.target });
        });
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n2) {
          throw n2.clientVersion = this._clientVersion, n2;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n2) {
          throw n2.clientVersion = this._clientVersion, n2;
        } finally {
          Eo();
        }
      }
      $executeRawInternal(n2, i, o2, s2) {
        let a2 = this._activeProvider, l2 = this._engineConfig.adapter?.flavour;
        return this._request({ action: "executeRaw", args: o2, transaction: n2, clientMethod: i, argsMapper: Ji({ clientMethod: i, activeProvider: a2, activeProviderFlavour: l2 }), callsite: Ve(this._errorFormat), dataPath: [], middlewareArgsMapper: s2 });
      }
      $executeRaw(n2, ...i) {
        return this._createPrismaPromise((o2) => {
          if (n2.raw !== undefined || n2.sql !== undefined) {
            let [s2, a2] = Il(n2, i);
            return Gi(this._activeProvider, s2.text, s2.values, Array.isArray(n2) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o2, "$executeRaw", s2, a2);
          }
          throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n2, ...i) {
        return this._createPrismaPromise((o2) => (Gi(this._activeProvider, n2, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o2, "$executeRawUnsafe", [n2, ...i])));
      }
      $runCommandRaw(n2) {
        if (e2.activeProvider !== "mongodb")
          throw new X(`The ${e2.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n2, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: nl, callsite: Ve(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n2, i, o2, s2) {
        let a2 = this._activeProvider, l2 = this._engineConfig.adapter?.flavour;
        return this._request({ action: "queryRaw", args: o2, transaction: n2, clientMethod: i, argsMapper: Ji({ clientMethod: i, activeProvider: a2, activeProviderFlavour: l2 }), callsite: Ve(this._errorFormat), dataPath: [], middlewareArgsMapper: s2 }).then(Pl);
      }
      $queryRaw(n2, ...i) {
        return this._createPrismaPromise((o2) => {
          if (n2.raw !== undefined || n2.sql !== undefined)
            return this.$queryRawInternal(o2, "$queryRaw", ...Il(n2, i));
          throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n2, ...i) {
        return this._createPrismaPromise((o2) => this.$queryRawInternal(o2, "$queryRawUnsafe", [n2, ...i]));
      }
      _transactionWithArray({ promises: n2, options: i }) {
        let o2 = nm.nextId(), s2 = fl(n2.length), a2 = n2.map((l2, u2) => {
          if (l2?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c2 = i?.isolationLevel, p2 = { kind: "batch", id: o2, index: u2, isolationLevel: c2, lock: s2 };
          return l2.requestTransaction?.(p2) ?? l2;
        });
        return Sl(a2);
      }
      async _transactionWithCallback({ callback: n2, options: i }) {
        let o2 = { traceparent: this._tracingHelper.getTraceParent() }, s2 = await this._engine.transaction("start", o2, i), a2;
        try {
          let l2 = { kind: "itx", ...s2 };
          a2 = await n2(this._createItxClient(l2)), await this._engine.transaction("commit", o2, s2);
        } catch (l2) {
          throw await this._engine.transaction("rollback", o2, s2).catch(() => {
          }), l2;
        }
        return a2;
      }
      _createItxClient(n2) {
        return zt(Ee(on(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n2)), re("_createPrismaPromise", () => Hi(n2)), re(rm, () => n2.id), Gt(zi)]));
      }
      $transaction(n2, i) {
        let o2;
        typeof n2 == "function" ? o2 = () => this._transactionWithCallback({ callback: n2, options: i }) : o2 = () => this._transactionWithArray({ promises: n2, options: i });
        let s2 = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s2, o2);
      }
      _request(n2) {
        n2.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n2.middlewareArgsMapper ?? tm, o2 = { args: i.requestArgsToMiddlewareArgs(n2.args), dataPath: n2.dataPath, runInTransaction: !!n2.transaction, action: n2.action, model: n2.model }, s2 = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o2.action, model: o2.model, name: o2.model ? `${o2.model}.${o2.action}` : o2.action } } }, a2 = -1, l2 = async (u2) => {
          let c2 = this._middlewares.get(++a2);
          if (c2)
            return this._tracingHelper.runInChildSpan(s2.middleware, (P) => c2(u2, (T) => (P?.end(), l2(T))));
          let { runInTransaction: p2, args: d2, ...f } = u2, y2 = { ...n2, ...f };
          d2 && (y2.args = i.middlewareArgsToRequestArgs(d2)), n2.transaction !== undefined && p2 === false && delete y2.transaction;
          let g = await ua(this, y2);
          return y2.model ? oa({ result: g, modelName: y2.model, args: y2.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : g;
        };
        return this._tracingHelper.runInChildSpan(s2.operation, () => new kl.AsyncResource("prisma-client-request").runInAsyncScope(() => l2(o2)));
      }
      async _executeRequest({ args: n2, clientMethod: i, dataPath: o2, callsite: s2, action: a2, model: l2, argsMapper: u2, transaction: c2, unpacker: p2, otelParentCtx: d2, customDataProxyFetch: f }) {
        try {
          n2 = u2 ? u2(n2) : n2;
          let y2 = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(y2, () => el({ modelName: l2, runtimeDataModel: this._runtimeDataModel, action: a2, args: n2, clientMethod: i, callsite: s2, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return D.enabled("prisma:client") && (Ue("Prisma Client call:"), Ue(`prisma.${i}(${$s(n2)})`), Ue("Generated request:"), Ue(JSON.stringify(g, null, 2) + `
`)), c2?.kind === "batch" && await c2.lock, this._requestHandler.request({ protocolQuery: g, modelName: l2, action: a2, clientMethod: i, dataPath: o2, callsite: s2, args: n2, extensions: this._extensions, transaction: c2, unpacker: p2, otelParentCtx: d2, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (y2) {
          throw y2.clientVersion = this._clientVersion, y2;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new X("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n2) {
        return !!this._engineConfig.previewFeatures?.includes(n2);
      }
    }
    return t2;
  };
  var Il = function(e2, t2) {
    return im(e2) ? [new oe(e2, t2), ul] : [e2, cl];
  };
  var im = function(e2) {
    return Array.isArray(e2) && Array.isArray(e2.raw);
  };
  var _l = function(e2) {
    return new Proxy(e2, { get(t2, r) {
      if (r in t2)
        return t2[r];
      if (!om.has(r))
        throw new TypeError(`Invalid enum value: ${String(r)}`);
    } });
  };
  var Nl = function(e2) {
    _t(e2, { conflictCheck: "warn" });
  };
  var Ll = Object.create;
  var Mt = Object.defineProperty;
  var $l = Object.getOwnPropertyDescriptor;
  var ql = Object.getOwnPropertyNames;
  var Vl = Object.getPrototypeOf;
  var jl = Object.prototype.hasOwnProperty;
  var Bl = (e2, t2, r) => (t2 in e2) ? Mt(e2, t2, { enumerable: true, configurable: true, writable: true, value: r }) : e2[t2] = r;
  var V = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
  var St = (e2, t2) => {
    for (var r in t2)
      Mt(e2, r, { get: t2[r], enumerable: true });
  };
  var Xi = (e2, t2, r, n2) => {
    if (t2 && typeof t2 == "object" || typeof t2 == "function")
      for (let i of ql(t2))
        !jl.call(e2, i) && i !== r && Mt(e2, i, { get: () => t2[i], enumerable: !(n2 = $l(t2, i)) || n2.enumerable });
    return e2;
  };
  var S2 = (e2, t2, r) => (r = e2 != null ? Ll(Vl(e2)) : {}, Xi(t2 || !e2 || !e2.__esModule ? Mt(r, "default", { value: e2, enumerable: true }) : r, e2));
  var Ul = (e2) => Xi(Mt({}, "__esModule", { value: true }), e2);
  var eo = (e2, t2, r) => (Bl(e2, typeof t2 != "symbol" ? t2 + "" : t2, r), r);
  var co = V((xm, uo) => {
    var rt = 1000, nt = rt * 60, it = nt * 60, Qe = it * 24, Kl = Qe * 7, Ql = Qe * 365.25;
    uo.exports = function(e2, t2) {
      t2 = t2 || {};
      var r = typeof e2;
      if (r === "string" && e2.length > 0)
        return Gl(e2);
      if (r === "number" && isFinite(e2))
        return t2.long ? Hl(e2) : Jl(e2);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
    };
    function Gl(e2) {
      if (e2 = String(e2), !(e2.length > 100)) {
        var t2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
        if (t2) {
          var r = parseFloat(t2[1]), n2 = (t2[2] || "ms").toLowerCase();
          switch (n2) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return r * Ql;
            case "weeks":
            case "week":
            case "w":
              return r * Kl;
            case "days":
            case "day":
            case "d":
              return r * Qe;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return r * it;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return r * nt;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return r * rt;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return r;
            default:
              return;
          }
        }
      }
    }
    function Jl(e2) {
      var t2 = Math.abs(e2);
      return t2 >= Qe ? Math.round(e2 / Qe) + "d" : t2 >= it ? Math.round(e2 / it) + "h" : t2 >= nt ? Math.round(e2 / nt) + "m" : t2 >= rt ? Math.round(e2 / rt) + "s" : e2 + "ms";
    }
    function Hl(e2) {
      var t2 = Math.abs(e2);
      return t2 >= Qe ? br(e2, t2, Qe, "day") : t2 >= it ? br(e2, t2, it, "hour") : t2 >= nt ? br(e2, t2, nt, "minute") : t2 >= rt ? br(e2, t2, rt, "second") : e2 + " ms";
    }
    function br(e2, t2, r, n2) {
      var i = t2 >= r * 1.5;
      return Math.round(e2 / r) + " " + n2 + (i ? "s" : "");
    }
  });
  var kn = V((bm, po) => {
    function Wl(e2) {
      r.debug = r, r.default = r, r.coerce = l2, r.disable = o2, r.enable = i, r.enabled = s2, r.humanize = co(), r.destroy = u2, Object.keys(e2).forEach((c2) => {
        r[c2] = e2[c2];
      }), r.names = [], r.skips = [], r.formatters = {};
      function t2(c2) {
        let p2 = 0;
        for (let d2 = 0;d2 < c2.length; d2++)
          p2 = (p2 << 5) - p2 + c2.charCodeAt(d2), p2 |= 0;
        return r.colors[Math.abs(p2) % r.colors.length];
      }
      r.selectColor = t2;
      function r(c2) {
        let p2, d2 = null, f, y2;
        function g(...P) {
          if (!g.enabled)
            return;
          let T = g, C = Number(new Date), x = C - (p2 || C);
          T.diff = x, T.prev = p2, T.curr = C, p2 = C, P[0] = r.coerce(P[0]), typeof P[0] != "string" && P.unshift("%O");
          let R = 0;
          P[0] = P[0].replace(/%([a-zA-Z%])/g, (J, Ke) => {
            if (J === "%%")
              return "%";
            R++;
            let $ = r.formatters[Ke];
            if (typeof $ == "function") {
              let z = P[R];
              J = $.call(T, z), P.splice(R, 1), R--;
            }
            return J;
          }), r.formatArgs.call(T, P), (T.log || r.log).apply(T, P);
        }
        return g.namespace = c2, g.useColors = r.useColors(), g.color = r.selectColor(c2), g.extend = n2, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: true, configurable: false, get: () => d2 !== null ? d2 : (f !== r.namespaces && (f = r.namespaces, y2 = r.enabled(c2)), y2), set: (P) => {
          d2 = P;
        } }), typeof r.init == "function" && r.init(g), g;
      }
      function n2(c2, p2) {
        let d2 = r(this.namespace + (typeof p2 > "u" ? ":" : p2) + c2);
        return d2.log = this.log, d2;
      }
      function i(c2) {
        r.save(c2), r.namespaces = c2, r.names = [], r.skips = [];
        let p2, d2 = (typeof c2 == "string" ? c2 : "").split(/[\s,]+/), f = d2.length;
        for (p2 = 0;p2 < f; p2++)
          d2[p2] && (c2 = d2[p2].replace(/\*/g, ".*?"), c2[0] === "-" ? r.skips.push(new RegExp("^" + c2.slice(1) + "$")) : r.names.push(new RegExp("^" + c2 + "$")));
      }
      function o2() {
        let c2 = [...r.names.map(a2), ...r.skips.map(a2).map((p2) => "-" + p2)].join(",");
        return r.enable(""), c2;
      }
      function s2(c2) {
        if (c2[c2.length - 1] === "*")
          return true;
        let p2, d2;
        for (p2 = 0, d2 = r.skips.length;p2 < d2; p2++)
          if (r.skips[p2].test(c2))
            return false;
        for (p2 = 0, d2 = r.names.length;p2 < d2; p2++)
          if (r.names[p2].test(c2))
            return true;
        return false;
      }
      function a2(c2) {
        return c2.toString().substring(2, c2.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function l2(c2) {
        return c2 instanceof Error ? c2.stack || c2.message : c2;
      }
      function u2() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return r.enable(r.load()), r;
    }
    po.exports = Wl;
  });
  var mo = V((le, Er) => {
    le.formatArgs = Yl;
    le.save = Zl;
    le.load = Xl;
    le.useColors = zl;
    le.storage = eu();
    le.destroy = (() => {
      let e2 = false;
      return () => {
        e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    le.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function zl() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function Yl(e2) {
      if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + Er.exports.humanize(this.diff), !this.useColors)
        return;
      let t2 = "color: " + this.color;
      e2.splice(1, 0, t2, "color: inherit");
      let r = 0, n2 = 0;
      e2[0].replace(/%[a-zA-Z%]/g, (i) => {
        i !== "%%" && (r++, i === "%c" && (n2 = r));
      }), e2.splice(n2, 0, t2);
    }
    le.log = console.debug || console.log || (() => {
    });
    function Zl(e2) {
      try {
        e2 ? le.storage.setItem("debug", e2) : le.storage.removeItem("debug");
      } catch {
      }
    }
    function Xl() {
      let e2;
      try {
        e2 = le.storage.getItem("debug");
      } catch {
      }
      return !e2 && typeof process < "u" && ("env" in process) && (e2 = process.env.DEBUG), e2;
    }
    function eu() {
      try {
        return localStorage;
      } catch {
      }
    }
    Er.exports = kn()(le);
    var { formatters: tu } = Er.exports;
    tu.j = function(e2) {
      try {
        return JSON.stringify(e2);
      } catch (t2) {
        return "[UnexpectedJSONParseError]: " + t2.message;
      }
    };
  });
  var Fn = V((Em, fo) => {
    fo.exports = (e2, t2 = process.argv) => {
      let r = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", n2 = t2.indexOf(r + e2), i = t2.indexOf("--");
      return n2 !== -1 && (i === -1 || n2 < i);
    };
  });
  var _n = V((wm, yo) => {
    var ru = import.meta.require("os"), go = import.meta.require("tty"), de = Fn(), { env: B } = process, ke;
    de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? ke = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (ke = 1);
    ("FORCE_COLOR" in B) && (B.FORCE_COLOR === "true" ? ke = 1 : B.FORCE_COLOR === "false" ? ke = 0 : ke = B.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(B.FORCE_COLOR, 10), 3));
    function On(e2) {
      return e2 === 0 ? false : { level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3 };
    }
    function Dn(e2, t2) {
      if (ke === 0)
        return 0;
      if (de("color=16m") || de("color=full") || de("color=truecolor"))
        return 3;
      if (de("color=256"))
        return 2;
      if (e2 && !t2 && ke === undefined)
        return 0;
      let r = ke || 0;
      if (B.TERM === "dumb")
        return r;
      if (process.platform === "win32") {
        let n2 = ru.release().split(".");
        return Number(n2[0]) >= 10 && Number(n2[2]) >= 10586 ? Number(n2[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in B)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n2) => (n2 in B)) || B.CI_NAME === "codeship" ? 1 : r;
      if ("TEAMCITY_VERSION" in B)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(B.TEAMCITY_VERSION) ? 1 : 0;
      if (B.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in B) {
        let n2 = parseInt((B.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (B.TERM_PROGRAM) {
          case "iTerm.app":
            return n2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(B.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(B.TERM) || ("COLORTERM" in B) ? 1 : r;
    }
    function nu(e2) {
      let t2 = Dn(e2, e2 && e2.isTTY);
      return On(t2);
    }
    yo.exports = { supportsColor: nu, stdout: On(Dn(true, go.isatty(1))), stderr: On(Dn(true, go.isatty(2))) };
  });
  var xo = V((H2, Pr) => {
    var iu = import.meta.require("tty"), wr = import.meta.require("util");
    H2.init = pu;
    H2.log = lu;
    H2.formatArgs = su;
    H2.save = uu;
    H2.load = cu;
    H2.useColors = ou;
    H2.destroy = wr.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    H2.colors = [6, 2, 3, 4, 5, 1];
    try {
      let e2 = _n();
      e2 && (e2.stderr || e2).level >= 2 && (H2.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    H2.inspectOpts = Object.keys(process.env).filter((e2) => /^debug_/i.test(e2)).reduce((e2, t2) => {
      let r = t2.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o2) => o2.toUpperCase()), n2 = process.env[t2];
      return /^(yes|on|true|enabled)$/i.test(n2) ? n2 = true : /^(no|off|false|disabled)$/i.test(n2) ? n2 = false : n2 === "null" ? n2 = null : n2 = Number(n2), e2[r] = n2, e2;
    }, {});
    function ou() {
      return "colors" in H2.inspectOpts ? !!H2.inspectOpts.colors : iu.isatty(process.stderr.fd);
    }
    function su(e2) {
      let { namespace: t2, useColors: r } = this;
      if (r) {
        let n2 = this.color, i = "\x1B[3" + (n2 < 8 ? n2 : "8;5;" + n2), o2 = `  ${i};1m${t2} \x1B[0m`;
        e2[0] = o2 + e2[0].split(`
`).join(`
` + o2), e2.push(i + "m+" + Pr.exports.humanize(this.diff) + "\x1B[0m");
      } else
        e2[0] = au() + t2 + " " + e2[0];
    }
    function au() {
      return H2.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }
    function lu(...e2) {
      return process.stderr.write(wr.format(...e2) + `
`);
    }
    function uu(e2) {
      e2 ? process.env.DEBUG = e2 : delete process.env.DEBUG;
    }
    function cu() {
      return process.env.DEBUG;
    }
    function pu(e2) {
      e2.inspectOpts = {};
      let t2 = Object.keys(H2.inspectOpts);
      for (let r = 0;r < t2.length; r++)
        e2.inspectOpts[t2[r]] = H2.inspectOpts[t2[r]];
    }
    Pr.exports = kn()(H2);
    var { formatters: ho } = Pr.exports;
    ho.o = function(e2) {
      return this.inspectOpts.colors = this.useColors, wr.inspect(e2, this.inspectOpts).split(`
`).map((t2) => t2.trim()).join(" ");
    };
    ho.O = function(e2) {
      return this.inspectOpts.colors = this.useColors, wr.inspect(e2, this.inspectOpts);
    };
  });
  var Ln = V((Pm, Nn) => {
    typeof process > "u" || process.type === "renderer" || false || process.__nwjs ? Nn.exports = mo() : Nn.exports = xo();
  });
  var So = V((ef, Un) => {
    var A = Un.exports;
    Un.exports.default = A;
    var I = "\x1B[", kt = "\x1B]", at = "\x07", Rr = ";", Mo = false;
    A.cursorTo = (e2, t2) => {
      if (typeof e2 != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t2 != "number" ? I + (e2 + 1) + "G" : I + (t2 + 1) + ";" + (e2 + 1) + "H";
    };
    A.cursorMove = (e2, t2) => {
      if (typeof e2 != "number")
        throw new TypeError("The `x` argument is required");
      let r = "";
      return e2 < 0 ? r += I + -e2 + "D" : e2 > 0 && (r += I + e2 + "C"), t2 < 0 ? r += I + -t2 + "A" : t2 > 0 && (r += I + t2 + "B"), r;
    };
    A.cursorUp = (e2 = 1) => I + e2 + "A";
    A.cursorDown = (e2 = 1) => I + e2 + "B";
    A.cursorForward = (e2 = 1) => I + e2 + "C";
    A.cursorBackward = (e2 = 1) => I + e2 + "D";
    A.cursorLeft = I + "G";
    A.cursorSavePosition = Mo ? "\x1B7" : I + "s";
    A.cursorRestorePosition = Mo ? "\x1B8" : I + "u";
    A.cursorGetPosition = I + "6n";
    A.cursorNextLine = I + "E";
    A.cursorPrevLine = I + "F";
    A.cursorHide = I + "?25l";
    A.cursorShow = I + "?25h";
    A.eraseLines = (e2) => {
      let t2 = "";
      for (let r = 0;r < e2; r++)
        t2 += A.eraseLine + (r < e2 - 1 ? A.cursorUp() : "");
      return e2 && (t2 += A.cursorLeft), t2;
    };
    A.eraseEndLine = I + "K";
    A.eraseStartLine = I + "1K";
    A.eraseLine = I + "2K";
    A.eraseDown = I + "J";
    A.eraseUp = I + "1J";
    A.eraseScreen = I + "2J";
    A.scrollUp = I + "S";
    A.scrollDown = I + "T";
    A.clearScreen = "\x1Bc";
    A.clearTerminal = process.platform === "win32" ? `${A.eraseScreen}${I}0f` : `${A.eraseScreen}${I}3J${I}H`;
    A.beep = at;
    A.link = (e2, t2) => [kt, "8", Rr, Rr, t2, at, e2, kt, "8", Rr, Rr, at].join("");
    A.image = (e2, t2 = {}) => {
      let r = `${kt}1337;File=inline=1`;
      return t2.width && (r += `;width=${t2.width}`), t2.height && (r += `;height=${t2.height}`), t2.preserveAspectRatio === false && (r += ";preserveAspectRatio=0"), r + ":" + e2.toString("base64") + at;
    };
    A.iTerm = { setCwd: (e2 = process.cwd()) => `${kt}50;CurrentDir=${e2}${at}`, annotation: (e2, t2 = {}) => {
      let r = `${kt}1337;`, n2 = typeof t2.x < "u", i = typeof t2.y < "u";
      if ((n2 || i) && !(n2 && i && typeof t2.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e2 = e2.replace(/\|/g, ""), r += t2.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t2.length > 0 ? r += (n2 ? [e2, t2.length, t2.x, t2.y] : [t2.length, e2]).join("|") : r += e2, r + at;
    } };
  });
  var Fo = V((tf, ko) => {
    var hu = _n(), lt = Fn();
    function Io(e2) {
      if (/^\d{3,4}$/.test(e2)) {
        let r = /(\d{1,2})(\d{2})/.exec(e2);
        return { major: 0, minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) };
      }
      let t2 = (e2 || "").split(".").map((r) => parseInt(r, 10));
      return { major: t2[0], minor: t2[1], patch: t2[2] };
    }
    function Kn(e2) {
      let { env: t2 } = process;
      if ("FORCE_HYPERLINK" in t2)
        return !(t2.FORCE_HYPERLINK.length > 0 && parseInt(t2.FORCE_HYPERLINK, 10) === 0);
      if (lt("no-hyperlink") || lt("no-hyperlinks") || lt("hyperlink=false") || lt("hyperlink=never"))
        return false;
      if (lt("hyperlink=true") || lt("hyperlink=always") || ("NETLIFY" in t2))
        return true;
      if (!hu.supportsColor(e2) || e2 && !e2.isTTY || process.platform === "win32" || ("CI" in t2) || ("TEAMCITY_VERSION" in t2))
        return false;
      if ("TERM_PROGRAM" in t2) {
        let r = Io(t2.TERM_PROGRAM_VERSION);
        switch (t2.TERM_PROGRAM) {
          case "iTerm.app":
            return r.major === 3 ? r.minor >= 1 : r.major > 3;
          case "WezTerm":
            return r.major >= 20200620;
          case "vscode":
            return r.major > 1 || r.major === 1 && r.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t2) {
        if (t2.VTE_VERSION === "0.50.0")
          return false;
        let r = Io(t2.VTE_VERSION);
        return r.major > 0 || r.minor >= 50;
      }
      return false;
    }
    ko.exports = { supportsHyperlink: Kn, stdout: Kn(process.stdout), stderr: Kn(process.stderr) };
  });
  var Do = V((rf, Ft) => {
    var xu = So(), Qn = Fo(), Oo = (e2, t2, { target: r = "stdout", ...n2 } = {}) => Qn[r] ? xu.link(e2, t2) : n2.fallback === false ? e2 : typeof n2.fallback == "function" ? n2.fallback(e2, t2) : `${e2} (\u200B${t2}\u200B)`;
    Ft.exports = (e2, t2, r = {}) => Oo(e2, t2, r);
    Ft.exports.stderr = (e2, t2, r = {}) => Oo(e2, t2, { target: "stderr", ...r });
    Ft.exports.isSupported = Qn.stdout;
    Ft.exports.stderr.isSupported = Qn.stderr;
  });
  var Ko = V((wf, Ou) => {
    Ou.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Go = V((Pf, Fr) => {
    var Du = import.meta.require("fs"), Qo = import.meta.require("path"), _u = import.meta.require("os"), Nu = Ko(), Lu = Nu.version, $u = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function qu(e2) {
      let t2 = {}, r = e2.toString();
      r = r.replace(/\r\n?/mg, `
`);
      let n2;
      for (;(n2 = $u.exec(r)) != null; ) {
        let i = n2[1], o2 = n2[2] || "";
        o2 = o2.trim();
        let s2 = o2[0];
        o2 = o2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s2 === '"' && (o2 = o2.replace(/\\n/g, `
`), o2 = o2.replace(/\\r/g, "\r")), t2[i] = o2;
      }
      return t2;
    }
    function Wn(e2) {
      console.log(`[dotenv@${Lu}][DEBUG] ${e2}`);
    }
    function Vu(e2) {
      return e2[0] === "~" ? Qo.join(_u.homedir(), e2.slice(1)) : e2;
    }
    function ju(e2) {
      let t2 = Qo.resolve(process.cwd(), ".env"), r = "utf8", n2 = !!(e2 && e2.debug), i = !!(e2 && e2.override);
      e2 && (e2.path != null && (t2 = Vu(e2.path)), e2.encoding != null && (r = e2.encoding));
      try {
        let o2 = kr.parse(Du.readFileSync(t2, { encoding: r }));
        return Object.keys(o2).forEach(function(s2) {
          Object.prototype.hasOwnProperty.call(process.env, s2) ? (i === true && (process.env[s2] = o2[s2]), n2 && Wn(i === true ? `"${s2}" is already defined in \`process.env\` and WAS overwritten` : `"${s2}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s2] = o2[s2];
        }), { parsed: o2 };
      } catch (o2) {
        return n2 && Wn(`Failed to load ${t2} ${o2.message}`), { error: o2 };
      }
    }
    var kr = { config: ju, parse: qu };
    Fr.exports.config = kr.config;
    Fr.exports.parse = kr.parse;
    Fr.exports = kr;
  });
  var Zo = V((Sf, Yo) => {
    Yo.exports = (e2) => {
      let t2 = e2.match(/^[ \t]*(?=\S)/gm);
      return t2 ? t2.reduce((r, n2) => Math.min(r, n2.length), 1 / 0) : 0;
    };
  });
  var es = V((If, Xo) => {
    var Qu = Zo();
    Xo.exports = (e2) => {
      let t2 = Qu(e2);
      if (t2 === 0)
        return e2;
      let r = new RegExp(`^[ \\t]{${t2}}`, "gm");
      return e2.replace(r, "");
    };
  });
  var ts = V((kf, Gu) => {
    Gu.exports = { name: "@prisma/engines-version", version: "5.4.1-2.ac9d7041ed77bcc8a8dbd2ab6616b39013829574", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.18.4", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var Xn = V((Dr) => {
    Object.defineProperty(Dr, "__esModule", { value: true });
    Dr.enginesVersion = undefined;
    Dr.enginesVersion = ts().prisma.enginesVersion;
  });
  var ii = V((Kf, is) => {
    is.exports = (e2, t2 = 1, r) => {
      if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e2 != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e2}\``);
      if (typeof t2 != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t2}\``);
      if (typeof r.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
      if (t2 === 0)
        return e2;
      let n2 = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e2.replace(n2, r.indent.repeat(t2));
    };
  });
  var ls = V((Jf, as) => {
    as.exports = ({ onlyFirst: e2 = false } = {}) => {
      let t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t2, e2 ? undefined : "g");
    };
  });
  var li = V((Hf, us) => {
    var rc = ls();
    us.exports = (e2) => typeof e2 == "string" ? e2.replace(rc(), "") : e2;
  });
  var cs = V((Yf, Nr) => {
    Nr.exports = (e2 = {}) => {
      let t2;
      if (e2.repoUrl)
        t2 = e2.repoUrl;
      else if (e2.user && e2.repo)
        t2 = `https://github.com/${e2.user}/${e2.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r = new URL(`${t2}/issues/new`), n2 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n2) {
        let o2 = e2[i];
        if (o2 !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o2))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o2 = o2.join(",");
          }
          r.searchParams.set(i, o2);
        }
      }
      return r.toString();
    };
    Nr.exports.default = Nr.exports;
  });
  var Ui = V((CP, Ka) => {
    Ka.exports = function() {
      function e2(t2, r, n2, i, o2) {
        return t2 < r || n2 < r ? t2 > n2 ? n2 + 1 : t2 + 1 : i === o2 ? r : r + 1;
      }
      return function(t2, r) {
        if (t2 === r)
          return 0;
        if (t2.length > r.length) {
          var n2 = t2;
          t2 = r, r = n2;
        }
        for (var i = t2.length, o2 = r.length;i > 0 && t2.charCodeAt(i - 1) === r.charCodeAt(o2 - 1); )
          i--, o2--;
        for (var s2 = 0;s2 < i && t2.charCodeAt(s2) === r.charCodeAt(s2); )
          s2++;
        if (i -= s2, o2 -= s2, i === 0 || o2 < 3)
          return o2;
        var a2 = 0, l2, u2, c2, p2, d2, f, y2, g, P, T, C, x, R = [];
        for (l2 = 0;l2 < i; l2++)
          R.push(l2 + 1), R.push(t2.charCodeAt(s2 + l2));
        for (var ce = R.length - 1;a2 < o2 - 3; )
          for (P = r.charCodeAt(s2 + (u2 = a2)), T = r.charCodeAt(s2 + (c2 = a2 + 1)), C = r.charCodeAt(s2 + (p2 = a2 + 2)), x = r.charCodeAt(s2 + (d2 = a2 + 3)), f = a2 += 4, l2 = 0;l2 < ce; l2 += 2)
            y2 = R[l2], g = R[l2 + 1], u2 = e2(y2, u2, c2, P, g), c2 = e2(u2, c2, p2, T, g), p2 = e2(c2, p2, d2, C, g), f = e2(p2, d2, f, x, g), R[l2] = f, d2 = p2, p2 = c2, c2 = u2, u2 = y2;
        for (;a2 < o2; )
          for (P = r.charCodeAt(s2 + (u2 = a2)), f = ++a2, l2 = 0;l2 < ce; l2 += 2)
            y2 = R[l2], R[l2] = f = e2(y2, u2, f, P, R[l2 + 1]), u2 = y2;
        return f;
      };
    }();
  });
  var sm = {};
  St(sm, { DMMF: () => pe, DMMFClass: () => xr, Debug: () => $n, Decimal: () => Pe, Extensions: () => Rn, MetricsClient: () => dt, NotFoundError: () => Re, ObjectEnumValue: () => xe, PrismaClientInitializationError: () => F, PrismaClientKnownRequestError: () => U, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => K, PrismaClientValidationError: () => X, Public: () => Mn, Sql: () => oe, Types: () => Sn, defineDmmfProperty: () => ms, empty: () => ys, getPrismaClient: () => Dl, itxClientDenyList: () => zi, join: () => gs, makeStrictEnum: () => _l, objectEnumNames: () => ic, objectEnumValues: () => $r, raw: () => gi, sqltag: () => yi, warnEnvConflicts: () => Nl, warnOnce: () => qt });
  module.exports = Ul(sm);
  var Rn = {};
  St(Rn, { defineExtension: () => to, getExtensionContext: () => ro });
  var Mn = {};
  St(Mn, { validator: () => no });
  var Sn = {};
  St(Sn, { Extensions: () => io, Public: () => oo, Result: () => so, Utils: () => ao });
  var io = {};
  var oo = {};
  var so = {};
  var ao = {};
  var Ie = (e2, t2) => {
    let r = {};
    for (let n2 of e2) {
      let i = n2[t2];
      r[i] = n2;
    }
    return r;
  };
  var xr = class {
    constructor(t2) {
      this.document = t2;
      this.compositeNames = new Set(this.datamodel.types.map((r) => r.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
    }
    get datamodel() {
      return this.document.datamodel;
    }
    get mappings() {
      return this.document.mappings;
    }
    get schema() {
      return this.document.schema;
    }
    get inputObjectTypes() {
      return this.schema.inputObjectTypes;
    }
    get outputObjectTypes() {
      return this.schema.outputObjectTypes;
    }
    isComposite(t2) {
      return this.compositeNames.has(t2);
    }
    getOtherOperationNames() {
      return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
    }
    hasEnumInNamespace(t2, r) {
      return this.schema.enumTypes[r]?.find((n2) => n2.name === t2) !== undefined;
    }
    resolveInputObjectType(t2) {
      return this.inputTypesByName.get(In(t2.type, t2.namespace));
    }
    resolveOutputObjectType(t2) {
      if (t2.location === "outputObjectTypes")
        return this.outputObjectTypes[t2.namespace ?? "prisma"].find((r) => r.name === t2.type);
    }
    buildModelMap() {
      return Ie(this.datamodel.models, "name");
    }
    buildTypeMap() {
      return Ie(this.datamodel.types, "name");
    }
    buildTypeModelMap() {
      return { ...this.buildTypeMap(), ...this.buildModelMap() };
    }
    buildMappingsMap() {
      return Ie(this.mappings.modelOperations, "model");
    }
    buildMergedOutputTypeMap() {
      return { model: Ie(this.schema.outputObjectTypes.model, "name"), prisma: Ie(this.schema.outputObjectTypes.prisma, "name") };
    }
    buildRootFieldMap() {
      return { ...Ie(this.outputTypeMap.prisma.Query.fields, "name"), ...Ie(this.outputTypeMap.prisma.Mutation.fields, "name") };
    }
    buildInputTypesMap() {
      let t2 = new Map;
      for (let r of this.inputObjectTypes.prisma)
        t2.set(In(r.name, "prisma"), r);
      if (!this.inputObjectTypes.model)
        return t2;
      for (let r of this.inputObjectTypes.model)
        t2.set(In(r.name, "model"), r);
      return t2;
    }
  };
  var pe;
  ((t2) => {
    let e2;
    ((x) => (x.findUnique = "findUnique", x.findUniqueOrThrow = "findUniqueOrThrow", x.findFirst = "findFirst", x.findFirstOrThrow = "findFirstOrThrow", x.findMany = "findMany", x.create = "create", x.createMany = "createMany", x.update = "update", x.updateMany = "updateMany", x.upsert = "upsert", x.delete = "delete", x.deleteMany = "deleteMany", x.groupBy = "groupBy", x.count = "count", x.aggregate = "aggregate", x.findRaw = "findRaw", x.aggregateRaw = "aggregateRaw"))(e2 = t2.ModelAction || (t2.ModelAction = {}));
  })(pe || (pe = {}));
  var vr = S2(Ln());
  var du = 100;
  var It = [];
  typeof process < "u" && typeof process.stderr?.write != "function" && (vr.default.log = console.debug ?? console.log);
  var $n = Object.assign(mu, vr.default);
  var D = $n;
  var qn;
  var wo;
  var Po;
  var vo;
  var To = true;
  typeof process < "u" && ({ FORCE_COLOR: qn, NODE_DISABLE_COLORS: wo, NO_COLOR: Po, TERM: vo } = process.env || {}, To = process.stdout && process.stdout.isTTY);
  var fu = { enabled: !wo && Po == null && vo !== "dumb" && (qn != null && qn !== "0" || To) };
  var Tm = _(0, 0);
  var ne = _(1, 22);
  var Fe = _(2, 22);
  var Cm = _(3, 23);
  var te = _(4, 24);
  var Am = _(7, 27);
  var Rm = _(8, 28);
  var Mm = _(9, 29);
  var Sm = _(30, 39);
  var me = _(31, 39);
  var Ge = _(32, 39);
  var he = _(33, 39);
  var ot = _(34, 39);
  var Im = _(35, 39);
  var Oe = _(36, 39);
  var km = _(37, 39);
  var Tr = _(90, 39);
  var Fm = _(90, 39);
  var Om = _(40, 49);
  var Dm = _(41, 49);
  var _m = _(42, 49);
  var Nm = _(43, 49);
  var Lm = _(44, 49);
  var $m = _(45, 49);
  var qm = _(46, 49);
  var Vm = _(47, 49);
  var Co = S2(import.meta.require("fs"));
  var Cr = "libquery_engine";
  var $o = S2(import.meta.require("child_process"));
  var Gn = S2(import.meta.require("fs/promises"));
  var Sr = S2(import.meta.require("os"));
  var Ar = Symbol("@ts-pattern/matcher");
  var Ao = "@ts-pattern/anonymous-select-key";
  var Ro = function(e2) {
    return !!(e2 && typeof e2 == "object");
  };
  var Bn = function(e2) {
    return e2 && !!e2[Ar];
  };
  var gu = function e(t2, r, n2) {
    if (Ro(t2)) {
      if (Bn(t2)) {
        var i = t2[Ar]().match(r), o2 = i.matched, s2 = i.selections;
        return o2 && s2 && Object.keys(s2).forEach(function(l2) {
          return n2(l2, s2[l2]);
        }), o2;
      }
      if (!Ro(r))
        return false;
      if (Array.isArray(t2))
        return !!Array.isArray(r) && t2.length === r.length && t2.every(function(l2, u2) {
          return e(l2, r[u2], n2);
        });
      if (t2 instanceof Map)
        return r instanceof Map && Array.from(t2.keys()).every(function(l2) {
          return e(t2.get(l2), r.get(l2), n2);
        });
      if (t2 instanceof Set) {
        if (!(r instanceof Set))
          return false;
        if (t2.size === 0)
          return r.size === 0;
        if (t2.size === 1) {
          var a2 = Array.from(t2.values())[0];
          return Bn(a2) ? Array.from(r.values()).every(function(l2) {
            return e(a2, l2, n2);
          }) : r.has(a2);
        }
        return Array.from(t2.values()).every(function(l2) {
          return r.has(l2);
        });
      }
      return Object.keys(t2).every(function(l2) {
        var u2, c2 = t2[l2];
        return ((l2 in r) || Bn(u2 = c2) && u2[Ar]().matcherType === "optional") && e(c2, r[l2], n2);
      });
    }
    return Object.is(r, t2);
  };
  var Gm = Je(function(e2) {
    return true;
  });
  var Jm = Je(function(e2) {
    return typeof e2 == "string";
  });
  var Hm = Je(function(e2) {
    return typeof e2 == "number";
  });
  var Wm = Je(function(e2) {
    return typeof e2 == "boolean";
  });
  var zm = Je(function(e2) {
    return typeof e2 == "bigint";
  });
  var Ym = Je(function(e2) {
    return typeof e2 == "symbol";
  });
  var Zm = Je(function(e2) {
    return e2 == null;
  });
  var yu = function() {
    function e2(r, n2) {
      this.value = undefined, this.cases = undefined, this.value = r, this.cases = n2;
    }
    var t2 = e2.prototype;
    return t2.with = function() {
      var r = [].slice.call(arguments), n2 = r[r.length - 1], i = [r[0]], o2 = [];
      return r.length === 3 && typeof r[1] == "function" ? (i.push(r[0]), o2.push(r[1])) : r.length > 2 && i.push.apply(i, r.slice(1, r.length - 1)), new e2(this.value, this.cases.concat([{ match: function(s2) {
        var a2 = {}, l2 = !!(i.some(function(u2) {
          return gu(u2, s2, function(c2, p2) {
            a2[c2] = p2;
          });
        }) && o2.every(function(u2) {
          return u2(s2);
        }));
        return { matched: l2, value: l2 && Object.keys(a2).length ? Ao in a2 ? a2[Ao] : a2 : s2 };
      }, handler: n2 }]));
    }, t2.when = function(r, n2) {
      return new e2(this.value, this.cases.concat([{ match: function(i) {
        return { matched: !!r(i), value: i };
      }, handler: n2 }]));
    }, t2.otherwise = function(r) {
      return new e2(this.value, this.cases.concat([{ match: function(n2) {
        return { matched: true, value: n2 };
      }, handler: r }])).run();
    }, t2.exhaustive = function() {
      return this.run();
    }, t2.run = function() {
      for (var r = this.value, n2 = undefined, i = 0;i < this.cases.length; i++) {
        var o2 = this.cases[i], s2 = o2.match(this.value);
        if (s2.matched) {
          r = s2.value, n2 = o2.handler;
          break;
        }
      }
      if (!n2) {
        var a2;
        try {
          a2 = JSON.stringify(this.value);
        } catch {
          a2 = this.value;
        }
        throw new Error("Pattern matching error: no pattern matches value " + a2);
      }
      return n2(r, this.value);
    }, e2;
  }();
  var qo = import.meta.require("util");
  var _o = S2(Do());
  var bu = { warn: he("prisma:warn") };
  var Eu = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var wu = (0, qo.promisify)($o.default.exec);
  var ie = D("prisma:get-platform");
  var Pu = ["1.0.x", "1.1.x", "3.0.x"];
  var Mr = {};
  var Hn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "openbsd", "netbsd", "arm"];
  var Yn = S2(Go());
  var Or2 = S2(import.meta.require("fs"));
  var ct = S2(import.meta.require("path"));
  var zn = D("prisma:tryLoadEnv");
  var zo = "library";
  var Ju = S2(Xn());
  var N = S2(import.meta.require("path"));
  var Hu = S2(Xn());
  var Df = D("prisma:engines");
  N.default.join(import.meta.dir, "../query-engine-darwin");
  N.default.join(import.meta.dir, "../query-engine-darwin-arm64");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-1.0.x");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-1.1.x");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-3.0.x");
  N.default.join(import.meta.dir, "../query-engine-linux-static-x64");
  N.default.join(import.meta.dir, "../query-engine-linux-static-arm64");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-1.0.x");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-1.1.x");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-3.0.x");
  N.default.join(import.meta.dir, "../libquery_engine-darwin.dylib.node");
  N.default.join(import.meta.dir, "../libquery_engine-darwin-arm64.dylib.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-musl.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../query_engine-windows.dll.node");
  var ei = S2(import.meta.require("fs"));
  var ns = D("chmodPlusX");
  var Nt = S2(import.meta.require("path"));
  var os = S2(ii());
  var oi = class {
    constructor(t2) {
      this.config = t2;
    }
    toString() {
      let { config: t2 } = this, r = t2.provider.fromEnvVar ? `env("${t2.provider.fromEnvVar}")` : t2.provider.value, n2 = JSON.parse(JSON.stringify({ provider: r, binaryTargets: Wu(t2.binaryTargets) }));
      return `generator ${t2.name} {
${(0, os.default)(zu(n2), 2)}
}`;
    }
  };
  var $t = {};
  St($t, { error: () => ec, info: () => Xu, log: () => Zu, query: () => tc, should: () => ss, tags: () => Lt, warn: () => ai });
  var Lt = { error: me("prisma:error"), warn: he("prisma:warn"), info: Oe("prisma:info"), query: ot("prisma:query") };
  var ss = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var ci = (e2, t2) => e2.reduce((r, n2) => (r[t2(n2)] = n2, r), {});
  var ps = new Set;
  var qt = (e2, t2, ...r) => {
    ps.has(e2) || (ps.add(e2), ai(t2, ...r));
  };
  var U = class extends Error {
    constructor(r, { code: n2, clientVersion: i, meta: o2, batchRequestIdx: s2 }) {
      super(r);
      this.name = "PrismaClientKnownRequestError", this.code = n2, this.clientVersion = i, this.meta = o2, Object.defineProperty(this, "batchRequestIdx", { value: s2, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  E(U, "PrismaClientKnownRequestError");
  var Re = class extends U {
    constructor(t2, r) {
      super(t2, { code: "P2025", clientVersion: r }), this.name = "NotFoundError";
    }
  };
  E(Re, "NotFoundError");
  var F = class e2 extends Error {
    constructor(r, n2, i) {
      super(r);
      this.name = "PrismaClientInitializationError", this.clientVersion = n2, this.errorCode = i, Error.captureStackTrace(e2);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  E(F, "PrismaClientInitializationError");
  var ue = class extends Error {
    constructor(r, n2) {
      super(r);
      this.name = "PrismaClientRustPanicError", this.clientVersion = n2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  E(ue, "PrismaClientRustPanicError");
  var K = class extends Error {
    constructor(r, { clientVersion: n2, batchRequestIdx: i }) {
      super(r);
      this.name = "PrismaClientUnknownRequestError", this.clientVersion = n2, Object.defineProperty(this, "batchRequestIdx", { value: i, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  E(K, "PrismaClientUnknownRequestError");
  var X = class extends Error {
    constructor(r, { clientVersion: n2 }) {
      super(r);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  E(X, "PrismaClientValidationError");
  var dt = class {
    constructor(t2) {
      this._engine = t2;
    }
    prometheus(t2) {
      return this._engine.metrics({ format: "prometheus", ...t2 });
    }
    json(t2) {
      return this._engine.metrics({ format: "json", ...t2 });
    }
  };
  var ic = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
  var Lr = Symbol();
  var mi = new WeakMap;
  var xe = class {
    constructor(t2) {
      t2 === Lr ? mi.set(this, `Prisma.${this._getName()}`) : mi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return mi.get(this);
    }
  };
  var jt = class extends xe {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var Bt = class extends jt {
  };
  fi(Bt, "DbNull");
  var Ut = class extends jt {
  };
  fi(Ut, "JsonNull");
  var Kt = class extends jt {
  };
  fi(Kt, "AnyNull");
  var $r = { classes: { DbNull: Bt, JsonNull: Ut, AnyNull: Kt }, instances: { DbNull: new Bt(Lr), JsonNull: new Ut(Lr), AnyNull: new Kt(Lr) } };
  var lc = S2(Ln(), 1);
  var oc = class {
    constructor() {
      eo(this, "registeredErrors", []);
    }
    consumeError(e2) {
      return this.registeredErrors[e2];
    }
    registerNewError(e2) {
      let t2 = 0;
      for (;this.registeredErrors[t2] !== undefined; )
        t2++;
      return this.registeredErrors[t2] = { error: e2 }, t2;
    }
  };
  var fs = (e2) => {
    let t2 = new oc, r = De(t2, e2.startTransaction.bind(e2));
    return { errorRegistry: t2, queryRaw: De(t2, e2.queryRaw.bind(e2)), executeRaw: De(t2, e2.executeRaw.bind(e2)), flavour: e2.flavour, startTransaction: async (...n2) => (await r(...n2)).map((o2) => sc(t2, o2)), close: De(t2, e2.close.bind(e2)) };
  };
  var sc = (e2, t2) => ({ flavour: t2.flavour, options: t2.options, queryRaw: De(e2, t2.queryRaw.bind(t2)), executeRaw: De(e2, t2.executeRaw.bind(t2)), commit: De(e2, t2.commit.bind(t2)), rollback: De(e2, t2.rollback.bind(t2)), dispose: ac(e2, t2.dispose.bind(t2)) });
  var kl = import.meta.require("async_hooks");
  var Fl = import.meta.require("events");
  var Ol = S2(import.meta.require("fs"));
  var yr = S2(import.meta.require("path"));
  var oe = class e2 {
    constructor(t2, r) {
      if (t2.length - 1 !== r.length)
        throw t2.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t2.length} strings to have ${t2.length - 1} values`);
      let n2 = r.reduce((s2, a2) => s2 + (a2 instanceof e2 ? a2.values.length : 1), 0);
      this.values = new Array(n2), this.strings = new Array(n2 + 1), this.strings[0] = t2[0];
      let i = 0, o2 = 0;
      for (;i < r.length; ) {
        let s2 = r[i++], a2 = t2[i];
        if (s2 instanceof e2) {
          this.strings[o2] += s2.strings[0];
          let l2 = 0;
          for (;l2 < s2.values.length; )
            this.values[o2++] = s2.values[l2++], this.strings[o2] = s2.strings[l2];
          this.strings[o2] += a2;
        } else
          this.values[o2++] = s2, this.strings[o2] = a2;
      }
    }
    get text() {
      let t2 = 1, r = this.strings[0];
      for (;t2 < this.strings.length; )
        r += `\$${t2}${this.strings[t2++]}`;
      return r;
    }
    get sql() {
      let t2 = 1, r = this.strings[0];
      for (;t2 < this.strings.length; )
        r += `?${this.strings[t2++]}`;
      return r;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var ys = gi("");
  var be = class {
    constructor() {
      this._map = new Map;
    }
    get(t2) {
      return this._map.get(t2)?.value;
    }
    set(t2, r) {
      this._map.set(t2, { value: r });
    }
    getOrCreate(t2, r) {
      let n2 = this._map.get(t2);
      if (n2)
        return n2.value;
      let i = r();
      return this.set(t2, i), i;
    }
  };
  var bs = import.meta.require("util");
  var Vr = { enumerable: true, configurable: true, writable: true };
  var hs = Symbol.for("nodejs.util.inspect.custom");
  var mt = class {
    constructor(t2 = 0, r) {
      this.context = r;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t2;
    }
    write(t2) {
      return typeof t2 == "string" ? this.currentLine += t2 : t2.write(this), this;
    }
    writeJoined(t2, r) {
      let n2 = r.length - 1;
      for (let i = 0;i < r.length; i++)
        this.write(r[i]), i !== n2 && this.write(t2);
      return this;
    }
    writeLine(t2) {
      return this.write(t2).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t2 = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t2?.(), this;
    }
    withIndent(t2) {
      return this.indent(), t2(this), this.unindent(), this;
    }
    afterNextNewline(t2) {
      return this.afterNextNewLineCallback = t2, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t2) {
      return this.marginSymbol = t2, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t2 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t2.slice(1) : t2;
    }
  };
  var gt = 9000000000000000;
  var $e = 1e9;
  var hi = "0123456789abcdef";
  var Kr = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var Qr = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var xi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -gt, maxE: gt, crypto: false };
  var vs;
  var Me;
  var w2 = true;
  var Jr = "[DecimalError] ";
  var Le = Jr + "Invalid argument: ";
  var Ts = Jr + "Precision limit exceeded";
  var Cs = Jr + "crypto unavailable";
  var As = "[object Decimal]";
  var ee = Math.floor;
  var j = Math.pow;
  var cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var pc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var dc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Rs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var ge = 1e7;
  var b2 = 7;
  var mc = 9007199254740991;
  var fc = Kr.length - 1;
  var bi = Qr.length - 1;
  var m2 = { toStringTag: As };
  m2.absoluteValue = m2.abs = function() {
    var e2 = new this.constructor(this);
    return e2.s < 0 && (e2.s = 1), h2(e2);
  };
  m2.ceil = function() {
    return h2(new this.constructor(this), this.e + 1, 2);
  };
  m2.clampedTo = m2.clamp = function(e2, t2) {
    var r, n2 = this, i = n2.constructor;
    if (e2 = new i(e2), t2 = new i(t2), !e2.s || !t2.s)
      return new i(NaN);
    if (e2.gt(t2))
      throw Error(Le + t2);
    return r = n2.cmp(e2), r < 0 ? e2 : n2.cmp(t2) > 0 ? t2 : new i(n2);
  };
  m2.comparedTo = m2.cmp = function(e2) {
    var t2, r, n2, i, o2 = this, s2 = o2.d, a2 = (e2 = new o2.constructor(e2)).d, l2 = o2.s, u2 = e2.s;
    if (!s2 || !a2)
      return !l2 || !u2 ? NaN : l2 !== u2 ? l2 : s2 === a2 ? 0 : !s2 ^ l2 < 0 ? 1 : -1;
    if (!s2[0] || !a2[0])
      return s2[0] ? l2 : a2[0] ? -u2 : 0;
    if (l2 !== u2)
      return l2;
    if (o2.e !== e2.e)
      return o2.e > e2.e ^ l2 < 0 ? 1 : -1;
    for (n2 = s2.length, i = a2.length, t2 = 0, r = n2 < i ? n2 : i;t2 < r; ++t2)
      if (s2[t2] !== a2[t2])
        return s2[t2] > a2[t2] ^ l2 < 0 ? 1 : -1;
    return n2 === i ? 0 : n2 > i ^ l2 < 0 ? 1 : -1;
  };
  m2.cosine = m2.cos = function() {
    var e2, t2, r = this, n2 = r.constructor;
    return r.d ? r.d[0] ? (e2 = n2.precision, t2 = n2.rounding, n2.precision = e2 + Math.max(r.e, r.sd()) + b2, n2.rounding = 1, r = gc(n2, Fs(n2, r)), n2.precision = e2, n2.rounding = t2, h2(Me == 2 || Me == 3 ? r.neg() : r, e2, t2, true)) : new n2(1) : new n2(NaN);
  };
  m2.cubeRoot = m2.cbrt = function() {
    var e2, t2, r, n2, i, o2, s2, a2, l2, u2, c2 = this, p2 = c2.constructor;
    if (!c2.isFinite() || c2.isZero())
      return new p2(c2);
    for (w2 = false, o2 = c2.s * j(c2.s * c2, 1 / 3), !o2 || Math.abs(o2) == 1 / 0 ? (r = W(c2.d), e2 = c2.e, (o2 = (e2 - r.length + 1) % 3) && (r += o2 == 1 || o2 == -2 ? "0" : "00"), o2 = j(r, 1 / 3), e2 = ee((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2)), o2 == 1 / 0 ? r = "5e" + e2 : (r = o2.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e2), n2 = new p2(r), n2.s = c2.s) : n2 = new p2(o2.toString()), s2 = (e2 = p2.precision) + 3;; )
      if (a2 = n2, l2 = a2.times(a2).times(a2), u2 = l2.plus(c2), n2 = O(u2.plus(c2).times(a2), u2.plus(l2), s2 + 2, 1), W(a2.d).slice(0, s2) === (r = W(n2.d)).slice(0, s2))
        if (r = r.slice(s2 - 3, s2 + 1), r == "9999" || !i && r == "4999") {
          if (!i && (h2(a2, e2 + 1, 0), a2.times(a2).times(a2).eq(c2))) {
            n2 = a2;
            break;
          }
          s2 += 4, i = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (h2(n2, e2 + 1, 1), t2 = !n2.times(n2).times(n2).eq(c2));
          break;
        }
    return w2 = true, h2(n2, e2, p2.rounding, t2);
  };
  m2.decimalPlaces = m2.dp = function() {
    var e2, t2 = this.d, r = NaN;
    if (t2) {
      if (e2 = t2.length - 1, r = (e2 - ee(this.e / b2)) * b2, e2 = t2[e2], e2)
        for (;e2 % 10 == 0; e2 /= 10)
          r--;
      r < 0 && (r = 0);
    }
    return r;
  };
  m2.dividedBy = m2.div = function(e2) {
    return O(this, new this.constructor(e2));
  };
  m2.dividedToIntegerBy = m2.divToInt = function(e2) {
    var t2 = this, r = t2.constructor;
    return h2(O(t2, new r(e2), 0, 1, 1), r.precision, r.rounding);
  };
  m2.equals = m2.eq = function(e2) {
    return this.cmp(e2) === 0;
  };
  m2.floor = function() {
    return h2(new this.constructor(this), this.e + 1, 3);
  };
  m2.greaterThan = m2.gt = function(e2) {
    return this.cmp(e2) > 0;
  };
  m2.greaterThanOrEqualTo = m2.gte = function(e2) {
    var t2 = this.cmp(e2);
    return t2 == 1 || t2 === 0;
  };
  m2.hyperbolicCosine = m2.cosh = function() {
    var e2, t2, r, n2, i, o2 = this, s2 = o2.constructor, a2 = new s2(1);
    if (!o2.isFinite())
      return new s2(o2.s ? 1 / 0 : NaN);
    if (o2.isZero())
      return a2;
    r = s2.precision, n2 = s2.rounding, s2.precision = r + Math.max(o2.e, o2.sd()) + 4, s2.rounding = 1, i = o2.d.length, i < 32 ? (e2 = Math.ceil(i / 3), t2 = (1 / Wr(4, e2)).toString()) : (e2 = 16, t2 = "2.3283064365386962890625e-10"), o2 = yt(s2, 1, o2.times(t2), new s2(1), true);
    for (var l2, u2 = e2, c2 = new s2(8);u2--; )
      l2 = o2.times(o2), o2 = a2.minus(l2.times(c2.minus(l2.times(c2))));
    return h2(o2, s2.precision = r, s2.rounding = n2, true);
  };
  m2.hyperbolicSine = m2.sinh = function() {
    var e2, t2, r, n2, i = this, o2 = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o2(i);
    if (t2 = o2.precision, r = o2.rounding, o2.precision = t2 + Math.max(i.e, i.sd()) + 4, o2.rounding = 1, n2 = i.d.length, n2 < 3)
      i = yt(o2, 2, i, i, true);
    else {
      e2 = 1.4 * Math.sqrt(n2), e2 = e2 > 16 ? 16 : e2 | 0, i = i.times(1 / Wr(5, e2)), i = yt(o2, 2, i, i, true);
      for (var s2, a2 = new o2(5), l2 = new o2(16), u2 = new o2(20);e2--; )
        s2 = i.times(i), i = i.times(a2.plus(s2.times(l2.times(s2).plus(u2))));
    }
    return o2.precision = t2, o2.rounding = r, h2(i, t2, r, true);
  };
  m2.hyperbolicTangent = m2.tanh = function() {
    var e2, t2, r = this, n2 = r.constructor;
    return r.isFinite() ? r.isZero() ? new n2(r) : (e2 = n2.precision, t2 = n2.rounding, n2.precision = e2 + 7, n2.rounding = 1, O(r.sinh(), r.cosh(), n2.precision = e2, n2.rounding = t2)) : new n2(r.s);
  };
  m2.inverseCosine = m2.acos = function() {
    var e2, t2 = this, r = t2.constructor, n2 = t2.abs().cmp(1), i = r.precision, o2 = r.rounding;
    return n2 !== -1 ? n2 === 0 ? t2.isNeg() ? fe(r, i, o2) : new r(0) : new r(NaN) : t2.isZero() ? fe(r, i + 4, o2).times(0.5) : (r.precision = i + 6, r.rounding = 1, t2 = t2.asin(), e2 = fe(r, i + 4, o2).times(0.5), r.precision = i, r.rounding = o2, e2.minus(t2));
  };
  m2.inverseHyperbolicCosine = m2.acosh = function() {
    var e2, t2, r = this, n2 = r.constructor;
    return r.lte(1) ? new n2(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e2 = n2.precision, t2 = n2.rounding, n2.precision = e2 + Math.max(Math.abs(r.e), r.sd()) + 4, n2.rounding = 1, w2 = false, r = r.times(r).minus(1).sqrt().plus(r), w2 = true, n2.precision = e2, n2.rounding = t2, r.ln()) : new n2(r);
  };
  m2.inverseHyperbolicSine = m2.asinh = function() {
    var e2, t2, r = this, n2 = r.constructor;
    return !r.isFinite() || r.isZero() ? new n2(r) : (e2 = n2.precision, t2 = n2.rounding, n2.precision = e2 + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n2.rounding = 1, w2 = false, r = r.times(r).plus(1).sqrt().plus(r), w2 = true, n2.precision = e2, n2.rounding = t2, r.ln());
  };
  m2.inverseHyperbolicTangent = m2.atanh = function() {
    var e2, t2, r, n2, i = this, o2 = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o2(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e2 = o2.precision, t2 = o2.rounding, n2 = i.sd(), Math.max(n2, e2) < 2 * -i.e - 1 ? h2(new o2(i), e2, t2, true) : (o2.precision = r = n2 - i.e, i = O(i.plus(1), new o2(1).minus(i), r + e2, 1), o2.precision = e2 + 4, o2.rounding = 1, i = i.ln(), o2.precision = e2, o2.rounding = t2, i.times(0.5))) : new o2(NaN);
  };
  m2.inverseSine = m2.asin = function() {
    var e2, t2, r, n2, i = this, o2 = i.constructor;
    return i.isZero() ? new o2(i) : (t2 = i.abs().cmp(1), r = o2.precision, n2 = o2.rounding, t2 !== -1 ? t2 === 0 ? (e2 = fe(o2, r + 4, n2).times(0.5), e2.s = i.s, e2) : new o2(NaN) : (o2.precision = r + 6, o2.rounding = 1, i = i.div(new o2(1).minus(i.times(i)).sqrt().plus(1)).atan(), o2.precision = r, o2.rounding = n2, i.times(2)));
  };
  m2.inverseTangent = m2.atan = function() {
    var e2, t2, r, n2, i, o2, s2, a2, l2, u2 = this, c2 = u2.constructor, p2 = c2.precision, d2 = c2.rounding;
    if (u2.isFinite()) {
      if (u2.isZero())
        return new c2(u2);
      if (u2.abs().eq(1) && p2 + 4 <= bi)
        return s2 = fe(c2, p2 + 4, d2).times(0.25), s2.s = u2.s, s2;
    } else {
      if (!u2.s)
        return new c2(NaN);
      if (p2 + 4 <= bi)
        return s2 = fe(c2, p2 + 4, d2).times(0.5), s2.s = u2.s, s2;
    }
    for (c2.precision = a2 = p2 + 10, c2.rounding = 1, r = Math.min(28, a2 / b2 + 2 | 0), e2 = r;e2; --e2)
      u2 = u2.div(u2.times(u2).plus(1).sqrt().plus(1));
    for (w2 = false, t2 = Math.ceil(a2 / b2), n2 = 1, l2 = u2.times(u2), s2 = new c2(u2), i = u2;e2 !== -1; )
      if (i = i.times(l2), o2 = s2.minus(i.div(n2 += 2)), i = i.times(l2), s2 = o2.plus(i.div(n2 += 2)), s2.d[t2] !== undefined)
        for (e2 = t2;s2.d[e2] === o2.d[e2] && e2--; )
          ;
    return r && (s2 = s2.times(2 << r - 1)), w2 = true, h2(s2, c2.precision = p2, c2.rounding = d2, true);
  };
  m2.isFinite = function() {
    return !!this.d;
  };
  m2.isInteger = m2.isInt = function() {
    return !!this.d && ee(this.e / b2) > this.d.length - 2;
  };
  m2.isNaN = function() {
    return !this.s;
  };
  m2.isNegative = m2.isNeg = function() {
    return this.s < 0;
  };
  m2.isPositive = m2.isPos = function() {
    return this.s > 0;
  };
  m2.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m2.lessThan = m2.lt = function(e2) {
    return this.cmp(e2) < 0;
  };
  m2.lessThanOrEqualTo = m2.lte = function(e2) {
    return this.cmp(e2) < 1;
  };
  m2.logarithm = m2.log = function(e2) {
    var t2, r, n2, i, o2, s2, a2, l2, u2 = this, c2 = u2.constructor, p2 = c2.precision, d2 = c2.rounding, f = 5;
    if (e2 == null)
      e2 = new c2(10), t2 = true;
    else {
      if (e2 = new c2(e2), r = e2.d, e2.s < 0 || !r || !r[0] || e2.eq(1))
        return new c2(NaN);
      t2 = e2.eq(10);
    }
    if (r = u2.d, u2.s < 0 || !r || !r[0] || u2.eq(1))
      return new c2(r && !r[0] ? -1 / 0 : u2.s != 1 ? NaN : r ? 0 : 1 / 0);
    if (t2)
      if (r.length > 1)
        o2 = true;
      else {
        for (i = r[0];i % 10 === 0; )
          i /= 10;
        o2 = i !== 1;
      }
    if (w2 = false, a2 = p2 + f, s2 = Ne(u2, a2), n2 = t2 ? Gr(c2, a2 + 10) : Ne(e2, a2), l2 = O(s2, n2, a2, 1), Jt(l2.d, i = p2, d2))
      do
        if (a2 += 10, s2 = Ne(u2, a2), n2 = t2 ? Gr(c2, a2 + 10) : Ne(e2, a2), l2 = O(s2, n2, a2, 1), !o2) {
          +W(l2.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l2 = h2(l2, p2 + 1, 0));
          break;
        }
      while (Jt(l2.d, i += 10, d2));
    return w2 = true, h2(l2, p2, d2);
  };
  m2.minus = m2.sub = function(e2) {
    var t2, r, n2, i, o2, s2, a2, l2, u2, c2, p2, d2, f = this, y2 = f.constructor;
    if (e2 = new y2(e2), !f.d || !e2.d)
      return !f.s || !e2.s ? e2 = new y2(NaN) : f.d ? e2.s = -e2.s : e2 = new y2(e2.d || f.s !== e2.s ? f : NaN), e2;
    if (f.s != e2.s)
      return e2.s = -e2.s, f.plus(e2);
    if (u2 = f.d, d2 = e2.d, a2 = y2.precision, l2 = y2.rounding, !u2[0] || !d2[0]) {
      if (d2[0])
        e2.s = -e2.s;
      else if (u2[0])
        e2 = new y2(f);
      else
        return new y2(l2 === 3 ? -0 : 0);
      return w2 ? h2(e2, a2, l2) : e2;
    }
    if (r = ee(e2.e / b2), c2 = ee(f.e / b2), u2 = u2.slice(), o2 = c2 - r, o2) {
      for (p2 = o2 < 0, p2 ? (t2 = u2, o2 = -o2, s2 = d2.length) : (t2 = d2, r = c2, s2 = u2.length), n2 = Math.max(Math.ceil(a2 / b2), s2) + 2, o2 > n2 && (o2 = n2, t2.length = 1), t2.reverse(), n2 = o2;n2--; )
        t2.push(0);
      t2.reverse();
    } else {
      for (n2 = u2.length, s2 = d2.length, p2 = n2 < s2, p2 && (s2 = n2), n2 = 0;n2 < s2; n2++)
        if (u2[n2] != d2[n2]) {
          p2 = u2[n2] < d2[n2];
          break;
        }
      o2 = 0;
    }
    for (p2 && (t2 = u2, u2 = d2, d2 = t2, e2.s = -e2.s), s2 = u2.length, n2 = d2.length - s2;n2 > 0; --n2)
      u2[s2++] = 0;
    for (n2 = d2.length;n2 > o2; ) {
      if (u2[--n2] < d2[n2]) {
        for (i = n2;i && u2[--i] === 0; )
          u2[i] = ge - 1;
        --u2[i], u2[n2] += ge;
      }
      u2[n2] -= d2[n2];
    }
    for (;u2[--s2] === 0; )
      u2.pop();
    for (;u2[0] === 0; u2.shift())
      --r;
    return u2[0] ? (e2.d = u2, e2.e = Hr(u2, r), w2 ? h2(e2, a2, l2) : e2) : new y2(l2 === 3 ? -0 : 0);
  };
  m2.modulo = m2.mod = function(e2) {
    var t2, r = this, n2 = r.constructor;
    return e2 = new n2(e2), !r.d || !e2.s || e2.d && !e2.d[0] ? new n2(NaN) : !e2.d || r.d && !r.d[0] ? h2(new n2(r), n2.precision, n2.rounding) : (w2 = false, n2.modulo == 9 ? (t2 = O(r, e2.abs(), 0, 3, 1), t2.s *= e2.s) : t2 = O(r, e2, 0, n2.modulo, 1), t2 = t2.times(e2), w2 = true, r.minus(t2));
  };
  m2.naturalExponential = m2.exp = function() {
    return Ei(this);
  };
  m2.naturalLogarithm = m2.ln = function() {
    return Ne(this);
  };
  m2.negated = m2.neg = function() {
    var e2 = new this.constructor(this);
    return e2.s = -e2.s, h2(e2);
  };
  m2.plus = m2.add = function(e2) {
    var t2, r, n2, i, o2, s2, a2, l2, u2, c2, p2 = this, d2 = p2.constructor;
    if (e2 = new d2(e2), !p2.d || !e2.d)
      return !p2.s || !e2.s ? e2 = new d2(NaN) : p2.d || (e2 = new d2(e2.d || p2.s === e2.s ? p2 : NaN)), e2;
    if (p2.s != e2.s)
      return e2.s = -e2.s, p2.minus(e2);
    if (u2 = p2.d, c2 = e2.d, a2 = d2.precision, l2 = d2.rounding, !u2[0] || !c2[0])
      return c2[0] || (e2 = new d2(p2)), w2 ? h2(e2, a2, l2) : e2;
    if (o2 = ee(p2.e / b2), n2 = ee(e2.e / b2), u2 = u2.slice(), i = o2 - n2, i) {
      for (i < 0 ? (r = u2, i = -i, s2 = c2.length) : (r = c2, n2 = o2, s2 = u2.length), o2 = Math.ceil(a2 / b2), s2 = o2 > s2 ? o2 + 1 : s2 + 1, i > s2 && (i = s2, r.length = 1), r.reverse();i--; )
        r.push(0);
      r.reverse();
    }
    for (s2 = u2.length, i = c2.length, s2 - i < 0 && (i = s2, r = c2, c2 = u2, u2 = r), t2 = 0;i; )
      t2 = (u2[--i] = u2[i] + c2[i] + t2) / ge | 0, u2[i] %= ge;
    for (t2 && (u2.unshift(t2), ++n2), s2 = u2.length;u2[--s2] == 0; )
      u2.pop();
    return e2.d = u2, e2.e = Hr(u2, n2), w2 ? h2(e2, a2, l2) : e2;
  };
  m2.precision = m2.sd = function(e2) {
    var t2, r = this;
    if (e2 !== undefined && e2 !== !!e2 && e2 !== 1 && e2 !== 0)
      throw Error(Le + e2);
    return r.d ? (t2 = Ms(r.d), e2 && r.e + 1 > t2 && (t2 = r.e + 1)) : t2 = NaN, t2;
  };
  m2.round = function() {
    var e2 = this, t2 = e2.constructor;
    return h2(new t2(e2), e2.e + 1, t2.rounding);
  };
  m2.sine = m2.sin = function() {
    var e2, t2, r = this, n2 = r.constructor;
    return r.isFinite() ? r.isZero() ? new n2(r) : (e2 = n2.precision, t2 = n2.rounding, n2.precision = e2 + Math.max(r.e, r.sd()) + b2, n2.rounding = 1, r = hc(n2, Fs(n2, r)), n2.precision = e2, n2.rounding = t2, h2(Me > 2 ? r.neg() : r, e2, t2, true)) : new n2(NaN);
  };
  m2.squareRoot = m2.sqrt = function() {
    var e2, t2, r, n2, i, o2, s2 = this, a2 = s2.d, l2 = s2.e, u2 = s2.s, c2 = s2.constructor;
    if (u2 !== 1 || !a2 || !a2[0])
      return new c2(!u2 || u2 < 0 && (!a2 || a2[0]) ? NaN : a2 ? s2 : 1 / 0);
    for (w2 = false, u2 = Math.sqrt(+s2), u2 == 0 || u2 == 1 / 0 ? (t2 = W(a2), (t2.length + l2) % 2 == 0 && (t2 += "0"), u2 = Math.sqrt(t2), l2 = ee((l2 + 1) / 2) - (l2 < 0 || l2 % 2), u2 == 1 / 0 ? t2 = "5e" + l2 : (t2 = u2.toExponential(), t2 = t2.slice(0, t2.indexOf("e") + 1) + l2), n2 = new c2(t2)) : n2 = new c2(u2.toString()), r = (l2 = c2.precision) + 3;; )
      if (o2 = n2, n2 = o2.plus(O(s2, o2, r + 2, 1)).times(0.5), W(o2.d).slice(0, r) === (t2 = W(n2.d)).slice(0, r))
        if (t2 = t2.slice(r - 3, r + 1), t2 == "9999" || !i && t2 == "4999") {
          if (!i && (h2(o2, l2 + 1, 0), o2.times(o2).eq(s2))) {
            n2 = o2;
            break;
          }
          r += 4, i = 1;
        } else {
          (!+t2 || !+t2.slice(1) && t2.charAt(0) == "5") && (h2(n2, l2 + 1, 1), e2 = !n2.times(n2).eq(s2));
          break;
        }
    return w2 = true, h2(n2, l2, c2.rounding, e2);
  };
  m2.tangent = m2.tan = function() {
    var e2, t2, r = this, n2 = r.constructor;
    return r.isFinite() ? r.isZero() ? new n2(r) : (e2 = n2.precision, t2 = n2.rounding, n2.precision = e2 + 10, n2.rounding = 1, r = r.sin(), r.s = 1, r = O(r, new n2(1).minus(r.times(r)).sqrt(), e2 + 10, 0), n2.precision = e2, n2.rounding = t2, h2(Me == 2 || Me == 4 ? r.neg() : r, e2, t2, true)) : new n2(NaN);
  };
  m2.times = m2.mul = function(e2) {
    var t2, r, n2, i, o2, s2, a2, l2, u2, c2 = this, p2 = c2.constructor, d2 = c2.d, f = (e2 = new p2(e2)).d;
    if (e2.s *= c2.s, !d2 || !d2[0] || !f || !f[0])
      return new p2(!e2.s || d2 && !d2[0] && !f || f && !f[0] && !d2 ? NaN : !d2 || !f ? e2.s / 0 : e2.s * 0);
    for (r = ee(c2.e / b2) + ee(e2.e / b2), l2 = d2.length, u2 = f.length, l2 < u2 && (o2 = d2, d2 = f, f = o2, s2 = l2, l2 = u2, u2 = s2), o2 = [], s2 = l2 + u2, n2 = s2;n2--; )
      o2.push(0);
    for (n2 = u2;--n2 >= 0; ) {
      for (t2 = 0, i = l2 + n2;i > n2; )
        a2 = o2[i] + f[n2] * d2[i - n2 - 1] + t2, o2[i--] = a2 % ge | 0, t2 = a2 / ge | 0;
      o2[i] = (o2[i] + t2) % ge | 0;
    }
    for (;!o2[--s2]; )
      o2.pop();
    return t2 ? ++r : o2.shift(), e2.d = o2, e2.e = Hr(o2, r), w2 ? h2(e2, p2.precision, p2.rounding) : e2;
  };
  m2.toBinary = function(e2, t2) {
    return Pi(this, 2, e2, t2);
  };
  m2.toDecimalPlaces = m2.toDP = function(e2, t2) {
    var r = this, n2 = r.constructor;
    return r = new n2(r), e2 === undefined ? r : (se(e2, 0, $e), t2 === undefined ? t2 = n2.rounding : se(t2, 0, 8), h2(r, e2 + r.e + 1, t2));
  };
  m2.toExponential = function(e2, t2) {
    var r, n2 = this, i = n2.constructor;
    return e2 === undefined ? r = we(n2, true) : (se(e2, 0, $e), t2 === undefined ? t2 = i.rounding : se(t2, 0, 8), n2 = h2(new i(n2), e2 + 1, t2), r = we(n2, true, e2 + 1)), n2.isNeg() && !n2.isZero() ? "-" + r : r;
  };
  m2.toFixed = function(e2, t2) {
    var r, n2, i = this, o2 = i.constructor;
    return e2 === undefined ? r = we(i) : (se(e2, 0, $e), t2 === undefined ? t2 = o2.rounding : se(t2, 0, 8), n2 = h2(new o2(i), e2 + i.e + 1, t2), r = we(n2, false, e2 + n2.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
  };
  m2.toFraction = function(e2) {
    var t2, r, n2, i, o2, s2, a2, l2, u2, c2, p2, d2, f = this, y2 = f.d, g = f.constructor;
    if (!y2)
      return new g(f);
    if (u2 = r = new g(1), n2 = l2 = new g(0), t2 = new g(n2), o2 = t2.e = Ms(y2) - f.e - 1, s2 = o2 % b2, t2.d[0] = j(10, s2 < 0 ? b2 + s2 : s2), e2 == null)
      e2 = o2 > 0 ? t2 : u2;
    else {
      if (a2 = new g(e2), !a2.isInt() || a2.lt(u2))
        throw Error(Le + a2);
      e2 = a2.gt(t2) ? o2 > 0 ? t2 : u2 : a2;
    }
    for (w2 = false, a2 = new g(W(y2)), c2 = g.precision, g.precision = o2 = y2.length * b2 * 2;p2 = O(a2, t2, 0, 1, 1), i = r.plus(p2.times(n2)), i.cmp(e2) != 1; )
      r = n2, n2 = i, i = u2, u2 = l2.plus(p2.times(i)), l2 = i, i = t2, t2 = a2.minus(p2.times(i)), a2 = i;
    return i = O(e2.minus(r), n2, 0, 1, 1), l2 = l2.plus(i.times(u2)), r = r.plus(i.times(n2)), l2.s = u2.s = f.s, d2 = O(u2, n2, o2, 1).minus(f).abs().cmp(O(l2, r, o2, 1).minus(f).abs()) < 1 ? [u2, n2] : [l2, r], g.precision = c2, w2 = true, d2;
  };
  m2.toHexadecimal = m2.toHex = function(e2, t2) {
    return Pi(this, 16, e2, t2);
  };
  m2.toNearest = function(e2, t2) {
    var r = this, n2 = r.constructor;
    if (r = new n2(r), e2 == null) {
      if (!r.d)
        return r;
      e2 = new n2(1), t2 = n2.rounding;
    } else {
      if (e2 = new n2(e2), t2 === undefined ? t2 = n2.rounding : se(t2, 0, 8), !r.d)
        return e2.s ? r : e2;
      if (!e2.d)
        return e2.s && (e2.s = r.s), e2;
    }
    return e2.d[0] ? (w2 = false, r = O(r, e2, 0, t2, 1).times(e2), w2 = true, h2(r)) : (e2.s = r.s, r = e2), r;
  };
  m2.toNumber = function() {
    return +this;
  };
  m2.toOctal = function(e2, t2) {
    return Pi(this, 8, e2, t2);
  };
  m2.toPower = m2.pow = function(e2) {
    var t2, r, n2, i, o2, s2, a2 = this, l2 = a2.constructor, u2 = +(e2 = new l2(e2));
    if (!a2.d || !e2.d || !a2.d[0] || !e2.d[0])
      return new l2(j(+a2, u2));
    if (a2 = new l2(a2), a2.eq(1))
      return a2;
    if (n2 = l2.precision, o2 = l2.rounding, e2.eq(1))
      return h2(a2, n2, o2);
    if (t2 = ee(e2.e / b2), t2 >= e2.d.length - 1 && (r = u2 < 0 ? -u2 : u2) <= mc)
      return i = Ss(l2, a2, r, n2), e2.s < 0 ? new l2(1).div(i) : h2(i, n2, o2);
    if (s2 = a2.s, s2 < 0) {
      if (t2 < e2.d.length - 1)
        return new l2(NaN);
      if (e2.d[t2] & 1 || (s2 = 1), a2.e == 0 && a2.d[0] == 1 && a2.d.length == 1)
        return a2.s = s2, a2;
    }
    return r = j(+a2, u2), t2 = r == 0 || !isFinite(r) ? ee(u2 * (Math.log("0." + W(a2.d)) / Math.LN10 + a2.e + 1)) : new l2(r + "").e, t2 > l2.maxE + 1 || t2 < l2.minE - 1 ? new l2(t2 > 0 ? s2 / 0 : 0) : (w2 = false, l2.rounding = a2.s = 1, r = Math.min(12, (t2 + "").length), i = Ei(e2.times(Ne(a2, n2 + r)), n2), i.d && (i = h2(i, n2 + 5, 1), Jt(i.d, n2, o2) && (t2 = n2 + 10, i = h2(Ei(e2.times(Ne(a2, t2 + r)), t2), t2 + 5, 1), +W(i.d).slice(n2 + 1, n2 + 15) + 1 == 100000000000000 && (i = h2(i, n2 + 1, 0)))), i.s = s2, w2 = true, l2.rounding = o2, h2(i, n2, o2));
  };
  m2.toPrecision = function(e2, t2) {
    var r, n2 = this, i = n2.constructor;
    return e2 === undefined ? r = we(n2, n2.e <= i.toExpNeg || n2.e >= i.toExpPos) : (se(e2, 1, $e), t2 === undefined ? t2 = i.rounding : se(t2, 0, 8), n2 = h2(new i(n2), e2, t2), r = we(n2, e2 <= n2.e || n2.e <= i.toExpNeg, e2)), n2.isNeg() && !n2.isZero() ? "-" + r : r;
  };
  m2.toSignificantDigits = m2.toSD = function(e2, t2) {
    var r = this, n2 = r.constructor;
    return e2 === undefined ? (e2 = n2.precision, t2 = n2.rounding) : (se(e2, 1, $e), t2 === undefined ? t2 = n2.rounding : se(t2, 0, 8)), h2(new n2(r), e2, t2);
  };
  m2.toString = function() {
    var e2 = this, t2 = e2.constructor, r = we(e2, e2.e <= t2.toExpNeg || e2.e >= t2.toExpPos);
    return e2.isNeg() && !e2.isZero() ? "-" + r : r;
  };
  m2.truncated = m2.trunc = function() {
    return h2(new this.constructor(this), this.e + 1, 1);
  };
  m2.valueOf = m2.toJSON = function() {
    var e2 = this, t2 = e2.constructor, r = we(e2, e2.e <= t2.toExpNeg || e2.e >= t2.toExpPos);
    return e2.isNeg() ? "-" + r : r;
  };
  var O = function() {
    function e2(n2, i, o2) {
      var s2, a2 = 0, l2 = n2.length;
      for (n2 = n2.slice();l2--; )
        s2 = n2[l2] * i + a2, n2[l2] = s2 % o2 | 0, a2 = s2 / o2 | 0;
      return a2 && n2.unshift(a2), n2;
    }
    function t2(n2, i, o2, s2) {
      var a2, l2;
      if (o2 != s2)
        l2 = o2 > s2 ? 1 : -1;
      else
        for (a2 = l2 = 0;a2 < o2; a2++)
          if (n2[a2] != i[a2]) {
            l2 = n2[a2] > i[a2] ? 1 : -1;
            break;
          }
      return l2;
    }
    function r(n2, i, o2, s2) {
      for (var a2 = 0;o2--; )
        n2[o2] -= a2, a2 = n2[o2] < i[o2] ? 1 : 0, n2[o2] = a2 * s2 + n2[o2] - i[o2];
      for (;!n2[0] && n2.length > 1; )
        n2.shift();
    }
    return function(n2, i, o2, s2, a2, l2) {
      var u2, c2, p2, d2, f, y2, g, P, T, C, x, R, ce, J, Ke, $, z, Ae, Y, tt, hr = n2.constructor, An = n2.s == i.s ? 1 : -1, Z = n2.d, k2 = i.d;
      if (!Z || !Z[0] || !k2 || !k2[0])
        return new hr(!n2.s || !i.s || (Z ? k2 && Z[0] == k2[0] : !k2) ? NaN : Z && Z[0] == 0 || !k2 ? An * 0 : An / 0);
      for (l2 ? (f = 1, c2 = n2.e - i.e) : (l2 = ge, f = b2, c2 = ee(n2.e / f) - ee(i.e / f)), Y = k2.length, z = Z.length, T = new hr(An), C = T.d = [], p2 = 0;k2[p2] == (Z[p2] || 0); p2++)
        ;
      if (k2[p2] > (Z[p2] || 0) && c2--, o2 == null ? (J = o2 = hr.precision, s2 = hr.rounding) : a2 ? J = o2 + (n2.e - i.e) + 1 : J = o2, J < 0)
        C.push(1), y2 = true;
      else {
        if (J = J / f + 2 | 0, p2 = 0, Y == 1) {
          for (d2 = 0, k2 = k2[0], J++;(p2 < z || d2) && J--; p2++)
            Ke = d2 * l2 + (Z[p2] || 0), C[p2] = Ke / k2 | 0, d2 = Ke % k2 | 0;
          y2 = d2 || p2 < z;
        } else {
          for (d2 = l2 / (k2[0] + 1) | 0, d2 > 1 && (k2 = e2(k2, d2, l2), Z = e2(Z, d2, l2), Y = k2.length, z = Z.length), $ = Y, x = Z.slice(0, Y), R = x.length;R < Y; )
            x[R++] = 0;
          tt = k2.slice(), tt.unshift(0), Ae = k2[0], k2[1] >= l2 / 2 && ++Ae;
          do
            d2 = 0, u2 = t2(k2, x, Y, R), u2 < 0 ? (ce = x[0], Y != R && (ce = ce * l2 + (x[1] || 0)), d2 = ce / Ae | 0, d2 > 1 ? (d2 >= l2 && (d2 = l2 - 1), g = e2(k2, d2, l2), P = g.length, R = x.length, u2 = t2(g, x, P, R), u2 == 1 && (d2--, r(g, Y < P ? tt : k2, P, l2))) : (d2 == 0 && (u2 = d2 = 1), g = k2.slice()), P = g.length, P < R && g.unshift(0), r(x, g, R, l2), u2 == -1 && (R = x.length, u2 = t2(k2, x, Y, R), u2 < 1 && (d2++, r(x, Y < R ? tt : k2, R, l2))), R = x.length) : u2 === 0 && (d2++, x = [0]), C[p2++] = d2, u2 && x[0] ? x[R++] = Z[$] || 0 : (x = [Z[$]], R = 1);
          while (($++ < z || x[0] !== undefined) && J--);
          y2 = x[0] !== undefined;
        }
        C[0] || C.shift();
      }
      if (f == 1)
        T.e = c2, vs = y2;
      else {
        for (p2 = 1, d2 = C[0];d2 >= 10; d2 /= 10)
          p2++;
        T.e = p2 + c2 * f - 1, h2(T, a2 ? o2 + T.e + 1 : o2, s2, y2);
      }
      return T;
    };
  }();
  m2[Symbol.for("nodejs.util.inspect.custom")] = m2.toString;
  m2[Symbol.toStringTag] = "Decimal";
  var ze = m2.constructor = Os(xi);
  Kr = new ze(Kr);
  Qr = new ze(Qr);
  var Pe = ze;
  var Ht = class {
    constructor(t2, r, n2, i, o2) {
      this.modelName = t2, this.name = r, this.typeName = n2, this.isList = i, this.isEnum = o2;
    }
    _toGraphQLInputType() {
      let t2 = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
      return `${t2}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var zr = class {
    constructor(t2) {
      this.value = t2;
    }
    write(t2) {
      t2.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var Yr = (e2) => e2;
  var Zr = { bold: Yr, red: Yr, green: Yr, dim: Yr, enabled: false };
  var Ds = { bold: ne, red: me, green: Ge, dim: Fe, enabled: true };
  var bt = { write(e2) {
    e2.writeLine(",");
  } };
  var ve = class {
    constructor(t2) {
      this.contents = t2;
      this.isUnderlined = false;
      this.color = (t3) => t3;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t2) {
      return this.color = t2, this;
    }
    write(t2) {
      let r = t2.getCurrentLineLength();
      t2.write(this.color(this.contents)), this.isUnderlined && t2.afterNextNewline(() => {
        t2.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var qe = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Et = class extends qe {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r) {
      return this.items.push(new zr(r)), this;
    }
    getField(r) {
      return this.items[r];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n2) => n2.value.getPrintWidth())) + 2;
    }
    write(r) {
      if (this.items.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithItems(r);
    }
    writeEmpty(r) {
      let n2 = new ve("[]");
      this.hasError && n2.setColor(r.context.colors.red).underline(), r.write(n2);
    }
    writeWithItems(r) {
      let { colors: n2 } = r.context;
      r.writeLine("[").withIndent(() => r.writeJoined(bt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(n2.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var _s = ": ";
  var Xr = class {
    constructor(t2, r) {
      this.name = t2;
      this.value = r;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + _s.length;
    }
    write(t2) {
      let r = new ve(this.name);
      this.hasError && r.underline().setColor(t2.context.colors.red), t2.write(r).write(_s).write(this.value);
    }
  };
  var Q = class e2 extends qe {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r) {
      this.fields[r.name] = r;
    }
    addSuggestion(r) {
      this.suggestions.push(r);
    }
    getField(r) {
      return this.fields[r];
    }
    getDeepField(r) {
      let [n2, ...i] = r, o2 = this.getField(n2);
      if (!o2)
        return;
      let s2 = o2;
      for (let a2 of i) {
        let l2;
        if (s2.value instanceof e2 ? l2 = s2.value.getField(a2) : s2.value instanceof Et && (l2 = s2.value.getField(Number(a2))), !l2)
          return;
        s2 = l2;
      }
      return s2;
    }
    getDeepFieldValue(r) {
      return r.length === 0 ? this : this.getDeepField(r)?.value;
    }
    hasField(r) {
      return !!this.getField(r);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r) {
      delete this.fields[r];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r) {
      return this.getField(r)?.value;
    }
    getDeepSubSelectionValue(r) {
      let n2 = this;
      for (let i of r) {
        if (!(n2 instanceof e2))
          return;
        let o2 = n2.getSubSelectionValue(i);
        if (!o2)
          return;
        n2 = o2;
      }
      return n2;
    }
    getDeepSelectionParent(r) {
      let n2 = this.getSelectionParent();
      if (!n2)
        return;
      let i = n2;
      for (let o2 of r) {
        let s2 = i.value.getFieldValue(o2);
        if (!s2 || !(s2 instanceof e2))
          return;
        let a2 = s2.getSelectionParent();
        if (!a2)
          return;
        i = a2;
      }
      return i;
    }
    getSelectionParent() {
      let r = this.getField("select");
      if (r?.value instanceof e2)
        return { kind: "select", value: r.value };
      let n2 = this.getField("include");
      if (n2?.value instanceof e2)
        return { kind: "include", value: n2.value };
    }
    getSubSelectionValue(r) {
      return this.getSelectionParent()?.value.fields[r].value;
    }
    getPrintWidth() {
      let r = Object.values(this.fields);
      return r.length == 0 ? 2 : Math.max(...r.map((i) => i.getPrintWidth())) + 2;
    }
    write(r) {
      let n2 = Object.values(this.fields);
      if (n2.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithContents(r, n2);
    }
    writeEmpty(r) {
      let n2 = new ve("{}");
      this.hasError && n2.setColor(r.context.colors.red).underline(), r.write(n2);
    }
    writeWithContents(r, n2) {
      r.writeLine("{").withIndent(() => {
        r.writeJoined(bt, [...n2, ...this.suggestions]).newLine();
      }), r.write("}"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var G = class extends qe {
    constructor(r) {
      super();
      this.text = r;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r) {
      let n2 = new ve(this.text);
      this.hasError && n2.underline().setColor(r.context.colors.red), r.write(n2);
    }
  };
  var vi = class {
    constructor(t2) {
      this.errorMessages = [];
      this.arguments = t2;
    }
    write(t2) {
      t2.write(this.arguments);
    }
    addErrorMessage(t2) {
      this.errorMessages.push(t2);
    }
    renderAllMessages(t2) {
      return this.errorMessages.map((r) => r(t2)).join(`
`);
    }
  };
  var Wt = "<unknown>";
  var op = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var sp = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var lp = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var cp = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var pp = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var mp = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var gp = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Ti = class {
    getLocation() {
      return null;
    }
  };
  var Ci = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t2 = this._error.stack;
      if (!t2)
        return null;
      let n2 = qs(t2).find((i) => {
        if (!i.file)
          return false;
        let o2 = ni(i.file);
        return o2 !== "<anonymous>" && !o2.includes("@prisma") && !o2.includes("/packages/client/src/runtime/") && !o2.endsWith("/runtime/binary.js") && !o2.endsWith("/runtime/library.js") && !o2.endsWith("/runtime/edge.js") && !o2.endsWith("/runtime/edge-esm.js") && !o2.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n2 || !n2.file ? null : { fileName: n2.file, lineNumber: n2.lineNumber, columnNumber: n2.column };
    }
  };
  var Vs = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var Gs = (e2) => Array.isArray(e2) ? e2 : e2.split(".");
  var Ai = (e2, t2) => Gs(t2).reduce((r, n2) => r && r[n2], e2);
  var Js = (e2, t2, r) => Gs(t2).reduceRight((n2, i, o2, s2) => Object.assign({}, Ai(e2, s2.slice(0, o2)), { [i]: n2 }), r);
  var Xs = S2(ii());
  var Zs = S2(import.meta.require("fs"));
  var Hs = { keyword: Oe, entity: Oe, value: (e2) => ne(ot(e2)), punctuation: ot, directive: Oe, function: Oe, variable: (e2) => ne(ot(e2)), string: (e2) => ne(Ge(e2)), boolean: he, number: Oe, comment: Tr };
  var Ap = (e2) => e2;
  var rn = {};
  var Rp = 0;
  var v = { manual: rn.Prism && rn.Prism.manual, disableWorkerMessageHandler: rn.Prism && rn.Prism.disableWorkerMessageHandler, util: { encode: function(e2) {
    if (e2 instanceof ye) {
      let t2 = e2;
      return new ye(t2.type, v.util.encode(t2.content), t2.alias);
    } else
      return Array.isArray(e2) ? e2.map(v.util.encode) : e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e2) {
    return Object.prototype.toString.call(e2).slice(8, -1);
  }, objId: function(e2) {
    return e2.__id || Object.defineProperty(e2, "__id", { value: ++Rp }), e2.__id;
  }, clone: function e(t2, r) {
    let n2, i, o2 = v.util.type(t2);
    switch (r = r || {}, o2) {
      case "Object":
        if (i = v.util.objId(t2), r[i])
          return r[i];
        n2 = {}, r[i] = n2;
        for (let s2 in t2)
          t2.hasOwnProperty(s2) && (n2[s2] = e(t2[s2], r));
        return n2;
      case "Array":
        return i = v.util.objId(t2), r[i] ? r[i] : (n2 = [], r[i] = n2, t2.forEach(function(s2, a2) {
          n2[a2] = e(s2, r);
        }), n2);
      default:
        return t2;
    }
  } }, languages: { extend: function(e2, t2) {
    let r = v.util.clone(v.languages[e2]);
    for (let n2 in t2)
      r[n2] = t2[n2];
    return r;
  }, insertBefore: function(e2, t2, r, n2) {
    n2 = n2 || v.languages;
    let i = n2[e2], o2 = {};
    for (let a2 in i)
      if (i.hasOwnProperty(a2)) {
        if (a2 == t2)
          for (let l2 in r)
            r.hasOwnProperty(l2) && (o2[l2] = r[l2]);
        r.hasOwnProperty(a2) || (o2[a2] = i[a2]);
      }
    let s2 = n2[e2];
    return n2[e2] = o2, v.languages.DFS(v.languages, function(a2, l2) {
      l2 === s2 && a2 != e2 && (this[a2] = o2);
    }), o2;
  }, DFS: function e(t2, r, n2, i) {
    i = i || {};
    let o2 = v.util.objId;
    for (let s2 in t2)
      if (t2.hasOwnProperty(s2)) {
        r.call(t2, s2, t2[s2], n2 || s2);
        let a2 = t2[s2], l2 = v.util.type(a2);
        l2 === "Object" && !i[o2(a2)] ? (i[o2(a2)] = true, e(a2, r, null, i)) : l2 === "Array" && !i[o2(a2)] && (i[o2(a2)] = true, e(a2, r, s2, i));
      }
  } }, plugins: {}, highlight: function(e2, t2, r) {
    let n2 = { code: e2, grammar: t2, language: r };
    return v.hooks.run("before-tokenize", n2), n2.tokens = v.tokenize(n2.code, n2.grammar), v.hooks.run("after-tokenize", n2), ye.stringify(v.util.encode(n2.tokens), n2.language);
  }, matchGrammar: function(e2, t2, r, n2, i, o2, s2) {
    for (let g in r) {
      if (!r.hasOwnProperty(g) || !r[g])
        continue;
      if (g == s2)
        return;
      let P = r[g];
      P = v.util.type(P) === "Array" ? P : [P];
      for (let T = 0;T < P.length; ++T) {
        let C = P[T], x = C.inside, R = !!C.lookbehind, ce = !!C.greedy, J = 0, Ke = C.alias;
        if (ce && !C.pattern.global) {
          let $ = C.pattern.toString().match(/[imuy]*$/)[0];
          C.pattern = RegExp(C.pattern.source, $ + "g");
        }
        C = C.pattern || C;
        for (let $ = n2, z = i;$ < t2.length; z += t2[$].length, ++$) {
          let Ae = t2[$];
          if (t2.length > e2.length)
            return;
          if (Ae instanceof ye)
            continue;
          if (ce && $ != t2.length - 1) {
            C.lastIndex = z;
            var p2 = C.exec(e2);
            if (!p2)
              break;
            var c2 = p2.index + (R ? p2[1].length : 0), d2 = p2.index + p2[0].length, a2 = $, l2 = z;
            for (let k2 = t2.length;a2 < k2 && (l2 < d2 || !t2[a2].type && !t2[a2 - 1].greedy); ++a2)
              l2 += t2[a2].length, c2 >= l2 && (++$, z = l2);
            if (t2[$] instanceof ye)
              continue;
            u2 = a2 - $, Ae = e2.slice(z, l2), p2.index -= z;
          } else {
            C.lastIndex = 0;
            var p2 = C.exec(Ae), u2 = 1;
          }
          if (!p2) {
            if (o2)
              break;
            continue;
          }
          R && (J = p2[1] ? p2[1].length : 0);
          var c2 = p2.index + J, p2 = p2[0].slice(J), d2 = c2 + p2.length, f = Ae.slice(0, c2), y2 = Ae.slice(d2);
          let Y = [$, u2];
          f && (++$, z += f.length, Y.push(f));
          let tt = new ye(g, x ? v.tokenize(p2, x) : p2, Ke, p2, ce);
          if (Y.push(tt), y2 && Y.push(y2), Array.prototype.splice.apply(t2, Y), u2 != 1 && v.matchGrammar(e2, t2, r, $, z, true, g), o2)
            break;
        }
      }
    }
  }, tokenize: function(e2, t2) {
    let r = [e2], n2 = t2.rest;
    if (n2) {
      for (let i in n2)
        t2[i] = n2[i];
      delete t2.rest;
    }
    return v.matchGrammar(e2, r, t2, 0, 0, false), r;
  }, hooks: { all: {}, add: function(e2, t2) {
    let r = v.hooks.all;
    r[e2] = r[e2] || [], r[e2].push(t2);
  }, run: function(e2, t2) {
    let r = v.hooks.all[e2];
    if (!(!r || !r.length))
      for (var n2 = 0, i;i = r[n2++]; )
        i(t2);
  } }, Token: ye };
  v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
  v.languages.js = v.languages.javascript;
  v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  v.languages.ts = v.languages.typescript;
  ye.stringify = function(e2, t2) {
    return typeof e2 == "string" ? e2 : Array.isArray(e2) ? e2.map(function(r) {
      return ye.stringify(r, t2);
    }).join("") : Mp(e2.type)(e2.content);
  };
  var zs = S2(es());
  var nn = class e2 {
    static read(t2) {
      let r;
      try {
        r = Zs.default.readFileSync(t2, "utf-8");
      } catch {
        return null;
      }
      return e2.fromContent(r);
    }
    static fromContent(t2) {
      let r = t2.split(/\r?\n/);
      return new e2(1, r);
    }
    constructor(t2, r) {
      this.firstLineNumber = t2, this.lines = r;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t2, r) {
      if (t2 < this.firstLineNumber || t2 > this.lines.length + this.firstLineNumber)
        return this;
      let n2 = t2 - this.firstLineNumber, i = [...this.lines];
      return i[n2] = r(i[n2]), new e2(this.firstLineNumber, i);
    }
    mapLines(t2) {
      return new e2(this.firstLineNumber, this.lines.map((r, n2) => t2(r, this.firstLineNumber + n2)));
    }
    lineAt(t2) {
      return this.lines[t2 - this.firstLineNumber];
    }
    prependSymbolAt(t2, r) {
      return this.mapLines((n2, i) => i === t2 ? `${r} ${n2}` : `  ${n2}`);
    }
    slice(t2, r) {
      let n2 = this.lines.slice(t2 - 1, r).join(`
`);
      return new e2(t2, Ys(n2).split(`
`));
    }
    highlight() {
      let t2 = Ws(this.toString());
      return new e2(this.firstLineNumber, t2.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Ip = { red: me, gray: Tr, dim: Fe, bold: ne, underline: te, highlightSource: (e2) => e2.highlight() };
  var kp = { red: (e2) => e2, gray: (e2) => e2, dim: (e2) => e2, bold: (e2) => e2, underline: (e2) => e2, highlightSource: (e2) => e2 };
  var $p = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var qp = ["aggregate", "count", "groupBy"];
  var Si = Symbol();
  var aa = (e2) => e2;
  var an = class {
    constructor(t2, r) {
      this.extension = t2;
      this.previous = r;
      this.computedFieldsCache = new be;
      this.modelExtensionsCache = new be;
      this.queryCallbacksCache = new be;
      this.clientExtensions = Vt(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = Vt(() => {
        let t3 = this.previous?.getAllBatchQueryCallbacks() ?? [], r2 = this.extension.query?.$__internalBatch;
        return r2 ? t3.concat(r2) : t3;
      });
    }
    getAllComputedFields(t2) {
      return this.computedFieldsCache.getOrCreate(t2, () => fa(this.previous?.getAllComputedFields(t2), this.extension, t2));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t2) {
      return this.modelExtensionsCache.getOrCreate(t2, () => {
        let r = Te(t2);
        return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t2) : { ...this.previous?.getAllModelExtensions(t2), ...this.extension.model.$allModels, ...this.extension.model[r] };
      });
    }
    getAllQueryCallbacks(t2, r) {
      return this.queryCallbacksCache.getOrCreate(`${t2}:${r}`, () => {
        let n2 = this.previous?.getAllQueryCallbacks(t2, r) ?? [], i = [], o2 = this.extension.query;
        return !o2 || !(o2[t2] || o2.$allModels || o2[r] || o2.$allOperations) ? n2 : (o2[t2] !== undefined && (o2[t2][r] !== undefined && i.push(o2[t2][r]), o2[t2].$allOperations !== undefined && i.push(o2[t2].$allOperations)), t2 !== "$none" && o2.$allModels !== undefined && (o2.$allModels[r] !== undefined && i.push(o2.$allModels[r]), o2.$allModels.$allOperations !== undefined && i.push(o2.$allModels.$allOperations)), o2[r] !== undefined && i.push(o2[r]), o2.$allOperations !== undefined && i.push(o2.$allOperations), n2.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var ln = class e2 {
    constructor(t2) {
      this.head = t2;
    }
    static empty() {
      return new e2;
    }
    static single(t2) {
      return new e2(new an(t2));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t2) {
      return new e2(new an(t2, this.head));
    }
    getAllComputedFields(t2) {
      return this.head?.getAllComputedFields(t2);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t2) {
      return this.head?.getAllModelExtensions(t2);
    }
    getAllQueryCallbacks(t2, r) {
      return this.head?.getAllQueryCallbacks(t2, r) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ya = D("prisma:client");
  var ha = { Vercel: "vercel", "Netlify CI": "netlify" };
  var vt = class {
  };
  var Ta = S2(import.meta.require("fs"));
  var Xt = S2(import.meta.require("path"));
  var zp = D("prisma:client:engines:resolveEnginePath");
  var Yp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Ii = S2(li());
  var Sa = S2(cs());
  var mn = class extends Error {
    constructor(r, n2) {
      super(r);
      this.clientVersion = n2.clientVersion, this.cause = n2.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends mn {
    constructor(r, n2) {
      super(r, n2);
      this.isRetryable = n2.isRetryable ?? true;
    }
  };
  var Tt = class extends ae {
    constructor(r) {
      super("This request must be retried", M(r, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  E(Tt, "ForcedRetryError");
  var Ye = class extends ae {
    constructor(r, n2) {
      super(r, M(n2, false));
      this.name = "InvalidDatasourceError";
      this.code = "P5002";
    }
  };
  E(Ye, "InvalidDatasourceError");
  var Ze = class extends ae {
    constructor(r, n2) {
      super(r, M(n2, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  E(Ze, "NotImplementedYetError");
  var L2 = class extends ae {
    constructor(r, n2) {
      super(r, n2);
      this.response = n2.response;
      let i = this.response.headers.get("prisma-request-id");
      if (i) {
        let o2 = `(The request id was: ${i})`;
        this.message = this.message + " " + o2;
      }
    }
  };
  var Xe = class extends L2 {
    constructor(r) {
      super("Schema needs to be uploaded", M(r, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  E(Xe, "SchemaMissingError");
  var ki = "This request could not be understood by the server";
  var er = class extends L2 {
    constructor(r, n2, i) {
      super(n2 || ki, M(r, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  E(er, "BadRequestError");
  var tr = class extends L2 {
    constructor(r, n2) {
      super("Engine not started: healthcheck timeout", M(r, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n2;
    }
  };
  E(tr, "HealthcheckTimeoutError");
  var rr = class extends L2 {
    constructor(r, n2, i) {
      super(n2, M(r, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  E(rr, "EngineStartupError");
  var nr = class extends L2 {
    constructor(r) {
      super("Engine version is not supported", M(r, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  E(nr, "EngineVersionNotSupportedError");
  var Fi = "Request timed out";
  var ir = class extends L2 {
    constructor(r, n2 = Fi) {
      super(n2, M(r, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  E(ir, "GatewayTimeoutError");
  var Xp = "Interactive transaction error";
  var or = class extends L2 {
    constructor(r, n2 = Xp) {
      super(n2, M(r, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  E(or, "InteractiveTransactionError");
  var ed = "Request parameters are invalid";
  var sr = class extends L2 {
    constructor(r, n2 = ed) {
      super(n2, M(r, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  E(sr, "InvalidRequestError");
  var Oi = "Requested resource does not exist";
  var ar = class extends L2 {
    constructor(r, n2 = Oi) {
      super(n2, M(r, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  E(ar, "NotFoundError");
  var Di = "Unknown server error";
  var Ct = class extends L2 {
    constructor(r, n2, i) {
      super(n2 || Di, M(r, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  E(Ct, "ServerError");
  var _i = "Unauthorized, check your connection string";
  var lr = class extends L2 {
    constructor(r, n2 = _i) {
      super(n2, M(r, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  E(lr, "UnauthorizedError");
  var Ni = "Usage exceeded, retry again later";
  var ur = class extends L2 {
    constructor(r, n2 = Ni) {
      super(n2, M(r, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  E(ur, "UsageExceededError");
  var Da = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.4.1-2.ac9d7041ed77bcc8a8dbd2ab6616b39013829574", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.75", "@swc/jest": "0.2.29", "@types/jest": "29.5.5", "@types/node": "18.18.0", execa: "5.1.1", jest: "29.7.0", typescript: "5.2.2" };
  var pr = class extends ae {
    constructor(r, n2) {
      super(`Cannot fetch data from service:
${r}`, M(n2, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  E(pr, "RequestError");
  var sd = typeof require < "u" ? require : () => {
  };
  var $i = class {
    constructor(t2 = {}) {
      this.headers = new Map;
      for (let [r, n2] of Object.entries(t2))
        if (typeof n2 == "string")
          this.headers.set(r, n2);
        else if (Array.isArray(n2))
          for (let i of n2)
            this.headers.set(r, i);
    }
    append(t2, r) {
      this.headers.set(t2, r);
    }
    delete(t2) {
      this.headers.delete(t2);
    }
    get(t2) {
      return this.headers.get(t2) ?? null;
    }
    has(t2) {
      return this.headers.has(t2);
    }
    set(t2, r) {
      this.headers.set(t2, r);
    }
    forEach(t2, r) {
      for (let [n2, i] of this.headers)
        t2.call(r, i, n2, this);
    }
  };
  var ad = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var _a = D("prisma:client:dataproxyEngine");
  var La = 3;
  var qi = D("prisma:client:dataproxyEngine");
  var Vi = class {
    constructor({ apiKey: t2, tracingHelper: r, logLevel: n2, logQueries: i }) {
      this.apiKey = t2, this.tracingHelper = r, this.logLevel = n2, this.logQueries = i;
    }
    build({ traceparent: t2, interactiveTransaction: r } = {}) {
      let n2 = { Authorization: `Bearer ${this.apiKey}` };
      this.tracingHelper.isEnabled() && (n2.traceparent = t2 ?? this.tracingHelper.getTraceParent()), r && (n2["X-transaction-id"] = r.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n2["X-capture-telemetry"] = i.join(", ")), n2;
    }
    buildCaptureSettings() {
      let t2 = [];
      return this.tracingHelper.isEnabled() && t2.push("tracing"), this.logLevel && t2.push(this.logLevel), this.logQueries && t2.push("query"), t2;
    }
  };
  var dr = class extends vt {
    constructor(r) {
      super();
      Oa(r), this.config = r, this.env = { ...this.config.env, ...process.env }, this.inlineSchema = r.inlineSchema ?? "", this.inlineDatasources = r.inlineDatasources ?? {}, this.inlineSchemaHash = r.inlineSchemaHash ?? "", this.clientVersion = r.clientVersion ?? "unknown", this.logEmitter = r.logEmitter, this.tracingHelper = this.config.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return "unknown";
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [r, n2] = this.extractHostAndApiKey();
        this.host = r, this.headerBuilder = new Vi({ apiKey: n2, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries }), this.remoteClientVersion = await Na(r, this.config), qi("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(r) {
      r?.logs?.length && r.logs.forEach((n2) => {
        switch (n2.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let i = typeof n2.attributes.query == "string" ? n2.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [o2] = i.split("/* traceparent");
              i = o2;
            }
            this.logEmitter.emit("query", { query: i, timestamp: n2.timestamp, duration: n2.attributes.duration_ms, params: n2.attributes.params, target: n2.attributes.target });
          }
        }
      }), r?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
    }
    on(r, n2) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      this.logEmitter.on(r, n2);
    }
    async url(r) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
    }
    async uploadSchema() {
      let r = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r, async () => {
        let n2 = await et(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        n2.ok || qi("schema response status", n2.status);
        let i = await cr(n2, this.clientVersion);
        if (i)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${i.message}` }), i;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
      });
    }
    request(r, { traceparent: n2, interactiveTransaction: i, customDataProxyFetch: o2 }) {
      return this.requestInternal({ body: r, traceparent: n2, interactiveTransaction: i, customDataProxyFetch: o2 });
    }
    async requestBatch(r, { traceparent: n2, transaction: i, customDataProxyFetch: o2 }) {
      let s2 = i?.kind === "itx" ? i.options : undefined, a2 = pn(r, i), { batchResult: l2, elapsed: u2 } = await this.requestInternal({ body: a2, customDataProxyFetch: o2, interactiveTransaction: s2, traceparent: n2 });
      return l2.map((c2) => ("errors" in c2) && c2.errors.length > 0 ? Zt(c2.errors[0], this.clientVersion) : { data: c2, elapsed: u2 });
    }
    requestInternal({ body: r, traceparent: n2, customDataProxyFetch: i, interactiveTransaction: o2 }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s2 }) => {
        let a2 = o2 ? `${o2.payload.endpoint}/graphql` : await this.url("graphql");
        s2(a2);
        let l2 = await et(a2, { method: "POST", headers: this.headerBuilder.build({ traceparent: n2, interactiveTransaction: o2 }), body: JSON.stringify(r), clientVersion: this.clientVersion }, i);
        l2.ok || qi("graphql response status", l2.status), await this.handleError(await cr(l2, this.clientVersion));
        let u2 = await l2.json(), c2 = u2.extensions;
        if (c2 && this.propagateResponseExtensions(c2), u2.errors)
          throw u2.errors.length === 1 ? Zt(u2.errors[0], this.config.clientVersion) : new K(u2.errors, { clientVersion: this.config.clientVersion });
        return u2;
      } });
    }
    async transaction(r, n2, i) {
      let o2 = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${o2[r]} transaction`, callback: async ({ logHttpCall: s2 }) => {
        if (r === "start") {
          let a2 = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel }), l2 = await this.url("transaction/start");
          s2(l2);
          let u2 = await et(l2, { method: "POST", headers: this.headerBuilder.build({ traceparent: n2.traceparent }), body: a2, clientVersion: this.clientVersion });
          await this.handleError(await cr(u2, this.clientVersion));
          let c2 = await u2.json(), p2 = c2.extensions;
          p2 && this.propagateResponseExtensions(p2);
          let d2 = c2.id, f = c2["data-proxy"].endpoint;
          return { id: d2, payload: { endpoint: f } };
        } else {
          let a2 = `${i.payload.endpoint}/${r}`;
          s2(a2);
          let l2 = await et(a2, { method: "POST", headers: this.headerBuilder.build({ traceparent: n2.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await cr(l2, this.clientVersion));
          let c2 = (await l2.json()).extensions;
          c2 && this.propagateResponseExtensions(c2);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let r = { clientVersion: this.clientVersion }, n2 = Object.keys(this.inlineDatasources)[0], i = dn({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), o2;
      try {
        o2 = new URL(i);
      } catch {
        throw new Ye(`Error validating datasource \`${n2}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: s2, host: a2, searchParams: l2 } = o2;
      if (s2 !== "prisma:")
        throw new Ye(`Error validating datasource \`${n2}\`: the URL must start with the protocol \`prisma://\``, r);
      let u2 = l2.get("api_key");
      if (u2 === null || u2.length < 1)
        throw new Ye(`Error validating datasource \`${n2}\`: the URL must contain a valid API key`, r);
      return [a2, u2];
    }
    metrics() {
      throw new Ze("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r) {
      for (let n2 = 0;; n2++) {
        let i = (o2) => {
          this.logEmitter.emit("info", { message: `Calling ${o2} (n=${n2})` });
        };
        try {
          return await r.callback({ logHttpCall: i });
        } catch (o2) {
          if (!(o2 instanceof ae) || !o2.isRetryable)
            throw o2;
          if (n2 >= La)
            throw o2 instanceof Tt ? o2.cause : o2;
          this.logEmitter.emit("warn", { message: `Attempt ${n2 + 1}/${La} failed for ${r.actionGerund}: ${o2.message ?? "(unknown)"}` });
          let s2 = await Fa(n2);
          this.logEmitter.emit("warn", { message: `Retrying after ${s2}ms` });
        }
      }
    }
    async handleError(r) {
      if (r instanceof Xe)
        throw await this.uploadSchema(), new Tt({ clientVersion: this.clientVersion, cause: r });
      if (r)
        throw r;
    }
  };
  var Ba = S2(import.meta.require("fs"));
  var Bi = S2(import.meta.require("os"));
  var qa = S2(import.meta.require("path"));
  var ji = Symbol("PrismaLibraryEngineCache");
  var fn = class {
    constructor(t2) {
      this.config = t2;
    }
    async loadLibrary() {
      let t2 = await Jn(), r = await Ca("library", this.config);
      try {
        return this.config.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => pd(r));
      } catch (n2) {
        let i = ri({ e: n2, platformInfo: t2, id: r });
        throw new F(i, this.config.clientVersion);
      }
    }
  };
  var dd = "P2036";
  var Ce = D("prisma:client:libraryEngine");
  var Va = [...Hn, "native"];
  var ja = 0;
  var mr = class extends vt {
    constructor(r, n2 = new fn(r)) {
      super();
      try {
        this.datamodel = Ba.default.readFileSync(r.datamodelPath, "utf-8");
      } catch (s2) {
        throw s2.stack.match(/\/\.next|\/next@|\/next\//) ? new F(`Your schema.prisma could not be found, and we detected that you are using Next.js.
Find out why and learn how to fix this: https://pris.ly/d/schema-not-found-nextjs`, r.clientVersion) : r.isBundled === true ? new F("Prisma Client could not find its `schema.prisma`. This is likely caused by a bundling step, which leads to `schema.prisma` not being copied near the resulting bundle. We would appreciate if you could take the time to share some information with us.\nPlease help us by answering a few questions: https://pris.ly/bundler-investigation-error", r.clientVersion) : s2;
      }
      this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.libraryLoader = n2, this.logEmitter = r.logEmitter, r.enableDebugLogs && (this.logLevel = "debug");
      let i = Object.keys(r.overrideDatasources)[0], o2 = r.overrideDatasources[i]?.url;
      i !== undefined && o2 !== undefined && (this.datasourceOverrides = { [i]: o2 }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      ja === 10 && console.warn(`${he("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(r, n2, i) {
      await this.start();
      let o2 = JSON.stringify(n2), s2;
      if (r === "start") {
        let l2 = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel });
        s2 = await this.engine?.startTransaction(l2, o2);
      } else
        r === "commit" ? s2 = await this.engine?.commitTransaction(i.id, o2) : r === "rollback" && (s2 = await this.engine?.rollbackTransaction(i.id, o2));
      let a2 = this.parseEngineResponse(s2);
      if (a2.error_code)
        throw new U(a2.message, { code: a2.error_code, clientVersion: this.config.clientVersion, meta: a2.meta });
      return a2;
    }
    async instantiateLibrary() {
      if (Ce("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Vn(), this.platform = await this.getPlatform(), await this.loadEngine(), this.version();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      let r = await ut();
      if (!Va.includes(r))
        throw new F(`Unknown ${me("PRISMA_QUERY_ENGINE_LIBRARY")} ${me(ne(r))}. Possible binaryTargets: ${Ge(Va.join(", "))} or a path to the query engine library.
You may have to run ${Ge("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      return r;
    }
    parseEngineResponse(r) {
      if (!r)
        throw new K("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r);
      } catch {
        throw new K("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r = new WeakRef(this), { adapter: n2 } = this.config;
          n2 && Ce("Using driver adapter: %O", n2), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (i) => {
            r.deref()?.logger(i);
          }, n2), ja++;
        } catch (r) {
          let n2 = r, i = this.parseInitError(n2.message);
          throw typeof i == "string" ? n2 : new F(i.message, this.config.clientVersion, i.error_code);
        }
      }
    }
    logger(r) {
      let n2 = this.parseEngineResponse(r);
      if (n2) {
        if ("span" in n2) {
          this.config.tracingHelper.createEngineSpan(n2);
          return;
        }
        n2.level = n2?.level.toLowerCase() ?? "unknown", md(n2) ? this.logEmitter.emit("query", { timestamp: new Date, query: n2.query, params: n2.params, duration: Number(n2.duration_ms), target: n2.module_path }) : fd(n2) ? this.loggerRustPanic = new ue(this.getErrorMessageWithLink(`${n2.message}: ${n2.reason} in ${n2.file}:${n2.line}:${n2.column}`), this.config.clientVersion) : this.logEmitter.emit(n2.level, { timestamp: new Date, message: n2.message, target: n2.module_path });
      }
    }
    getErrorMessageWithLink(r) {
      return ka({ platform: this.platform, title: r, version: this.config.clientVersion, engineVersion: this.versionInfo?.commit, database: this.config.activeProvider, query: this.lastQuery });
    }
    parseInitError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    parseRequestError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    on(r, n2) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      this.logEmitter.on(r, n2);
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ce(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r = async () => {
        Ce("library starting");
        try {
          let n2 = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(n2)), this.libraryStarted = true, Ce("library started");
        } catch (n2) {
          let i = this.parseInitError(n2.message);
          throw typeof i == "string" ? n2 : new F(i.message, this.config.clientVersion, i.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ce("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let r = async () => {
        await new Promise((i) => setTimeout(i, 5)), Ce("library stopping");
        let n2 = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(n2)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Ce("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r) {
      return this.library?.debugPanic(r);
    }
    async request(r, { traceparent: n2, interactiveTransaction: i }) {
      Ce(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let o2 = JSON.stringify({ traceparent: n2 }), s2 = JSON.stringify(r);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(s2, o2, i?.id), this.lastQuery = s2;
        let a2 = this.parseEngineResponse(await this.executingQueryPromise);
        if (a2.errors)
          throw a2.errors.length === 1 ? this.buildQueryError(a2.errors[0]) : new K(JSON.stringify(a2.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: a2, elapsed: 0 };
      } catch (a2) {
        if (a2 instanceof F)
          throw a2;
        if (a2.code === "GenericFailure" && a2.message?.startsWith("PANIC:"))
          throw new ue(this.getErrorMessageWithLink(a2.message), this.config.clientVersion);
        let l2 = this.parseRequestError(a2.message);
        throw typeof l2 == "string" ? a2 : new K(`${l2.message}
${l2.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r, { transaction: n2, traceparent: i }) {
      Ce("requestBatch");
      let o2 = pn(r, n2);
      await this.start(), this.lastQuery = JSON.stringify(o2), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: i }), $a(n2));
      let s2 = await this.executingQueryPromise, a2 = this.parseEngineResponse(s2);
      if (a2.errors)
        throw a2.errors.length === 1 ? this.buildQueryError(a2.errors[0]) : new K(JSON.stringify(a2.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: l2, errors: u2 } = a2;
      if (Array.isArray(l2))
        return l2.map((c2) => c2.errors && c2.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c2.errors[0]) : { data: c2, elapsed: 0 });
      throw u2 && u2.length === 1 ? new Error(u2[0].error) : new Error(JSON.stringify(a2));
    }
    buildQueryError(r) {
      if (r.user_facing_error.is_panic)
        return new ue(this.getErrorMessageWithLink(r.user_facing_error.message), this.config.clientVersion);
      if (r.user_facing_error.error_code === dd && this.config.adapter) {
        let n2 = r.user_facing_error.meta?.id;
        _r(typeof n2 == "number", "Malformed external JS error received from the engine");
        let i = this.config.adapter.errorRegistry.consumeError(n2);
        return _r(i, "External error with reported id was not registered"), i.error;
      }
      return Zt(r, this.config.clientVersion);
    }
    async metrics(r) {
      await this.start();
      let n2 = await this.engine.metrics(JSON.stringify(r));
      return r.format === "prometheus" ? n2 : this.parseEngineResponse(n2);
    }
  };
  var Wa = S2(Ui());
  var Se = class {
    constructor(t2, r) {
      this.name = t2;
      this.value = r;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t2) {
      let { colors: { green: r } } = t2.context;
      t2.addMarginSymbol(r(this.isRequired ? "+" : "?")), t2.write(r(this.name)), this.isRequired || t2.write(r("?")), t2.write(r(": ")), typeof this.value == "string" ? t2.write(r(this.value)) : t2.write(this.value);
    }
  };
  var hn = class {
    constructor() {
      this.fields = [];
    }
    addField(t2, r) {
      return this.fields.push({ write(n2) {
        let { green: i, dim: o2 } = n2.context.colors;
        n2.write(i(o2(`${t2}: ${r}`))).addMarginSymbol(i(o2("+")));
      } }), this;
    }
    write(t2) {
      let { colors: { green: r } } = t2.context;
      t2.writeLine(r("{")).withIndent(() => {
        t2.writeJoined(bt, this.fields).newLine();
      }).write(r("}")).addMarginSymbol(r("+"));
    }
  };
  var kd = 3;
  var Od = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var Ki = class e2 {
    constructor(t2) {
      this.params = t2;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(t2) {
      En({ errors: [t2], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((t2) => ({ name: t2.name, typeName: "boolean", isRelation: t2.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t2) {
      return this.model?.fields.find((r) => r.name === t2);
    }
    nestSelection(t2) {
      let r = this.findField(t2), n2 = r?.kind === "object" ? r.type : undefined;
      return new e2({ ...this.params, modelName: n2, selectionPath: this.params.selectionPath.concat(t2) });
    }
    nestArgument(t2) {
      return new e2({ ...this.params, argumentPath: this.params.argumentPath.concat(t2) });
    }
  };
  var nl = (e2) => ({ command: e2 });
  var il = (e2) => e2.strings.reduce((t2, r, n2) => `${t2}@P${n2}${r}`);
  var Ud = /^(\s*alter\s)/i;
  var ll = D("prisma:client");
  var Ji = ({ clientMethod: e2, activeProvider: t2, activeProviderFlavour: r }) => (n2) => {
    r !== undefined && (t2 = r);
    let i = "", o2;
    if (Array.isArray(n2)) {
      let [s2, ...a2] = n2;
      i = s2, o2 = { values: gr(a2 || []), __prismaRawParameters__: true };
    } else
      switch (t2) {
        case "sqlite":
        case "mysql": {
          i = n2.sql, o2 = { values: gr(n2.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          i = n2.text, o2 = { values: gr(n2.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          i = il(n2), o2 = { values: gr(n2.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t2} provider does not support ${e2}`);
      }
    return o2?.values ? ll(`prisma.${e2}(${i}, ${o2.values})`) : ll(`prisma.${e2}(${i})`), { query: i, parameters: o2 };
  };
  var ul = { requestArgsToMiddlewareArgs(e2) {
    return [e2.strings, ...e2.values];
  }, middlewareArgsToRequestArgs(e2) {
    let [t2, ...r] = e2;
    return new oe(t2, r);
  } };
  var cl = { requestArgsToMiddlewareArgs(e2) {
    return [e2];
  }, middlewareArgsToRequestArgs(e2) {
    return e2[0];
  } };
  var dl = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e2, t2) {
    return t2();
  } };
  var Wi = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t2) {
      return this.getGlobalTracingHelper().getTraceParent(t2);
    }
    createEngineSpan(t2) {
      return this.getGlobalTracingHelper().createEngineSpan(t2);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t2, r) {
      return this.getGlobalTracingHelper().runInChildSpan(t2, r);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? dl;
    }
  };
  var Kd = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var zi = Kd;
  var wn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t2) {
      this._middlewares.push(t2);
    }
    get(t2) {
      return this._middlewares[t2];
    }
    has(t2) {
      return !!this._middlewares[t2];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var hl = S2(li());
  var Jd = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var Tn = class {
    constructor(t2) {
      this.options = t2;
      this.tickActive = false;
      this.batches = {};
    }
    request(t2) {
      let r = this.options.batchBy(t2);
      return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n2, i) => {
        this.batches[r].push({ request: t2, resolve: n2, reject: i });
      })) : this.options.singleLoader(t2);
    }
    dispatchBatches() {
      for (let t2 in this.batches) {
        let r = this.batches[t2];
        delete this.batches[t2], r.length === 1 ? this.options.singleLoader(r[0].request).then((n2) => {
          n2 instanceof Error ? r[0].reject(n2) : r[0].resolve(n2);
        }).catch((n2) => {
          r[0].reject(n2);
        }) : (r.sort((n2, i) => this.options.batchOrder(n2.request, i.request)), this.options.batchLoader(r.map((n2) => n2.request)).then((n2) => {
          if (n2 instanceof Error)
            for (let i = 0;i < r.length; i++)
              r[i].reject(n2);
          else
            for (let i = 0;i < r.length; i++) {
              let o2 = n2[i];
              o2 instanceof Error ? r[i].reject(o2) : r[i].resolve(o2);
            }
        }).catch((n2) => {
          for (let i = 0;i < r.length; i++)
            r[i].reject(n2);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var Hd = D("prisma:client:request_handler");
  var Cn = class {
    constructor(t2, r) {
      this.logEmitter = r, this.client = t2, this.dataloader = new Tn({ batchLoader: ca(async ({ requests: n2, customDataProxyFetch: i }) => {
        let { transaction: o2, otelParentCtx: s2 } = n2[0], a2 = n2.map((p2) => p2.protocolQuery), l2 = this.client._tracingHelper.getTraceParent(s2), u2 = n2.some((p2) => Zi(p2.protocolQuery.action));
        return (await this.client._engine.requestBatch(a2, { traceparent: l2, transaction: Wd(o2), containsWrite: u2, customDataProxyFetch: i })).map((p2, d2) => {
          if (p2 instanceof Error)
            return p2;
          try {
            return this.mapQueryEngineResult(n2[d2], p2);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n2) => {
        let i = n2.transaction?.kind === "itx" ? xl(n2.transaction) : undefined, o2 = await this.client._engine.request(n2.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Zi(n2.protocolQuery.action), customDataProxyFetch: n2.customDataProxyFetch });
        return this.mapQueryEngineResult(n2, o2);
      }, batchBy: (n2) => n2.transaction?.id ? `transaction-${n2.transaction.id}` : yl(n2.protocolQuery), batchOrder(n2, i) {
        return n2.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n2.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(t2) {
      try {
        return await this.dataloader.request(t2);
      } catch (r) {
        let { clientMethod: n2, callsite: i, transaction: o2, args: s2 } = t2;
        this.handleAndLogRequestError({ error: r, clientMethod: n2, callsite: i, transaction: o2, args: s2 });
      }
    }
    mapQueryEngineResult({ dataPath: t2, unpacker: r }, n2) {
      let i = n2?.data, o2 = n2?.elapsed, s2 = this.unpack(i, t2, r);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s2, elapsed: o2 } : s2;
    }
    handleAndLogRequestError(t2) {
      try {
        this.handleRequestError(t2);
      } catch (r) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t2.clientMethod, timestamp: new Date }), r;
      }
    }
    handleRequestError({ error: t2, clientMethod: r, callsite: n2, transaction: i, args: o2 }) {
      if (Hd(t2), zd(t2, i) || t2 instanceof Re)
        throw t2;
      if (t2 instanceof U && Yd(t2)) {
        let a2 = bl(t2.meta);
        En({ args: o2, errors: [a2], callsite: n2, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion });
      }
      let s2 = t2.message;
      throw n2 && (s2 = Pt({ callsite: n2, originalMethod: r, isPanic: t2.isPanic, showColors: this.client._errorFormat === "pretty", message: s2 })), s2 = this.sanitizeMessage(s2), t2.code ? new U(s2, { code: t2.code, clientVersion: this.client._clientVersion, meta: t2.meta, batchRequestIdx: t2.batchRequestIdx }) : t2.isPanic ? new ue(s2, this.client._clientVersion) : t2 instanceof K ? new K(s2, { clientVersion: this.client._clientVersion, batchRequestIdx: t2.batchRequestIdx }) : t2 instanceof F ? new F(s2, this.client._clientVersion) : t2 instanceof ue ? new ue(s2, this.client._clientVersion) : (t2.clientVersion = this.client._clientVersion, t2);
    }
    sanitizeMessage(t2) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, hl.default)(t2) : t2;
    }
    unpack(t2, r, n2) {
      if (!t2 || (t2.data && (t2 = t2.data), !t2))
        return t2;
      let i = Object.values(t2)[0], o2 = r.filter((a2) => a2 !== "select" && a2 !== "include"), s2 = vn(Ai(i, o2));
      return n2 ? n2(s2) : s2;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var El = "5.4.2";
  var wl = El;
  var Rl = S2(Ui());
  var q = class extends Error {
    constructor(t2) {
      super(t2 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  E(q, "PrismaClientConstructorValidationError");
  var Tl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "__internal"];
  var Cl = ["pretty", "colorless", "minimal"];
  var Al = ["info", "query", "warn", "error"];
  var Xd = { datasources: (e2, { datasourceNames: t2 }) => {
    if (e2) {
      if (typeof e2 != "object" || Array.isArray(e2))
        throw new q(`Invalid value ${JSON.stringify(e2)} for "datasources" provided to PrismaClient constructor`);
      for (let [r, n2] of Object.entries(e2)) {
        if (!t2.includes(r)) {
          let i = Rt(r, t2) || ` Available datasources: ${t2.join(", ")}`;
          throw new q(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n2 != "object" || Array.isArray(n2))
          throw new q(`Invalid value ${JSON.stringify(e2)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n2 && typeof n2 == "object")
          for (let [i, o2] of Object.entries(n2)) {
            if (i !== "url")
              throw new q(`Invalid value ${JSON.stringify(e2)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o2 != "string")
              throw new q(`Invalid value ${JSON.stringify(o2)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e2, t2) => {
    if (e2 === null)
      return;
    if (e2 === undefined)
      throw new q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!gn(t2).includes("driverAdapters"))
      throw new q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
  }, datasourceUrl: (e2) => {
    if (typeof e2 < "u" && typeof e2 != "string")
      throw new q(`Invalid value ${JSON.stringify(e2)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e2) => {
    if (e2) {
      if (typeof e2 != "string")
        throw new q(`Invalid value ${JSON.stringify(e2)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!Cl.includes(e2)) {
        let t2 = Rt(e2, Cl);
        throw new q(`Invalid errorFormat ${e2} provided to PrismaClient constructor.${t2}`);
      }
    }
  }, log: (e2) => {
    if (!e2)
      return;
    if (!Array.isArray(e2))
      throw new q(`Invalid value ${JSON.stringify(e2)} for "log" provided to PrismaClient constructor.`);
    function t2(r) {
      if (typeof r == "string" && !Al.includes(r)) {
        let n2 = Rt(r, Al);
        throw new q(`Invalid log level "${r}" provided to PrismaClient constructor.${n2}`);
      }
    }
    for (let r of e2) {
      t2(r);
      let n2 = { level: t2, emit: (i) => {
        let o2 = ["stdout", "event"];
        if (!o2.includes(i)) {
          let s2 = Rt(i, o2);
          throw new q(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s2}`);
        }
      } };
      if (r && typeof r == "object")
        for (let [i, o2] of Object.entries(r))
          if (n2[i])
            n2[i](o2);
          else
            throw new q(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, __internal: (e2) => {
    if (!e2)
      return;
    let t2 = ["debug", "hooks", "engine", "measurePerformance"];
    if (typeof e2 != "object")
      throw new q(`Invalid value ${JSON.stringify(e2)} for "__internal" to PrismaClient constructor`);
    for (let [r] of Object.entries(e2))
      if (!t2.includes(r)) {
        let n2 = Rt(r, t2);
        throw new q(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n2}`);
      }
  } };
  var Ue = D("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var tm = { requestArgsToMiddlewareArgs: (e2) => e2, middlewareArgsToRequestArgs: (e2) => e2 };
  var rm = Symbol.for("prisma.client.transaction.id");
  var nm = { id: 0, nextId() {
    return ++this.id;
  } };
  var om = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// /Users/richardguerre/Projects/flow/node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join3,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.4.2",
    engine: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join3;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.DayScalarFieldEnum = {
    date: "date",
    tasksOrder: "tasksOrder"
  };
  exports.Prisma.NoteScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    date: "date",
    slug: "slug",
    title: "title",
    content: "content"
  };
  exports.Prisma.NoteTagScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    color: "color",
    isPrivate: "isPrivate"
  };
  exports.Prisma.TaskScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    title: "title",
    status: "status",
    completedAt: "completedAt",
    date: "date",
    durationInMinutes: "durationInMinutes",
    itemId: "itemId",
    parentTaskId: "parentTaskId"
  };
  exports.Prisma.TaskTagScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    color: "color",
    isPrivate: "isPrivate"
  };
  exports.Prisma.TaskPluginDataScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    min: "min",
    full: "full",
    pluginSlug: "pluginSlug",
    originalId: "originalId",
    taskId: "taskId"
  };
  exports.Prisma.ItemPluginDataScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    min: "min",
    full: "full",
    pluginSlug: "pluginSlug",
    originalId: "originalId",
    itemId: "itemId"
  };
  exports.Prisma.ItemScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    title: "title",
    isRelevant: "isRelevant",
    scheduledAt: "scheduledAt",
    durationInMinutes: "durationInMinutes",
    isAllDay: "isAllDay",
    color: "color",
    inboxPoints: "inboxPoints",
    listId: "listId"
  };
  exports.Prisma.ListScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    description: "description"
  };
  exports.Prisma.StoreScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    key: "key",
    value: "value",
    pluginSlug: "pluginSlug",
    isSecret: "isSecret",
    isServerOnly: "isServerOnly"
  };
  exports.Prisma.RoutineScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    actionName: "actionName",
    time: "time",
    repeats: "repeats",
    firstDay: "firstDay",
    lastDay: "lastDay",
    isActive: "isActive",
    steps: "steps"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.JsonNullValueInput = {
    JsonNull: Prisma.JsonNull
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.JsonNullValueFilter = {
    DbNull: Prisma.DbNull,
    JsonNull: Prisma.JsonNull,
    AnyNull: Prisma.AnyNull
  };
  exports.Color = exports.$Enums.Color = {
    slate: "slate",
    gray: "gray",
    zinc: "zinc",
    neutral: "neutral",
    stone: "stone",
    red: "red",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    green: "green",
    emerald: "emerald",
    teal: "teal",
    cyan: "cyan",
    sky: "sky",
    blue: "blue",
    indigo: "indigo",
    violet: "violet",
    purple: "purple",
    fuchsia: "fuchsia",
    pink: "pink",
    rose: "rose"
  };
  exports.TaskStatus = exports.$Enums.TaskStatus = {
    TODO: "TODO",
    DONE: "DONE",
    CANCELED: "CANCELED"
  };
  exports.RepetitionPattern = exports.$Enums.RepetitionPattern = {
    MONDAY: "MONDAY",
    TUESDAY: "TUESDAY",
    WEDNESDAY: "WEDNESDAY",
    THURSDAY: "THURSDAY",
    FRIDAY: "FRIDAY",
    SATURDAY: "SATURDAY",
    SUNDAY: "SUNDAY"
  };
  exports.Prisma.ModelName = {
    Day: "Day",
    Note: "Note",
    NoteTag: "NoteTag",
    Task: "Task",
    TaskTag: "TaskTag",
    TaskPluginData: "TaskPluginData",
    ItemPluginData: "ItemPluginData",
    Item: "Item",
    List: "List",
    Store: "Store",
    Routine: "Routine"
  };
  var config = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/Users/richardguerre/Projects/flow/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "darwin-arm64",
          native: true
        },
        {
          fromEnvVar: null,
          value: "rhel-openssl-3.0.x"
        },
        {
          fromEnvVar: null,
          value: "darwin-arm64"
        },
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x"
        }
      ],
      previewFeatures: []
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../apps/server/.env"
    },
    relativePath: "../../../apps/server/prisma",
    clientVersion: "5.4.2",
    engineVersion: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    postinstall: false,
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "ZGF0YXNvdXJjZSBkYiB7CiAgcHJvdmlkZXIgPSAicG9zdGdyZXNxbCIKICB1cmwgICAgICA9IGVudigiREFUQUJBU0VfVVJMIikKfQoKZ2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgICAgICA9ICJwcmlzbWEtY2xpZW50LWpzIgogIC8vIG5hdGl2ZSBmb3IgZGV2ZWxvcG1lbnQKICAvLyByaGVsLW9wZW5zc2wtMy4wLnggZm9yIHByb2R1Y3Rpb24KICAvLyBkYXJ3aW4tYXJtNjQgZm9yIE0xIE1hY3MKICAvLyBkZWJpYW4tb3BlbnNzbC0zLjAueCBmb3IgR2l0SHViIEFjdGlvbnMgb24gdWJ1bnR1LWxhdGVzdAogIGJpbmFyeVRhcmdldHMgPSBbIm5hdGl2ZSIsICJyaGVsLW9wZW5zc2wtMy4wLngiLCAiZGFyd2luLWFybTY0IiwgImRlYmlhbi1vcGVuc3NsLTMuMC54Il0KfQoKZ2VuZXJhdG9yIHBvdGhvcyB7CiAgcHJvdmlkZXIgICAgPSAicHJpc21hLXBvdGhvcy10eXBlcyIKICBwcmlzbWFVdGlscyA9IHRydWUKfQoKLy8vIEEgZGF5IGEgdXNlciBoYXMgcGxhbm5lZCBvciBhbHJlYWR5IGRvbmUuCi8vLyBEYXlzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gcGxhbm5lZCBhcmUgdmlydHVhbGx5IGNyZWF0ZWQgaW4gdGhlIEdyYXBoUUwgQVBJLgptb2RlbCBEYXkgewogIC8vLyBUaGUgZGF0ZSBvZiB0aGUgZGF5LCB3aGljaCBhY3RzIGFzIHRoZSBJRAogIGRhdGUgICAgICAgRGF0ZVRpbWUgQGlkIEBkYi5EYXRlCiAgLy8vIFRoZSBvcmRlciBvZiB0aGUgdGFza3MgaW4gdGhlIGRheQogIHRhc2tzT3JkZXIgSW50W10KCiAgLy8vIFRoZSB0YXNrcyBsaW5rZWQgdG8gdGhlIGRheS4KICB0YXNrcyAgICAgICAgICAgICBUYXNrW10KICAvLy8gVGhlIG5vdGVzIGxpbmtlZCB0byB0aGUgZGF5LgogIG5vdGVzICAgICAgICAgICAgIE5vdGVbXQogIC8vLyBUaGUgcm91dGluZXMgY29tcGxldGVkIG9uIHRoZSBkYXkuCiAgcm91dGluZXNDb21wbGV0ZWQgUm91dGluZVtdCn0KCi8vLyBBIG5vdGUgdGhhdCB0aGUgdXNlciBoYXMgY3JlYXRlZC4KbW9kZWwgTm90ZSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgbm90ZQogIGlkICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgbm90ZQogIGNyZWF0ZWRBdCBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIG5vdGUgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIHRoZSBub3RlIHdhcyBjcmVhdGVkCiAgZGF0ZSAgICAgIERhdGVUaW1lIEBkYi5EYXRlCiAgLy8vIFRoZSBkYXkgdGhlIG5vdGUgd2FzIGNyZWF0ZWQKICBkYXkgICAgICAgRGF5ICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2RhdGVdLCByZWZlcmVuY2VzOiBbZGF0ZV0pCiAgLy8vIFRoZSBzbHVnIG9mIHRoZSBub3RlIHdoaWNoIG5lZWRzIHRvIGJlIHVuaXF1ZS4KICAvLy8gSXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIG5vdGUgYW5kIHVwZGF0ZSBpdC4KICBzbHVnICAgICAgU3RyaW5nICAgQHVuaXF1ZQogIC8vLyBUaGUgdGl0bGUgb2YgdGhlIG5vdGUKICB0aXRsZSAgICAgU3RyaW5nCiAgLy8vIFRoZSBjb250ZW50IG9mIHRoZSBub3RlIGluIEhUTUwuIElmIGl0J3MgdGV4dCAoaS5lLiBvbmUgbGluZSksCiAgLy8vIGl0IHdpbGwgbW9zdCBsaWtlbHkgYmUgY29udmVydGVkIHRvIEhUTUwgYnkgdGhlIFRpcFRhcCBlZGl0b3IuCiAgY29udGVudCAgIFN0cmluZwoKICAvLy8gVGhlIHRhZ3Mgb2YgdGhlIG5vdGUKICB0YWdzIE5vdGVUYWdbXQp9CgovLy8gQSB0YWcgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIG5vdGUuCm1vZGVsIE5vdGVUYWcgewogIC8vLyBUaGUgaWQgb2YgdGhlIG5vdGUgdGFnCiAgaWQgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSBub3RlIHRhZwogIGNyZWF0ZWRBdCBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIG5vdGUgdGFnIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgRGF0ZVRpbWUgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm90ZSB0YWcKICBuYW1lICAgICAgU3RyaW5nCiAgLy8vIFRoZSBzbHVnIChpLmUuIHRoZSB1cmwtc2FmZSB2ZXJzaW9uKSBvZiB0aGUgbm90ZSB0YWcgbmFtZQogIHNsdWcgICAgICBTdHJpbmcgICBAdW5pcXVlCiAgLy8vIFRoZSBjb2xvciBvZiB0aGUgbm90ZSB0YWcgaW4gaGV4CiAgY29sb3IgICAgIENvbG9yCiAgLy8vIFdoZXRoZXIgbm90ZXMgd2l0aCB0aGlzIHRhZyBzaG91bGQgYmUgcHJpdmF0ZS4gKGRlZmF1bHQ6IHRydWUpCiAgaXNQcml2YXRlIEJvb2xlYW4gIEBkZWZhdWx0KHRydWUpCgogIC8vLyBUaGUgbm90ZXMgd2l0aCB0aGlzIHRhZwogIG5vdGVzIE5vdGVbXQp9CgovLy8gQSB0YXNrIHRoYXQgdGhlIHVzZXIgb3IgYSBwbHVnaW4gaGFzIGNyZWF0ZWQuCm1vZGVsIFRhc2sgewogIC8vLyBUaGUgaWQgb2YgdGhlIHRhc2suCiAgaWQgICAgICAgICAgICAgICAgSW50ICAgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgdGFzawogIGNyZWF0ZWRBdCAgICAgICAgIERhdGVUaW1lICAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSB0YXNrIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICAgICAgICBEYXRlVGltZSAgIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIHRpdGxlIG9mIHRoZSB0YXNrIGluIHRleHQgb3IgSFRNTC4KICB0aXRsZSAgICAgICAgICAgICBTdHJpbmcKICAvLy8gVGhlIHN0YXR1cyBvZiB0aGUgdGFzawogIHN0YXR1cyAgICAgICAgICAgIFRhc2tTdGF0dXMgQGRlZmF1bHQoVE9ETykKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIHRhc2sgd2FzIGNvbXBsZXRlZC4KICBjb21wbGV0ZWRBdCAgICAgICBEYXRlVGltZT8gIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXkgdGhlIHRhc2sgaXMgc2NoZWR1bGVkIGZvcgogIGRheSAgICAgICAgICAgICAgIERheSAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2RhdGVdLCByZWZlcmVuY2VzOiBbZGF0ZV0pCiAgLy8vIFRoZSBkYXRlIHRoZSB0YXNrIGlzIHNjaGVkdWxlZCBmb3IKICBkYXRlICAgICAgICAgICAgICBEYXRlVGltZSAgIEBkYi5EYXRlCiAgLy8vIFRoZSBsZW5ndGggb2YgdGltZSB0aGUgdGFzayBpcyBleHBlY3RlZCB0byB0YWtlLgogIGR1cmF0aW9uSW5NaW51dGVzIEludD8KCiAgLy8vIFRoZSBpdGVtIGxpbmtlZCB0byB0aGUgdGFzawogIGl0ZW0gICBJdGVtPyBAcmVsYXRpb24oZmllbGRzOiBbaXRlbUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICBpdGVtSWQgSW50PwoKICAvLy8gVGhlIHBhcmVudCB0YXNrIG9mIHRoZSB0YXNrCiAgcGFyZW50VGFzayAgIFRhc2s/IEByZWxhdGlvbigiU3VidGFzayIsIGZpZWxkczogW3BhcmVudFRhc2tJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgcGFyZW50VGFza0lkIEludD8KCiAgLy8vIFRoZSBzdWJ0YXNrcyBvZiB0aGUgdGFzawogIHN1YnRhc2tzICAgIFRhc2tbXSAgICAgICAgICAgQHJlbGF0aW9uKCJTdWJ0YXNrIikKICAvLy8gVGhlIHRhZ3Mgb2YgdGhlIHRhc2sgCiAgdGFncyAgICAgICAgVGFza1RhZ1tdCiAgLy8vIFRoZSBwbHVnaW4gZGF0YXMgb2YgdGhlIHRhc2sKICBwbHVnaW5EYXRhcyBUYXNrUGx1Z2luRGF0YVtdCn0KCi8vIFRoZSBkZXNjcmlwdGlvbiBvZiBlYWNoIGVudW0gdmFsdWUgaXMgY29waWVkIGludG8gc3JjL2dyYXBocWwvVGFzay50cwovLy8gVGhlIHN0YXR1cyBvZiBhIHRhc2sKZW51bSBUYXNrU3RhdHVzIHsKICAvLy8gV2hlbiB0aGUgdGFzayBpcyBwbGFubmVkIG9yIGluIHByb2dyZXNzLgogIFRPRE8KICAvLy8gV2hlbiB0aGUgdGFzayBpcyBkb25lLgogIERPTkUKICAvLy8gV2hlbiB0aGUgdGFzayB3YXMgZGVjaWRlZCBub3QgdG8gYmUgZG9uZSBhbnltb3JlLgogIENBTkNFTEVECn0KCi8vLyBBIHRhZyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGEgdGFzay4KbW9kZWwgVGFza1RhZyB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgdGFzayB0YWcKICBpZCAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIHRhc2sgdGFnCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgdGFzayB0YWcgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBuYW1lIG9mIHRoZSB0YXNrIHRhZwogIG5hbWUgICAgICBTdHJpbmcKICAvLy8gVGhlIHNsdWcgKGkuZS4gdGhlIHVybC1zYWZlIHZlcnNpb24pIG9mIHRoZSB0YXNrIHRhZyBuYW1lCiAgc2x1ZyAgICAgIFN0cmluZyAgIEB1bmlxdWUKICAvLy8gVGhlIGNvbG9yIG9mIHRoZSB0YXNrIHRhZwogIGNvbG9yICAgICBDb2xvcgogIC8vLyBXaGV0aGVyIHRhc2tzIHdpdGggdGhpcyB0YWcgc2hvdWxkIGJlIHByaXZhdGUuIChkZWZhdWx0OiB0cnVlKQogIGlzUHJpdmF0ZSBCb29sZWFuICBAZGVmYXVsdCh0cnVlKQoKICB0YXNrcyBUYXNrW10KfQoKLy8vIFRoZSBkYXRhIHJlcXVpcmVkIGJ5IGEgcGx1Z2luIHRvIGJlIGxpbmtlZCB0byBhIHRhc2suCm1vZGVsIFRhc2tQbHVnaW5EYXRhIHsKICAvLy8gVGhlIGlkIG9mIHRoZSB0YXNrIHBsdWdpbiBkYXRhCiAgaWQgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgdGFzayBwbHVnaW4gZGF0YQogIGNyZWF0ZWRBdCAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSB0YXNrIHBsdWdpbiBkYXRhIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgIERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIG1pbmltdW0gZGF0YSByZXF1aXJlZCB0byByZW5kZXIgdGhlIGluZm9ybWF0aW9uIG9uIHRhc2sgY2FyZHMuCiAgbWluICAgICAgICBKc29uCiAgLy8vIFRoZSBmdWxsIGRhdGEgcmVxdWlyZWQgYnkgdGhlIHBsdWdpbiB0byBiZSBsaW5rZWQgdG8gdGhlIHRhc2suCiAgZnVsbCAgICAgICBKc29uCiAgLy8vIFRoZSBzbHVnIG9mIHRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBkYXRhCiAgcGx1Z2luU2x1ZyBTdHJpbmcKICAvLy8gVGhlIG9yaWdpbmFsIGlkIG9mIHRoZSB0YXNrIGdpdmVuIGJ5IHRoZSBwbHVnaW4sIGlmIGFueQogIG9yaWdpbmFsSWQgU3RyaW5nPwoKICAvLy8gVGhlIHRhc2sgbGlua2VkIHRvIHRoZSBwbHVnaW4gZGF0YQogIHRhc2sgICBUYXNrIEByZWxhdGlvbihmaWVsZHM6IFt0YXNrSWRdLCByZWZlcmVuY2VzOiBbaWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKICB0YXNrSWQgSW50Cn0KCi8vLyBUaGUgZGF0YSBhIHBsdWdpbiBsaW5rcyB0byBhbiBpdGVtLgptb2RlbCBJdGVtUGx1Z2luRGF0YSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgaXRlbSBwbHVnaW4gZGF0YQogIGlkICAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIGl0ZW0gcGx1Z2luIGRhdGEKICBjcmVhdGVkQXQgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgaXRlbSBwbHVnaW4gZGF0YSB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0ICBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBtaW5pbXVtIGRhdGEgcmVxdWlyZWQgdG8gcmVuZGVyIHRoZSBpbmZvcm1hdGlvbiBvbiBpdGVtIGNhcmRzLgogIG1pbiAgICAgICAgSnNvbgogIC8vLyBUaGUgZnVsbCBkYXRhIHJlcXVpcmVkIGJ5IHRoZSBwbHVnaW4gdG8gYmUgbGlua2VkIHRvIHRoZSBpdGVtLgogIGZ1bGwgICAgICAgSnNvbgogIC8vLyBUaGUgc2x1ZyBvZiB0aGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgZGF0YQogIHBsdWdpblNsdWcgU3RyaW5nCiAgLy8vIFRoZSBvcmlnaW5hbCBpZCBvZiB0aGUgaXRlbSBnaXZlbiBieSB0aGUgcGx1Z2luLCBpZiBhbnkKICBvcmlnaW5hbElkIFN0cmluZz8KCiAgLy8vIFRoZSBpdGVtIGxpbmtlZCB0byB0aGUgcGx1Z2luIGRhdGEKICBpdGVtICAgSXRlbSBAcmVsYXRpb24oZmllbGRzOiBbaXRlbUlkXSwgcmVmZXJlbmNlczogW2lkXSwgb25EZWxldGU6IENhc2NhZGUpCiAgaXRlbUlkIEludAp9CgovLy8gQW4gaXRlbSBjcmVhdGVkIGJ5IHRoZSB1c2VyIG9yIGEgcGx1Z2luLiBUaGUgdXNlciBjYW4gdGhlbiBjcmVhdGUgMSBvciBtb3JlIHRhc2tzIGZyb20gdGhlIGl0ZW0uCi8vLyBJdCBjYW4gYmUgYSBjYWxlbmRhciBldmVudCwgYSBUcmVsbG8gdGFzaywgYSBMaW5lYXIgaXNzdWUsIGEgR2l0SHViIHJlcXVlc3QgZm9yIHJldmlldywgYSBub3RpZmljYXRpb24sIGV0Yy4KbW9kZWwgSXRlbSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgaXRlbQogIGlkICAgICAgICAgICAgICAgIEludCAgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgaXRlbQogIGNyZWF0ZWRBdCAgICAgICAgIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIGl0ZW0gd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCAgICAgICAgIERhdGVUaW1lICBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSB0aXRsZSBvZiB0aGUgaXRlbS4KICAvLy8gSXQgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCB0aXRsZSB3aGVuIGNyZWF0aW5nIGEgdGFzayBmcm9tIHRoZSBpdGVtLgogIHRpdGxlICAgICAgICAgICAgIFN0cmluZwogIC8vLyBXaGV0aGVyIHRoZSBpdGVtIGlzIHJlbGV2YW50IHRvIHRoZSB1c2VyIGFuZCBzaG91bGQgYmUgc2hvd24uIChkZWZhdWx0OiB0cnVlKQogIC8vLyBGb3IgZXhhbXBsZSB3aGVuIGEgcGx1Z2luIGNyZWF0ZXMgYW4gaXRlbSBmb3IgYSBUcmVsbG8gdGFzaywgdGhlbiBsYXRlciBvbiB0aGUgdXNlciBhcmhpdmVzIHRoZSB0YXNrLCB0aGUgaXRlbSBpcyBubyBsb25nZXIgcmVsZXZhbnQuCiAgaXNSZWxldmFudCAgICAgICAgQm9vbGVhbiAgIEBkZWZhdWx0KHRydWUpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBpdGVtIGlzIHNjaGVkdWxlZCBmb3IuCiAgc2NoZWR1bGVkQXQgICAgICAgRGF0ZVRpbWU/IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBsZW5ndGggb2YgdGltZSB0aGUgaXRlbSBpcyBleHBlY3RlZCB0byB0YWtlLiBJZiB0aGUgaXRlbSBpcyBhbGwtZGF5LCB0aGlzIGlzIG51bGwuCiAgZHVyYXRpb25Jbk1pbnV0ZXMgSW50PwogIC8vLyBXaGV0aGVyIHRoZSBpdGVtIGlzIGFsbC1kYXkgb24gdGhlIGRhdGUgb2YgYHNjaGVkdWxlZEF0YC4KICBpc0FsbERheSAgICAgICAgICBCb29sZWFuICAgQGRlZmF1bHQoZmFsc2UpCiAgLy8vIFRoZSB0YWlsd2luZCBjb2xvciBvZiB0aGUgaXRlbS4gVXNlZCBpbiB0aGUgY2FsZW5kYXIgdmlldy4KICBjb2xvciAgICAgICAgICAgICBDb2xvcj8KICAvLy8gVGhlIG51bWJlciBvZiBpbmJveCBwb2ludHMgdGhlIGl0ZW0gaGFzIHRvIGJlIHNob3duIGluIHRoZSBpbmJveC4KICAvLy8gVGhlIG1vcmUgaW5ib3ggcG9pbnRzIGFuIGl0ZW0gaGFzLCB0aGUgaGlnaGVyIGl0IGlzIGluIHRoZSBpbmJveC4KICBpbmJveFBvaW50cyAgICAgICBJbnQ/CgogIC8vLyBUaGUgdGFza3MgbGlua2VkIHRvIHRoZSBpdGVtCiAgdGFza3MgICAgICAgVGFza1tdCiAgLy8vIFRoZSBwbHVnaW4gZGF0YXMgbGlua2VkIHRvIHRoZSBpdGVtCiAgcGx1Z2luRGF0YXMgSXRlbVBsdWdpbkRhdGFbXQogIC8vLyBUaGUgbGlzdCBpbiB3aGljaCB0aGUgaXRlbSBpcyBpbgogIGxpc3QgICAgICAgIExpc3Q/ICAgICAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2xpc3RJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgbGlzdElkICAgICAgSW50Pwp9CgovLy8gTGlzdCBvZiBpdGVtcwptb2RlbCBMaXN0IHsKICAvLy8gVGhlIGlkIG9mIHRoZSBsaXN0CiAgaWQgICAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIGxpc3QKICBjcmVhdGVkQXQgICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIGxpc3Qgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCAgIERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIG5hbWUgb2YgdGhlIGxpc3QKICBuYW1lICAgICAgICBTdHJpbmcKICAvLy8gVGhlIHNsdWcgKGkuZS4gdGhlIHVybC1zYWZlIHZlcnNpb24pIG9mIHRoZSBsaXN0IG5hbWUKICBzbHVnICAgICAgICBTdHJpbmcgICBAdW5pcXVlCiAgLy8vIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdAogIGRlc2NyaXB0aW9uIFN0cmluZz8KCiAgLy8vIFRoZSBpdGVtcyBsaW5rZWQgdG8gdGhlIGxpc3QKICBpdGVtcyBJdGVtW10KfQoKLy8vIEEga2V5LXZhbHVlIHN0b3JlIGNvbnRhaW5pbmcgc2V0dGluZ3MgdGhlIHVzZXIgaGFzIG1vZGlmaWVkIGZvciBib3RoIEZsb3cgYW5kIHBsdWdpbnMgKGJ5IGNvbnZlbnRpb24sIHRoZSBrZXkgaXMgcHJlZml4ZWQgd2l0aCB0aGUgcGx1Z2luJ3Mgc2x1ZyksIG9yIGNvbmZpZ3MgYW5kIHNlY3JlbnRzIHRoYXQgcGx1Z2lucyBoYXZlIHN0b3JlZCBzdWNoIGFzIEFQSSBrZXlzLgptb2RlbCBTdG9yZSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgc3RvcmUgaXRlbQogIGlkICAgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgc3RvcmUgaXRlbQogIGNyZWF0ZWRBdCAgICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIHN0b3JlIGl0ZW0gd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCAgICBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBrZXkgb2YgdGhlIHN0b3JlIGl0ZW0KICBrZXkgICAgICAgICAgU3RyaW5nCiAgLy8vIFRoZSB2YWx1ZSBvZiB0aGUgc3RvcmUgaXRlbQogIHZhbHVlICAgICAgICBKc29uCiAgLy8vIFRoZSBzbHVnIG9mIHRoZSBwbHVnaW4gdGhlIHN0b3JlIGl0ZW0gaXMgbGlua2VkIHRvLgogIHBsdWdpblNsdWcgICBTdHJpbmcKICAvLy8gV2hldGhlciB0aGUgc3RvcmUgaXRlbSBpcyBzZWNyZXQuCiAgLy8vIFNlY3JldCBpdGVtcyBhcmUgYXV0b21hdGljYWxseSBzZXJ2ZXItb25seSBhcyB3ZWxsIChldmVuIGlmIHRoZSB2YWx1ZSBvZiBpc1NlcnZlck9ubHkgaXMgZmFsc2UpCiAgLy8vIGFuZCBjYW4gb25seSBiZSBhY2Nlc3NlZCBieSB0aGUgcGx1Z2luIHdpdGggdGhlIHNhbWUgcGx1Z2luU2x1Zy4KICBpc1NlY3JldCAgICAgQm9vbGVhbiAgQGRlZmF1bHQoZmFsc2UpCiAgLy8vIFdoZXRoZXIgdGhlIHN0b3JlIGl0ZW0gaXMgc2VydmVyLW9ubHkuCiAgLy8vIFNlcnZlci1vbmx5IGl0ZW1zIGFyZSBub3Qgc2VudCB0byB0aGUgY2xpZW50LgogIGlzU2VydmVyT25seSBCb29sZWFuICBAZGVmYXVsdChmYWxzZSkKCiAgQEB1bmlxdWUoW3BsdWdpblNsdWcsIGtleV0sIG5hbWU6ICJwbHVnaW5TbHVnX2tleV91bmlxdWUiKQp9CgovLy8gQSByb3V0aW5lIHRoZSB1c2VyIGhhcyBzZXQgdXAuCm1vZGVsIFJvdXRpbmUgewogIC8vLyBUaGUgaWQgb2YgdGhlIHJvdXRpbmUKICBpZCAgICAgICAgICAgICAgSW50ICAgICAgICAgICAgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgcm91dGluZQogIGNyZWF0ZWRBdCAgICAgICBEYXRlVGltZSAgICAgICAgICAgIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgcm91dGluZSB3YXMgbGFzdCB1cGRhdGVkCiAgdXBkYXRlZEF0ICAgICAgIERhdGVUaW1lICAgICAgICAgICAgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbmFtZSBvZiB0aGUgcm91dGluZQogIG5hbWUgICAgICAgICAgICBTdHJpbmcKICAvLy8gQWN0aW9uIG5hbWUgdXNlZCBvbiB0aGUgYnV0dG9uIHRvIHN0YXJ0IHRoZSByb3V0aW5lCiAgYWN0aW9uTmFtZSAgICAgIFN0cmluZwogIC8vLyBUaGUgdGltZSB0aGUgcm91dGluZSB0YWtlcyBwbGFjZQogIHRpbWUgICAgICAgICAgICBEYXRlVGltZSAgICAgICAgICAgIEBkYi5UaW1lKDApCiAgLy8vIFRoZSBwYXR0ZXJuKHMpIHRoZSByb3V0aW5lIHJlcGVhdHMgb24KICByZXBlYXRzICAgICAgICAgUmVwZXRpdGlvblBhdHRlcm5bXQogIC8vLyBUaGUgZGF0ZSB0aGUgcm91dGluZSBzdGFydHMgcmVwZWF0aW5nIGZyb20KICBmaXJzdERheSAgICAgICAgRGF0ZVRpbWUgICAgICAgICAgICBAZGVmYXVsdChub3coKSkgQGRiLkRhdGUKICAvLy8gVGhlIGRhdGUgdGhlIHJvdXRpbmUgZW5kIHJlcGVhdGluZyBvbgogIGxhc3REYXkgICAgICAgICBEYXRlVGltZT8gICAgICAgICAgIEBkYi5EYXRlCiAgLy8vIFdoZXRoZXIgdGhlIHJvdXRpbmUgaXMgYWN0aXZlLiBUaGlzIGNhbiBiZSB1c2VkIHRvIHBhdXNlIGEgcm91dGluZS4KICBpc0FjdGl2ZSAgICAgICAgQm9vbGVhbiAgICAgICAgICAgICBAZGVmYXVsdCh0cnVlKQogIC8vLyBUaGUgc3RlcHMgb2YgdGhlIHJvdXRpbmUuCiAgLy8vIEEgbGlzdCBvZiBzdHJpbmdzIGluIHRoZSBmb3JtYXQgYFsnZmxvdycgb3IgcGx1Z2luU2x1Z11fW3N0ZXBTbHVnXV9bc2hvdWxkU2tpcF1gLgogIHN0ZXBzICAgICAgICAgICBTdHJpbmdbXQogIC8vLyBUaGUgZGF5cyB0aGUgcm91dGluZSBoYXMgYmVlbiBjb21wbGV0ZWQgb24uCiAgZGF5c0NvbXBsZXRlZE9uIERheVtdCn0KCmVudW0gUmVwZXRpdGlvblBhdHRlcm4gewogIE1PTkRBWQogIFRVRVNEQVkKICBXRURORVNEQVkKICBUSFVSU0RBWQogIEZSSURBWQogIFNBVFVSREFZCiAgU1VOREFZCgogIC8vIGZvbGxvd2luZyB3aWxsIGJlIGFkZGVkIGxhdGVyCiAgLy8gQklXRUVLTFlfTU9OREFZCiAgLy8gQklXRUVLTFlfVFVFU0RBWQogIC8vIEJJV0VFS0xZX1dFRE5FU0RBWQogIC8vIEJJV0VFS0xZX1RIVVJTREFZCiAgLy8gQklXRUVLTFlfRlJJREFZCiAgLy8gQklXRUVLTFlfU0FUVVJEQVkKICAvLyBCSVdFRUtMWV9TVU5EQVkKICAvLyBUUklXRUVLTFlfTU9OREFZCiAgLy8gVFJJV0VFS0xZX1RVRVNEQVkKICAvLyBUUklXRUVLTFlfV0VETkVTREFZCiAgLy8gVFJJV0VFS0xZX1RIVVJTREFZCiAgLy8gVFJJV0VFS0xZX0ZSSURBWQogIC8vIFRSSVdFRUtMWV9TQVRVUkRBWQogIC8vIFRSSVdFRUtMWV9TVU5EQVkKICAvLyBGSVJTVF9PRl9NT05USAogIC8vIExBU1RfT0ZfTU9OVEgKfQoKLy8vIFRhaWx3aW5kQ1NTIGNvbG9ycy4gVXNlZnVsIHRvIGdlbmVyYXRlIGEgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBmcm9tIGVhY2ggY29sb3IsCi8vLyBpbnN0ZWFkIG9mIGhhdmluZyBpbmRlcGVuZGVudCBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9ycwplbnVtIENvbG9yIHsKICBzbGF0ZQogIGdyYXkKICB6aW5jCiAgbmV1dHJhbAogIHN0b25lCiAgcmVkCiAgb3JhbmdlCiAgYW1iZXIKICB5ZWxsb3cKICBsaW1lCiAgZ3JlZW4KICBlbWVyYWxkCiAgdGVhbAogIGN5YW4KICBza3kKICBibHVlCiAgaW5kaWdvCiAgdmlvbGV0CiAgcHVycGxlCiAgZnVjaHNpYQogIHBpbmsKICByb3NlCn0K",
    inlineSchemaHash: "ef1a25d1663a172111fbe7f5b3aefb596990b18194057114e011144751a06f19",
    noEngine: false
  };
  var fs = import.meta.require("fs");
  config.dirname = import.meta.dir;
  if (!fs.existsSync(path.join(import.meta.dir, "schema.prisma"))) {
    const alternativePaths = [
      "../../node_modules/.prisma/client",
      "../node_modules/.prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config.dirname = path.join(process.cwd(), alternativePath);
    config.isBundled = true;
  }
  config.runtimeDataModel = JSON.parse("{\"models\":{\"Day\":{\"dbName\":null,\"fields\":[{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date of the day, which acts as the ID\"},{\"name\":\"tasksOrder\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The order of the tasks in the day\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"DayToTask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the day.\"},{\"name\":\"notes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Note\",\"relationName\":\"DayToNote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The notes linked to the day.\"},{\"name\":\"routinesCompleted\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Routine\",\"relationName\":\"DayToRoutine\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The routines completed on the day.\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A day a user has planned or already done.\\\\nDays that have not yet been planned are virtually created in the GraphQL API.\"},\"Note\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the note\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the note\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the note was last updated\"},{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the note was created\"},{\"name\":\"day\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToNote\",\"relationFromFields\":[\"date\"],\"relationToFields\":[\"date\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The day the note was created\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the note which needs to be unique.\\\\nIt can be used to retrieve the note and update it.\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the note\"},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The content of the note in HTML. If it's text (i.e. one line),\\\\nit will most likely be converted to HTML by the TipTap editor.\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"NoteTag\",\"relationName\":\"NoteToNoteTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags of the note\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A note that the user has created.\"},\"NoteTag\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the note tag\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the note tag\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the note tag was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the note tag\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the note tag name\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The color of the note tag in hex\"},{\"name\":\"isPrivate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether notes with this tag should be private. (default: true)\"},{\"name\":\"notes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Note\",\"relationName\":\"NoteToNoteTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The notes with this tag\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A tag that can be applied to a note.\"},\"Task\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task.\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task was last updated\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the task in text or HTML.\"},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"TaskStatus\",\"default\":\"TODO\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The status of the task\"},{\"name\":\"completedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time the task was completed.\"},{\"name\":\"day\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToTask\",\"relationFromFields\":[\"date\"],\"relationToFields\":[\"date\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The day the task is scheduled for\"},{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the task is scheduled for\"},{\"name\":\"durationInMinutes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The length of time the task is expected to take.\"},{\"name\":\"item\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToTask\",\"relationFromFields\":[\"itemId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The item linked to the task\"},{\"name\":\"itemId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"parentTask\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"Subtask\",\"relationFromFields\":[\"parentTaskId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The parent task of the task\"},{\"name\":\"parentTaskId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"subtasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"Subtask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The subtasks of the task\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskTag\",\"relationName\":\"TaskToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags of the task \"},{\"name\":\"pluginDatas\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskPluginData\",\"relationName\":\"TaskToTaskPluginData\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin datas of the task\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A task that the user or a plugin has created.\"},\"TaskTag\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task tag\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task tag\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task tag was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the task tag\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the task tag name\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The color of the task tag\"},{\"name\":\"isPrivate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether tasks with this tag should be private. (default: true)\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"TaskToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A tag that can be applied to a task.\"},\"TaskPluginData\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task plugin data\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task plugin data\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task plugin data was last updated\"},{\"name\":\"min\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The minimum data required to render the information on task cards.\"},{\"name\":\"full\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The full data required by the plugin to be linked to the task.\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin that created the data\"},{\"name\":\"originalId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The original id of the task given by the plugin, if any\"},{\"name\":\"task\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"TaskToTaskPluginData\",\"relationFromFields\":[\"taskId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The task linked to the plugin data\"},{\"name\":\"taskId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"The data required by a plugin to be linked to a task.\"},\"ItemPluginData\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the item plugin data\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the item plugin data\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the item plugin data was last updated\"},{\"name\":\"min\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The minimum data required to render the information on item cards.\"},{\"name\":\"full\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The full data required by the plugin to be linked to the item.\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin that created the data\"},{\"name\":\"originalId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The original id of the item given by the plugin, if any\"},{\"name\":\"item\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToItemPluginData\",\"relationFromFields\":[\"itemId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The item linked to the plugin data\"},{\"name\":\"itemId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"The data a plugin links to an item.\"},\"Item\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the item\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the item\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the item was last updated\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the item.\\\\nIt is used as the initial title when creating a task from the item.\"},{\"name\":\"isRelevant\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the item is relevant to the user and should be shown. (default: true)\\\\nFor example when a plugin creates an item for a Trello task, then later on the user arhives the task, the item is no longer relevant.\"},{\"name\":\"scheduledAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time the item is scheduled for.\"},{\"name\":\"durationInMinutes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The length of time the item is expected to take. If the item is all-day, this is null.\"},{\"name\":\"isAllDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the item is all-day on the date of `scheduledAt`.\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tailwind color of the item. Used in the calendar view.\"},{\"name\":\"inboxPoints\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The number of inbox points the item has to be shown in the inbox.\\\\nThe more inbox points an item has, the higher it is in the inbox.\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"ItemToTask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the item\"},{\"name\":\"pluginDatas\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"ItemPluginData\",\"relationName\":\"ItemToItemPluginData\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin datas linked to the item\"},{\"name\":\"list\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"List\",\"relationName\":\"ItemToList\",\"relationFromFields\":[\"listId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The list in which the item is in\"},{\"name\":\"listId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"An item created by the user or a plugin. The user can then create 1 or more tasks from the item.\\\\nIt can be a calendar event, a Trello task, a Linear issue, a GitHub request for review, a notification, etc.\"},\"List\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the list\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the list\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the list was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the list\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the list name\"},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The description of the list\"},{\"name\":\"items\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToList\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The items linked to the list\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"List of items\"},\"Store\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the store item\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the store item\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the store item was last updated\"},{\"name\":\"key\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The key of the store item\"},{\"name\":\"value\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The value of the store item\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin the store item is linked to.\"},{\"name\":\"isSecret\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the store item is secret.\\\\nSecret items are automatically server-only as well (even if the value of isServerOnly is false)\\\\nand can only be accessed by the plugin with the same pluginSlug.\"},{\"name\":\"isServerOnly\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the store item is server-only.\\\\nServer-only items are not sent to the client.\"}],\"primaryKey\":null,\"uniqueFields\":[[\"pluginSlug\",\"key\"]],\"uniqueIndexes\":[{\"name\":\"pluginSlug_key_unique\",\"fields\":[\"pluginSlug\",\"key\"]}],\"isGenerated\":false,\"documentation\":\"A key-value store containing settings the user has modified for both Flow and plugins (by convention, the key is prefixed with the plugin's slug), or configs and secrents that plugins have stored such as API keys.\"},\"Routine\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the routine\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the routine\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the routine was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the routine\"},{\"name\":\"actionName\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Action name used on the button to start the routine\"},{\"name\":\"time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The time the routine takes place\"},{\"name\":\"repeats\",\"kind\":\"enum\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"RepetitionPattern\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The pattern(s) the routine repeats on\"},{\"name\":\"firstDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the routine starts repeating from\"},{\"name\":\"lastDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the routine end repeating on\"},{\"name\":\"isActive\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the routine is active. This can be used to pause a routine.\"},{\"name\":\"steps\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The steps of the routine.\\\\nA list of strings in the format `['flow' or pluginSlug]_[stepSlug]_[shouldSkip]`.\"},{\"name\":\"daysCompletedOn\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToRoutine\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The days the routine has been completed on.\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A routine the user has set up.\"}},\"enums\":{\"TaskStatus\":{\"values\":[{\"name\":\"TODO\",\"dbName\":null,\"documentation\":\"When the task is planned or in progress.\"},{\"name\":\"DONE\",\"dbName\":null,\"documentation\":\"When the task is done.\"},{\"name\":\"CANCELED\",\"dbName\":null,\"documentation\":\"When the task was decided not to be done anymore.\"}],\"dbName\":null,\"documentation\":\"The status of a task\"},\"RepetitionPattern\":{\"values\":[{\"name\":\"MONDAY\",\"dbName\":null},{\"name\":\"TUESDAY\",\"dbName\":null},{\"name\":\"WEDNESDAY\",\"dbName\":null},{\"name\":\"THURSDAY\",\"dbName\":null},{\"name\":\"FRIDAY\",\"dbName\":null},{\"name\":\"SATURDAY\",\"dbName\":null},{\"name\":\"SUNDAY\",\"dbName\":null}],\"dbName\":null},\"Color\":{\"values\":[{\"name\":\"slate\",\"dbName\":null},{\"name\":\"gray\",\"dbName\":null},{\"name\":\"zinc\",\"dbName\":null},{\"name\":\"neutral\",\"dbName\":null},{\"name\":\"stone\",\"dbName\":null},{\"name\":\"red\",\"dbName\":null},{\"name\":\"orange\",\"dbName\":null},{\"name\":\"amber\",\"dbName\":null},{\"name\":\"yellow\",\"dbName\":null},{\"name\":\"lime\",\"dbName\":null},{\"name\":\"green\",\"dbName\":null},{\"name\":\"emerald\",\"dbName\":null},{\"name\":\"teal\",\"dbName\":null},{\"name\":\"cyan\",\"dbName\":null},{\"name\":\"sky\",\"dbName\":null},{\"name\":\"blue\",\"dbName\":null},{\"name\":\"indigo\",\"dbName\":null},{\"name\":\"violet\",\"dbName\":null},{\"name\":\"purple\",\"dbName\":null},{\"name\":\"fuchsia\",\"dbName\":null},{\"name\":\"pink\",\"dbName\":null},{\"name\":\"rose\",\"dbName\":null}],\"dbName\":null,\"documentation\":\"TailwindCSS colors. Useful to generate a foreground and background color from each color,\\\\ninstead of having independent foreground and background colors\"}},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(import.meta.dir, "libquery_engine-darwin-arm64.dylib.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-darwin-arm64.dylib.node");
  path.join(import.meta.dir, "libquery_engine-rhel-openssl-3.0.x.so.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-rhel-openssl-3.0.x.so.node");
  path.join(import.meta.dir, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(import.meta.dir, "schema.prisma");
  path.join(process.cwd(), "../../node_modules/.prisma/client/schema.prisma");
});

// /Users/richardguerre/Projects/flow/node_modules/@prisma/client/index.js
var require_client2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_client()
  };
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t2, e2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e2() : typeof define == "function" && define.amd ? define(e2) : (t2 = typeof globalThis != "undefined" ? globalThis : t2 || self).dayjs = e2();
  })(exports, function() {
    var t2 = 1000, e2 = 60000, n2 = 3600000, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f = "month", h2 = "quarter", c2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n3) {
      var r2 = String(t3);
      return !r2 || r2.length >= e3 ? t3 : "" + Array(e3 + 1 - r2.length).join(n3) + t3;
    }, v = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r2 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t(e3, n3) {
      if (e3.date() < n3.date())
        return -t(n3, e3);
      var r2 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r2, f), s3 = n3 - i2 < 0, u3 = e3.clone().add(r2 + (s3 ? -1 : 1), f);
      return +(-(r2 + (n3 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: f, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: h2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return t3 === undefined;
    } }, g = "en", D = {};
    D[g] = M;
    var p2 = function(t3) {
      return t3 instanceof _;
    }, S2 = function t(e3, n3, r2) {
      var i2;
      if (!e3)
        return g;
      if (typeof e3 == "string") {
        var s3 = e3.toLowerCase();
        D[s3] && (i2 = s3), n3 && (D[s3] = n3, i2 = s3);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t(u3[0]);
      } else {
        var a3 = e3.name;
        D[a3] = e3, i2 = a3;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, w2 = function(t3, e3) {
      if (p2(t3))
        return t3.clone();
      var n3 = typeof e3 == "object" ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _(n3);
    }, O = v;
    O.l = S2, O.i = p2, O.w = function(t3, e3) {
      return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = S2(t3.locale, null, true), this.parse(t3);
      }
      var m3 = M2.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var { date: e3, utc: n3 } = t4;
          if (e3 === null)
            return new Date(NaN);
          if (O.u(e3))
            return new Date;
          if (e3 instanceof Date)
            return new Date(e3);
          if (typeof e3 == "string" && !/Z$/i.test(e3)) {
            var r2 = e3.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return O;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = w2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return w2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < w2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return O.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r2 = !!O.u(e3) || e3, h3 = O.p(t3), l3 = function(t4, e4) {
          var i2 = O.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r2 ? i2 : i2.endOf(a2);
        }, $2 = function(t4, e4) {
          return O.w(n3.toDate()[t4].apply(n3.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M3 = this.$M, m4 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r2 ? l3(1, 0) : l3(31, 11);
          case f:
            return r2 ? l3(1, M3) : l3(0, M3 + 1);
          case o2:
            var g2 = this.$locale().weekStart || 0, D2 = (y3 < g2 ? y3 + 7 : y3) - g2;
            return l3(r2 ? m4 - D2 : m4 + (6 - D2), M3);
          case a2:
          case d2:
            return $2(v2 + "Hours", 0);
          case u2:
            return $2(v2 + "Minutes", 1);
          case s2:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = O.p(t3), h3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i] = h3 + "Seconds", n3[r] = h3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === f || o3 === c2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[O.p(t3)]();
      }, m3.add = function(r2, h3) {
        var d3, l3 = this;
        r2 = Number(r2);
        var $2 = O.p(h3), y3 = function(t3) {
          var e3 = w2(l3);
          return O.w(e3.date(e3.date() + Math.round(t3 * r2)), l3);
        };
        if ($2 === f)
          return this.set(f, this.$M + r2);
        if ($2 === c2)
          return this.set(c2, this.$y + r2);
        if ($2 === a2)
          return y3(1);
        if ($2 === o2)
          return y3(7);
        var M3 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r2 * M3;
        return O.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f2 = n3.months, h3 = function(t4, n4, i3, s4) {
          return t4 && (t4[n4] || t4(e3, r2)) || i3[n4].slice(0, s4);
        }, c3 = function(t4) {
          return O.s(s3 % 12 || 12, t4, "0");
        }, d3 = n3.meridiem || function(t4, e4, n4) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n4 ? r3.toLowerCase() : r3;
        }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f2, 3), MMMM: h3(f2, a3), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O.s(u3, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y2, function(t4, e4) {
          return e4 || $2[t4] || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r2, d3, l3) {
        var $2, y3 = O.p(d3), M3 = w2(r2), m4 = (M3.utcOffset() - this.utcOffset()) * e2, v2 = this - M3, g2 = O.m(this, M3);
        return g2 = ($2 = {}, $2[c2] = g2 / 12, $2[f] = g2, $2[h2] = g2 / 3, $2[o2] = (v2 - m4) / 604800000, $2[a2] = (v2 - m4) / 86400000, $2[u2] = v2 / n2, $2[s2] = v2 / e2, $2[i] = v2 / t2, $2)[y3] || v2, l3 ? g2 : O.a(g2);
      }, m3.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m3.$locale = function() {
        return D[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r2 = S2(t3, e3, true);
        return r2 && (n3.$L = r2), n3;
      }, m3.clone = function() {
        return O.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w2.prototype = T, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f], ["$y", c2], ["$D", d2]].forEach(function(t3) {
      T[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), w2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _, w2), t3.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t3) {
      return w2(1000 * t3);
    }, w2.en = D[g], w2.Ls = D, w2.p = {}, w2;
  });
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS((exports, module) => {
  (function(e2, t2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t2() : typeof define == "function" && define.amd ? define(t2) : (e2 = typeof globalThis != "undefined" ? globalThis : e2 || self).dayjs_plugin_customParseFormat = t2();
  })(exports, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2000);
    };
    var a2 = function(e3) {
      return function(t3) {
        this[e3] = +t3;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4)
          return 0;
        if (e4 === "Z")
          return 0;
        var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
        return n3 === 0 ? 0 : t3[0] === "+" ? -n3 : n3;
      }(e3);
    }], h2 = function(e3) {
      var t3 = o2[e3];
      return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
    }, u2 = function(e3, t3) {
      var n3, r2 = o2.meridiem;
      if (r2) {
        for (var i2 = 1;i2 <= 24; i2 += 1)
          if (e3.indexOf(r2(i2, 0, t3)) > -1) {
            n3 = i2 > 12;
            break;
          }
      } else
        n3 = e3 === (t3 ? "pm" : "PM");
      return n3;
    }, d2 = { A: [i, function(e3) {
      this.afternoon = u2(e3, false);
    }], a: [i, function(e3) {
      this.afternoon = u2(e3, true);
    }], S: [/\d/, function(e3) {
      this.milliseconds = 100 * +e3;
    }], SS: [n2, function(e3) {
      this.milliseconds = 10 * +e3;
    }], SSS: [/\d{3}/, function(e3) {
      this.milliseconds = +e3;
    }], s: [r, a2("seconds")], ss: [r, a2("seconds")], m: [r, a2("minutes")], mm: [r, a2("minutes")], H: [r, a2("hours")], h: [r, a2("hours")], HH: [r, a2("hours")], hh: [r, a2("hours")], D: [r, a2("day")], DD: [n2, a2("day")], Do: [i, function(e3) {
      var t3 = o2.ordinal, n3 = e3.match(/\d+/);
      if (this.day = n3[0], t3)
        for (var r2 = 1;r2 <= 31; r2 += 1)
          t3(r2).replace(/\[|\]/g, "") === e3 && (this.day = r2);
    }], M: [r, a2("month")], MM: [n2, a2("month")], MMM: [i, function(e3) {
      var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
        return e4.slice(0, 3);
      })).indexOf(e3) + 1;
      if (n3 < 1)
        throw new Error;
      this.month = n3 % 12 || n3;
    }], MMMM: [i, function(e3) {
      var t3 = h2("months").indexOf(e3) + 1;
      if (t3 < 1)
        throw new Error;
      this.month = t3 % 12 || t3;
    }], Y: [/[+-]?\d+/, a2("year")], YY: [n2, function(e3) {
      this.year = s2(e3);
    }], YYYY: [/\d{4}/, a2("year")], Z: f, ZZ: f };
    function c2(n3) {
      var r2, i2;
      r2 = n3, i2 = o2 && o2.formats;
      for (var s3 = (n3 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r3) {
        var o3 = r3 && r3.toUpperCase();
        return n4 || i2[r3] || e2[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
          return t4 || n5.slice(1);
        });
      })).match(t2), a3 = s3.length, f2 = 0;f2 < a3; f2 += 1) {
        var h3 = s3[f2], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
        s3[f2] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t3 = {}, n4 = 0, r3 = 0;n4 < a3; n4 += 1) {
          var i3 = s3[n4];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var { regex: o3, parser: f3 } = i3, h4 = e3.slice(r3), u4 = o3.exec(h4)[0];
            f3.call(t3, u4), e3 = e3.replace(u4, "");
          }
        }
        return function(e4) {
          var t4 = e4.afternoon;
          if (t4 !== undefined) {
            var n5 = e4.hours;
            t4 ? n5 < 12 && (e4.hours += 12) : n5 === 12 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t3), t3;
      };
    }
    return function(e3, t3, n3) {
      n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s2 = e3.parseTwoDigitYear);
      var r2 = t3.prototype, i2 = r2.parse;
      r2.parse = function(e4) {
        var { date: t4, utc: r3, args: s3 } = e4;
        this.$u = r3;
        var a3 = s3[1];
        if (typeof a3 == "string") {
          var f2 = s3[2] === true, h3 = s3[3] === true, u3 = f2 || h3, d3 = s3[2];
          h3 && (d3 = s3[2]), o2 = this.$locale(), !f2 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
            try {
              if (["x", "X"].indexOf(t5) > -1)
                return new Date((t5 === "X" ? 1000 : 1) * e5);
              var r4 = c2(t5)(e5), i3 = r4.year, o3 = r4.month, s4 = r4.day, a4 = r4.hours, f3 = r4.minutes, h4 = r4.seconds, u4 = r4.milliseconds, d4 = r4.zone, l3 = new Date, m3 = s4 || (i3 || o3 ? 1 : l3.getDate()), M2 = i3 || l3.getFullYear(), Y = 0;
              i3 && !o3 || (Y = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v = f3 || 0, D = h4 || 0, g = u4 || 0;
              return d4 ? new Date(Date.UTC(M2, Y, m3, p2, v, D, g + 60 * d4.offset * 1000)) : n4 ? new Date(Date.UTC(M2, Y, m3, p2, v, D, g)) : new Date(M2, Y, m3, p2, v, D, g);
            } catch (e6) {
              return new Date("");
            }
          }(t4, a3, r3), this.init(), d3 && d3 !== true && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a3) && (this.$d = new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1;m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M = n3.apply(this, s3);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = new Date(""));
          }
        else
          i2.call(this, e4);
      };
    };
  });
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS((exports, module) => {
  (function(t2, i) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t2 = typeof globalThis != "undefined" ? globalThis : t2 || self).dayjs_plugin_utc = i();
  })(exports, function() {
    var t2 = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e2 = /([+-]|\d\d)/g;
    return function(s2, f, n2) {
      var u2 = f.prototype;
      n2.utc = function(t3) {
        var i2 = { date: t3, utc: true, args: arguments };
        return new f(i2);
      }, u2.utc = function(i2) {
        var e3 = n2(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e3.add(this.utcOffset(), t2) : e3;
      }, u2.local = function() {
        return n2(this.toDate(), { locale: this.$L, utc: false });
      };
      var o2 = u2.parse;
      u2.parse = function(t3) {
        t3.utc && (this.$u = true), this.$utils().u(t3.$offset) || (this.$offset = t3.$offset), o2.call(this, t3);
      };
      var r = u2.init;
      u2.init = function() {
        if (this.$u) {
          var t3 = this.$d;
          this.$y = t3.getUTCFullYear(), this.$M = t3.getUTCMonth(), this.$D = t3.getUTCDate(), this.$W = t3.getUTCDay(), this.$H = t3.getUTCHours(), this.$m = t3.getUTCMinutes(), this.$s = t3.getUTCSeconds(), this.$ms = t3.getUTCMilliseconds();
        } else
          r.call(this);
      };
      var a2 = u2.utcOffset;
      u2.utcOffset = function(s3, f2) {
        var n3 = this.$utils().u;
        if (n3(s3))
          return this.$u ? 0 : n3(this.$offset) ? a2.call(this) : this.$offset;
        if (typeof s3 == "string" && (s3 = function(t3) {
          t3 === undefined && (t3 = "");
          var s4 = t3.match(i);
          if (!s4)
            return null;
          var f3 = ("" + s4[0]).match(e2) || ["-", 0, 0], n4 = f3[0], u4 = 60 * +f3[1] + +f3[2];
          return u4 === 0 ? 0 : n4 === "+" ? u4 : -u4;
        }(s3), s3 === null))
          return this;
        var u3 = Math.abs(s3) <= 16 ? 60 * s3 : s3, o3 = this;
        if (f2)
          return o3.$offset = u3, o3.$u = s3 === 0, o3;
        if (s3 !== 0) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o3 = this.local().add(u3 + r2, t2)).$offset = u3, o3.$x.$localOffset = r2;
        } else
          o3 = this.utc();
        return o3;
      };
      var h2 = u2.format;
      u2.format = function(t3) {
        var i2 = t3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h2.call(this, i2);
      }, u2.valueOf = function() {
        var t3 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 60000 * t3;
      }, u2.isUTC = function() {
        return !!this.$u;
      }, u2.toISOString = function() {
        return this.toDate().toISOString();
      }, u2.toString = function() {
        return this.toDate().toUTCString();
      };
      var l2 = u2.toDate;
      u2.toDate = function(t3) {
        return t3 === "s" && this.$offset ? n2(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l2.call(this);
      };
      var c2 = u2.diff;
      u2.diff = function(t3, i2, e3) {
        if (t3 && this.$u === t3.$u)
          return c2.call(this, t3, i2, e3);
        var s3 = this.local(), f2 = n2(t3).local();
        return c2.call(s3, f2, i2, e3);
      };
    };
  });
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS((exports, module) => {
  (function(t2, e2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e2() : typeof define == "function" && define.amd ? define(e2) : (t2 = typeof globalThis != "undefined" ? globalThis : t2 || self).dayjs_plugin_timezone = e2();
  })(exports, function() {
    var t2 = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e2 = {};
    return function(n2, i, o2) {
      var r, a2 = function(t3, n3, i2) {
        i2 === undefined && (i2 = {});
        var o3 = new Date(t3), r2 = function(t4, n4) {
          n4 === undefined && (n4 = {});
          var i3 = n4.timeZoneName || "short", o4 = t4 + "|" + i3, r3 = e2[o4];
          return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t4, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e2[o4] = r3), r3;
        }(n3, i2);
        return r2.formatToParts(o3);
      }, u2 = function(e3, n3) {
        for (var i2 = a2(e3, n3), r2 = [], u3 = 0;u3 < i2.length; u3 += 1) {
          var f2 = i2[u3], s3 = f2.type, m2 = f2.value, c2 = t2[s3];
          c2 >= 0 && (r2[c2] = parseInt(m2, 10));
        }
        var d2 = r2[3], l2 = d2 === 24 ? 0 : d2, v = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l2 + ":" + r2[4] + ":" + r2[5] + ":000", h2 = +e3;
        return (o2.utc(v).valueOf() - (h2 -= h2 % 1000)) / 60000;
      }, f = i.prototype;
      f.tz = function(t3, e3) {
        t3 === undefined && (t3 = r);
        var n3 = this.utcOffset(), i2 = this.toDate(), a3 = i2.toLocaleString("en-US", { timeZone: t3 }), u3 = Math.round((i2 - new Date(a3)) / 1000 / 60), f2 = o2(a3).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u3, true);
        if (e3) {
          var s3 = f2.utcOffset();
          f2 = f2.add(n3 - s3, "minute");
        }
        return f2.$x.$timezone = t3, f2;
      }, f.offsetName = function(t3) {
        var e3 = this.$x.$timezone || o2.tz.guess(), n3 = a2(this.valueOf(), e3, { timeZoneName: t3 }).find(function(t4) {
          return t4.type.toLowerCase() === "timezonename";
        });
        return n3 && n3.value;
      };
      var s2 = f.startOf;
      f.startOf = function(t3, e3) {
        if (!this.$x || !this.$x.$timezone)
          return s2.call(this, t3, e3);
        var n3 = o2(this.format("YYYY-MM-DD HH:mm:ss:SSS"));
        return s2.call(n3, t3, e3).tz(this.$x.$timezone, true);
      }, o2.tz = function(t3, e3, n3) {
        var i2 = n3 && e3, a3 = n3 || e3 || r, f2 = u2(+o2(), a3);
        if (typeof t3 != "string")
          return o2(t3).tz(a3);
        var s3 = function(t4, e4, n4) {
          var i3 = t4 - 60 * e4 * 1000, o3 = u2(i3, n4);
          if (e4 === o3)
            return [i3, e4];
          var r2 = u2(i3 -= 60 * (o3 - e4) * 1000, n4);
          return o3 === r2 ? [i3, o3] : [t4 - 60 * Math.min(o3, r2) * 1000, Math.max(o3, r2)];
        }(o2.utc(t3, i2).valueOf(), f2, a3), m2 = s3[0], c2 = s3[1], d2 = o2(m2).utcOffset(c2);
        return d2.$x.$timezone = a3, d2;
      }, o2.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o2.tz.setDefault = function(t3) {
        r = t3;
      };
    };
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/plans.js
var require_plans = __commonJS((exports, module) => {
  var locked = function(schema3, query3) {
    if (Array.isArray(query3)) {
      query3 = query3.join(";\n");
    }
    return `
    BEGIN;
    SET LOCAL statement_timeout = '30s';
    ${advisoryLock(schema3)};
    ${query3};
    COMMIT;
  `;
  };
  var create4 = function(schema3, version2) {
    const commands = [
      createSchema(schema3),
      createVersionTable(schema3),
      createJobStateEnum(schema3),
      createJobTable(schema3),
      cloneJobTableForArchive(schema3),
      createScheduleTable(schema3),
      createSubscriptionTable(schema3),
      addIdIndexToArchive(schema3),
      addArchivedOnToArchive(schema3),
      addArchivedOnIndexToArchive(schema3),
      createIndexJobName(schema3),
      createIndexJobFetch(schema3),
      createIndexSingletonOn(schema3),
      createIndexSingletonKeyOn(schema3),
      createIndexSingletonKey(schema3),
      createIndexSingletonQueue(schema3),
      insertVersion(schema3, version2)
    ];
    return locked(schema3, commands);
  };
  var createSchema = function(schema3) {
    return `
    CREATE SCHEMA IF NOT EXISTS ${schema3}
  `;
  };
  var createVersionTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.version (
      version int primary key,
      maintained_on timestamp with time zone,
      cron_on timestamp with time zone
    )
  `;
  };
  var createJobStateEnum = function(schema3) {
    return `
    CREATE TYPE ${schema3}.job_state AS ENUM (
      '${states.created}',
      '${states.retry}',
      '${states.active}',
      '${states.completed}',
      '${states.expired}',
      '${states.cancelled}',
      '${states.failed}'
    )
  `;
  };
  var createJobTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.job (
      id uuid primary key not null default gen_random_uuid(),
      name text not null,
      priority integer not null default(0),
      data jsonb,
      state ${schema3}.job_state not null default('${states.created}'),
      retryLimit integer not null default(0),
      retryCount integer not null default(0),
      retryDelay integer not null default(0),
      retryBackoff boolean not null default false,
      startAfter timestamp with time zone not null default now(),
      startedOn timestamp with time zone,
      singletonKey text,
      singletonOn timestamp without time zone,
      expireIn interval not null default interval '15 minutes',
      createdOn timestamp with time zone not null default now(),
      completedOn timestamp with time zone,
      keepUntil timestamp with time zone NOT NULL default now() + interval '14 days',
      on_complete boolean not null default false,
      output jsonb
    )
  `;
  };
  var cloneJobTableForArchive = function(schema3) {
    return `CREATE TABLE ${schema3}.archive (LIKE ${schema3}.job)`;
  };
  var addArchivedOnToArchive = function(schema3) {
    return `ALTER TABLE ${schema3}.archive ADD archivedOn timestamptz NOT NULL DEFAULT now()`;
  };
  var addArchivedOnIndexToArchive = function(schema3) {
    return `CREATE INDEX archive_archivedon_idx ON ${schema3}.archive(archivedon)`;
  };
  var addIdIndexToArchive = function(schema3) {
    return `CREATE INDEX archive_id_idx ON ${schema3}.archive(id)`;
  };
  var setMaintenanceTime = function(schema3) {
    return `UPDATE ${schema3}.version SET maintained_on = now()`;
  };
  var getMaintenanceTime = function(schema3) {
    return `SELECT maintained_on, EXTRACT( EPOCH FROM (now() - maintained_on) ) seconds_ago FROM ${schema3}.version`;
  };
  var setCronTime = function(schema3, time) {
    time = time || "now()";
    return `UPDATE ${schema3}.version SET cron_on = ${time}`;
  };
  var getCronTime = function(schema3) {
    return `SELECT cron_on, EXTRACT( EPOCH FROM (now() - cron_on) ) seconds_ago FROM ${schema3}.version`;
  };
  var deleteQueue = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `DELETE FROM ${schema3}.job WHERE name = \$1 and state < '${options.before}'`;
  };
  var deleteAllQueues = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `DELETE FROM ${schema3}.job WHERE state < '${options.before}'`;
  };
  var clearStorage = function(schema3) {
    return `TRUNCATE ${schema3}.job, ${schema3}.archive`;
  };
  var getQueueSize = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `SELECT count(*) as count FROM ${schema3}.job WHERE name = \$1 AND state < '${options.before}'`;
  };
  var createIndexSingletonKey = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < '${states.completed}' AND singletonOn IS NULL AND NOT singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
  `;
  };
  var createIndexSingletonQueue = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < '${states.active}' AND singletonOn IS NULL AND singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
  `;
  };
  var createIndexSingletonOn = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonOn ON ${schema3}.job (name, singletonOn) WHERE state < '${states.expired}' AND singletonKey IS NULL
  `;
  };
  var createIndexSingletonKeyOn = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonKeyOn ON ${schema3}.job (name, singletonOn, singletonKey) WHERE state < '${states.expired}'
  `;
  };
  var createIndexJobName = function(schema3) {
    return `
    CREATE INDEX job_name ON ${schema3}.job (name text_pattern_ops)
  `;
  };
  var createIndexJobFetch = function(schema3) {
    return `
    CREATE INDEX job_fetch ON ${schema3}.job (name text_pattern_ops, startAfter) WHERE state < '${states.active}'
  `;
  };
  var createScheduleTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.schedule (
      name text primary key,
      cron text not null,
      timezone text,
      data jsonb,
      options jsonb,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now()
    )
  `;
  };
  var createSubscriptionTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.subscription (
      event text not null,
      name text not null,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now(),
      PRIMARY KEY(event, name)
    )
  `;
  };
  var getSchedules = function(schema3) {
    return `
    SELECT * FROM ${schema3}.schedule
  `;
  };
  var schedule = function(schema3) {
    return `
    INSERT INTO ${schema3}.schedule (name, cron, timezone, data, options)
    VALUES (\$1, \$2, \$3, \$4, \$5)
    ON CONFLICT (name) DO UPDATE SET
      cron = EXCLUDED.cron,
      timezone = EXCLUDED.timezone,
      data = EXCLUDED.data,
      options = EXCLUDED.options,
      updated_on = now()
  `;
  };
  var unschedule = function(schema3) {
    return `
    DELETE FROM ${schema3}.schedule
    WHERE name = \$1
  `;
  };
  var subscribe3 = function(schema3) {
    return `
    INSERT INTO ${schema3}.subscription (event, name)
    VALUES (\$1, \$2)
    ON CONFLICT (event, name) DO UPDATE SET
      event = EXCLUDED.event,
      name = EXCLUDED.name,
      updated_on = now()
  `;
  };
  var unsubscribe = function(schema3) {
    return `
    DELETE FROM ${schema3}.subscription
    WHERE event = \$1 and name = \$2
  `;
  };
  var getQueuesForEvent = function(schema3) {
    return `
    SELECT name FROM ${schema3}.subscription
    WHERE event = \$1
  `;
  };
  var getTime = function() {
    return "SELECT round(date_part('epoch', now()) * 1000) as time";
  };
  var getVersion = function(schema3) {
    return `SELECT version from ${schema3}.version`;
  };
  var setVersion = function(schema3, version2) {
    return `UPDATE ${schema3}.version SET version = '${version2}'`;
  };
  var versionTableExists = function(schema3) {
    return `SELECT to_regclass('${schema3}.version') as name`;
  };
  var insertVersion = function(schema3, version2) {
    return `INSERT INTO ${schema3}.version(version) VALUES ('${version2}')`;
  };
  var fetchNextJob = function(schema3) {
    return (includeMetadata, enforceSingletonQueueActiveLimit) => `
    WITH nextJob as (
      SELECT id
      FROM ${schema3}.job j
      WHERE state < '${states.active}'
        AND name LIKE \$1
        AND startAfter < now()
        ${enforceSingletonQueueActiveLimit ? `AND (
          CASE
            WHEN singletonKey IS NOT NULL
              AND singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
              THEN NOT EXISTS (
                SELECT 1
                FROM ${schema3}.job active_job
                WHERE active_job.state = '${states.active}'
                  AND active_job.name = j.name
                  AND active_job.singletonKey = j.singletonKey
                  LIMIT 1
              )
            ELSE
              true
          END
        )` : ""}
      ORDER BY priority desc, createdOn, id
      LIMIT \$2
      FOR UPDATE SKIP LOCKED
    )
    UPDATE ${schema3}.job j SET
      state = '${states.active}',
      startedOn = now(),
      retryCount = CASE WHEN state = '${states.retry}' THEN retryCount + 1 ELSE retryCount END
    FROM nextJob
    WHERE j.id = nextJob.id
    RETURNING ${includeMetadata ? "j.*" : "j.id, name, data"}, EXTRACT(epoch FROM expireIn) as expire_in_seconds
  `;
  };
  var buildJsonCompletionObject = function(withResponse) {
    return `jsonb_build_object(
    'request', jsonb_build_object('id', id, 'name', name, 'data', data),
    'response', ${withResponse ? "$2::jsonb" : "null"},
    'state', state,
    'retryCount', retryCount,
    'createdOn', createdOn,
    'startedOn', startedOn,
    'completedOn', completedOn,
    'failed', CASE WHEN state = '${states.completed}' THEN false ELSE true END
  )`;
  };
  var completeJobs = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET completedOn = now(),
        state = '${states.completed}',
        output = \$2::jsonb
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state = '${states.active}'
      RETURNING *
    ), completion_jobs as (
      INSERT INTO ${schema3}.job (name, data, keepUntil)
      SELECT
        '${COMPLETION_JOB_PREFIX}' || name,
        ${buildJsonCompletionObject(true)},
        ${keepUntilInheritance}
      FROM results
      WHERE NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
        AND on_complete
    )
    SELECT COUNT(*) FROM results
  `;
  };
  var failJobs = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET state = CASE
          WHEN retryCount < retryLimit
          THEN '${states.retry}'::${schema3}.job_state
          ELSE '${states.failed}'::${schema3}.job_state
          END,
        completedOn = ${retryCompletedOnCase},
        startAfter = ${retryStartAfterCase},
        output = \$2::jsonb
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state < '${states.completed}'
      RETURNING *
    ), completion_jobs as (
      INSERT INTO ${schema3}.job (name, data, keepUntil)
      SELECT
        '${COMPLETION_JOB_PREFIX}' || name,
        ${buildJsonCompletionObject(true)},
        ${keepUntilInheritance}
      FROM results
      WHERE state = '${states.failed}'
        AND NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
        AND on_complete
    )
    SELECT COUNT(*) FROM results
  `;
  };
  var expire = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET state = CASE
          WHEN retryCount < retryLimit THEN '${states.retry}'::${schema3}.job_state
          ELSE '${states.expired}'::${schema3}.job_state
          END,
        completedOn = ${retryCompletedOnCase},
        startAfter = ${retryStartAfterCase}
      WHERE state = '${states.active}'
        AND (startedOn + expireIn) < now()
      RETURNING *
    )
    INSERT INTO ${schema3}.job (name, data, keepUntil)
    SELECT
      '${COMPLETION_JOB_PREFIX}' || name,
      ${buildJsonCompletionObject()},
      ${keepUntilInheritance}
    FROM results
    WHERE state = '${states.expired}'
      AND NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
      AND on_complete
  `;
  };
  var cancelJobs = function(schema3) {
    return `
    with results as (
      UPDATE ${schema3}.job
      SET completedOn = now(),
        state = '${states.cancelled}'
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state < '${states.completed}'
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
  };
  var resumeJobs = function(schema3) {
    return `
    with results as (
      UPDATE ${schema3}.job
      SET completedOn = NULL,
        state = '${states.created}'
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
  };
  var insertJob = function(schema3) {
    return `
    INSERT INTO ${schema3}.job (
      id,
      name,
      priority,
      state,
      retryLimit,
      startAfter,
      expireIn,
      data,
      singletonKey,
      singletonOn,
      retryDelay,
      retryBackoff,
      keepUntil,
      on_complete
    )
    SELECT
      id,
      name,
      priority,
      state,
      retryLimit,
      startAfter,
      expireIn,
      data,
      singletonKey,
      singletonOn,
      retryDelay,
      retryBackoff,
      keepUntil,
      on_complete
    FROM
    ( SELECT *,
        CASE
          WHEN right(keepUntilValue, 1) = 'Z' THEN CAST(keepUntilValue as timestamp with time zone)
          ELSE startAfter + CAST(COALESCE(keepUntilValue,'0') as interval)
          END as keepUntil
      FROM
      ( SELECT *,
          CASE
            WHEN right(startAfterValue, 1) = 'Z' THEN CAST(startAfterValue as timestamp with time zone)
            ELSE now() + CAST(COALESCE(startAfterValue,'0') as interval)
            END as startAfter
        FROM
        ( SELECT
            \$1::uuid as id,
            \$2::text as name,
            \$3::int as priority,
            '${states.created}'::${schema3}.job_state as state,
            \$4::int as retryLimit,
            \$5::text as startAfterValue,
            CAST(\$6 as interval) as expireIn,
            \$7::jsonb as data,
            \$8::text as singletonKey,
            CASE
              WHEN \$9::integer IS NOT NULL THEN 'epoch'::timestamp + '1 second'::interval * (\$9 * floor((date_part('epoch', now()) + \$10) / \$9))
              ELSE NULL
              END as singletonOn,
            \$11::int as retryDelay,
            \$12::bool as retryBackoff,
            \$13::text as keepUntilValue,
            \$14::boolean as on_complete
        ) j1
      ) j2
    ) j3
    ON CONFLICT DO NOTHING
    RETURNING id
  `;
  };
  var insertJobs = function(schema3) {
    return `
    INSERT INTO ${schema3}.job (
      id,
      name,
      data,
      priority,
      startAfter,
      expireIn,
      retryLimit,
      retryDelay,
      retryBackoff,
      singletonKey,
      keepUntil,
      on_complete
    )
    SELECT
      COALESCE(id, gen_random_uuid()) as id,
      name,
      data,
      COALESCE(priority, 0) as priority,
      COALESCE("startAfter", now()) as startAfter,
      COALESCE("expireInSeconds", 15 * 60) * interval '1s' as expireIn,
      COALESCE("retryLimit", 0) as retryLimit,
      COALESCE("retryDelay", 0) as retryDelay,
      COALESCE("retryBackoff", false) as retryBackoff,
      "singletonKey",
      COALESCE("keepUntil", now() + interval '14 days') as keepUntil,
      COALESCE("onComplete", false) as onComplete
    FROM json_to_recordset(\$1) as x(
      id uuid,
      name text,
      priority integer,
      data jsonb,
      "retryLimit" integer,
      "retryDelay" integer,
      "retryBackoff" boolean,
      "startAfter" timestamp with time zone,
      "singletonKey" text,
      "expireInSeconds" integer,
      "keepUntil" timestamp with time zone,
      "onComplete" boolean
    )
    ON CONFLICT DO NOTHING
  `;
  };
  var purge = function(schema3, interval) {
    return `
    DELETE FROM ${schema3}.archive
    WHERE archivedOn < (now() - interval '${interval}')
  `;
  };
  var archive = function(schema3, completedInterval, failedInterval = completedInterval) {
    return `
    WITH archived_rows AS (
      DELETE FROM ${schema3}.job
      WHERE (
          state <> '${states.failed}' AND completedOn < (now() - interval '${completedInterval}')
        )
        OR (
          state = '${states.failed}' AND completedOn < (now() - interval '${failedInterval}')
        )
        OR (
          state < '${states.active}' AND keepUntil < now()
        )
      RETURNING *
    )
    INSERT INTO ${schema3}.archive (
      id, name, priority, data, state, retryLimit, retryCount, retryDelay, retryBackoff, startAfter, startedOn, singletonKey, singletonOn, expireIn, createdOn, completedOn, keepUntil, on_complete, output
    )
    SELECT
      id, name, priority, data, state, retryLimit, retryCount, retryDelay, retryBackoff, startAfter, startedOn, singletonKey, singletonOn, expireIn, createdOn, completedOn, keepUntil, on_complete, output
    FROM archived_rows
  `;
  };
  var countStates = function(schema3) {
    return `
    SELECT name, state, count(*) size
    FROM ${schema3}.job
    GROUP BY rollup(name), rollup(state)
  `;
  };
  var advisoryLock = function(schema3) {
    return `SELECT pg_advisory_xact_lock(
      ('x' || md5(current_database() || '.pgboss.${schema3}'))::bit(64)::bigint
  )`;
  };
  var assertMigration = function(schema3, version2) {
    return `SELECT version::int/(version::int-${version2}) from ${schema3}.version`;
  };
  var getJobById = function(schema3) {
    return getJobByTableAndId(schema3, "job");
  };
  var getArchivedJobById = function(schema3) {
    return getJobByTableAndId(schema3, "archive");
  };
  var getJobByTableAndId = function(schema3, table) {
    return `SELECT * From ${schema3}.${table} WHERE id = \$1`;
  };
  var assert = import.meta.require("assert");
  var states = {
    created: "created",
    retry: "retry",
    active: "active",
    completed: "completed",
    expired: "expired",
    cancelled: "cancelled",
    failed: "failed"
  };
  var DEFAULT_SCHEMA = "pgboss";
  var COMPLETION_JOB_PREFIX = `__state__${states.completed}__`;
  var SINGLETON_QUEUE_KEY = "__pgboss__singleton_queue";
  var SINGLETON_QUEUE_KEY_ESCAPED = SINGLETON_QUEUE_KEY.replace(/_/g, "\\_");
  var MIGRATE_RACE_MESSAGE = "division by zero";
  var CREATE_RACE_MESSAGE = "already exists";
  module.exports = {
    create: create4,
    insertVersion,
    getVersion,
    setVersion,
    versionTableExists,
    fetchNextJob,
    completeJobs,
    cancelJobs,
    resumeJobs,
    failJobs,
    insertJob,
    insertJobs,
    getTime,
    getSchedules,
    schedule,
    unschedule,
    subscribe: subscribe3,
    unsubscribe,
    getQueuesForEvent,
    expire,
    archive,
    purge,
    countStates,
    deleteQueue,
    deleteAllQueues,
    clearStorage,
    getQueueSize,
    getMaintenanceTime,
    setMaintenanceTime,
    getCronTime,
    setCronTime,
    locked,
    assertMigration,
    getArchivedJobById,
    getJobById,
    states: { ...states },
    COMPLETION_JOB_PREFIX,
    SINGLETON_QUEUE_KEY,
    MIGRATE_RACE_MESSAGE,
    CREATE_RACE_MESSAGE,
    DEFAULT_SCHEMA
  };
  var retryCompletedOnCase = `CASE
          WHEN retryCount < retryLimit
          THEN NULL
          ELSE now()
          END`;
  var retryStartAfterCase = `CASE
          WHEN retryCount = retryLimit THEN startAfter
          WHEN NOT retryBackoff THEN now() + retryDelay * interval '1'
          ELSE now() +
            (
                retryDelay * 2 ^ LEAST(16, retryCount + 1) / 2
                +
                retryDelay * 2 ^ LEAST(16, retryCount + 1) / 2 * random()
            )
            * interval '1'
          END`;
  var keepUntilInheritance = "keepUntil + (keepUntil - startAfter)";
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/attorney.js
var require_attorney = __commonJS((exports, module) => {
  var checkSendArgs = function(args, defaults) {
    let name, data, options;
    if (typeof args[0] === "string") {
      name = args[0];
      data = args[1];
      assert(typeof data !== "function", "send() cannot accept a function as the payload.  Did you intend to use work()?");
      options = args[2];
    } else if (typeof args[0] === "object") {
      assert(args.length === 1, "send object API only accepts 1 argument");
      const job = args[0];
      assert(job, "boss requires all jobs to have a name");
      name = job.name;
      data = job.data;
      options = job.options;
    }
    options = options || {};
    assert(name, "boss requires all jobs to have a queue name");
    assert(typeof options === "object", "options should be an object");
    options = { ...options };
    assert(!("priority" in options) || Number.isInteger(options.priority), "priority must be an integer");
    options.priority = options.priority || 0;
    applyRetryConfig(options, defaults);
    applyExpirationConfig(options, defaults);
    applyRetentionConfig(options, defaults);
    applyCompletionConfig(options, defaults);
    applySingletonKeyConfig(options);
    const { startAfter, singletonSeconds, singletonMinutes, singletonHours } = options;
    options.startAfter = startAfter instanceof Date && typeof startAfter.toISOString === "function" ? startAfter.toISOString() : startAfter > 0 ? "" + startAfter : typeof startAfter === "string" ? startAfter : null;
    options.singletonSeconds = singletonHours > 0 ? singletonHours * 60 * 60 : singletonMinutes > 0 ? singletonMinutes * 60 : singletonSeconds > 0 ? singletonSeconds : null;
    assert(!singletonSeconds || singletonSeconds <= defaults.archiveSeconds, `throttling interval ${singletonSeconds}s cannot exceed archive interval ${defaults.archiveSeconds}s`);
    return { name, data, options };
  };
  var checkInsertArgs = function(jobs) {
    assert(Array.isArray(jobs), `jobs argument should be an array.  Received '${typeof jobs}'`);
    return jobs.map((job) => {
      job = { ...job };
      applySingletonKeyConfig(job);
      return job;
    });
  };
  var applySingletonKeyConfig = function(options) {
    if (options.singletonKey && options.useSingletonQueue && options.singletonKey !== SINGLETON_QUEUE_KEY) {
      options.singletonKey = SINGLETON_QUEUE_KEY + options.singletonKey;
    }
    delete options.useSingletonQueue;
  };
  var checkWorkArgs = function(name, args, defaults) {
    let options, callback;
    assert(name, "missing job name");
    if (args.length === 1) {
      callback = args[0];
      options = {};
    } else if (args.length > 1) {
      options = args[0] || {};
      callback = args[1];
    }
    assert(typeof callback === "function", "expected callback to be a function");
    assert(typeof options === "object", "expected config to be an object");
    options = { ...options };
    applyNewJobCheckInterval(options, defaults);
    assert(!("teamConcurrency" in options) || Number.isInteger(options.teamConcurrency) && options.teamConcurrency >= 1 && options.teamConcurrency <= 1000, "teamConcurrency must be an integer between 1 and 1000");
    assert(!("teamSize" in options) || Number.isInteger(options.teamSize) && options.teamSize >= 1, "teamSize must be an integer > 0");
    assert(!("batchSize" in options) || Number.isInteger(options.batchSize) && options.batchSize >= 1, "batchSize must be an integer > 0");
    assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
    assert(!("enforceSingletonQueueActiveLimit" in options) || typeof options.enforceSingletonQueueActiveLimit === "boolean", "enforceSingletonQueueActiveLimit must be a boolean");
    return { options, callback };
  };
  var checkFetchArgs = function(name, batchSize, options) {
    assert(name, "missing queue name");
    name = sanitizeQueueNameForFetch(name);
    assert(!batchSize || Number.isInteger(batchSize) && batchSize >= 1, "batchSize must be an integer > 0");
    assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
    assert(!("enforceSingletonQueueActiveLimit" in options) || typeof options.enforceSingletonQueueActiveLimit === "boolean", "enforceSingletonQueueActiveLimit must be a boolean");
    return { name };
  };
  var sanitizeQueueNameForFetch = function(name) {
    return name.replace(/[%_*]/g, (match) => match === "*" ? "%" : "\\" + match);
  };
  var getConfig = function(value14) {
    assert(value14 && (typeof value14 === "object" || typeof value14 === "string"), "configuration assert: string or config object is required to connect to postgres");
    const config = typeof value14 === "string" ? { connectionString: value14 } : { ...value14 };
    applyDatabaseConfig(config);
    applyMaintenanceConfig(config);
    applyArchiveConfig(config);
    applyArchiveFailedConfig(config);
    applyDeleteConfig(config);
    applyMonitoringConfig(config);
    applyUuidConfig(config);
    applyNewJobCheckInterval(config);
    applyExpirationConfig(config);
    applyRetentionConfig(config);
    applyCompletionConfig(config);
    return config;
  };
  var applyDatabaseConfig = function(config) {
    if (config.schema) {
      assert(typeof config.schema === "string", "configuration assert: schema must be a string");
      assert(config.schema.length <= 50, "configuration assert: schema name cannot exceed 50 characters");
      assert(!/\W/.test(config.schema), `configuration assert: ${config.schema} cannot be used as a schema. Only alphanumeric characters and underscores are allowed`);
    }
    config.schema = config.schema || DEFAULT_SCHEMA;
  };
  var applyArchiveConfig = function(config) {
    const ARCHIVE_DEFAULT = 60 * 60 * 12;
    assert(!("archiveCompletedAfterSeconds" in config) || config.archiveCompletedAfterSeconds >= 1, "configuration assert: archiveCompletedAfterSeconds must be at least every second and less than ");
    config.archiveSeconds = config.archiveCompletedAfterSeconds || ARCHIVE_DEFAULT;
    config.archiveInterval = `${config.archiveSeconds} seconds`;
    if (config.archiveSeconds < 60) {
      emitWarning2(WARNINGS.CRON_DISABLED);
    }
  };
  var applyArchiveFailedConfig = function(config) {
    assert(!("archiveFailedAfterSeconds" in config) || config.archiveFailedAfterSeconds >= 1, "configuration assert: archiveFailedAfterSeconds must be at least every second and less than ");
    config.archiveFailedSeconds = config.archiveFailedAfterSeconds || config.archiveSeconds;
    config.archiveFailedInterval = `${config.archiveFailedSeconds} seconds`;
    if (config.archiveFailedSeconds < 60 && config.archiveSeconds >= 60) {
      emitWarning2(WARNINGS.CRON_DISABLED);
    }
  };
  var applyCompletionConfig = function(config, defaults) {
    assert(!("onComplete" in config) || config.onComplete === true || config.onComplete === false, "configuration assert: onComplete must be either true or false");
    if (!("onComplete" in config)) {
      config.onComplete = defaults ? defaults.onComplete : false;
    }
  };
  var applyRetentionConfig = function(config, defaults) {
    assert(!("retentionSeconds" in config) || config.retentionSeconds >= 1, "configuration assert: retentionSeconds must be at least every second");
    assert(!("retentionMinutes" in config) || config.retentionMinutes >= 1, "configuration assert: retentionMinutes must be at least every minute");
    assert(!("retentionHours" in config) || config.retentionHours >= 1, "configuration assert: retentionHours must be at least every hour");
    assert(!("retentionDays" in config) || config.retentionDays >= 1, "configuration assert: retentionDays must be at least every day");
    const keepUntil = "retentionDays" in config ? `${config.retentionDays} days` : ("retentionHours" in config) ? `${config.retentionHours} hours` : ("retentionMinutes" in config) ? `${config.retentionMinutes} minutes` : ("retentionSeconds" in config) ? `${config.retentionSeconds} seconds` : defaults ? defaults.keepUntil : "14 days";
    config.keepUntil = keepUntil;
  };
  var applyExpirationConfig = function(config, defaults) {
    if ("expireIn" in config) {
      emitWarning2(WARNINGS.EXPIRE_IN_REMOVED);
    }
    assert(!("expireInSeconds" in config) || config.expireInSeconds >= 1, "configuration assert: expireInSeconds must be at least every second");
    assert(!("expireInMinutes" in config) || config.expireInMinutes >= 1, "configuration assert: expireInMinutes must be at least every minute");
    assert(!("expireInHours" in config) || config.expireInHours >= 1, "configuration assert: expireInHours must be at least every hour");
    const expireIn = "expireInHours" in config ? `${config.expireInHours} hours` : ("expireInMinutes" in config) ? `${config.expireInMinutes} minutes` : ("expireInSeconds" in config) ? `${config.expireInSeconds} seconds` : defaults ? defaults.expireIn : "15 minutes";
    config.expireIn = expireIn;
  };
  var applyRetryConfig = function(config, defaults) {
    assert(!("retryDelay" in config) || Number.isInteger(config.retryDelay) && config.retryDelay >= 0, "retryDelay must be an integer >= 0");
    assert(!("retryLimit" in config) || Number.isInteger(config.retryLimit) && config.retryLimit >= 0, "retryLimit must be an integer >= 0");
    assert(!("retryBackoff" in config) || (config.retryBackoff === true || config.retryBackoff === false), "retryBackoff must be either true or false");
    if (defaults) {
      config.retryDelay = config.retryDelay || defaults.retryDelay;
      config.retryLimit = config.retryLimit || defaults.retryLimit;
      config.retryBackoff = config.retryBackoff || defaults.retryBackoff;
    }
    config.retryDelay = config.retryDelay || 0;
    config.retryLimit = config.retryLimit || 0;
    config.retryBackoff = !!config.retryBackoff;
    config.retryDelay = config.retryBackoff && !config.retryDelay ? 1 : config.retryDelay;
    config.retryLimit = config.retryDelay && !config.retryLimit ? 1 : config.retryLimit;
  };
  var applyNewJobCheckInterval = function(config, defaults) {
    const second = 1000;
    assert(!("newJobCheckInterval" in config) || config.newJobCheckInterval >= 100, "configuration assert: newJobCheckInterval must be at least every 100ms");
    assert(!("newJobCheckIntervalSeconds" in config) || config.newJobCheckIntervalSeconds >= 1, "configuration assert: newJobCheckIntervalSeconds must be at least every second");
    config.newJobCheckInterval = ("newJobCheckIntervalSeconds" in config) ? config.newJobCheckIntervalSeconds * second : ("newJobCheckInterval" in config) ? config.newJobCheckInterval : defaults ? defaults.newJobCheckInterval : second * 2;
  };
  var applyMaintenanceConfig = function(config) {
    assert(!("maintenanceIntervalSeconds" in config) || config.maintenanceIntervalSeconds >= 1, "configuration assert: maintenanceIntervalSeconds must be at least every second");
    assert(!("maintenanceIntervalMinutes" in config) || config.maintenanceIntervalMinutes >= 1, "configuration assert: maintenanceIntervalMinutes must be at least every minute");
    config.maintenanceIntervalSeconds = ("maintenanceIntervalMinutes" in config) ? config.maintenanceIntervalMinutes * 60 : ("maintenanceIntervalSeconds" in config) ? config.maintenanceIntervalSeconds : 120;
  };
  var applyDeleteConfig = function(config) {
    assert(!("deleteAfterSeconds" in config) || config.deleteAfterSeconds >= 1, "configuration assert: deleteAfterSeconds must be at least every second");
    assert(!("deleteAfterMinutes" in config) || config.deleteAfterMinutes >= 1, "configuration assert: deleteAfterMinutes must be at least every minute");
    assert(!("deleteAfterHours" in config) || config.deleteAfterHours >= 1, "configuration assert: deleteAfterHours must be at least every hour");
    assert(!("deleteAfterDays" in config) || config.deleteAfterDays >= 1, "configuration assert: deleteAfterDays must be at least every day");
    const deleteAfter = "deleteAfterDays" in config ? `${config.deleteAfterDays} days` : ("deleteAfterHours" in config) ? `${config.deleteAfterHours} hours` : ("deleteAfterMinutes" in config) ? `${config.deleteAfterMinutes} minutes` : ("deleteAfterSeconds" in config) ? `${config.deleteAfterSeconds} seconds` : "7 days";
    config.deleteAfter = deleteAfter;
  };
  var applyMonitoringConfig = function(config) {
    assert(!("monitorStateIntervalSeconds" in config) || config.monitorStateIntervalSeconds >= 1, "configuration assert: monitorStateIntervalSeconds must be at least every second");
    assert(!("monitorStateIntervalMinutes" in config) || config.monitorStateIntervalMinutes >= 1, "configuration assert: monitorStateIntervalMinutes must be at least every minute");
    config.monitorStateIntervalSeconds = ("monitorStateIntervalMinutes" in config) ? config.monitorStateIntervalMinutes * 60 : ("monitorStateIntervalSeconds" in config) ? config.monitorStateIntervalSeconds : null;
    const TEN_MINUTES_IN_SECONDS = 600;
    assert(!("clockMonitorIntervalSeconds" in config) || config.clockMonitorIntervalSeconds >= 1 && config.clockMonitorIntervalSeconds <= TEN_MINUTES_IN_SECONDS, "configuration assert: clockMonitorIntervalSeconds must be between 1 second and 10 minutes");
    assert(!("clockMonitorIntervalMinutes" in config) || config.clockMonitorIntervalMinutes >= 1 && config.clockMonitorIntervalMinutes <= 10, "configuration assert: clockMonitorIntervalMinutes must be between 1 and 10");
    config.clockMonitorIntervalSeconds = ("clockMonitorIntervalMinutes" in config) ? config.clockMonitorIntervalMinutes * 60 : ("clockMonitorIntervalSeconds" in config) ? config.clockMonitorIntervalSeconds : TEN_MINUTES_IN_SECONDS;
    assert(!("cronMonitorIntervalSeconds" in config) || config.cronMonitorIntervalSeconds >= 1 && config.cronMonitorIntervalSeconds <= 60, "configuration assert: cronMonitorIntervalSeconds must be between 1 and 60 seconds");
    config.cronMonitorIntervalSeconds = ("cronMonitorIntervalSeconds" in config) ? config.cronMonitorIntervalSeconds : 60;
    assert(!("cronWorkerIntervalSeconds" in config) || config.cronWorkerIntervalSeconds >= 1 && config.cronWorkerIntervalSeconds <= 60, "configuration assert: cronWorkerIntervalSeconds must be between 1 and 60 seconds");
    config.cronWorkerIntervalSeconds = ("cronWorkerIntervalSeconds" in config) ? config.cronWorkerIntervalSeconds : 4;
  };
  var applyUuidConfig = function(config) {
    assert(!("uuid" in config) || config.uuid === "v1" || config.uuid === "v4", "configuration assert: uuid option only supports v1 or v4");
    config.uuid = config.uuid || "v4";
  };
  var warnClockSkew = function(message) {
    emitWarning2(WARNINGS.CLOCK_SKEW, message, { force: true });
  };
  var emitWarning2 = function(warning, message, options = {}) {
    const { force } = options;
    if (force || !warning.warned) {
      warning.warned = true;
      message = `${warning.message} ${message || ""}`;
      process.emitWarning(message, warning.type, warning.code);
    }
  };
  var assert = import.meta.require("assert");
  var { DEFAULT_SCHEMA, SINGLETON_QUEUE_KEY } = require_plans();
  module.exports = {
    getConfig,
    checkSendArgs,
    checkInsertArgs,
    checkWorkArgs,
    checkFetchArgs,
    warnClockSkew
  };
  var WARNINGS = {
    EXPIRE_IN_REMOVED: {
      message: "\'expireIn\' option detected. This option has been removed. Use expireInSeconds, expireInMinutes or expireInHours.",
      code: "pg-boss-w01"
    },
    CLOCK_SKEW: {
      message: "Timekeeper detected clock skew between this instance and the database server. This will not affect scheduling operations, but this warning is shown any time the skew exceeds 60 seconds.",
      code: "pg-boss-w02"
    },
    CRON_DISABLED: {
      message: "Archive interval is set less than 60s.  Cron processing is disabled.",
      code: "pg-boss-w03"
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/migrationStore.js
var require_migrationStore = __commonJS((exports, module) => {
  var flatten = function(schema3, commands, version2) {
    commands.unshift(plans.assertMigration(schema3, version2));
    commands.push(plans.setVersion(schema3, version2));
    return plans.locked(schema3, commands);
  };
  var rollback = function(schema3, version2, migrations) {
    migrations = migrations || getAll(schema3);
    const result = migrations.find((i) => i.version === version2);
    assert(result, `Version ${version2} not found.`);
    return flatten(schema3, result.uninstall || [], result.previous);
  };
  var next = function(schema3, version2, migrations) {
    migrations = migrations || getAll(schema3);
    const result = migrations.find((i) => i.previous === version2);
    assert(result, `Version ${version2} not found.`);
    return flatten(schema3, result.install, result.version);
  };
  var migrate = function(value14, version2, migrations) {
    let schema3, config;
    if (typeof value14 === "string") {
      config = null;
      schema3 = value14;
    } else {
      config = value14;
      schema3 = config.schema;
    }
    migrations = migrations || getAll(schema3, config);
    const result = migrations.filter((i) => i.previous >= version2).sort((a2, b2) => a2.version - b2.version).reduce((acc, i) => {
      acc.install = acc.install.concat(i.install);
      acc.version = i.version;
      return acc;
    }, { install: [], version: version2 });
    assert(result.install.length > 0, `Version ${version2} not found.`);
    return flatten(schema3, result.install, result.version);
  };
  var getAll = function(schema3) {
    return [
      {
        release: "7.4.0",
        version: 20,
        previous: 19,
        install: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey LIKE '\\_\\_pgboss\\_\\_singleton\\_queue%'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey LIKE '\\_\\_pgboss\\_\\_singleton\\_queue%'`
        ],
        uninstall: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey = '__pgboss__singleton_queue'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey = '__pgboss__singleton_queue'`
        ]
      },
      {
        release: "7.0.0",
        version: 19,
        previous: 18,
        install: [
          `CREATE TABLE ${schema3}.subscription (
          event text not null,
          name text not null,
          created_on timestamp with time zone not null default now(),
          updated_on timestamp with time zone not null default now(),
          PRIMARY KEY(event, name)
        )`
        ],
        uninstall: [
          `DROP TABLE ${schema3}.subscription`
        ]
      },
      {
        release: "6.1.1",
        version: 18,
        previous: 17,
        install: [
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT false`
        ]
      },
      {
        release: "6.0.0",
        version: 17,
        previous: 16,
        install: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey = '__pgboss__singleton_queue'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey = '__pgboss__singleton_queue'`,
          `CREATE INDEX IF NOT EXISTS job_fetch ON ${schema3}.job (name text_pattern_ops, startAfter) WHERE state < 'active'`,
          `ALTER TABLE ${schema3}.job ADD output jsonb`,
          `ALTER TABLE ${schema3}.archive ADD output jsonb`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT false`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN keepuntil SET DEFAULT now() + interval '14 days'`
        ],
        uninstall: [
          `DROP INDEX ${schema3}.job_fetch`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `DROP INDEX ${schema3}.job_singletonKey`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL`,
          `ALTER TABLE ${schema3}.job DROP COLUMN output`,
          `ALTER TABLE ${schema3}.archive DROP COLUMN output`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN keepuntil SET DEFAULT now() + interval '30 days'`
        ]
      },
      {
        release: "5.2.0",
        version: 16,
        previous: 15,
        install: [
          `ALTER TABLE ${schema3}.job ADD on_complete boolean`,
          `UPDATE ${schema3}.job SET on_complete = true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET NOT NULL`,
          `ALTER TABLE ${schema3}.archive ADD on_complete boolean`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.job DROP COLUMN on_complete`,
          `ALTER TABLE ${schema3}.archive DROP COLUMN on_complete`
        ]
      },
      {
        release: "5.0.6",
        version: 15,
        previous: 14,
        install: [
          `ALTER TABLE ${schema3}.version ADD cron_on timestamp with time zone`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.version DROP COLUMN cron_on`
        ]
      },
      {
        release: "5.0.0",
        version: 14,
        previous: 13,
        install: [
          `ALTER TABLE ${schema3}.version ADD maintained_on timestamp with time zone`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.version DROP COLUMN maintained_on`
        ]
      }
    ];
  };
  var assert = import.meta.require("assert");
  var plans = require_plans();
  module.exports = {
    rollback,
    next,
    migrate,
    getAll
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/version.json
var require_version = __commonJS((exports, module) => {
  module.exports = {
    schema: 20
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/contractor.js
var require_contractor = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var plans = require_plans();
  var { DEFAULT_SCHEMA } = plans;
  var migrationStore = require_migrationStore();
  var schemaVersion = require_version().schema;

  class Contractor {
    static constructionPlans(schema3 = DEFAULT_SCHEMA) {
      return plans.create(schema3, schemaVersion);
    }
    static migrationPlans(schema3 = DEFAULT_SCHEMA, version2 = schemaVersion - 1) {
      return migrationStore.migrate(schema3, version2);
    }
    static rollbackPlans(schema3 = DEFAULT_SCHEMA, version2 = schemaVersion) {
      return migrationStore.rollback(schema3, version2);
    }
    constructor(db, config) {
      this.config = config;
      this.db = db;
      this.migrations = this.config.migrations || migrationStore.getAll(this.config.schema);
    }
    async version() {
      const result = await this.db.executeSql(plans.getVersion(this.config.schema));
      return result.rows.length ? parseInt(result.rows[0].version) : null;
    }
    async isInstalled() {
      const result = await this.db.executeSql(plans.versionTableExists(this.config.schema));
      return result.rows.length ? result.rows[0].name : null;
    }
    async start() {
      const installed = await this.isInstalled();
      if (installed) {
        const version2 = await this.version();
        if (schemaVersion > version2) {
          await this.migrate(version2);
        }
      } else {
        await this.create();
      }
    }
    async create() {
      try {
        const commands = plans.create(this.config.schema, schemaVersion);
        await this.db.executeSql(commands);
      } catch (err) {
        assert(err.message.includes(plans.CREATE_RACE_MESSAGE), err);
      }
    }
    async migrate(version2) {
      try {
        const commands = migrationStore.migrate(this.config, version2, this.migrations);
        await this.db.executeSql(commands);
      } catch (err) {
        assert(err.message.includes(plans.MIGRATE_RACE_MESSAGE), err);
      }
    }
    async next(version2) {
      const commands = migrationStore.next(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    }
    async rollback(version2) {
      const commands = migrationStore.rollback(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    }
  }
  module.exports = Contractor;
});

// /Users/richardguerre/Projects/flow/node_modules/delay/index.js
var require_delay = __commonJS((exports, module) => {
  var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
  var createAbortError = () => {
    const error28 = new Error("Delay aborted");
    error28.name = "AbortError";
    return error28;
  };
  var createDelay = ({ clearTimeout: defaultClear, setTimeout: set2, willResolve }) => (ms, { value: value14, signal } = {}) => {
    if (signal && signal.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFn;
    const clear = defaultClear || clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFn(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject2) => {
      settle = () => {
        cleanup();
        if (willResolve) {
          resolve(value14);
        } else {
          reject2(value14);
        }
      };
      rejectFn = reject2;
      timeoutId = (set2 || setTimeout)(settle, ms);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    delayPromise.clear = () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    };
    return delayPromise;
  };
  var createWithTimers = (clearAndSet) => {
    const delay2 = createDelay({ ...clearAndSet, willResolve: true });
    delay2.reject = createDelay({ ...clearAndSet, willResolve: false });
    delay2.range = (minimum, maximum, options) => delay2(randomInteger(minimum, maximum), options);
    return delay2;
  };
  var delay = createWithTimers();
  delay.createWithTimers = createWithTimers;
  module.exports = delay;
  module.exports.default = delay;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate3 = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate3;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  };
  var stringify4 = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = stringify4;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b2 = buf || new Array(16);
    options = options || {};
    let node3 = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node3 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node3 == null) {
        node3 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b2[i++] = tl >>> 24 & 255;
    b2[i++] = tl >>> 16 & 255;
    b2[i++] = tl >>> 8 & 255;
    b2[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b2[i++] = tmh >>> 8 & 255;
    b2[i++] = tmh & 255;
    b2[i++] = tmh >>> 24 & 15 | 16;
    b2[i++] = tmh >>> 16 & 255;
    b2[i++] = clockseq >>> 8 | 128;
    b2[i++] = clockseq & 255;
    for (let n2 = 0;n2 < 6; ++n2) {
      b2[i + n2] = node3[n2];
    }
    return buf || (0, _stringify.unsafeStringify)(b2);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse5 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse5;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version2, hashfunc) {
    function generateUUID(value14, namespace, buf, offset) {
      var _namespace;
      if (typeof value14 === "string") {
        value14 = stringToBytes(value14);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value14.length);
      bytes.set(namespace);
      bytes.set(value14, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify2();
  var _parse = _interopRequireDefault(require_parse2());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  var _default = v4;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/version.js
var require_version2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version2 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version2;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version2());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _parse = _interopRequireDefault(require_parse2());
});

// /Users/richardguerre/Projects/flow/node_modules/lodash.debounce/index.js
var require_lodash = __commonJS((exports, module) => {
  var debounce = function(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = ("maxWait" in options);
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = ("trailing" in options) ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = undefined;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }
    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  };
  var isObject2 = function(value14) {
    var type74 = typeof value14;
    return !!value14 && (type74 == "object" || type74 == "function");
  };
  var isObjectLike11 = function(value14) {
    return !!value14 && typeof value14 == "object";
  };
  var isSymbol = function(value14) {
    return typeof value14 == "symbol" || isObjectLike11(value14) && objectToString.call(value14) == symbolTag;
  };
  var toNumber = function(value14) {
    if (typeof value14 == "number") {
      return value14;
    }
    if (isSymbol(value14)) {
      return NAN;
    }
    if (isObject2(value14)) {
      var other = typeof value14.valueOf == "function" ? value14.valueOf() : value14;
      value14 = isObject2(other) ? other + "" : other;
    }
    if (typeof value14 != "string") {
      return value14 === 0 ? value14 : +value14;
    }
    value14 = value14.replace(reTrim, "");
    var isBinary = reIsBinary.test(value14);
    return isBinary || reIsOctal.test(value14) ? freeParseInt(value14.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value14) ? NAN : +value14;
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root6 = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var now = function() {
    return root6.Date.now();
  };
  module.exports = debounce;
});

// /Users/richardguerre/Projects/flow/node_modules/serialize-error/index.js
var require_serialize_error = __commonJS((exports, module) => {
  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
  }
  var commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  var isCalled = Symbol(".toJSON called");
  var toJSON = (from) => {
    from[isCalled] = true;
    const json2 = from.toJSON();
    delete from[isCalled];
    return json2;
  };
  var destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value14] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value14)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value14 === "function") {
        continue;
      }
      if (!value14 || typeof value14 !== "object") {
        to[key] = value14;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  var serializeError = (value14, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value14 === "object" && value14 !== null) {
      return destroyCircular({
        from: value14,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value14 === "function") {
      return `[Function: ${value14.name || "anonymous"}]`;
    }
    return value14;
  };
  var deserializeError = (value14, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value14 instanceof Error) {
      return value14;
    }
    if (typeof value14 === "object" && value14 !== null && !Array.isArray(value14)) {
      const newError = new Error;
      destroyCircular({
        from: value14,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value14);
  };
  module.exports = {
    serializeError,
    deserializeError
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/worker.js
var require_worker = __commonJS((exports, module) => {
  var delay = require_delay();
  var WORKER_STATES = {
    created: "created",
    active: "active",
    stopping: "stopping",
    stopped: "stopped"
  };

  class Worker {
    constructor({ id, name, options, interval, fetch: fetch6, onFetch, onError }) {
      this.id = id;
      this.name = name;
      this.options = options;
      this.fetch = fetch6;
      this.onFetch = onFetch;
      this.onError = onError;
      this.interval = interval;
      this.jobs = [];
      this.createdOn = Date.now();
      this.lastFetchedOn = null;
      this.lastJobStartedOn = null;
      this.lastJobEndedOn = null;
      this.lastError = null;
      this.lastErrorOn = null;
      this.state = WORKER_STATES.created;
      this.stopping = false;
      this.stopped = false;
      this.loopDelayPromise = null;
      this.beenNotified = false;
    }
    notify() {
      this.beenNotified = true;
      if (this.loopDelayPromise) {
        this.loopDelayPromise.clear();
      }
    }
    async start() {
      this.state = WORKER_STATES.active;
      while (!this.stopping) {
        const started = Date.now();
        try {
          this.beenNotified = false;
          const jobs = await this.fetch();
          this.lastFetchedOn = Date.now();
          if (jobs) {
            this.jobs = jobs;
            this.lastJobStartedOn = this.lastFetchedOn;
            await this.onFetch(jobs);
            this.lastJobEndedOn = Date.now();
            this.jobs = [];
          }
        } catch (err) {
          this.lastErrorOn = Date.now();
          this.lastError = err;
          err.message = `${err.message} (Queue: ${this.name}, Worker: ${this.id})`;
          this.onError(err);
        }
        const duration = Date.now() - started;
        this.lastJobDuration = duration;
        if (!this.stopping && !this.beenNotified && duration < this.interval) {
          this.loopDelayPromise = delay(this.interval - duration);
          await this.loopDelayPromise;
          this.loopDelayPromise = null;
        }
      }
      this.stopping = false;
      this.stopped = true;
      this.state = WORKER_STATES.stopped;
    }
    stop() {
      this.stopping = true;
      this.state = WORKER_STATES.stopping;
      if (this.loopDelayPromise) {
        this.loopDelayPromise.clear();
      }
    }
  }
  module.exports = Worker;
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  var identity2 = function(value14) {
    return value14;
  };
  exports.parse = function(source2, transform5) {
    return new ArrayParser(source2, transform5).parse();
  };

  class ArrayParser {
    constructor(source2, transform5) {
      this.source = source2;
      this.transform = transform5 || identity2;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array4 = require_postgres_array();
  module.exports = {
    create: function(source2, transform5) {
      return {
        parse: function() {
          return array4.parse(source2, transform5);
        }
      };
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var getDate = function(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var date4 = new Date(year, month, day2);
    if (is0To99(year)) {
      date4.setFullYear(year);
    }
    return date4;
  };
  var timeZoneOffset = function(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type74 = zone[1];
    if (type74 === "Z") {
      return 0;
    }
    var sign = type74 === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  };
  var bcYearToNegativeYear = function(year) {
    return -(year - 1);
  };
  var is0To99 = function(num) {
    return num >= 0 && num < 100;
  };
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date4;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date4 = new Date(Date.UTC(year, month, day2, hour, minute, second, ms));
      if (is0To99(year)) {
        date4.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date4.setTime(date4.getTime() - offset);
      }
    } else {
      date4 = new Date(year, month, day2, hour, minute, second, ms);
      if (is0To99(year)) {
        date4.setFullYear(year);
      }
    }
    return date4;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  var extend = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (hasOwnProperty3.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  module.exports = extend;
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var PostgresInterval = function(raw2) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw2);
    }
    extend(this, parse5(raw2));
  };
  var parseMilliseconds = function(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  };
  var parse5 = function(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value14 = matches[position];
      if (!value14)
        return parsed;
      value14 = property === "milliseconds" ? parseMilliseconds(value14) : parseInt(value14, 10);
      if (!value14)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value14 *= -1;
      }
      parsed[property] = value14;
      return parsed;
    }, {});
  };
  var extend = require_mutable();
  module.exports = PostgresInterval;
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value14 = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value14 = (value14 + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value14 + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value14 = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value14 = (value14 + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value14 + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input6) {
    if (/^\\x/.test(input6)) {
      return new Buffer(input6.substr(2), "hex");
    }
    var output2 = "";
    var i = 0;
    while (i < input6.length) {
      if (input6[i] !== "\\") {
        output2 += input6[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input6.substr(i + 1, 3))) {
          output2 += String.fromCharCode(parseInt(input6.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input6.length && input6[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k2 = 0;k2 < Math.floor(backslashes / 2); ++k2) {
            output2 += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output2, "binary");
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var allowNull = function(fn) {
    return function nullAllowed(value14) {
      if (value14 === null)
        return value14;
      return fn(value14);
    };
  };
  var parseBool = function(value14) {
    if (value14 === null)
      return value14;
    return value14 === "TRUE" || value14 === "t" || value14 === "true" || value14 === "y" || value14 === "yes" || value14 === "on" || value14 === "1";
  };
  var parseBoolArray = function(value14) {
    if (!value14)
      return null;
    return array4.parse(value14, parseBool);
  };
  var parseBaseTenInt = function(string6) {
    return parseInt(string6, 10);
  };
  var parseIntegerArray = function(value14) {
    if (!value14)
      return null;
    return array4.parse(value14, allowNull(parseBaseTenInt));
  };
  var parseBigIntegerArray = function(value14) {
    if (!value14)
      return null;
    return array4.parse(value14, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  };
  var array4 = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate2 = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  var parsePointArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseFloatArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseStringArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14);
    return p2.parse();
  };
  var parseDateArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parseDate2(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseIntervalArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseByteAArray = function(value14) {
    if (!value14) {
      return null;
    }
    return array4.parse(value14, allowNull(parseByteA));
  };
  var parseInteger = function(value14) {
    return parseInt(value14, 10);
  };
  var parseBigInteger = function(value14) {
    var valStr = String(value14);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value14;
  };
  var parseJsonArray = function(value14) {
    if (!value14) {
      return null;
    }
    return array4.parse(value14, allowNull(JSON.parse));
  };
  var parsePoint = function(value14) {
    if (value14[0] !== "(") {
      return null;
    }
    value14 = value14.substring(1, value14.length - 1).split(",");
    return {
      x: parseFloat(value14[0]),
      y: parseFloat(value14[1])
    };
  };
  var parseCircle = function(value14) {
    if (value14[0] !== "<" && value14[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value14.length - 1; i++) {
      if (!pointParsed) {
        point += value14[i];
      }
      if (value14[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value14[i] === ",") {
        continue;
      }
      radius += value14[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate2);
    register(1114, parseDate2);
    register(1184, parseDate2);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var readInt8 = function(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t2;
    var digits;
    var pad;
    var l2;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l2 = 6 - digits.length;
      for (i = 0;i < l2; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l2 = 6 - digits.length;
      for (i = 0;i < l2; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l2 = 6 - digits.length;
      for (i = 0;i < l2; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t2 = 4294967296 * carry + low;
      digits = "" + t2 % BASE;
      return sign + digits + result;
    }
  };
  var BASE = 1e6;
  module.exports = readInt8;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value14) {
      if (invert) {
        return ~value14 & 255;
      }
      return value14;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : (-Infinity);
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value14) {
    if (parseBits(value14, 1) == 1) {
      return -1 * (parseBits(value14, 15, 1, true) + 1);
    }
    return parseBits(value14, 15, 1);
  };
  var parseInt32 = function(value14) {
    if (parseBits(value14, 1) == 1) {
      return -1 * (parseBits(value14, 31, 1, true) + 1);
    }
    return parseBits(value14, 31, 1);
  };
  var parseFloat32 = function(value14) {
    return parseFloatFromBits(value14, 23, 8);
  };
  var parseFloat64 = function(value14) {
    return parseFloatFromBits(value14, 52, 11);
  };
  var parseNumeric = function(value14) {
    var sign = parseBits(value14, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value14, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value14, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value14, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value14, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate2 = function(isUTC, value14) {
    var sign = parseBits(value14, 1);
    var rawValue = parseBits(value14, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value15) {
      this.usec = value15;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value14) {
    var dim = parseBits(value14, 32);
    var flags = parseBits(value14, 32, 32);
    var elementType = parseBits(value14, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value14, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value14, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value14, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value14.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse5 = function(dimension, elementType2) {
      var array4 = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array4[i2] = parse5(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array4[i2] = parseElement(elementType2);
        }
      }
      return array4;
    };
    return parse5(dims, elementType);
  };
  var parseText = function(value14) {
    return value14.toString("utf8");
  };
  var parseBool = function(value14) {
    if (value14 === null)
      return null;
    return parseBits(value14, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate2.bind(null, false));
    register(1184, parseDate2.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var noParse = function(val) {
    return String(val);
  };
  var getTypeParser = function(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  };
  var setTypeParser = function(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  };
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : "richardguerre",
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var escapeElement = function(elementRepresentation) {
    var escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + escaped + '"';
  };
  var arrayString = function(val) {
    var result = "{";
    for (var i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (val[i] instanceof Buffer) {
        result += "\\\\x" + val[i].toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  };
  var prepareObject = function(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  };
  var pad = function(number6, digits) {
    number6 = "" + number6;
    while (number6.length < digits) {
      number6 = "0" + number6;
    }
    return number6;
  };
  var dateToString = function(date4) {
    var offset = -date4.getTimezoneOffset();
    var year = date4.getFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = pad(year, 4) + "-" + pad(date4.getMonth() + 1, 2) + "-" + pad(date4.getDate(), 2) + "T" + pad(date4.getHours(), 2) + ":" + pad(date4.getMinutes(), 2) + ":" + pad(date4.getSeconds(), 2) + "." + pad(date4.getMilliseconds(), 3);
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += pad(Math.floor(offset / 60), 2) + ":" + pad(offset % 60, 2);
    if (isBCYear)
      ret += " BC";
    return ret;
  };
  var dateToStringUTC = function(date4) {
    var year = date4.getUTCFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = pad(year, 4) + "-" + pad(date4.getUTCMonth() + 1, 2) + "-" + pad(date4.getUTCDate(), 2) + "T" + pad(date4.getUTCHours(), 2) + ":" + pad(date4.getUTCMinutes(), 2) + ":" + pad(date4.getUTCSeconds(), 2) + "." + pad(date4.getUTCMilliseconds(), 3);
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  };
  var normalizeQueryConfig = function(config, values4, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values4) {
      if (typeof values4 === "function") {
        config.callback = values4;
      } else {
        config.values = values4;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  };
  var defaults = require_defaults();
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (val instanceof Buffer) {
      return val;
    }
    if (ArrayBuffer.isView(val)) {
      var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
      if (buf.length === val.byteLength) {
        return buf;
      }
      return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
    }
    if (val instanceof Date) {
      if (defaults.parseInputDatesAsUTC) {
        return dateToStringUTC(val);
      } else {
        return dateToString(val);
      }
    }
    if (Array.isArray(val)) {
      return arrayString(val);
    }
    if (typeof val === "object") {
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    var hasBackslash = false;
    var escaped = "'";
    for (var i = 0;i < str.length; i++) {
      var c2 = str[i];
      if (c2 === "'") {
        escaped += c2 + c2;
      } else if (c2 === "\\") {
        escaped += c2 + c2;
        hasBackslash = true;
      } else {
        escaped += c2;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value14) {
      return prepareValue(value14);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var md5 = function(string6) {
    return nodeCrypto.createHash("md5").update(string6, "utf-8").digest("hex");
  };
  var postgresMd5PasswordHash = function(user, password, salt) {
    var inner = md5(password + user);
    var outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  };
  var sha256 = function(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  };
  var hmacSha256 = function(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  };
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var randomBytes = function(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  };
  async function md5(string6) {
    try {
      return nodeCrypto.createHash("md5").update(string6, "utf-8").digest("hex");
    } catch (e2) {
      const data = typeof string6 === "string" ? textEncoder.encode(string6) : string6;
      const hash6 = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash6)).map((b2) => b2.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    var inner = await md5(password + user);
    var outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params3 = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params3, key, 32 * 8, ["deriveBits"]);
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var startSession = function(mechanisms) {
    if (mechanisms.indexOf("SCRAM-SHA-256") === -1) {
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    return {
      mechanism: "SCRAM-SHA-256",
      clientNonce,
      response: "n,,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  };
  async function continueSession(session, password, serverData) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    var clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    var serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    var clientFinalMessageWithoutProof = "c=biws,r=" + sv.nonce;
    var authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    var saltBytes = Buffer.from(sv.salt, "base64");
    var saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    var clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    var storedKey = await crypto2.sha256(clientKey);
    var clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    var clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    var serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    var serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  var finalizeSession = function(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  };
  var isPrintableChars = function(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c2) => c2 >= 33 && c2 <= 43 || c2 >= 45 && c2 <= 126);
  };
  var isBase64 = function(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  };
  var parseAttributePairs = function(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value14 = attrValue.substring(2);
      return [name, value14];
    }));
  };
  var parseServerFirstMessage = function(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  };
  var parseServerFinalMessage = function(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  };
  var xorBuffers = function(a2, b2) {
    if (!Buffer.isBuffer(a2)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b2)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a2.length !== b2.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a2.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a2.map((_, i) => a2[i] ^ b2[i]));
  };
  var crypto2 = require_utils4();
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var TypeOverrides = function(userTypes) {
    this._types = userTypes || types24;
    this.text = {};
    this.binary = {};
  };
  var types24 = require_pg_types();
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  var parse5 = function(str) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
    }
    try {
      result = new URL(str, "postgres://base");
    } catch (e2) {
      result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
      dummyHost = true;
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? import.meta.require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    switch (config.sslmode) {
      case "disable": {
        config.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full": {
        break;
      }
      case "no-verify": {
        config.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return config;
  };
  module.exports = parse5;
  parse5.parse = parse5;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = import.meta.require("dns");
  var defaults = require_defaults();
  var parse5 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {
    } else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value14) {
    return "'" + ("" + value14).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params3, config, paramName) {
    var value14 = config[paramName];
    if (value14 !== undefined && value14 !== null) {
      params3.push(paramName + "=" + quoteParamValue(value14));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse5(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse5(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      var params3 = [];
      add(params3, this, "user");
      add(params3, this, "password");
      add(params3, this, "port");
      add(params3, this, "application_name");
      add(params3, this, "fallback_application_name");
      add(params3, this, "connect_timeout");
      add(params3, this, "options");
      var ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params3, ssl, "sslmode");
      add(params3, ssl, "sslca");
      add(params3, ssl, "sslkey");
      add(params3, ssl, "sslcert");
      add(params3, ssl, "sslrootcert");
      if (this.database) {
        params3.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params3.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params3.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params3.join(" "));
      }
      if (this.client_encoding) {
        params3.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params3.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params3.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types24 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types25) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types25;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      var match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      var row = new Array(rowData.length);
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      var row = { ...this._prebuiltEmptyResultObject };
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        var field3 = this.fields[i].name;
        if (rawValue !== null) {
          row[field3] = this._parsers[i](rawValue);
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      for (var i = 0;i < fieldDescriptions.length; i++) {
        var desc = fieldDescriptions[i];
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types24.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._createPrebuiltEmptyResultObject();
    }
    _createPrebuiltEmptyResultObject() {
      var row = {};
      for (var i = 0;i < this.fields.length; i++) {
        row[this.fields[i].name] = null;
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = import.meta.require("events");
  var Result = require_result();
  var utils32 = require_utils3();

  class Query extends EventEmitter {
    constructor(config, values4, callback) {
      super();
      config = utils32.normalizeQueryConfig(config, values4, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this.isPreparedStatement = false;
      this._canceledDueToError = false;
      this._promise = null;
    }
    requiresPreparation() {
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this.types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection2) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection2.sync();
      }
    }
    handleEmptyQuery(connection2) {
      if (this.rows) {
        connection2.sync();
      }
    }
    handleError(err, connection2) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection2) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection2.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        this.prepare(connection2);
      } else {
        connection2.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection2) {
      return this.name && connection2.parsedStatements[this.name];
    }
    handlePortalSuspended(connection2) {
      this._getRows(connection2, this.rows);
    }
    _getRows(connection2, rows) {
      connection2.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection2.sync();
      } else {
        connection2.flush();
      }
    }
    prepare(connection2) {
      this.isPreparedStatement = true;
      if (!this.hasBeenParsed(connection2)) {
        connection2.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection2.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils32.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection2);
        return;
      }
      connection2.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection2, this.rows);
    }
    handleCopyInResponse(connection2) {
      connection2.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection2) {
    }
  }
  module.exports = Query;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      var remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        var oldBuffer = this.buffer;
        var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string6) {
      if (!string6) {
        this.ensure(1);
      } else {
        var len = Buffer.byteLength(string6);
        this.ensure(len + 1);
        this.buffer.write(string6, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string6 = "") {
      var len = Buffer.byteLength(string6);
      this.ensure(len);
      this.buffer.write(string6, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      var result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    var bodyBuffer = writer.addCString("").flush();
    var length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query3 = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse5 = (query4) => {
    const name = query4.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types24 = query4.types || emptyArray;
    var len = types24.length;
    var buffer = writer.addCString(name).addCString(query4.text).addInt16(len);
    for (var i = 0;i < len; i++) {
      buffer.addInt32(types24[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values4, valueMapper) {
    for (let i = 0;i < values4.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values4[i], i) : values4[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values4 = config.values || emptyArray;
    const len = values4.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values4, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute5 = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string6) => {
    const stringLen = Buffer.byteLength(string6);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string6, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query: query3,
    parse: parse5,
    bind,
    execute: execute5,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {
      }
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var assert_1 = __importDefault(import.meta.require("assert"));
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser2 {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          assert_1.default.fail(`unknown message code: ${code.toString(16)}`);
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.int32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.int32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value14 = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value14);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          message.name = "authenticationSASL";
          message.mechanisms = [];
          let mechanism;
          do {
            mechanism = this.reader.cstring();
            if (mechanism) {
              message.mechanisms.push(mechanism);
            }
          } while (mechanism);
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\0") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser2;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var parse5 = function(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  exports.parse = parse5;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-cloudflare/dist/empty.js
var exports_empty = {};
__export(exports_empty, {
  default: () => {
    {
      return empty_default;
    }
  }
});
var empty_default;
var init_empty = __esm(() => {
  empty_default = {};
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  exports.getStream = function getStream(ssl) {
    const net = import.meta.require("net");
    if (typeof net.Socket === "function") {
      return new net.Socket;
    } else {
      const { CloudflareSocket } = (init_empty(), __toCommonJS(exports_empty));
      return new CloudflareSocket(ssl);
    }
  };
  exports.getSecureStream = function getSecureStream(options) {
    var tls = import.meta.require("tls");
    if (tls.connect) {
      return tls.connect(options);
    } else {
      options.socket.startTls(options);
      return options.socket;
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var net = import.meta.require("net");
  var EventEmitter = import.meta.require("events").EventEmitter;
  var { parse: parse5, serialize } = require_dist2();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      var self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      var self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error28) {
        if (self2._ending && (error28.code === "ECONNRESET" || error28.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error28);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        var responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        var net2 = import.meta.require("net");
        if (net2.isIP && net2.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse5(stream, (msg) => {
        var eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize.query(text));
    }
    parse(query3) {
      this._send(serialize.parse(query3));
    }
    bind(config) {
      this._send(serialize.bind(config));
    }
    execute(config) {
      this._send(serialize.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// /Users/richardguerre/Projects/flow/node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var transform5 = function(chunk, enc, cb) {
    let list6;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list6 = buf.split(this.matcher);
      if (list6.length === 1)
        return cb();
      list6.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list6 = this[kLast].split(this.matcher);
    }
    this[kLast] = list6.pop();
    for (let i = 0;i < list6.length; i++) {
      try {
        push2(this, this.mapper(list6[i]));
      } catch (error28) {
        return cb(error28);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  };
  var flush = function(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push2(this, this.mapper(this[kLast]));
      } catch (error28) {
        return cb(error28);
      }
    }
    cb();
  };
  var push2 = function(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  };
  var noop2 = function(incoming) {
    return incoming;
  };
  var split = function(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop2;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop2;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform5;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform2(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  };
  var { Transform: Transform2 } = import.meta.require("stream");
  var { StringDecoder } = import.meta.require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  module.exports = split;
});

// /Users/richardguerre/Projects/flow/node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var isRegFile = function(mode) {
    return (mode & S_IFMT) == S_IFREG;
  };
  var warn = function() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat("\n");
      warnStream.write(util2.format.apply(util2, args));
    }
  };
  var path = import.meta.require("path");
  var Stream = import.meta.require("stream").Stream;
  var split = require_split2();
  var util2 = import.meta.require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env3 = rawEnv || process.env;
    var file = env3.PGPASSFILE || (isWin ? path.join(env3.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env3.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field3, idx) {
      if (idx == 1) {
        if (Number(connInfo[field3] || defaultPort) === Number(entry[field3])) {
          return prev && true;
        }
      }
      return prev && (entry[field3] === "*" || entry[field3] === connInfo[field3]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i13) {
      var field3 = line.substring(i0, i13);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field3 = field3.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field3;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value14 = entry[fieldNames[idx]] || "";
      var res = rule(value14);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pgpass/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var fs = import.meta.require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/client.js
var require_client3 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var utils32 = require_utils3();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils4();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      var c2 = config || {};
      this._Promise = c2.Promise || global.Promise;
      this._types = new TypeOverrides(c2.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.connection = c2.connection || new Connection({
        stream: c2.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c2.keepAlive || false,
        keepAliveInitialDelayMillis: c2.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c2.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c2.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query3) => {
        process.nextTick(() => {
          query3.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      var self2 = this;
      var con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      this.connectionTimeoutHandle;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error28 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error28);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error28);
            } else {
              this._handleErrorEvent(error28);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error28);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject2) => {
        this._connect((error28) => {
          if (error28) {
            reject2(error28);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib3();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e2) {
          this.emit("error", e2);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e2) {
          this.emit("error", e2);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete(msg) {
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      var params3 = this.connectionParameters;
      var data = {
        user: params3.user,
        database: params3.database
      };
      var appName = params3.application_name || params3.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params3.replication) {
        data.replication = "" + params3.replication;
      }
      if (params3.statement_timeout) {
        data.statement_timeout = String(parseInt(params3.statement_timeout, 10));
      }
      if (params3.lock_timeout) {
        data.lock_timeout = String(parseInt(params3.lock_timeout, 10));
      }
      if (params3.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params3.idle_in_transaction_session_timeout, 10));
      }
      if (params3.options) {
        data.options = params3.options;
      }
      return data;
    }
    cancel(client2, query3) {
      if (client2.activeQuery === query3) {
        var con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client2.processID, client2.secretKey);
        });
      } else if (client2.queryQueue.indexOf(query3) !== -1) {
        client2.queryQueue.splice(client2.queryQueue.indexOf(query3), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils32.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils32.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values4, callback) {
      var query3;
      var result;
      var readTimeout;
      var readTimeoutTimer;
      var queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query3 = config;
        if (typeof values4 === "function") {
          query3.callback = query3.callback || values4;
        }
      } else {
        readTimeout = this.connectionParameters.query_timeout;
        query3 = new Query(config, values4, callback);
        if (!query3.callback) {
          result = new this._Promise((resolve, reject2) => {
            query3.callback = (err, res) => err ? reject2(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query3.callback;
        readTimeoutTimer = setTimeout(() => {
          var error28 = new Error("Query read timeout");
          process.nextTick(() => {
            query3.handleError(error28, this.connection);
          });
          queryCallback(error28);
          query3.callback = () => {
          };
          var index = this.queryQueue.indexOf(query3);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query3.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query3.binary) {
        query3.binary = true;
      }
      if (query3._result && !query3._result._types) {
        query3._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query3.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query3.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query3);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var throwOnDoubleRelease = function() {
    throw new Error("Release called on client which has already been released to the pool.");
  };
  var promisify = function(Promise3, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client2) {
      err ? rej(err) : res(client2);
    };
    const result = new Promise3(function(resolve, reject2) {
      res = resolve;
      rej = reject2;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  };
  var makeIdleListener = function(pool, client2) {
    return function idleListener(err) {
      err.client = client2;
      client2.removeListener("error", idleListener);
      client2.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client2);
      pool.emit("error", err, client2);
    };
  };
  var EventEmitter = import.meta.require("events").EventEmitter;
  var NOOP2 = function() {
  };
  var removeWhere = (list6, predicate) => {
    const i = list6.findIndex(predicate);
    return i === -1 ? undefined : list6.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client2, idleListener, timeoutId) {
      this.client = client2;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && ("password" in options)) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {
      };
      this.Client = this.options.Client || Client || require_lib4().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client2 = idleItem.client;
        client2.ref && client2.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client2, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client2) {
      const removed = removeWhere(this._idle, (item) => item.client === client2);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c2) => c2 !== client2);
      client2.end();
      this.emit("remove", client2);
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client2 = new this.Client(this.options);
      this._clients.push(client2);
      const idleListener = makeIdleListener(this, client2);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client2.connection ? client2.connection.stream.destroy() : client2.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client2.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client2.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c2) => c2 !== client2);
          if (timeoutHit) {
            err.message = "Connection terminated due to connection timeout";
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP2);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client2);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client2);
              if (idleIndex !== -1) {
                this._acquireClient(client2, new PendingItem((err2, client3, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client2.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client2, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client2, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client2);
      }
      this.emit("acquire", client2);
      client2.release = this._releaseOnce(client2, idleListener);
      client2.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client2, (err) => {
            if (err) {
              client2.release(err);
              return pendingItem.callback(err, undefined, NOOP2);
            }
            pendingItem.callback(undefined, client2, client2.release);
          });
        } else {
          pendingItem.callback(undefined, client2, client2.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client2, client2.release);
        } else {
          client2.release();
        }
      }
    }
    _releaseOnce(client2, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client2, idleListener, err);
      };
    }
    _release(client2, idleListener, err) {
      client2.on("error", idleListener);
      client2._poolUseCount = (client2._poolUseCount || 0) + 1;
      this.emit("release", err, client2);
      if (err || this.ending || !client2._queryable || client2._ending || client2._poolUseCount >= this.options.maxUses) {
        if (client2._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        this._remove(client2);
        this._pulseQueue();
        return;
      }
      const isExpired = this._expired.has(client2);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client2);
        this._remove(client2);
        this._pulseQueue();
        return;
      }
      let tid;
      if (this.options.idleTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client2);
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client2.unref();
      }
      this._idle.push(new IdleItem(client2, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values4, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values4 === "function") {
        cb = values4;
        values4 = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client2) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client2.release(err2);
          cb(err2);
        };
        client2.once("error", onError);
        this.log("dispatching query");
        try {
          client2.query(text, values4, (err2, res) => {
            this.log("query dispatched");
            client2.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client2.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client2.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client2) => acc + (this._expired.has(client2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// /Users/richardguerre/Projects/flow/node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports, module) => {
  var fileUriToPath = function(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest3 = decodeURI(uri.substring(7));
    var firstSlash = rest3.indexOf("/");
    var host = rest3.substring(0, firstSlash);
    var path = rest3.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {
    } else {
      path = sep + path;
    }
    return host + path;
  };
  var sep = import.meta.require("path").sep || "/";
  module.exports = fileUriToPath;
});

// /Users/richardguerre/Projects/flow/node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports, module) => {
  var bindings = function(opts) {
    if (typeof opts == "string") {
      opts = { bindings: opts };
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports.getRoot(exports.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var tries = [], i = 0, l2 = opts.try.length, n2, b2, err;
    for (;i < l2; i++) {
      n2 = join3.apply(null, opts.try[i].map(function(p2) {
        return opts[p2] || p2;
      }));
      tries.push(n2);
      try {
        b2 = opts.path ? requireFunc.resolve(n2) : requireFunc(n2);
        if (!opts.path) {
          b2.path = n2;
        }
        return b2;
      } catch (e2) {
        if (e2.code !== "MODULE_NOT_FOUND" && e2.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e2.message)) {
          throw e2;
        }
      }
    }
    err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a2) {
      return opts.arrow + a2;
    }).join("\n"));
    err.tries = tries;
    throw err;
  };
  var __filename = "/Users/richardguerre/Projects/flow/node_modules/bindings/bindings.js";
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join3 = path.join;
  var dirname = path.dirname;
  var exists = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e2) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  module.exports = exports = bindings;
  exports.getFileName = function getFileName(calling_file) {
    var { prepareStackTrace: origPST, stackTraceLimit: origSTL } = Error, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e2, st) {
      for (var i = 0, l2 = st.length;i < l2; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports.getRoot = function getRoot(file) {
    var dir = dirname(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists(join3(dir, "package.json")) || exists(join3(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join3(dir, "..");
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/libpq/index.js
var require_libpq = __commonJS((exports, module) => {
  var __dirname = "/Users/richardguerre/Projects/flow/node_modules/libpq";
  var PQ = module.exports = require_bindings()("addon.node").PQ;
  var assert = import.meta.require("assert");
  if (!module.parent) {
    path = import.meta.require("path");
    console.log(path.normalize(__dirname + "/src"));
  }
  var path;
  var EventEmitter = import.meta.require("events").EventEmitter;
  var assert = import.meta.require("assert");
  for (key in EventEmitter.prototype) {
    PQ.prototype[key] = EventEmitter.prototype[key];
  }
  var key;
  PQ.prototype.connectSync = function(paramString) {
    this.connected = true;
    if (!paramString) {
      paramString = "";
    }
    var connected = this.$connectSync(paramString);
    if (!connected) {
      var err = new Error(this.errorMessage());
      this.finish();
      throw err;
    }
  };
  PQ.prototype.connect = function(paramString, cb) {
    this.connected = true;
    if (typeof paramString == "function") {
      cb = paramString;
      paramString = "";
    }
    if (!paramString) {
      paramString = "";
    }
    assert(cb, "Must provide a connection callback");
    if (process.domain) {
      cb = process.domain.bind(cb);
    }
    this.$connect(paramString, cb);
  };
  PQ.prototype.errorMessage = function() {
    return this.$getLastErrorMessage();
  };
  PQ.prototype.socket = function() {
    return this.$socket();
  };
  PQ.prototype.serverVersion = function() {
    return this.$serverVersion();
  };
  PQ.prototype.finish = function() {
    this.connected = false;
    this.$finish();
  };
  PQ.prototype.exec = function(commandText) {
    if (!commandText) {
      commandText = "";
    }
    this.$exec(commandText);
  };
  PQ.prototype.execParams = function(commandText, parameters3) {
    if (!commandText) {
      commandText = "";
    }
    if (!parameters3) {
      parameters3 = [];
    }
    assert(Array.isArray(parameters3), "Parameters must be an array");
    this.$execParams(commandText, parameters3);
  };
  PQ.prototype.prepare = function(statementName, commandText, nParams) {
    assert.equal(arguments.length, 3, "Must supply 3 arguments");
    if (!statementName) {
      statementName = "";
    }
    if (!commandText) {
      commandText = "";
    }
    nParams = Number(nParams) || 0;
    this.$prepare(statementName, commandText, nParams);
  };
  PQ.prototype.execPrepared = function(statementName, parameters3) {
    if (!statementName) {
      statementName = "";
    }
    if (!parameters3) {
      parameters3 = [];
    }
    assert(Array.isArray(parameters3), "Parameters must be an array");
    this.$execPrepared(statementName, parameters3);
  };
  PQ.prototype.sendQuery = function(commandText) {
    if (!commandText) {
      commandText = "";
    }
    return this.$sendQuery(commandText);
  };
  PQ.prototype.sendQueryParams = function(commandText, parameters3) {
    if (!commandText) {
      commandText = "";
    }
    if (!parameters3) {
      parameters3 = [];
    }
    assert(Array.isArray(parameters3), "Parameters must be an array");
    return this.$sendQueryParams(commandText, parameters3);
  };
  PQ.prototype.sendPrepare = function(statementName, commandText, nParams) {
    assert.equal(arguments.length, 3, "Must supply 3 arguments");
    if (!statementName) {
      statementName = "";
    }
    if (!commandText) {
      commandText = "";
    }
    nParams = Number(nParams) || 0;
    return this.$sendPrepare(statementName, commandText, nParams);
  };
  PQ.prototype.sendQueryPrepared = function(statementName, parameters3) {
    if (!statementName) {
      statementName = "";
    }
    if (!parameters3) {
      parameters3 = [];
    }
    assert(Array.isArray(parameters3), "Parameters must be an array");
    return this.$sendQueryPrepared(statementName, parameters3);
  };
  PQ.prototype.getResult = function() {
    return this.$getResult();
  };
  PQ.prototype.resultStatus = function() {
    return this.$resultStatus();
  };
  PQ.prototype.resultErrorMessage = function() {
    return this.$resultErrorMessage();
  };
  PQ.prototype.resultErrorFields = function() {
    return this.$resultErrorFields();
  };
  PQ.prototype.clear = function() {
    this.$clear();
  };
  PQ.prototype.ntuples = function() {
    return this.$ntuples();
  };
  PQ.prototype.nfields = function() {
    return this.$nfields();
  };
  PQ.prototype.fname = function(offset) {
    return this.$fname(offset);
  };
  PQ.prototype.ftype = function(offset) {
    return this.$ftype(offset);
  };
  PQ.prototype.getvalue = function(row, col) {
    return this.$getvalue(row, col);
  };
  PQ.prototype.getisnull = function(row, col) {
    return this.$getisnull(row, col);
  };
  PQ.prototype.cmdStatus = function() {
    return this.$cmdStatus();
  };
  PQ.prototype.cmdTuples = function() {
    return this.$cmdTuples();
  };
  PQ.prototype.startReader = function() {
    assert(this.connected, "Must be connected to start reader");
    this.$startRead();
  };
  PQ.prototype.stopReader = function() {
    this.$stopRead();
  };
  PQ.prototype.writable = function(cb) {
    assert(this.connected, "Must be connected to start writer");
    this.$startWrite();
    return this.once("writable", cb);
  };
  PQ.prototype.consumeInput = function() {
    return this.$consumeInput();
  };
  PQ.prototype.isBusy = function() {
    return this.$isBusy();
  };
  PQ.prototype.setNonBlocking = function(truthy) {
    return this.$setNonBlocking(truthy ? 1 : 0);
  };
  PQ.prototype.isNonBlocking = function() {
    return this.$isNonBlocking();
  };
  PQ.prototype.flush = function() {
    return this.$flush();
  };
  PQ.prototype.escapeLiteral = function(input6) {
    if (!input6)
      return input6;
    return this.$escapeLiteral(input6);
  };
  PQ.prototype.escapeIdentifier = function(input6) {
    if (!input6)
      return input6;
    return this.$escapeIdentifier(input6);
  };
  PQ.prototype.notifies = function() {
    return this.$notifies();
  };
  PQ.prototype.putCopyData = function(buffer) {
    assert(buffer instanceof Buffer);
    return this.$putCopyData(buffer);
  };
  PQ.prototype.putCopyEnd = function(errorMessage) {
    if (errorMessage) {
      return this.$putCopyEnd(errorMessage);
    }
    return this.$putCopyEnd();
  };
  PQ.prototype.getCopyData = function(async) {
    return this.$getCopyData(!!async);
  };
  PQ.prototype.cancel = function() {
    return this.$cancel();
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/node_modules/postgres-array/index.js
var require_postgres_array2 = __commonJS((exports) => {
  var ArrayParser = function(source2, transform5) {
    this.source = source2;
    this.transform = transform5 || identity2;
    this.position = 0;
    this.entries = [];
    this.recorded = [];
    this.dimension = 0;
  };
  var identity2 = function(value14) {
    return value14;
  };
  exports.parse = function(source2, transform5) {
    return new ArrayParser(source2, transform5).parse();
  };
  ArrayParser.prototype.isEof = function() {
    return this.position >= this.source.length;
  };
  ArrayParser.prototype.nextCharacter = function() {
    var character = this.source[this.position++];
    if (character === "\\") {
      return {
        value: this.source[this.position++],
        escaped: true
      };
    }
    return {
      value: character,
      escaped: false
    };
  };
  ArrayParser.prototype.record = function(character) {
    this.recorded.push(character);
  };
  ArrayParser.prototype.newEntry = function(includeEmpty) {
    var entry;
    if (this.recorded.length > 0 || includeEmpty) {
      entry = this.recorded.join("");
      if (entry === "NULL" && !includeEmpty) {
        entry = null;
      }
      if (entry !== null)
        entry = this.transform(entry);
      this.entries.push(entry);
      this.recorded = [];
    }
  };
  ArrayParser.prototype.parse = function(nested) {
    var character, parser, quote;
    while (!this.isEof()) {
      character = this.nextCharacter();
      if (character.value === "{" && !quote) {
        this.dimension++;
        if (this.dimension > 1) {
          parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
          this.entries.push(parser.parse(true));
          this.position += parser.position - 2;
        }
      } else if (character.value === "}" && !quote) {
        this.dimension--;
        if (!this.dimension) {
          this.newEntry();
          if (nested)
            return this.entries;
        }
      } else if (character.value === '"' && !character.escaped) {
        if (quote)
          this.newEntry(true);
        quote = !quote;
      } else if (character.value === "," && !quote) {
        this.newEntry();
      } else {
        this.record(character.value);
      }
    }
    if (this.dimension !== 0) {
      throw new Error("array dimension not balanced");
    }
    return this.entries;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser2 = __commonJS((exports, module) => {
  var array4 = require_postgres_array2();
  module.exports = {
    create: function(source2, transform5) {
      return {
        parse: function() {
          return array4.parse(source2, transform5);
        }
      };
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/lib/textParsers.js
var require_textParsers2 = __commonJS((exports, module) => {
  var allowNull = function(fn) {
    return function nullAllowed(value14) {
      if (value14 === null)
        return value14;
      return fn(value14);
    };
  };
  var parseBool = function(value14) {
    if (value14 === null)
      return value14;
    return value14 === "TRUE" || value14 === "t" || value14 === "true" || value14 === "y" || value14 === "yes" || value14 === "on" || value14 === "1";
  };
  var parseBoolArray = function(value14) {
    if (!value14)
      return null;
    return array4.parse(value14, parseBool);
  };
  var parseBaseTenInt = function(string6) {
    return parseInt(string6, 10);
  };
  var parseIntegerArray = function(value14) {
    if (!value14)
      return null;
    return array4.parse(value14, allowNull(parseBaseTenInt));
  };
  var parseBigIntegerArray = function(value14) {
    if (!value14)
      return null;
    return array4.parse(value14, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  };
  var array4 = require_postgres_array2();
  var arrayParser = require_arrayParser2();
  var parseDate2 = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  var parsePointArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseFloatArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseStringArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14);
    return p2.parse();
  };
  var parseDateArray = function(value14) {
    if (!value14) {
      return null;
    }
    var p2 = arrayParser.create(value14, function(entry) {
      if (entry !== null) {
        entry = parseDate2(entry);
      }
      return entry;
    });
    return p2.parse();
  };
  var parseByteAArray = function(value14) {
    if (!value14) {
      return null;
    }
    return array4.parse(value14, allowNull(parseByteA));
  };
  var parseInteger = function(value14) {
    return parseInt(value14, 10);
  };
  var parseBigInteger = function(value14) {
    var valStr = String(value14);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value14;
  };
  var parseJsonArray = function(value14) {
    var arr = parseStringArray(value14);
    if (!arr) {
      return arr;
    }
    return arr.map(function(el) {
      return JSON.parse(el);
    });
  };
  var parsePoint = function(value14) {
    if (value14[0] !== "(") {
      return null;
    }
    value14 = value14.substring(1, value14.length - 1).split(",");
    return {
      x: parseFloat(value14[0]),
      y: parseFloat(value14[1])
    };
  };
  var parseCircle = function(value14) {
    if (value14[0] !== "<" && value14[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value14.length - 1; i++) {
      if (!pointParsed) {
        point += value14[i];
      }
      if (value14[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value14[i] === ",") {
        continue;
      }
      radius += value14[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate2);
    register(1114, parseDate2);
    register(1184, parseDate2);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers2 = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value14) {
      if (invert) {
        return ~value14 & 255;
      }
      return value14;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : (-Infinity);
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value14) {
    if (parseBits(value14, 1) == 1) {
      return -1 * (parseBits(value14, 15, 1, true) + 1);
    }
    return parseBits(value14, 15, 1);
  };
  var parseInt32 = function(value14) {
    if (parseBits(value14, 1) == 1) {
      return -1 * (parseBits(value14, 31, 1, true) + 1);
    }
    return parseBits(value14, 31, 1);
  };
  var parseFloat32 = function(value14) {
    return parseFloatFromBits(value14, 23, 8);
  };
  var parseFloat64 = function(value14) {
    return parseFloatFromBits(value14, 52, 11);
  };
  var parseNumeric = function(value14) {
    var sign = parseBits(value14, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value14, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value14, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value14, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value14, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate2 = function(isUTC, value14) {
    var sign = parseBits(value14, 1);
    var rawValue = parseBits(value14, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value15) {
      this.usec = value15;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value14) {
    var dim = parseBits(value14, 32);
    var flags = parseBits(value14, 32, 32);
    var elementType = parseBits(value14, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value14, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value14, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value14, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value14.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse5 = function(dimension, elementType2) {
      var array4 = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array4[i2] = parse5(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array4[i2] = parseElement(elementType2);
        }
      }
      return array4;
    };
    return parse5(dims, elementType);
  };
  var parseText = function(value14) {
    return value14.toString("utf8");
  };
  var parseBool = function(value14) {
    if (value14 === null)
      return null;
    return parseBits(value14, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate2.bind(null, false));
    register(1184, parseDate2.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/index.js
var require_pg_types2 = __commonJS((exports) => {
  var noParse = function(val) {
    return String(val);
  };
  var getTypeParser = function(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  };
  var setTypeParser = function(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  };
  var textParsers = require_textParsers2();
  var binaryParsers = require_binaryParsers2();
  var arrayParser = require_arrayParser2();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  var typeParsers = {
    text: {},
    binary: {}
  };
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/lib/build-result.js
var require_build_result = __commonJS((exports, module) => {
  var buildResult = function(pq, types24, arrayMode) {
    const result = new Result(types24, arrayMode);
    result.consumeCommand(pq);
    result.consumeFields(pq);
    result.consumeRows(pq);
    return result;
  };

  class Result {
    constructor(types24, arrayMode) {
      this._types = types24;
      this._arrayMode = arrayMode;
      this.command = undefined;
      this.rowCount = undefined;
      this.fields = [];
      this.rows = [];
    }
    consumeCommand(pq) {
      this.command = pq.cmdStatus().split(" ")[0];
      this.rowCount = parseInt(pq.cmdTuples(), 10);
    }
    consumeFields(pq) {
      const nfields = pq.nfields();
      for (var x = 0;x < nfields; x++) {
        this.fields.push({
          name: pq.fname(x),
          dataTypeID: pq.ftype(x)
        });
      }
    }
    consumeRows(pq) {
      const tupleCount = pq.ntuples();
      for (var i = 0;i < tupleCount; i++) {
        const row = this._arrayMode ? this.consumeRowAsArray(pq, i) : this.consumeRowAsObject(pq, i);
        this.rows.push(row);
      }
    }
    consumeRowAsObject(pq, rowIndex) {
      const row = {};
      for (var j = 0;j < this.fields.length; j++) {
        const value14 = this.readValue(pq, rowIndex, j);
        row[this.fields[j].name] = value14;
      }
      return row;
    }
    consumeRowAsArray(pq, rowIndex) {
      const row = [];
      for (var j = 0;j < this.fields.length; j++) {
        const value14 = this.readValue(pq, rowIndex, j);
        row.push(value14);
      }
      return row;
    }
    readValue(pq, rowIndex, colIndex) {
      var rawValue = pq.getvalue(rowIndex, colIndex);
      if (rawValue === "") {
        if (pq.getisnull(rowIndex, colIndex)) {
          return null;
        }
      }
      const dataTypeId = this.fields[colIndex].dataTypeID;
      return this._types.getTypeParser(dataTypeId)(rawValue);
    }
  }
  module.exports = buildResult;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/lib/copy-stream.js
var require_copy_stream = __commonJS((exports, module) => {
  var Duplex = import.meta.require("stream").Duplex;
  var Writable = import.meta.require("stream").Writable;
  var util2 = import.meta.require("util");
  var CopyStream = module.exports = function(pq, options) {
    Duplex.call(this, options);
    this.pq = pq;
    this._reading = false;
  };
  util2.inherits(CopyStream, Duplex);
  CopyStream.prototype._write = function(chunk, encoding, cb) {
    var result = this.pq.putCopyData(chunk);
    if (result === 1)
      return cb();
    if (result === -1)
      return cb(new Error(this.pq.errorMessage()));
    var self2 = this;
    this.pq.writable(function() {
      self2._write(chunk, encoding, cb);
    });
  };
  CopyStream.prototype.end = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var self2 = this;
    var callback = args.pop();
    if (args.length) {
      this.write(args[0]);
    }
    var result = this.pq.putCopyEnd();
    if (result === 1) {
      return consumeResults(this.pq, function(err2, res) {
        Writable.prototype.end.call(self2);
        if (callback) {
          callback(err2);
        }
      });
    }
    if (result === -1) {
      var err = new Error(this.pq.errorMessage());
      return this.emit("error", err);
    }
    return this.pq.writable(function() {
      return self2.end.apply(self2, callback);
    });
  };
  CopyStream.prototype._consumeBuffer = function(cb) {
    var result = this.pq.getCopyData(true);
    if (result instanceof Buffer) {
      return setImmediate(function() {
        cb(null, result);
      });
    }
    if (result === -1) {
      return cb(null, null);
    }
    if (result === 0) {
      var self2 = this;
      this.pq.once("readable", function() {
        self2.pq.stopReader();
        self2.pq.consumeInput();
        self2._consumeBuffer(cb);
      });
      return this.pq.startReader();
    }
    cb(new Error("Unrecognized read status: " + result));
  };
  CopyStream.prototype._read = function(size) {
    if (this._reading)
      return;
    this._reading = true;
    var self2 = this;
    this._consumeBuffer(function(err, buffer) {
      self2._reading = false;
      if (err) {
        return self2.emit("error", err);
      }
      if (buffer === false) {
        return;
      }
      self2.push(buffer);
    });
  };
  var consumeResults = function(pq, cb) {
    var cleanup = function() {
      pq.removeListener("readable", onReadable);
      pq.stopReader();
    };
    var readError = function(message) {
      cleanup();
      return cb(new Error(message || pq.errorMessage()));
    };
    var onReadable = function() {
      if (!pq.consumeInput()) {
        return readError();
      }
      if (pq.isBusy()) {
        return;
      }
      pq.getResult();
      if (pq.getResult() && pq.resultStatus() !== "PGRES_COPY_OUT") {
        return readError("Only one result at a time is accepted");
      }
      if (pq.resultStatus() === "PGRES_FATAL_ERROR") {
        return readError();
      }
      cleanup();
      return cb(null);
    };
    pq.on("readable", onReadable);
    pq.startReader();
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "pg-native",
    version: "3.0.1",
    description: "A slightly nicer interface to Postgres over node-libpq",
    main: "index.js",
    scripts: {
      test: "mocha && eslint ."
    },
    repository: {
      type: "git",
      url: "git://github.com/brianc/node-pg-native.git"
    },
    keywords: [
      "postgres",
      "pg",
      "libpq"
    ],
    author: "Brian M. Carlson",
    license: "MIT",
    bugs: {
      url: "https://github.com/brianc/node-pg-native/issues"
    },
    homepage: "https://github.com/brianc/node-pg-native",
    dependencies: {
      libpq: "^1.8.10",
      "pg-types": "^1.12.1",
      "readable-stream": "1.0.31"
    },
    devDependencies: {
      async: "^0.9.0",
      "concat-stream": "^1.4.6",
      eslint: "4.2.0",
      "eslint-config-standard": "10.2.1",
      "eslint-plugin-import": "2.7.0",
      "eslint-plugin-node": "5.1.0",
      "eslint-plugin-promise": "3.5.0",
      "eslint-plugin-standard": "3.0.1",
      "generic-pool": "^2.1.1",
      lodash: "^2.4.1",
      mocha: "3.4.2",
      okay: "^0.3.0",
      pg: "*",
      semver: "^4.1.0"
    },
    prettier: {
      printWidth: 200
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/index.js
var require_pg_native = __commonJS((exports, module) => {
  var Libpq = require_libpq();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var assert = import.meta.require("assert");
  var types24 = require_pg_types2();
  var buildResult = require_build_result();
  var CopyStream = require_copy_stream();
  var Client = module.exports = function(config) {
    if (!(this instanceof Client)) {
      return new Client(config);
    }
    config = config || {};
    EventEmitter.call(this);
    this.pq = new Libpq;
    this._reading = false;
    this._read = this._read.bind(this);
    this._types = config.types || types24;
    this.arrayMode = config.arrayMode || false;
    this._resultCount = 0;
    this._rows = undefined;
    this._results = undefined;
    this.on("newListener", (event) => {
      if (event !== "notification")
        return;
      this._startReading();
    });
    this.on("result", this._onResult.bind(this));
    this.on("readyForQuery", this._onReadyForQuery.bind(this));
  };
  util2.inherits(Client, EventEmitter);
  Client.prototype.connect = function(params3, cb) {
    this.pq.connect(params3, cb);
  };
  Client.prototype.connectSync = function(params3) {
    this.pq.connectSync(params3);
  };
  Client.prototype.query = function(text, values4, cb) {
    var queryFn;
    if (typeof values4 === "function") {
      cb = values4;
    }
    if (Array.isArray(values4) && values4.length > 0) {
      queryFn = function() {
        return self2.pq.sendQueryParams(text, values4);
      };
    } else {
      queryFn = function() {
        return self2.pq.sendQuery(text);
      };
    }
    var self2 = this;
    self2._dispatchQuery(self2.pq, queryFn, function(err) {
      if (err)
        return cb(err);
      self2._awaitResult(cb);
    });
  };
  Client.prototype.prepare = function(statementName, text, nParams, cb) {
    var self2 = this;
    var fn = function() {
      return self2.pq.sendPrepare(statementName, text, nParams);
    };
    self2._dispatchQuery(self2.pq, fn, function(err) {
      if (err)
        return cb(err);
      self2._awaitResult(cb);
    });
  };
  Client.prototype.execute = function(statementName, parameters3, cb) {
    var self2 = this;
    var fn = function() {
      return self2.pq.sendQueryPrepared(statementName, parameters3);
    };
    self2._dispatchQuery(self2.pq, fn, function(err, rows) {
      if (err)
        return cb(err);
      self2._awaitResult(cb);
    });
  };
  Client.prototype.getCopyStream = function() {
    this.pq.setNonBlocking(true);
    this._stopReading();
    return new CopyStream(this.pq);
  };
  Client.prototype.cancel = function(cb) {
    assert(cb, "Callback is required");
    var result = this.pq.cancel();
    return setImmediate(function() {
      cb(result === true ? undefined : new Error(result));
    });
  };
  Client.prototype.querySync = function(text, values4) {
    if (values4) {
      this.pq.execParams(text, values4);
    } else {
      this.pq.exec(text);
    }
    throwIfError(this.pq);
    const result = buildResult(this.pq, this._types, this.arrayMode);
    return result.rows;
  };
  Client.prototype.prepareSync = function(statementName, text, nParams) {
    this.pq.prepare(statementName, text, nParams);
    throwIfError(this.pq);
  };
  Client.prototype.executeSync = function(statementName, parameters3) {
    this.pq.execPrepared(statementName, parameters3);
    throwIfError(this.pq);
    return buildResult(this.pq, this._types, this.arrayMode).rows;
  };
  Client.prototype.escapeLiteral = function(value14) {
    return this.pq.escapeLiteral(value14);
  };
  Client.prototype.escapeIdentifier = function(value14) {
    return this.pq.escapeIdentifier(value14);
  };
  module.exports.version = require_package().version;
  Client.prototype.end = function(cb) {
    this._stopReading();
    this.pq.finish();
    if (cb)
      setImmediate(cb);
  };
  Client.prototype._readError = function(message) {
    var err = new Error(message || this.pq.errorMessage());
    this.emit("error", err);
  };
  Client.prototype._stopReading = function() {
    if (!this._reading)
      return;
    this._reading = false;
    this.pq.stopReader();
    this.pq.removeListener("readable", this._read);
  };
  Client.prototype._consumeQueryResults = function(pq) {
    return buildResult(pq, this._types, this.arrayMode);
  };
  Client.prototype._emitResult = function(pq) {
    var status = pq.resultStatus();
    switch (status) {
      case "PGRES_FATAL_ERROR":
        this._queryError = new Error(this.pq.resultErrorMessage());
        break;
      case "PGRES_TUPLES_OK":
      case "PGRES_COMMAND_OK":
      case "PGRES_EMPTY_QUERY":
        const result = this._consumeQueryResults(this.pq);
        this.emit("result", result);
        break;
      case "PGRES_COPY_OUT":
      case "PGRES_COPY_BOTH": {
        break;
      }
      default:
        this._readError("unrecognized command status: " + status);
        break;
    }
    return status;
  };
  Client.prototype._read = function() {
    var pq = this.pq;
    if (!pq.consumeInput()) {
      return this._readError();
    }
    if (pq.isBusy()) {
      return;
    }
    while (pq.getResult()) {
      const resultStatus = this._emitResult(this.pq);
      if (resultStatus === "PGRES_COPY_BOTH" || resultStatus === "PGRES_COPY_OUT") {
        break;
      }
      if (pq.isBusy()) {
        return;
      }
    }
    this.emit("readyForQuery");
    var notice = this.pq.notifies();
    while (notice) {
      this.emit("notification", notice);
      notice = this.pq.notifies();
    }
  };
  Client.prototype._startReading = function() {
    if (this._reading)
      return;
    this._reading = true;
    this.pq.on("readable", this._read);
    this.pq.startReader();
  };
  var throwIfError = function(pq) {
    var err = pq.resultErrorMessage() || pq.errorMessage();
    if (err) {
      throw new Error(err);
    }
  };
  Client.prototype._awaitResult = function(cb) {
    this._queryCallback = cb;
    return this._startReading();
  };
  Client.prototype._waitForDrain = function(pq, cb) {
    var res = pq.flush();
    if (res === 0)
      return cb();
    if (res === -1)
      return cb(pq.errorMessage());
    var self2 = this;
    return pq.writable(function() {
      self2._waitForDrain(pq, cb);
    });
  };
  Client.prototype._dispatchQuery = function(pq, fn, cb) {
    this._stopReading();
    var success = pq.setNonBlocking(true);
    if (!success)
      return cb(new Error("Unable to set non-blocking to true"));
    var sent = fn();
    if (!sent)
      return cb(new Error(pq.errorMessage() || "Something went wrong dispatching the query"));
    this._waitForDrain(pq, cb);
  };
  Client.prototype._onResult = function(result) {
    if (this._resultCount === 0) {
      this._results = result;
      this._rows = result.rows;
    } else if (this._resultCount === 1) {
      this._results = [this._results, result];
      this._rows = [this._rows, result.rows];
    } else {
      this._results.push(result);
      this._rows.push(result.rows);
    }
    this._resultCount++;
  };
  Client.prototype._onReadyForQuery = function() {
    const cb = this._queryCallback;
    this._queryCallback = undefined;
    const err = this._queryError;
    this._queryError = undefined;
    const rows = this._rows;
    this._rows = undefined;
    const results = this._results;
    this._results = undefined;
    this._resultCount = 0;
    if (cb) {
      cb(err, rows || [], results);
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var utils32 = require_utils3();
  var NativeQuery = module.exports = function(config, values4, callback) {
    EventEmitter.call(this);
    config = utils32.normalizeQueryConfig(config, values4, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util2.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    var fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (var key in fields) {
        var normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject2) {
      this._once("end", resolve);
      this._once("error", reject2);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client2) {
    this.state = "running";
    var self2 = this;
    this.native = client2.native;
    client2.native.arrayMode = this._arrayMode;
    var after = function(err, rows, results) {
      client2.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      var values4 = (this.values || []).map(utils32.prepareValue);
      if (client2.namedQueries[this.name]) {
        if (this.text && client2.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client2.native.execute(this.name, values4, after);
      }
      return client2.native.prepare(this.name, this.text, values4.length, function(err) {
        if (err)
          return after(err);
        client2.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values4, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      var vals = this.values.map(utils32.prepareValue);
      client2.native.query(this.text, vals, after);
    } else {
      client2.native.query(this.text, after);
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/native/client.js
var require_client4 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = require_pg_native();
  } catch (e2) {
    throw e2;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    var cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util2.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query3) => {
      process.nextTick(() => {
        query3.native = this.native;
        query3.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    var self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject2) => {
      this._connect((error28) => {
        if (error28) {
          reject2(error28);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values4, callback) {
    var query3;
    var result;
    var readTimeout;
    var readTimeoutTimer;
    var queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query3 = config;
      if (typeof values4 === "function") {
        config.callback = values4;
      }
    } else {
      readTimeout = this.connectionParameters.query_timeout;
      query3 = new NativeQuery(config, values4, callback);
      if (!query3.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject2) => {
          resolveOut = resolve;
          rejectOut = reject2;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query3.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query3.callback;
      readTimeoutTimer = setTimeout(() => {
        var error28 = new Error("Query read timeout");
        process.nextTick(() => {
          query3.handleError(error28, this.connection);
        });
        queryCallback(error28);
        query3.callback = () => {
        };
        var index = this._queryQueue.indexOf(query3);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query3.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query3.native = this.native;
      process.nextTick(() => {
        query3.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query3.native = this.native;
      process.nextTick(() => {
        query3.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query3);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    var self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    var result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject2) {
        cb = (err) => err ? reject2(err) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    var query3 = this._queryQueue.shift();
    if (!query3) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query3;
    query3.submit(this);
    var self2 = this;
    query3.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query3) {
    if (this._activeQuery === query3) {
      this.native.cancel(function() {
      });
    } else if (this._queryQueue.indexOf(query3) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query3), 1);
    }
  };
  Client.prototype.ref = function() {
  };
  Client.prototype.unref = function() {
  };
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var Client = require_client3();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Pool = require_pg_pool();
  var { DatabaseError } = require_dist2();
  var { escapeIdentifier, escapeLiteral } = require_utils3();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client4());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        var native = null;
        try {
          native = new PG(require_client4());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/db.js
var require_db = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var pg = require_lib4();

  class Db extends EventEmitter {
    constructor(config) {
      super();
      config.application_name = config.application_name || "pgboss";
      this.config = config;
    }
    async open() {
      this.pool = new pg.Pool(this.config);
      this.pool.on("error", (error28) => this.emit("error", error28));
      this.opened = true;
    }
    async close() {
      if (!this.pool.ending) {
        this.opened = false;
        await this.pool.end();
      }
    }
    async executeSql(text, values4) {
      if (this.opened) {
        return await this.pool.query(text, values4);
      }
    }
    static quotePostgresStr(str) {
      const delimeter = "$sanitize$";
      if (str.includes(delimeter)) {
        throw new Error(`Attempted to quote string that contains reserved Postgres delimeter: ${str}`);
      }
      return `${delimeter}${str}${delimeter}`;
    }
  }
  module.exports = Db;
});

// /Users/richardguerre/Projects/flow/node_modules/indent-string/index.js
var require_indent_string = __commonJS((exports, module) => {
  module.exports = (string6, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string6 !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string6}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string6;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string6.replace(regex, options.indent.repeat(count));
  };
});

// /Users/richardguerre/Projects/flow/node_modules/clean-stack/index.js
var require_clean_stack = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
  var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
  var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
  module.exports = (stack, options) => {
    options = Object.assign({ pretty: false }, options);
    return stack.replace(/\\/g, "/").split("\n").filter((line) => {
      const pathMatches = line.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1]) {
        return true;
      }
      const match = pathMatches[1];
      if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
        return false;
      }
      return !pathRegex.test(match);
    }).filter((line) => line.trim() !== "").map((line) => {
      if (options.pretty) {
        return line.replace(extractPathRegex, (m2, p12) => m2.replace(p12, p12.replace(homeDir, "~")));
      }
      return line;
    }).join("\n");
  };
});

// /Users/richardguerre/Projects/flow/node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS((exports, module) => {
  var indentString = require_indent_string();
  var cleanStack = require_clean_stack();
  var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");

  class AggregateError extends Error {
    constructor(errors19) {
      if (!Array.isArray(errors19)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors19}`);
      }
      errors19 = [...errors19].map((error28) => {
        if (error28 instanceof Error) {
          return error28;
        }
        if (error28 !== null && typeof error28 === "object") {
          return Object.assign(new Error(error28.message), error28);
        }
        return new Error(error28);
      });
      let message = errors19.map((error28) => {
        return typeof error28.stack === "string" ? cleanInternalStack(cleanStack(error28.stack)) : String(error28);
      }).join("\n");
      message = "\n" + indentString(message, 4);
      super(message);
      this.name = "AggregateError";
      Object.defineProperty(this, "_errors", { value: errors19 });
    }
    *[Symbol.iterator]() {
      for (const error28 of this._errors) {
        yield error28;
      }
    }
  }
  module.exports = AggregateError;
});

// /Users/richardguerre/Projects/flow/node_modules/p-map/index.js
var require_p_map = __commonJS((exports, module) => {
  var AggregateError = require_aggregate_error();
  module.exports = async (iterable, mapper, {
    concurrency = Infinity,
    stopOnError = true
  } = {}) => {
    return new Promise((resolve, reject2) => {
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const result = [];
      const errors19 = [];
      const iterator4 = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator4.next();
        const index = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            if (!stopOnError && errors19.length !== 0) {
              reject2(new AggregateError(errors19));
            } else {
              resolve(result);
            }
          }
          return;
        }
        resolvingCount++;
        (async () => {
          try {
            const element = await nextItem.value;
            result[index] = await mapper(element, index);
            resolvingCount--;
            next();
          } catch (error28) {
            if (stopOnError) {
              isRejected = true;
              reject2(error28);
            } else {
              errors19.push(error28);
              resolvingCount--;
              next();
            }
          }
        })();
      };
      for (let i = 0;i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/boss.js
var require_boss = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var { states } = require_plans();
  var { COMPLETION_JOB_PREFIX } = plans;
  var queues = {
    MAINTENANCE: "__pgboss__maintenance",
    MONITOR_STATES: "__pgboss__monitor-states"
  };
  var events2 = {
    error: "error",
    monitorStates: "monitor-states",
    maintenance: "maintenance"
  };

  class Boss extends EventEmitter {
    constructor(db, config) {
      super();
      this.db = db;
      this.config = config;
      this.manager = config.manager;
      this.maintenanceIntervalSeconds = config.maintenanceIntervalSeconds;
      this.monitorStates = config.monitorStateIntervalSeconds !== null;
      if (this.monitorStates) {
        this.monitorIntervalSeconds = config.monitorStateIntervalSeconds;
      }
      this.events = events2;
      this.expireCommand = plans.locked(config.schema, plans.expire(config.schema));
      this.archiveCommand = plans.locked(config.schema, plans.archive(config.schema, config.archiveInterval, config.archiveFailedInterval));
      this.purgeCommand = plans.locked(config.schema, plans.purge(config.schema, config.deleteAfter));
      this.getMaintenanceTimeCommand = plans.getMaintenanceTime(config.schema);
      this.setMaintenanceTimeCommand = plans.setMaintenanceTime(config.schema);
      this.countStatesCommand = plans.countStates(config.schema);
      this.functions = [
        this.expire,
        this.archive,
        this.purge,
        this.countStates,
        this.getQueueNames
      ];
    }
    async supervise() {
      this.metaMonitor();
      await this.manager.deleteQueue(COMPLETION_JOB_PREFIX + queues.MAINTENANCE);
      await this.manager.deleteQueue(queues.MAINTENANCE);
      await this.maintenanceAsync();
      const maintenanceWorkOptions = {
        newJobCheckIntervalSeconds: Math.max(1, this.maintenanceIntervalSeconds / 2)
      };
      await this.manager.work(queues.MAINTENANCE, maintenanceWorkOptions, (job) => this.onMaintenance(job));
      if (this.monitorStates) {
        await this.manager.deleteQueue(COMPLETION_JOB_PREFIX + queues.MONITOR_STATES);
        await this.manager.deleteQueue(queues.MONITOR_STATES);
        await this.monitorStatesAsync();
        const monitorStatesWorkOptions = {
          newJobCheckIntervalSeconds: Math.max(1, this.monitorIntervalSeconds / 2)
        };
        await this.manager.work(queues.MONITOR_STATES, monitorStatesWorkOptions, (job) => this.onMonitorStates(job));
      }
    }
    metaMonitor() {
      this.metaMonitorInterval = setInterval(async () => {
        try {
          if (this.config.__test__throw_meta_monitor) {
            throw new Error(this.config.__test__throw_meta_monitor);
          }
          const { secondsAgo } = await this.getMaintenanceTime();
          if (secondsAgo > this.maintenanceIntervalSeconds * 2) {
            await this.manager.deleteQueue(queues.MAINTENANCE, { before: states.completed });
            await this.maintenanceAsync();
          }
        } catch (err) {
          this.emit(events2.error, err);
        }
      }, this.maintenanceIntervalSeconds * 2 * 1000);
    }
    async maintenanceAsync(options = {}) {
      const { startAfter } = options;
      options = {
        startAfter,
        retentionSeconds: this.maintenanceIntervalSeconds * 4,
        singletonKey: queues.MAINTENANCE,
        onComplete: false
      };
      await this.manager.send(queues.MAINTENANCE, null, options);
    }
    async monitorStatesAsync(options = {}) {
      const { startAfter } = options;
      options = {
        startAfter,
        retentionSeconds: this.monitorIntervalSeconds * 4,
        singletonKey: queues.MONITOR_STATES,
        onComplete: false
      };
      await this.manager.send(queues.MONITOR_STATES, null, options);
    }
    async onMaintenance(job) {
      try {
        if (this.config.__test__throw_maint) {
          throw new Error(this.config.__test__throw_maint);
        }
        const started = Date.now();
        await this.expire();
        await this.archive();
        await this.purge();
        const ended = Date.now();
        await this.setMaintenanceTime();
        this.emit("maintenance", { ms: ended - started });
        if (!this.stopped) {
          await this.manager.complete(job.id);
          await this.maintenanceAsync({ startAfter: this.maintenanceIntervalSeconds });
        }
      } catch (err) {
        this.emit(events2.error, err);
      }
    }
    async onMonitorStates(job) {
      try {
        if (this.config.__test__throw_monitor) {
          throw new Error(this.config.__test__throw_monitor);
        }
        const states2 = await this.countStates();
        this.emit(events2.monitorStates, states2);
        if (!this.stopped && this.monitorStates) {
          await this.manager.complete(job.id);
          await this.monitorStatesAsync({ startAfter: this.monitorIntervalSeconds });
        }
      } catch (err) {
        this.emit(events2.error, err);
      }
    }
    async stop() {
      if (this.config.__test__throw_stop) {
        throw new Error(this.config.__test__throw_stop);
      }
      if (!this.stopped) {
        if (this.metaMonitorInterval) {
          clearInterval(this.metaMonitorInterval);
        }
        await this.manager.offWork(queues.MAINTENANCE);
        if (this.monitorStates) {
          await this.manager.offWork(queues.MONITOR_STATES);
        }
        this.stopped = true;
      }
    }
    async countStates() {
      const stateCountDefault = { ...plans.states };
      Object.keys(stateCountDefault).forEach((key) => {
        stateCountDefault[key] = 0;
      });
      const counts = await this.executeSql(this.countStatesCommand);
      const states2 = counts.rows.reduce((acc, item) => {
        if (item.name) {
          acc.queues[item.name] = acc.queues[item.name] || { ...stateCountDefault };
        }
        const queue = item.name ? acc.queues[item.name] : acc;
        const state = item.state || "all";
        queue[state] = parseFloat(item.size);
        return acc;
      }, { ...stateCountDefault, queues: {} });
      return states2;
    }
    async expire() {
      await this.executeSql(this.expireCommand);
    }
    async archive() {
      await this.executeSql(this.archiveCommand);
    }
    async purge() {
      await this.executeSql(this.purgeCommand);
    }
    async setMaintenanceTime() {
      await this.executeSql(this.setMaintenanceTimeCommand);
    }
    async getMaintenanceTime() {
      if (!this.stopped) {
        const { rows } = await this.db.executeSql(this.getMaintenanceTimeCommand);
        let { maintained_on: maintainedOn, seconds_ago: secondsAgo } = rows[0];
        secondsAgo = secondsAgo !== null ? parseFloat(secondsAgo) : this.maintenanceIntervalSeconds * 10;
        return { maintainedOn, secondsAgo };
      }
    }
    getQueueNames() {
      return queues;
    }
    async executeSql(sql, params3) {
      if (!this.stopped) {
        return await this.db.executeSql(sql, params3);
      }
    }
  }
  module.exports = Boss;
  module.exports.QUEUES = queues;
});

// /Users/richardguerre/Projects/flow/node_modules/luxon/build/node/luxon.js
var require_luxon = __commonJS((exports) => {
  var makeDTF = function(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  };
  var hackyOffset = function(dtf, date4) {
    const formatted = dtf.format(date4).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  };
  var partsOffset = function(dtf, date4) {
    const formatted = dtf.formatToParts(date4);
    const filled = [];
    for (let i = 0;i < formatted.length; i++) {
      const {
        type: type74,
        value: value14
      } = formatted[i];
      const pos = typeToPos[type74];
      if (type74 === "era") {
        filled[pos] = value14;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value14, 10);
      }
    }
    return filled;
  };
  var getCachedLF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedDTF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedINF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  };
  var getCachedRTF = function(locString, opts = {}) {
    const {
      base: base18,
      ...cacheKeyOpts
    } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  };
  var systemLocale = function() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  };
  var parseLocaleString = function(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e2) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const {
        numberingSystem,
        calendar
      } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  };
  var intlConfigString = function(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  };
  var mapMonths = function(f) {
    const ms = [];
    for (let i = 1;i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  };
  var mapWeekdays = function(f) {
    const ms = [];
    for (let i = 1;i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  };
  var listStuff = function(loc, length, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  };
  var supportsFastNumbers = function(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  };
  var normalizeZone = function(input6, defaultZone2) {
    if (isUndefined(input6) || input6 === null) {
      return defaultZone2;
    } else if (input6 instanceof Zone) {
      return input6;
    } else if (isString(input6)) {
      const lowered = input6.toLowerCase();
      if (lowered === "default")
        return defaultZone2;
      else if (lowered === "local" || lowered === "system")
        return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt")
        return FixedOffsetZone.utcInstance;
      else
        return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input6);
    } else if (isNumber(input6)) {
      return FixedOffsetZone.instance(input6);
    } else if (typeof input6 === "object" && ("offset" in input6) && typeof input6.offset === "function") {
      return input6;
    } else {
      return new InvalidZone(input6);
    }
  };
  var isUndefined = function(o2) {
    return typeof o2 === "undefined";
  };
  var isNumber = function(o2) {
    return typeof o2 === "number";
  };
  var isInteger = function(o2) {
    return typeof o2 === "number" && o2 % 1 === 0;
  };
  var isString = function(o2) {
    return typeof o2 === "string";
  };
  var isDate = function(o2) {
    return Object.prototype.toString.call(o2) === "[object Date]";
  };
  var hasRelative = function() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e2) {
      return false;
    }
  };
  var maybeArray = function(thing) {
    return Array.isArray(thing) ? thing : [thing];
  };
  var bestBy = function(arr, by, compare) {
    if (arr.length === 0) {
      return;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  };
  var pick5 = function(obj, keys) {
    return keys.reduce((a2, k2) => {
      a2[k2] = obj[k2];
      return a2;
    }, {});
  };
  var hasOwnProperty3 = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  var integerBetween = function(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  };
  var floorMod = function(x, n3) {
    return x - n3 * Math.floor(x / n3);
  };
  var padStart = function(input6, n3 = 2) {
    const isNeg = input6 < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input6).padStart(n3, "0");
    } else {
      padded = ("" + input6).padStart(n3, "0");
    }
    return padded;
  };
  var parseInteger = function(string6) {
    if (isUndefined(string6) || string6 === null || string6 === "") {
      return;
    } else {
      return parseInt(string6, 10);
    }
  };
  var parseFloating = function(string6) {
    if (isUndefined(string6) || string6 === null || string6 === "") {
      return;
    } else {
      return parseFloat(string6);
    }
  };
  var parseMillis = function(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return;
    } else {
      const f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  };
  var roundTo = function(number6, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number6 * factor) / factor;
  };
  var isLeapYear = function(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var daysInYear = function(year) {
    return isLeapYear(year) ? 366 : 365;
  };
  var daysInMonth = function(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  };
  var objToLocalTS = function(obj) {
    let d2 = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
    if (obj.year < 100 && obj.year >= 0) {
      d2 = new Date(d2);
      d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d2;
  };
  var weeksInWeekYear = function(weekYear) {
    const p12 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
    return p12 === 4 || p2 === 3 ? 53 : 52;
  };
  var untruncateYear = function(year) {
    if (year > 99) {
      return year;
    } else
      return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
  };
  var parseZoneInfo = function(ts, offsetFormat, locale, timeZone = null) {
    const date4 = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = {
      timeZoneName: offsetFormat,
      ...intlOpts
    };
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date4).find((m2) => m2.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  };
  var signedOffset = function(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  };
  var asNumber = function(value14) {
    const numericValue = Number(value14);
    if (typeof value14 === "boolean" || value14 === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value14}`);
    return numericValue;
  };
  var normalizeObject = function(obj, normalizer) {
    const normalized = {};
    for (const u3 in obj) {
      if (hasOwnProperty3(obj, u3)) {
        const v = obj[u3];
        if (v === undefined || v === null)
          continue;
        normalized[normalizer(u3)] = asNumber(v);
      }
    }
    return normalized;
  };
  var formatOffset = function(offset2, format) {
    const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
    switch (format) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  };
  var timeObject = function(obj) {
    return pick5(obj, ["hour", "minute", "second", "millisecond"]);
  };
  var months = function(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  };
  var weekdays = function(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  };
  var eras = function(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  };
  var meridiemForDateTime = function(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  };
  var weekdayForDateTime = function(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  };
  var monthForDateTime = function(dt, length) {
    return months(length)[dt.month - 1];
  };
  var eraForDateTime = function(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  };
  var formatRelativeTime = function(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  };
  var stringifyTokens = function(splits, tokenToString) {
    let s3 = "";
    for (const token of splits) {
      if (token.literal) {
        s3 += token.val;
      } else {
        s3 += tokenToString(token.val);
      }
    }
    return s3;
  };
  var combineRegexes = function(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}\$`);
  };
  var combineExtractors = function(...extractors) {
    return (m2) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m2, cursor);
      return [{
        ...mergedVals,
        ...val
      }, zone || mergedZone, next];
    }, [{}, null, 1]).slice(0, 2);
  };
  var parse5 = function(s3, ...patterns6) {
    if (s3 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns6) {
      const m2 = regex.exec(s3);
      if (m2) {
        return extractor(m2);
      }
    }
    return [null, null];
  };
  var simpleParse = function(...keys) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0;i < keys.length; i++) {
        ret[keys[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  };
  var int = function(match2, pos, fallback) {
    const m2 = match2[pos];
    return isUndefined(m2) ? fallback : parseInteger(m2);
  };
  var extractISOYmd = function(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  };
  var extractISOTime = function(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  };
  var extractISOOffset = function(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  };
  var extractIANAZone = function(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  };
  var extractISODuration = function(match2) {
    const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s3[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
    return [{
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }];
  };
  var fromStrings = function(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr)
      result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  };
  var extractRFC2822 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset2;
    if (obsOffset) {
      offset2 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset2 = 0;
    } else {
      offset2 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset2)];
  };
  var preprocessRFC2822 = function(s3) {
    return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  };
  var extractRFC1123Or850 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  };
  var extractASCII = function(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  };
  var parseISODate = function(s3) {
    return parse5(s3, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
  };
  var parseRFC2822Date = function(s3) {
    return parse5(preprocessRFC2822(s3), [rfc2822, extractRFC2822]);
  };
  var parseHTTPDate = function(s3) {
    return parse5(s3, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
  };
  var parseISODuration = function(s3) {
    return parse5(s3, [isoDuration, extractISODuration]);
  };
  var parseISOTimeOnly = function(s3) {
    return parse5(s3, [isoTimeOnly, extractISOTimeOnly]);
  };
  var parseSQL = function(s3) {
    return parse5(s3, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
  };
  var clone$1 = function(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : {
        ...dur.values,
        ...alts.values || {}
      },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  };
  var durationToMillis = function(matrix, vals) {
    var _vals$milliseconds;
    let sum = (_vals$milliseconds = vals.milliseconds) != null ? _vals$milliseconds : 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum += vals[unit] * matrix[unit]["milliseconds"];
      }
    }
    return sum;
  };
  var normalizeValues = function(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits$1.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits$1.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  };
  var removeZeroes = function(vals) {
    const newVals = {};
    for (const [key, value14] of Object.entries(vals)) {
      if (value14 !== 0) {
        newVals[key] = value14;
      }
    }
    return newVals;
  };
  var validateStartEnd = function(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
    } else {
      return null;
    }
  };
  var dayDiff = function(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  };
  var highOrderDiffs = function(cursor, later, units) {
    const differs = [["years", (a2, b2) => b2.year - a2.year], ["quarters", (a2, b2) => b2.quarter - a2.quarter + (b2.year - a2.year) * 4], ["months", (a2, b2) => b2.month - a2.month + (b2.year - a2.year) * 12], ["weeks", (a2, b2) => {
      const days = dayDiff(a2, b2);
      return (days - days % 7) / 7;
    }], ["days", dayDiff]];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  };
  var diff = function(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter((u3) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0);
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({
          [lowestOrder]: 1
        });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  };
  var parseDigits = function(str) {
    let value14 = parseInt(str, 10);
    if (isNaN(value14)) {
      value14 = "";
      for (let i = 0;i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value14 += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value14 += code - min;
            }
          }
        }
      }
      return parseInt(value14, 10);
    } else {
      return value14;
    }
  };
  var digitRegex = function({
    numberingSystem
  }, append = "") {
    return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
  };
  var intUnit = function(regex, post = (i) => i) {
    return {
      regex,
      deser: ([s3]) => post(parseDigits(s3))
    };
  };
  var fixListRegex = function(s3) {
    return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  };
  var stripInsensitivities = function(s3) {
    return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  };
  var oneOf = function(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s3]) => strings.findIndex((i) => stripInsensitivities(s3) === stripInsensitivities(i)) + startIndex
      };
    }
  };
  var offset = function(regex, groups) {
    return {
      regex,
      deser: ([, h2, m2]) => signedOffset(h2, m2),
      groups
    };
  };
  var simple = function(regex) {
    return {
      regex,
      deser: ([s3]) => s3
    };
  };
  var escapeToken = function(value14) {
    return value14.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  };
  var unitForToken = function(token, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal13 = (t2) => ({
      regex: RegExp(escapeToken(t2.val)),
      deser: ([s3]) => s3,
      literal: true
    }), unitate = (t2) => {
      if (token.literal) {
        return literal13(t2);
      }
      switch (t2.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal13(t2);
      }
    };
    const unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token;
    return unit;
  };
  var tokenForPart = function(part, formatOpts, resolvedOpts) {
    const {
      type: type74,
      value: value14
    } = part;
    if (type74 === "literal") {
      const isSpace = /^\s+$/.test(value14);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value14
      };
    }
    const style = formatOpts[type74];
    let actualType = type74;
    if (type74 === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return;
  };
  var buildRegex = function(units) {
    const re = units.map((u3) => u3.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re}\$`, units];
  };
  var match = function(input6, regex, handlers) {
    const matches = input6.match(regex);
    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty3(handlers, i)) {
          const h2 = handlers[i], groups = h2.groups ? h2.groups + 1 : 1;
          if (!h2.literal && h2.token) {
            all[h2.token.val[0]] = h2.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  };
  var dateTimeFromMatches = function(matches) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }
    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }
    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }
    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }
    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }
    const vals = Object.keys(matches).reduce((r, k2) => {
      const f = toField(k2);
      if (f) {
        r[f] = matches[k2];
      }
      return r;
    }, {});
    return [vals, zone, specificOffset];
  };
  var getDummyDateTime = function() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  };
  var maybeExpandMacroToken = function(token, locale) {
    if (token.literal) {
      return token;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);
    if (tokens == null || tokens.includes(undefined)) {
      return token;
    }
    return tokens;
  };
  var expandMacroTokens = function(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t2) => maybeExpandMacroToken(t2, locale)));
  };
  var explainFromTokens = function(locale, input6, format) {
    const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t2) => unitForToken(t2, locale)), disqualifyingUnit = units.find((t2) => t2.invalidReason);
    if (disqualifyingUnit) {
      return {
        input: input6,
        tokens,
        invalidReason: disqualifyingUnit.invalidReason
      };
    } else {
      const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input6, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
      if (hasOwnProperty3(matches, "a") && hasOwnProperty3(matches, "H")) {
        throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
      }
      return {
        input: input6,
        tokens,
        regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset
      };
    }
  };
  var parseFromTokens = function(locale, input6, format) {
    const {
      result,
      zone,
      specificOffset,
      invalidReason
    } = explainFromTokens(locale, input6, format);
    return [result, zone, specificOffset, invalidReason];
  };
  var formatOptsToTokens = function(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p2) => tokenForPart(p2, formatOpts, resolvedOpts));
  };
  var unitOutOfRange = function(unit, value14) {
    return new Invalid("unit out of range", `you specified ${value14} (of type ${typeof value14}) as a ${unit}, which is invalid`);
  };
  var dayOfWeek = function(year, month, day2) {
    const d2 = new Date(Date.UTC(year, month - 1, day2));
    if (year < 100 && year >= 0) {
      d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
    }
    const js = d2.getUTCDay();
    return js === 0 ? 7 : js;
  };
  var computeOrdinal = function(year, month, day2) {
    return day2 + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  };
  var uncomputeOrdinal = function(year, ordinal) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day2 = ordinal - table[month0];
    return {
      month: month0 + 1,
      day: day2
    };
  };
  var gregorianToWeek = function(gregObj) {
    const {
      year,
      month,
      day: day2
    } = gregObj, ordinal = computeOrdinal(year, month, day2), weekday = dayOfWeek(year, month, day2);
    let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear);
    } else if (weekNumber > weeksInWeekYear(year)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return {
      weekYear,
      weekNumber,
      weekday,
      ...timeObject(gregObj)
    };
  };
  var weekToGregorian = function(weekData) {
    const {
      weekYear,
      weekNumber,
      weekday
    } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const {
      month,
      day: day2
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day: day2,
      ...timeObject(weekData)
    };
  };
  var gregorianToOrdinal = function(gregData) {
    const {
      year,
      month,
      day: day2
    } = gregData;
    const ordinal = computeOrdinal(year, month, day2);
    return {
      year,
      ordinal,
      ...timeObject(gregData)
    };
  };
  var ordinalToGregorian = function(ordinalData) {
    const {
      year,
      ordinal
    } = ordinalData;
    const {
      month,
      day: day2
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day: day2,
      ...timeObject(ordinalData)
    };
  };
  var hasInvalidWeekData = function(obj) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.week);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else
      return false;
  };
  var hasInvalidOrdinalData = function(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else
      return false;
  };
  var hasInvalidGregorianData = function(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else
      return false;
  };
  var hasInvalidTimeData = function(obj) {
    const {
      hour,
      minute,
      second,
      millisecond
    } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else
      return false;
  };
  var unsupportedZone = function(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  };
  var possiblyCachedWeekData = function(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  };
  var clone11 = function(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({
      ...current,
      ...alts,
      old: current
    });
  };
  var fixOffset = function(localTS, o2, tz) {
    let utcGuess = localTS - o2 * 60 * 1000;
    const o22 = tz.offset(utcGuess);
    if (o2 === o22) {
      return [utcGuess, o2];
    }
    utcGuess -= (o22 - o2) * 60 * 1000;
    const o3 = tz.offset(utcGuess);
    if (o22 === o3) {
      return [utcGuess, o22];
    }
    return [localTS - Math.min(o22, o3) * 60 * 1000, Math.max(o22, o3)];
  };
  var tsToObj = function(ts, offset2) {
    ts += offset2 * 60 * 1000;
    const d2 = new Date(ts);
    return {
      year: d2.getUTCFullYear(),
      month: d2.getUTCMonth() + 1,
      day: d2.getUTCDate(),
      hour: d2.getUTCHours(),
      minute: d2.getUTCMinutes(),
      second: d2.getUTCSeconds(),
      millisecond: d2.getUTCMilliseconds()
    };
  };
  var objToTS = function(obj, offset2, zone) {
    return fixOffset(objToLocalTS(obj), offset2, zone);
  };
  var adjustTime = function(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c2);
    let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o2 = inst.zone.offset(ts);
    }
    return {
      ts,
      o: o2
    };
  };
  var parseDataToDateTime = function(parsed, parsedZone, opts, format, text, specificOffset) {
    const {
      setZone,
      zone
    } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
    }
  };
  var toTechFormat = function(dt, format, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format) : null;
  };
  var toISODate = function(o2, extended) {
    const longFormat = o2.c.year > 9999 || o2.c.year < 0;
    let c2 = "";
    if (longFormat && o2.c.year >= 0)
      c2 += "+";
    c2 += padStart(o2.c.year, longFormat ? 6 : 4);
    if (extended) {
      c2 += "-";
      c2 += padStart(o2.c.month);
      c2 += "-";
      c2 += padStart(o2.c.day);
    } else {
      c2 += padStart(o2.c.month);
      c2 += padStart(o2.c.day);
    }
    return c2;
  };
  var toISOTime = function(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c2 = padStart(o2.c.hour);
    if (extended) {
      c2 += ":";
      c2 += padStart(o2.c.minute);
      if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
        c2 += ":";
      }
    } else {
      c2 += padStart(o2.c.minute);
    }
    if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
      c2 += padStart(o2.c.second);
      if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
        c2 += ".";
        c2 += padStart(o2.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
        c2 += "Z";
      } else if (o2.o < 0) {
        c2 += "-";
        c2 += padStart(Math.trunc(-o2.o / 60));
        c2 += ":";
        c2 += padStart(Math.trunc(-o2.o % 60));
      } else {
        c2 += "+";
        c2 += padStart(Math.trunc(o2.o / 60));
        c2 += ":";
        c2 += padStart(Math.trunc(o2.o % 60));
      }
    }
    if (extendedZone) {
      c2 += "[" + o2.zone.ianaName + "]";
    }
    return c2;
  };
  var normalizeUnit = function(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  };
  var quickDT = function(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
    let ts, o2;
    if (!isUndefined(obj.year)) {
      for (const u3 of orderedUnits) {
        if (isUndefined(obj[u3])) {
          obj[u3] = defaultUnitValues[u3];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = zone.offset(tsNow);
      [ts, o2] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = tsNow;
    }
    return new DateTime({
      ts,
      zone,
      loc,
      o: o2
    });
  };
  var diffRelative = function(start, end, opts) {
    const round = isUndefined(opts.round) ? true : opts.round, format = (c2, unit) => {
      c2 = roundTo(c2, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c2, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else
          return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  };
  var lastOpts = function(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  };
  var friendlyDateTime = function(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class LuxonError extends Error {
  }

  class InvalidDateTimeError extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  }

  class InvalidIntervalError extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  }

  class InvalidDurationError extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  }

  class ConflictingSpecificationError extends LuxonError {
  }

  class InvalidUnitError extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  }

  class InvalidArgumentError extends LuxonError {
  }

  class ZoneIsAbstractError extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  }
  var n2 = "numeric";
  var s2 = "short";
  var l2 = "long";
  var DATE_SHORT = {
    year: n2,
    month: n2,
    day: n2
  };
  var DATE_MED = {
    year: n2,
    month: s2,
    day: n2
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n2,
    month: s2,
    day: n2,
    weekday: s2
  };
  var DATE_FULL = {
    year: n2,
    month: l2,
    day: n2
  };
  var DATE_HUGE = {
    year: n2,
    month: l2,
    day: n2,
    weekday: l2
  };
  var TIME_SIMPLE = {
    hour: n2,
    minute: n2
  };
  var TIME_WITH_SECONDS = {
    hour: n2,
    minute: n2,
    second: n2
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: s2
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: l2
  };
  var TIME_24_SIMPLE = {
    hour: n2,
    minute: n2,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23",
    timeZoneName: s2
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23",
    timeZoneName: l2
  };
  var DATETIME_SHORT = {
    year: n2,
    month: n2,
    day: n2,
    hour: n2,
    minute: n2
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n2,
    month: n2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2
  };
  var DATETIME_MED = {
    year: n2,
    month: s2,
    day: n2,
    hour: n2,
    minute: n2
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n2,
    month: s2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n2,
    month: s2,
    day: n2,
    weekday: s2,
    hour: n2,
    minute: n2
  };
  var DATETIME_FULL = {
    year: n2,
    month: l2,
    day: n2,
    hour: n2,
    minute: n2,
    timeZoneName: s2
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n2,
    month: l2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: s2
  };
  var DATETIME_HUGE = {
    year: n2,
    month: l2,
    day: n2,
    weekday: l2,
    hour: n2,
    minute: n2,
    timeZoneName: l2
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n2,
    month: l2,
    day: n2,
    weekday: l2,
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: l2
  };

  class Zone {
    get type() {
      throw new ZoneIsAbstractError;
    }
    get name() {
      throw new ZoneIsAbstractError;
    }
    get ianaName() {
      return this.name;
    }
    get isUniversal() {
      throw new ZoneIsAbstractError;
    }
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError;
    }
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError;
    }
    offset(ts) {
      throw new ZoneIsAbstractError;
    }
    equals(otherZone) {
      throw new ZoneIsAbstractError;
    }
    get isValid() {
      throw new ZoneIsAbstractError;
    }
  }
  var singleton$1 = null;

  class SystemZone extends Zone {
    static get instance() {
      if (singleton$1 === null) {
        singleton$1 = new SystemZone;
      }
      return singleton$1;
    }
    get type() {
      return "system";
    }
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    equals(otherZone) {
      return otherZone.type === "system";
    }
    get isValid() {
      return true;
    }
  }
  var dtfCache = {};
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  var ianaZoneCache = {};

  class IANAZone extends Zone {
    static create(name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new IANAZone(name);
      }
      return ianaZoneCache[name];
    }
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    static isValidSpecifier(s3) {
      return this.isValidZone(s3);
    }
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", {
          timeZone: zone
        }).format();
        return true;
      } catch (e2) {
        return false;
      }
    }
    constructor(name) {
      super();
      this.zoneName = name;
      this.valid = IANAZone.isValidZone(name);
    }
    get type() {
      return "iana";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      const date4 = new Date(ts);
      if (isNaN(date4))
        return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day2, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date4) : hackyOffset(dtf, date4);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day: day2,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0
      });
      let asTS = +date4;
      const over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return (asUTC - asTS) / (60 * 1000);
    }
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    get isValid() {
      return this.valid;
    }
  }
  var intlLFCache = {};
  var intlDTCache = {};
  var intlNumCache = {};
  var intlRelCache = {};
  var sysLocaleCache = null;

  class PolyNumberFormatter {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const {
        padTo,
        floor,
        ...otherOpts
      } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = {
          useGrouping: false,
          ...opts
        };
        if (opts.padTo > 0)
          intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  }

  class PolyDateFormatter {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = undefined;
      let z = undefined;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
            minutes: dt.offset
          });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({
          minutes: dt.offset
        });
        this.originalZone = dt.zone;
      }
      const intlOpts = {
        ...this.opts
      };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({
          value: value14
        }) => value14).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }

  class PolyRelFormatter {
    constructor(intl, isEnglish, opts) {
      this.opts = {
        style: "long",
        ...opts
      };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  }

  class Locale {
    static fromOpts(opts) {
      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
    }
    static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      return Locale.create(locale, numberingSystem, outputCalendar);
    }
    constructor(locale, numbering, outputCalendar, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = {
        format: {},
        standalone: {}
      };
      this.monthsCache = {
        format: {},
        standalone: {}
      };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: true
      });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: false
      });
    }
    months(length, format = false) {
      return listStuff(this, length, months, () => {
        const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length];
      });
    }
    weekdays(length, format = false) {
      return listStuff(this, length, weekdays, () => {
        const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
        }
        return this.weekdaysCache[formatStr][length];
      });
    }
    meridiems() {
      return listStuff(this, undefined, () => meridiems, () => {
        if (!this.meridiemCache) {
          const intl = {
            hour: "numeric",
            hourCycle: "h12"
          };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
        }
        return this.meridiemCache;
      });
    }
    eras(length) {
      return listStuff(this, length, eras, () => {
        const intl = {
          era: length
        };
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
        }
        return this.eraCache[length];
      });
    }
    extract(dt, intlOpts, field3) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m2) => m2.type.toLowerCase() === field3);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
  }
  var singleton = null;

  class FixedOffsetZone extends Zone {
    static get utcInstance() {
      if (singleton === null) {
        singleton = new FixedOffsetZone(0);
      }
      return singleton;
    }
    static instance(offset2) {
      return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
    }
    static parseSpecifier(s3) {
      if (s3) {
        const r = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }
    constructor(offset2) {
      super();
      this.fixed = offset2;
    }
    get type() {
      return "fixed";
    }
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    offsetName() {
      return this.name;
    }
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }
    get isUniversal() {
      return true;
    }
    offset() {
      return this.fixed;
    }
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    get isValid() {
      return true;
    }
  }

  class InvalidZone extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    get type() {
      return "invalid";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName() {
      return null;
    }
    formatOffset() {
      return "";
    }
    offset() {
      return NaN;
    }
    equals() {
      return false;
    }
    get isValid() {
      return false;
    }
  }
  var now = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;

  class Settings {
    static get now() {
      return now;
    }
    static set now(n3) {
      now = n3;
    }
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    static get defaultLocale() {
      return defaultLocale;
    }
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    static set throwOnInvalid(t2) {
      throwOnInvalid = t2;
    }
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
    }
  }
  var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };

  class Formatter {
    static create(locale, opts = {}) {
      return new Formatter(locale, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0;i < fmt.length; i++) {
        const c2 = fmt.charAt(i);
        if (c2 === "'") {
          if (currentFull.length > 0) {
            splits.push({
              literal: bracketed || /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c2;
        } else if (c2 === current) {
          currentFull += c2;
        } else {
          if (currentFull.length > 0) {
            splits.push({
              literal: /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          currentFull = c2;
          current = c2;
        }
      }
      if (currentFull.length > 0) {
        splits.push({
          literal: bracketed || /^\s+$/.test(currentFull),
          val: currentFull
        });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }
    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n3, p2 = 0) {
      if (this.opts.forceSimple) {
        return padStart(n3, p2);
      }
      const opts = {
        ...this.opts
      };
      if (p2 > 0) {
        opts.padTo = p2;
      }
      return this.loc.numberFormatter(opts).format(n3);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string6 = (opts, extract5) => this.loc.extract(dt, opts, extract5), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string6({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string6(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string6(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"), maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string6({
        era: length
      }, "era"), tokenToString = (token) => {
        switch (token) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            return formatOffset2({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            return formatOffset2({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string6({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string6({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string6({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string6({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter ? string6({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string6({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter ? string6({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string6({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string6({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string6({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
      return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token) => {
        const mapped19 = tokenToField(token);
        if (mapped19) {
          return this.num(lildur.get(mapped19), token.length);
        } else {
          return token;
        }
      }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, {
        literal: literal13,
        val
      }) => literal13 ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2));
      return stringifyTokens(tokens, tokenToString(collapsed));
    }
  }

  class Invalid {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  }
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}\$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var INVALID$2 = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
  var reverseUnits = orderedUnits$1.slice(0).reverse();

  class Duration {
    constructor(config) {
      const accurate = config.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config.matrix) {
        matrix = config.matrix;
      }
      this.values = config.values;
      this.loc = config.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    static fromMillis(count, opts) {
      return Duration.fromObject({
        milliseconds: count
      }, opts);
    }
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
      }
      return new Duration({
        values: normalizeObject(obj, Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return Duration.fromMillis(durationLike);
      } else if (Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
      }
    }
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new Duration({
          invalid
        });
      }
    }
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    static isDuration(o2) {
      return o2 && o2.isLuxonDuration || false;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
    }
    toHuman(opts = {}) {
      if (!this.isValid)
        return INVALID$2;
      const l3 = orderedUnits$1.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({
          style: "unit",
          unitDisplay: "long",
          ...opts,
          unit: unit.slice(0, -1)
        }).format(val);
      }).filter((n3) => n3);
      return this.loc.listFormatter({
        type: "conjunction",
        style: opts.listStyle || "narrow",
        ...opts
      }).format(l3);
    }
    toObject() {
      if (!this.isValid)
        return {};
      return {
        ...this.values
      };
    }
    toISO() {
      if (!this.isValid)
        return null;
      let s3 = "P";
      if (this.years !== 0)
        s3 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0)
        s3 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0)
        s3 += this.weeks + "W";
      if (this.days !== 0)
        s3 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s3 += "T";
      if (this.hours !== 0)
        s3 += this.hours + "H";
      if (this.minutes !== 0)
        s3 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s3 += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
      if (s3 === "P")
        s3 += "T0S";
      return s3;
    }
    toISOTime(opts = {}) {
      if (!this.isValid)
        return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 86400000)
        return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, {
        zone: "UTC"
      });
      return dateTime.toISOTime(opts);
    }
    toJSON() {
      return this.toISO();
    }
    toString() {
      return this.toISO();
    }
    toMillis() {
      if (!this.isValid)
        return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    valueOf() {
      return this.toMillis();
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration), result = {};
      for (const k2 of orderedUnits$1) {
        if (hasOwnProperty3(dur.values, k2) || hasOwnProperty3(this.values, k2)) {
          result[k2] = dur.get(k2) + this.get(k2);
        }
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    mapUnits(fn) {
      if (!this.isValid)
        return this;
      const result = {};
      for (const k2 of Object.keys(this.values)) {
        result[k2] = asNumber(fn(this.values[k2], k2));
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    get(unit) {
      return this[Duration.normalizeUnit(unit)];
    }
    set(values4) {
      if (!this.isValid)
        return this;
      const mixed = {
        ...this.values,
        ...normalizeObject(values4, Duration.normalizeUnit)
      };
      return clone$1(this, {
        values: mixed
      });
    }
    reconfigure({
      locale,
      numberingSystem,
      conversionAccuracy,
      matrix
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem
      });
      const opts = {
        loc,
        matrix,
        conversionAccuracy
      };
      return clone$1(this, opts);
    }
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    normalize() {
      if (!this.isValid)
        return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone$1(this, {
        values: vals
      }, true);
    }
    rescale() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone$1(this, {
        values: vals
      }, true);
    }
    shiftTo(...units) {
      if (!this.isValid)
        return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u3) => Duration.normalizeUnit(u3));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k2 of orderedUnits$1) {
        if (units.indexOf(k2) >= 0) {
          lastUnit = k2;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k2] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k2])) {
            own += vals[k2];
          }
          const i = Math.trunc(own);
          built[k2] = i;
          accumulated[k2] = (own * 1000 - i * 1000) / 1000;
        } else if (isNumber(vals[k2])) {
          accumulated[k2] = vals[k2];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone$1(this, {
        values: built
      }, true);
    }
    shiftToAll() {
      if (!this.isValid)
        return this;
      return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
    }
    negate() {
      if (!this.isValid)
        return this;
      const negated = {};
      for (const k2 of Object.keys(this.values)) {
        negated[k2] = this.values[k2] === 0 ? 0 : -this.values[k2];
      }
      return clone$1(this, {
        values: negated
      }, true);
    }
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === undefined || v1 === 0)
          return v2 === undefined || v2 === 0;
        return v1 === v2;
      }
      for (const u3 of orderedUnits$1) {
        if (!eq(this.values[u3], other.values[u3])) {
          return false;
        }
      }
      return true;
    }
  }
  var INVALID$1 = "Invalid Interval";

  class Interval {
    constructor(config) {
      this.s = config.start;
      this.e = config.end;
      this.invalid = config.invalid || null;
      this.isLuxonInterval = true;
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new Interval({
          invalid
        });
      }
    }
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    static after(start, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
      return Interval.fromDateTimes(dt, dt.plus(dur));
    }
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return Interval.fromDateTimes(dt.minus(dur), dt);
    }
    static fromISO(text, opts) {
      const [s3, e2] = (text || "").split("/", 2);
      if (s3 && e2) {
        let start, startIsValid;
        try {
          start = DateTime.fromISO(s3, opts);
          startIsValid = start.isValid;
        } catch (e3) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e2, opts);
          endIsValid = end.isValid;
        } catch (e3) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return Interval.fromDateTimes(start, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e2, opts);
          if (dur.isValid) {
            return Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s3, opts);
          if (dur.isValid) {
            return Interval.before(end, dur);
          }
        }
      }
      return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    static isInterval(o2) {
      return o2 && o2.isLuxonInterval || false;
    }
    get start() {
      return this.isValid ? this.s : null;
    }
    get end() {
      return this.isValid ? this.e : null;
    }
    get isValid() {
      return this.invalidReason === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    count(unit = "milliseconds") {
      if (!this.isValid)
        return NaN;
      const start = this.start.startOf(unit), end = this.end.startOf(unit);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    isAfter(dateTime) {
      if (!this.isValid)
        return false;
      return this.s > dateTime;
    }
    isBefore(dateTime) {
      if (!this.isValid)
        return false;
      return this.e <= dateTime;
    }
    contains(dateTime) {
      if (!this.isValid)
        return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    set({
      start,
      end
    } = {}) {
      if (!this.isValid)
        return this;
      return Interval.fromDateTimes(start || this.s, end || this.e);
    }
    splitAt(...dateTimes) {
      if (!this.isValid)
        return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
      let {
        s: s3
      } = this, i = 0;
      while (s3 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s3, next));
        s3 = next;
        i += 1;
      }
      return results;
    }
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let {
        s: s3
      } = this, idx = 1, next;
      const results = [];
      while (s3 < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s3, next));
        s3 = next;
        idx += 1;
      }
      return results;
    }
    divideEqually(numberOfParts) {
      if (!this.isValid)
        return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    abutsStart(other) {
      if (!this.isValid)
        return false;
      return +this.e === +other.s;
    }
    abutsEnd(other) {
      if (!this.isValid)
        return false;
      return +other.e === +this.s;
    }
    engulfs(other) {
      if (!this.isValid)
        return false;
      return this.s <= other.s && this.e >= other.e;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    intersection(other) {
      if (!this.isValid)
        return this;
      const s3 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
      if (s3 >= e2) {
        return null;
      } else {
        return Interval.fromDateTimes(s3, e2);
      }
    }
    union(other) {
      if (!this.isValid)
        return this;
      const s3 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
      return Interval.fromDateTimes(s3, e2);
    }
    static merge(intervals) {
      const [found, final] = intervals.sort((a2, b2) => a2.s - b2.s).reduce(([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      }, [[], null]);
      if (final) {
        found.push(final);
      }
      return found;
    }
    static xor(intervals) {
      let start = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b2) => a2.time - b2.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start = i.time;
        } else {
          if (start && +start !== +i.time) {
            results.push(Interval.fromDateTimes(start, i.time));
          }
          start = null;
        }
      }
      return Interval.merge(results);
    }
    difference(...intervals) {
      return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    toString() {
      if (!this.isValid)
        return INVALID$1;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
    }
    toISO(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    toISODate() {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    toISOTime(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    toFormat(dateFormat, {
      separator = " \u2013 "
    } = {}) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    mapEndpoints(mapFn) {
      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  }

  class Info {
    static hasDST(zone = Settings.defaultZone) {
      const proto2 = DateTime.now().setZone(zone).set({
        month: 12
      });
      return !zone.isUniversal && proto2.offset !== proto2.set({
        month: 6
      }).offset;
    }
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    static normalizeZone(input6) {
      return normalizeZone(input6, Settings.defaultZone);
    }
    static months(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }
    static monthsFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }
    static weekdays(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }
    static weekdaysFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }
    static meridiems({
      locale = null
    } = {}) {
      return Locale.create(locale).meridiems();
    }
    static eras(length = "short", {
      locale = null
    } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }
    static features() {
      return {
        relative: hasRelative()
      };
    }
  }
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  var dummyDateTimeCache = null;
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var INVALID = "Invalid DateTime";
  var MAX_DATE = 8640000000000000;
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

  class DateTime {
    constructor(config) {
      const zone = config.zone || Settings.defaultZone;
      let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
      let c2 = null, o2 = null;
      if (!invalid) {
        const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
        if (unchanged) {
          [c2, o2] = [config.old.c, config.old.o];
        } else {
          const ot = zone.offset(this.ts);
          c2 = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
          c2 = invalid ? null : c2;
          o2 = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.c = c2;
      this.o = o2;
      this.isLuxonDateTime = true;
    }
    static now() {
      return new DateTime({});
    }
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day2, hour, minute, second, millisecond] = args;
      return quickDT({
        year,
        month,
        day: day2,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day2, hour, minute, second, millisecond] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({
        year,
        month,
        day: day2,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static fromJSDate(date4, options = {}) {
      const ts = isDate(date4) ? date4.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return DateTime.invalid("Timestamp out of range");
      } else {
        return new DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new DateTime({
          ts: seconds * 1000,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u3 of units) {
        const v = normalized[u3];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u3] = defaultValues[u3];
        } else {
          normalized[u3] = objNow[u3];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
      }
      return inst;
    }
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    static fromString(text, fmt, opts = {}) {
      return DateTime.fromFormat(text, fmt, opts);
    }
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new DateTime({
          invalid
        });
      }
    }
    static isDateTime(o2) {
      return o2 && o2.isLuxonDateTime || false;
    }
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
    }
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t2) => t2.val).join("");
    }
    get(unit) {
      return this[unit];
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    get zone() {
      return this._zone;
    }
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    get monthShort() {
      return this.isValid ? Info.months("short", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get monthLong() {
      return this.isValid ? Info.months("long", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1,
          day: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 86400000;
      const minuteMs = 60000;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c12 = tsToObj(ts1, o1);
      const c2 = tsToObj(ts2, o2);
      if (c12.hour === c2.hour && c12.minute === c2.minute && c12.second === c2.second && c12.millisecond === c2.millisecond) {
        return [clone11(this, {
          ts: ts1
        }), clone11(this, {
          ts: ts2
        })];
      }
      return [this];
    }
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    resolvedLocaleOptions(opts = {}) {
      const {
        locale,
        numberingSystem,
        calendar
      } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
      return {
        locale,
        numberingSystem,
        outputCalendar: calendar
      };
    }
    toUTC(offset2 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset2), opts);
    }
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    setZone(zone, {
      keepLocalTime = false,
      keepCalendarTime = false
    } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone11(this, {
          ts: newTS,
          zone
        });
      }
    }
    reconfigure({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem,
        outputCalendar
      });
      return clone11(this, {
        loc
      });
    }
    setLocale(locale) {
      return this.reconfigure({
        locale
      });
    }
    set(values4) {
      if (!this.isValid)
        return this;
      const normalized = normalizeObject(values4, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian({
          ...gregorianToWeek(this.c),
          ...normalized
        });
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({
          ...gregorianToOrdinal(this.c),
          ...normalized
        });
      } else {
        mixed = {
          ...this.toObject(),
          ...normalized
        };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o2] = objToTS(mixed, this.o, this.zone);
      return clone11(this, {
        ts,
        o: o2
      });
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return clone11(this, adjustTime(this, dur));
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone11(this, adjustTime(this, dur));
    }
    startOf(unit) {
      if (!this.isValid)
        return this;
      const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o2.month = 1;
        case "quarters":
        case "months":
          o2.day = 1;
        case "weeks":
        case "days":
          o2.hour = 0;
        case "hours":
          o2.minute = 0;
        case "minutes":
          o2.second = 0;
        case "seconds":
          o2.millisecond = 0;
          break;
      }
      if (normalizedUnit === "weeks") {
        o2.weekday = 1;
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o2.month = (q - 1) * 3 + 1;
      }
      return this.set(o2);
    }
    endOf(unit) {
      return this.isValid ? this.plus({
        [unit]: 1
      }).startOf(unit).minus(1) : this;
    }
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
    }
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format === "extended";
      let c2 = toISODate(this, ext);
      c2 += "T";
      c2 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c2;
    }
    toISODate({
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format === "extended");
    }
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c2 = includePrefix ? "T" : "";
      return c2 + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    }
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    toSQLTime({
      includeOffset = true,
      includeZone = false,
      includeOffsetSpace = true
    } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    toString() {
      return this.isValid ? this.toISO() : INVALID;
    }
    valueOf() {
      return this.toMillis();
    }
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    toSeconds() {
      return this.isValid ? this.ts / 1000 : NaN;
    }
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1000) : NaN;
    }
    toJSON() {
      return this.toISO();
    }
    toBSON() {
      return this.toJSDate();
    }
    toObject(opts = {}) {
      if (!this.isValid)
        return {};
      const base18 = {
        ...this.c
      };
      if (opts.includeConfig) {
        base18.outputCalendar = this.outputCalendar;
        base18.numberingSystem = this.loc.numberingSystem;
        base18.locale = this.loc.locale;
      }
      return base18;
    }
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = {
        locale: this.locale,
        numberingSystem: this.numberingSystem,
        ...opts
      };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(DateTime.now(), unit, opts);
    }
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    hasSame(otherDateTime, unit) {
      if (!this.isValid)
        return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, {
        keepLocalTime: true
      });
      return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
    }
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    toRelative(options = {}) {
      if (!this.isValid)
        return null;
      const base18 = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), padding = options.padding ? this < base18 ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = undefined;
      }
      return diffRelative(base18, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    toRelativeCalendar(options = {}) {
      if (!this.isValid)
        return null;
      return diffRelative(options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    static min(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    static max(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    static fromFormatExplain(text, fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    static fromStringExplain(text, fmt, options = {}) {
      return DateTime.fromFormatExplain(text, fmt, options);
    }
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    static get DATE_MED() {
      return DATE_MED;
    }
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    static get DATE_FULL() {
      return DATE_FULL;
    }
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }
  var VERSION = "3.4.3";
  exports.DateTime = DateTime;
  exports.Duration = Duration;
  exports.FixedOffsetZone = FixedOffsetZone;
  exports.IANAZone = IANAZone;
  exports.Info = Info;
  exports.Interval = Interval;
  exports.InvalidZone = InvalidZone;
  exports.Settings = Settings;
  exports.SystemZone = SystemZone;
  exports.VERSION = VERSION;
  exports.Zone = Zone;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/date.js
var require_date = __commonJS((exports, module) => {
  var CronDate = function(timestamp, tz) {
    var dateOpts = { zone: tz };
    if (!timestamp) {
      this._date = luxon.DateTime.local();
    } else if (timestamp instanceof CronDate) {
      this._date = timestamp._date;
    } else if (timestamp instanceof Date) {
      this._date = luxon.DateTime.fromJSDate(timestamp, dateOpts);
    } else if (typeof timestamp === "number") {
      this._date = luxon.DateTime.fromMillis(timestamp, dateOpts);
    } else if (typeof timestamp === "string") {
      this._date = luxon.DateTime.fromISO(timestamp, dateOpts);
      this._date.isValid || (this._date = luxon.DateTime.fromRFC2822(timestamp, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromSQL(timestamp, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromFormat(timestamp, "EEE, d MMM yyyy HH:mm:ss", dateOpts));
    }
    if (!this._date || !this._date.isValid) {
      throw new Error("CronDate: unhandled timestamp: " + JSON.stringify(timestamp));
    }
    if (tz && tz !== this._date.zoneName) {
      this._date = this._date.setZone(tz);
    }
  };
  var luxon = require_luxon();
  CronDate.prototype.addYear = function() {
    this._date = this._date.plus({ years: 1 });
  };
  CronDate.prototype.addMonth = function() {
    this._date = this._date.plus({ months: 1 }).startOf("month");
  };
  CronDate.prototype.addDay = function() {
    this._date = this._date.plus({ days: 1 }).startOf("day");
  };
  CronDate.prototype.addHour = function() {
    var prev = this._date;
    this._date = this._date.plus({ hours: 1 }).startOf("hour");
    if (this._date <= prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addMinute = function() {
    var prev = this._date;
    this._date = this._date.plus({ minutes: 1 }).startOf("minute");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addSecond = function() {
    var prev = this._date;
    this._date = this._date.plus({ seconds: 1 }).startOf("second");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractYear = function() {
    this._date = this._date.minus({ years: 1 });
  };
  CronDate.prototype.subtractMonth = function() {
    this._date = this._date.minus({ months: 1 }).endOf("month").startOf("second");
  };
  CronDate.prototype.subtractDay = function() {
    this._date = this._date.minus({ days: 1 }).endOf("day").startOf("second");
  };
  CronDate.prototype.subtractHour = function() {
    var prev = this._date;
    this._date = this._date.minus({ hours: 1 }).endOf("hour").startOf("second");
    if (this._date >= prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractMinute = function() {
    var prev = this._date;
    this._date = this._date.minus({ minutes: 1 }).endOf("minute").startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractSecond = function() {
    var prev = this._date;
    this._date = this._date.minus({ seconds: 1 }).startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.getDate = function() {
    return this._date.day;
  };
  CronDate.prototype.getFullYear = function() {
    return this._date.year;
  };
  CronDate.prototype.getDay = function() {
    var weekday = this._date.weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getMonth = function() {
    return this._date.month - 1;
  };
  CronDate.prototype.getHours = function() {
    return this._date.hour;
  };
  CronDate.prototype.getMinutes = function() {
    return this._date.minute;
  };
  CronDate.prototype.getSeconds = function() {
    return this._date.second;
  };
  CronDate.prototype.getMilliseconds = function() {
    return this._date.millisecond;
  };
  CronDate.prototype.getTime = function() {
    return this._date.valueOf();
  };
  CronDate.prototype.getUTCDate = function() {
    return this._getUTC().day;
  };
  CronDate.prototype.getUTCFullYear = function() {
    return this._getUTC().year;
  };
  CronDate.prototype.getUTCDay = function() {
    var weekday = this._getUTC().weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getUTCMonth = function() {
    return this._getUTC().month - 1;
  };
  CronDate.prototype.getUTCHours = function() {
    return this._getUTC().hour;
  };
  CronDate.prototype.getUTCMinutes = function() {
    return this._getUTC().minute;
  };
  CronDate.prototype.getUTCSeconds = function() {
    return this._getUTC().second;
  };
  CronDate.prototype.toISOString = function() {
    return this._date.toUTC().toISO();
  };
  CronDate.prototype.toJSON = function() {
    return this._date.toJSON();
  };
  CronDate.prototype.setDate = function(d2) {
    this._date = this._date.set({ day: d2 });
  };
  CronDate.prototype.setFullYear = function(y2) {
    this._date = this._date.set({ year: y2 });
  };
  CronDate.prototype.setDay = function(d2) {
    this._date = this._date.set({ weekday: d2 });
  };
  CronDate.prototype.setMonth = function(m2) {
    this._date = this._date.set({ month: m2 + 1 });
  };
  CronDate.prototype.setHours = function(h2) {
    this._date = this._date.set({ hour: h2 });
  };
  CronDate.prototype.setMinutes = function(m2) {
    this._date = this._date.set({ minute: m2 });
  };
  CronDate.prototype.setSeconds = function(s2) {
    this._date = this._date.set({ second: s2 });
  };
  CronDate.prototype.setMilliseconds = function(s2) {
    this._date = this._date.set({ millisecond: s2 });
  };
  CronDate.prototype._getUTC = function() {
    return this._date.toUTC();
  };
  CronDate.prototype.toString = function() {
    return this.toDate().toString();
  };
  CronDate.prototype.toDate = function() {
    return this._date.toJSDate();
  };
  CronDate.prototype.isLastDayOfMonth = function() {
    var newDate = this._date.plus({ days: 1 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  CronDate.prototype.isLastWeekdayOfMonth = function() {
    var newDate = this._date.plus({ days: 7 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  module.exports = CronDate;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/field_compactor.js
var require_field_compactor = __commonJS((exports, module) => {
  var buildRange = function(item) {
    return {
      start: item,
      count: 1
    };
  };
  var completeRangeWithItem = function(range, item) {
    range.end = item;
    range.step = item - range.start;
    range.count = 2;
  };
  var finalizeCurrentRange = function(results, currentRange, currentItemRange) {
    if (currentRange) {
      if (currentRange.count === 2) {
        results.push(buildRange(currentRange.start));
        results.push(buildRange(currentRange.end));
      } else {
        results.push(currentRange);
      }
    }
    if (currentItemRange) {
      results.push(currentItemRange);
    }
  };
  var compactField = function(arr) {
    var results = [];
    var currentRange = undefined;
    for (var i = 0;i < arr.length; i++) {
      var currentItem = arr[i];
      if (typeof currentItem !== "number") {
        finalizeCurrentRange(results, currentRange, buildRange(currentItem));
        currentRange = undefined;
      } else if (!currentRange) {
        currentRange = buildRange(currentItem);
      } else if (currentRange.count === 1) {
        completeRangeWithItem(currentRange, currentItem);
      } else {
        if (currentRange.step === currentItem - currentRange.end) {
          currentRange.count++;
          currentRange.end = currentItem;
        } else if (currentRange.count === 2) {
          results.push(buildRange(currentRange.start));
          currentRange = buildRange(currentRange.end);
          completeRangeWithItem(currentRange, currentItem);
        } else {
          finalizeCurrentRange(results, currentRange);
          currentRange = buildRange(currentItem);
        }
      }
    }
    finalizeCurrentRange(results, currentRange);
    return results;
  };
  module.exports = compactField;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/field_stringify.js
var require_field_stringify = __commonJS((exports, module) => {
  var stringifyField = function(arr, min, max) {
    var ranges = compactField(arr);
    if (ranges.length === 1) {
      var singleRange = ranges[0];
      var step = singleRange.step;
      if (step === 1 && singleRange.start === min && singleRange.end === max) {
        return "*";
      }
      if (step !== 1 && singleRange.start === min && singleRange.end === max - step + 1) {
        return "*/" + step;
      }
    }
    var result = [];
    for (var i = 0, l2 = ranges.length;i < l2; ++i) {
      var range = ranges[i];
      if (range.count === 1) {
        result.push(range.start);
        continue;
      }
      var step = range.step;
      if (range.step === 1) {
        result.push(range.start + "-" + range.end);
        continue;
      }
      var multiplier = range.start == 0 ? range.count - 1 : range.count;
      if (range.step * multiplier > range.end) {
        result = result.concat(Array.from({ length: range.end - range.start + 1 }).map(function(_, index) {
          var value14 = range.start + index;
          if ((value14 - range.start) % range.step === 0) {
            return value14;
          }
          return null;
        }).filter(function(value14) {
          return value14 != null;
        }));
      } else if (range.end === max - range.step + 1) {
        result.push(range.start + "/" + range.step);
      } else {
        result.push(range.start + "-" + range.end + "/" + range.step);
      }
    }
    return result.join(",");
  };
  var compactField = require_field_compactor();
  module.exports = stringifyField;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/expression.js
var require_expression = __commonJS((exports, module) => {
  var CronExpression = function(fields, options) {
    this._options = options;
    this._utc = options.utc || false;
    this._tz = this._utc ? "UTC" : options.tz;
    this._currentDate = new CronDate(options.currentDate, this._tz);
    this._startDate = options.startDate ? new CronDate(options.startDate, this._tz) : null;
    this._endDate = options.endDate ? new CronDate(options.endDate, this._tz) : null;
    this._isIterator = options.iterator || false;
    this._hasIterated = false;
    this._nthDayOfWeek = options.nthDayOfWeek || 0;
    this.fields = CronExpression._freezeFields(fields);
  };
  var CronDate = require_date();
  var stringifyField = require_field_stringify();
  var LOOP_LIMIT = 1e4;
  CronExpression.map = ["second", "minute", "hour", "dayOfMonth", "month", "dayOfWeek"];
  CronExpression.predefined = {
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  CronExpression.constraints = [
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 23, chars: [] },
    { min: 1, max: 31, chars: ["L"] },
    { min: 1, max: 12, chars: [] },
    { min: 0, max: 7, chars: ["L"] }
  ];
  CronExpression.daysInMonth = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  CronExpression.aliases = {
    month: {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12
    },
    dayOfWeek: {
      sun: 0,
      mon: 1,
      tue: 2,
      wed: 3,
      thu: 4,
      fri: 5,
      sat: 6
    }
  };
  CronExpression.parseDefaults = ["0", "*", "*", "*", "*", "*"];
  CronExpression.standardValidCharacters = /^[,*\d/-]+$/;
  CronExpression.dayOfWeekValidCharacters = /^[?,*\dL#/-]+$/;
  CronExpression.dayOfMonthValidCharacters = /^[?,*\dL/-]+$/;
  CronExpression.validCharacters = {
    second: CronExpression.standardValidCharacters,
    minute: CronExpression.standardValidCharacters,
    hour: CronExpression.standardValidCharacters,
    dayOfMonth: CronExpression.dayOfMonthValidCharacters,
    month: CronExpression.standardValidCharacters,
    dayOfWeek: CronExpression.dayOfWeekValidCharacters
  };
  CronExpression._isValidConstraintChar = function _isValidConstraintChar(constraints, value14) {
    if (typeof value14 !== "string") {
      return false;
    }
    return constraints.chars.some(function(char) {
      return value14.indexOf(char) > -1;
    });
  };
  CronExpression._parseField = function _parseField(field3, value14, constraints) {
    switch (field3) {
      case "month":
      case "dayOfWeek":
        var aliases = CronExpression.aliases[field3];
        value14 = value14.replace(/[a-z]{3}/gi, function(match) {
          match = match.toLowerCase();
          if (typeof aliases[match] !== "undefined") {
            return aliases[match];
          } else {
            throw new Error('Validation error, cannot resolve alias "' + match + '"');
          }
        });
        break;
    }
    if (!CronExpression.validCharacters[field3].test(value14)) {
      throw new Error("Invalid characters, got value: " + value14);
    }
    if (value14.indexOf("*") !== -1) {
      value14 = value14.replace(/\*/g, constraints.min + "-" + constraints.max);
    } else if (value14.indexOf("?") !== -1) {
      value14 = value14.replace(/\?/g, constraints.min + "-" + constraints.max);
    }
    function parseSequence(val) {
      var stack = [];
      function handleResult(result) {
        if (result instanceof Array) {
          for (var i2 = 0, c3 = result.length;i2 < c3; i2++) {
            var value15 = result[i2];
            if (CronExpression._isValidConstraintChar(constraints, value15)) {
              stack.push(value15);
              continue;
            }
            if (typeof value15 !== "number" || Number.isNaN(value15) || value15 < constraints.min || value15 > constraints.max) {
              throw new Error("Constraint error, got value " + value15 + " expected range " + constraints.min + "-" + constraints.max);
            }
            stack.push(value15);
          }
        } else {
          if (CronExpression._isValidConstraintChar(constraints, result)) {
            stack.push(result);
            return;
          }
          var numResult = +result;
          if (Number.isNaN(numResult) || numResult < constraints.min || numResult > constraints.max) {
            throw new Error("Constraint error, got value " + result + " expected range " + constraints.min + "-" + constraints.max);
          }
          if (field3 === "dayOfWeek") {
            numResult = numResult % 7;
          }
          stack.push(numResult);
        }
      }
      var atoms = val.split(",");
      if (!atoms.every(function(atom) {
        return atom.length > 0;
      })) {
        throw new Error("Invalid list value format");
      }
      if (atoms.length > 1) {
        for (var i = 0, c2 = atoms.length;i < c2; i++) {
          handleResult(parseRepeat(atoms[i]));
        }
      } else {
        handleResult(parseRepeat(val));
      }
      stack.sort(CronExpression._sortCompareFn);
      return stack;
    }
    function parseRepeat(val) {
      var repeatInterval = 1;
      var atoms = val.split("/");
      if (atoms.length > 2) {
        throw new Error("Invalid repeat: " + val);
      }
      if (atoms.length > 1) {
        if (atoms[0] == +atoms[0]) {
          atoms = [atoms[0] + "-" + constraints.max, atoms[1]];
        }
        return parseRange(atoms[0], atoms[atoms.length - 1]);
      }
      return parseRange(val, repeatInterval);
    }
    function parseRange(val, repeatInterval) {
      var stack = [];
      var atoms = val.split("-");
      if (atoms.length > 1) {
        if (atoms.length < 2) {
          return +val;
        }
        if (!atoms[0].length) {
          if (!atoms[1].length) {
            throw new Error("Invalid range: " + val);
          }
          return +val;
        }
        var min = +atoms[0];
        var max = +atoms[1];
        if (Number.isNaN(min) || Number.isNaN(max) || min < constraints.min || max > constraints.max) {
          throw new Error("Constraint error, got range " + min + "-" + max + " expected range " + constraints.min + "-" + constraints.max);
        } else if (min > max) {
          throw new Error("Invalid range: " + val);
        }
        var repeatIndex = +repeatInterval;
        if (Number.isNaN(repeatIndex) || repeatIndex <= 0) {
          throw new Error("Constraint error, cannot repeat at every " + repeatIndex + " time.");
        }
        if (field3 === "dayOfWeek" && max % 7 === 0) {
          stack.push(0);
        }
        for (var index = min, count = max;index <= count; index++) {
          var exists = stack.indexOf(index) !== -1;
          if (!exists && repeatIndex > 0 && repeatIndex % repeatInterval === 0) {
            repeatIndex = 1;
            stack.push(index);
          } else {
            repeatIndex++;
          }
        }
        return stack;
      }
      return Number.isNaN(+val) ? val : +val;
    }
    return parseSequence(value14);
  };
  CronExpression._sortCompareFn = function(a2, b2) {
    var aIsNumber = typeof a2 === "number";
    var bIsNumber = typeof b2 === "number";
    if (aIsNumber && bIsNumber) {
      return a2 - b2;
    }
    if (!aIsNumber && bIsNumber) {
      return 1;
    }
    if (aIsNumber && !bIsNumber) {
      return -1;
    }
    return a2.localeCompare(b2);
  };
  CronExpression._handleMaxDaysInMonth = function(mappedFields) {
    if (mappedFields.month.length === 1) {
      var daysInMonth = CronExpression.daysInMonth[mappedFields.month[0] - 1];
      if (mappedFields.dayOfMonth[0] > daysInMonth) {
        throw new Error("Invalid explicit day of month definition");
      }
      return mappedFields.dayOfMonth.filter(function(dayOfMonth) {
        return dayOfMonth === "L" ? true : dayOfMonth <= daysInMonth;
      }).sort(CronExpression._sortCompareFn);
    }
  };
  CronExpression._freezeFields = function(fields) {
    for (var i = 0, c2 = CronExpression.map.length;i < c2; ++i) {
      var field3 = CronExpression.map[i];
      var value14 = fields[field3];
      fields[field3] = Object.freeze(value14);
    }
    return Object.freeze(fields);
  };
  CronExpression.prototype._applyTimezoneShift = function(currentDate, dateMathVerb, method) {
    if (method === "Month" || method === "Day") {
      var prevTime = currentDate.getTime();
      currentDate[dateMathVerb + method]();
      var currTime = currentDate.getTime();
      if (prevTime === currTime) {
        if (currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
          currentDate.addHour();
        } else if (currentDate.getMinutes() === 59 && currentDate.getSeconds() === 59) {
          currentDate.subtractHour();
        }
      }
    } else {
      var previousHour = currentDate.getHours();
      currentDate[dateMathVerb + method]();
      var currentHour = currentDate.getHours();
      var diff = currentHour - previousHour;
      if (diff === 2) {
        if (this.fields.hour.length !== 24) {
          this._dstStart = currentHour;
        }
      } else if (diff === 0 && currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
        if (this.fields.hour.length !== 24) {
          this._dstEnd = currentHour;
        }
      }
    }
  };
  CronExpression.prototype._findSchedule = function _findSchedule(reverse) {
    function matchSchedule(value14, sequence) {
      for (var i = 0, c2 = sequence.length;i < c2; i++) {
        if (sequence[i] >= value14) {
          return sequence[i] === value14;
        }
      }
      return sequence[0] === value14;
    }
    function isNthDayMatch(date4, nthDayOfWeek) {
      if (nthDayOfWeek < 6) {
        if (date4.getDate() < 8 && nthDayOfWeek === 1) {
          return true;
        }
        var offset = date4.getDate() % 7 ? 1 : 0;
        var adjustedDate = date4.getDate() - date4.getDate() % 7;
        var occurrence = Math.floor(adjustedDate / 7) + offset;
        return occurrence === nthDayOfWeek;
      }
      return false;
    }
    function isLInExpressions(expressions) {
      return expressions.length > 0 && expressions.some(function(expression) {
        return typeof expression === "string" && expression.indexOf("L") >= 0;
      });
    }
    reverse = reverse || false;
    var dateMathVerb = reverse ? "subtract" : "add";
    var currentDate = new CronDate(this._currentDate, this._tz);
    var startDate = this._startDate;
    var endDate = this._endDate;
    var startTimestamp = currentDate.getTime();
    var stepCount = 0;
    function isLastWeekdayOfMonthMatch(expressions) {
      return expressions.some(function(expression) {
        if (!isLInExpressions([expression])) {
          return false;
        }
        var weekday = Number.parseInt(expression[0]) % 7;
        if (Number.isNaN(weekday)) {
          throw new Error("Invalid last weekday of the month expression: " + expression);
        }
        return currentDate.getDay() === weekday && currentDate.isLastWeekdayOfMonth();
      });
    }
    while (stepCount < LOOP_LIMIT) {
      stepCount++;
      if (reverse) {
        if (startDate && currentDate.getTime() - startDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      } else {
        if (endDate && endDate.getTime() - currentDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      }
      var dayOfMonthMatch = matchSchedule(currentDate.getDate(), this.fields.dayOfMonth);
      if (isLInExpressions(this.fields.dayOfMonth)) {
        dayOfMonthMatch = dayOfMonthMatch || currentDate.isLastDayOfMonth();
      }
      var dayOfWeekMatch = matchSchedule(currentDate.getDay(), this.fields.dayOfWeek);
      if (isLInExpressions(this.fields.dayOfWeek)) {
        dayOfWeekMatch = dayOfWeekMatch || isLastWeekdayOfMonthMatch(this.fields.dayOfWeek);
      }
      var isDayOfMonthWildcardMatch = this.fields.dayOfMonth.length >= CronExpression.daysInMonth[currentDate.getMonth()];
      var isDayOfWeekWildcardMatch = this.fields.dayOfWeek.length === CronExpression.constraints[5].max - CronExpression.constraints[5].min + 1;
      var currentHour = currentDate.getHours();
      if (!dayOfMonthMatch && (!dayOfWeekMatch || isDayOfWeekWildcardMatch)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!isDayOfMonthWildcardMatch && isDayOfWeekWildcardMatch && !dayOfMonthMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (isDayOfMonthWildcardMatch && !isDayOfWeekWildcardMatch && !dayOfWeekMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (this._nthDayOfWeek > 0 && !isNthDayMatch(currentDate, this._nthDayOfWeek)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!matchSchedule(currentDate.getMonth() + 1, this.fields.month)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Month");
        continue;
      }
      if (!matchSchedule(currentHour, this.fields.hour)) {
        if (this._dstStart !== currentHour) {
          this._dstStart = null;
          this._applyTimezoneShift(currentDate, dateMathVerb, "Hour");
          continue;
        } else if (!matchSchedule(currentHour - 1, this.fields.hour)) {
          currentDate[dateMathVerb + "Hour"]();
          continue;
        }
      } else if (this._dstEnd === currentHour) {
        if (!reverse) {
          this._dstEnd = null;
          this._applyTimezoneShift(currentDate, "add", "Hour");
          continue;
        }
      }
      if (!matchSchedule(currentDate.getMinutes(), this.fields.minute)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Minute");
        continue;
      }
      if (!matchSchedule(currentDate.getSeconds(), this.fields.second)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        continue;
      }
      if (startTimestamp === currentDate.getTime()) {
        if (dateMathVerb === "add" || currentDate.getMilliseconds() === 0) {
          this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        } else {
          currentDate.setMilliseconds(0);
        }
        continue;
      }
      break;
    }
    if (stepCount >= LOOP_LIMIT) {
      throw new Error("Invalid expression, loop limit exceeded");
    }
    this._currentDate = new CronDate(currentDate, this._tz);
    this._hasIterated = true;
    return currentDate;
  };
  CronExpression.prototype.next = function next() {
    var schedule = this._findSchedule();
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasNext()
      };
    }
    return schedule;
  };
  CronExpression.prototype.prev = function prev() {
    var schedule = this._findSchedule(true);
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasPrev()
      };
    }
    return schedule;
  };
  CronExpression.prototype.hasNext = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule();
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.hasPrev = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule(true);
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.iterate = function iterate(steps2, callback) {
    var dates = [];
    if (steps2 >= 0) {
      for (var i = 0, c2 = steps2;i < c2; i++) {
        try {
          var item = this.next();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    } else {
      for (var i = 0, c2 = steps2;i > c2; i--) {
        try {
          var item = this.prev();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    }
    return dates;
  };
  CronExpression.prototype.reset = function reset(newDate) {
    this._currentDate = new CronDate(newDate || this._options.currentDate);
  };
  CronExpression.prototype.stringify = function stringify(includeSeconds) {
    var resultArr = [];
    for (var i = includeSeconds ? 0 : 1, c2 = CronExpression.map.length;i < c2; ++i) {
      var field3 = CronExpression.map[i];
      var value14 = this.fields[field3];
      var constraint = CronExpression.constraints[i];
      if (field3 === "dayOfMonth" && this.fields.month.length === 1) {
        constraint = { min: 1, max: CronExpression.daysInMonth[this.fields.month[0] - 1] };
      } else if (field3 === "dayOfWeek") {
        constraint = { min: 0, max: 6 };
        value14 = value14[value14.length - 1] === 7 ? value14.slice(0, -1) : value14;
      }
      resultArr.push(stringifyField(value14, constraint.min, constraint.max));
    }
    return resultArr.join(" ");
  };
  CronExpression.parse = function parse(expression, options) {
    var self2 = this;
    if (typeof options === "function") {
      options = {};
    }
    function parse5(expression2, options2) {
      if (!options2) {
        options2 = {};
      }
      if (typeof options2.currentDate === "undefined") {
        options2.currentDate = new CronDate(undefined, self2._tz);
      }
      if (CronExpression.predefined[expression2]) {
        expression2 = CronExpression.predefined[expression2];
      }
      var fields = [];
      var atoms = (expression2 + "").trim().split(/\s+/);
      if (atoms.length > 6) {
        throw new Error("Invalid cron expression");
      }
      var start = CronExpression.map.length - atoms.length;
      for (var i = 0, c2 = CronExpression.map.length;i < c2; ++i) {
        var field3 = CronExpression.map[i];
        var value14 = atoms[atoms.length > c2 ? i : i - start];
        if (i < start || !value14) {
          fields.push(CronExpression._parseField(field3, CronExpression.parseDefaults[i], CronExpression.constraints[i]));
        } else {
          var val = field3 === "dayOfWeek" ? parseNthDay(value14) : value14;
          fields.push(CronExpression._parseField(field3, val, CronExpression.constraints[i]));
        }
      }
      var mappedFields = {};
      for (var i = 0, c2 = CronExpression.map.length;i < c2; i++) {
        var key = CronExpression.map[i];
        mappedFields[key] = fields[i];
      }
      var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
      mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
      return new CronExpression(mappedFields, options2);
      function parseNthDay(val2) {
        var atoms2 = val2.split("#");
        if (atoms2.length > 1) {
          var nthValue = +atoms2[atoms2.length - 1];
          if (/,/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `,` special characters are incompatible");
          }
          if (/\//.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `/` special characters are incompatible");
          }
          if (/-/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `-` special characters are incompatible");
          }
          if (atoms2.length > 2 || Number.isNaN(nthValue) || (nthValue < 1 || nthValue > 5)) {
            throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");
          }
          options2.nthDayOfWeek = nthValue;
          return atoms2[0];
        }
        return val2;
      }
    }
    return parse5(expression, options);
  };
  CronExpression.fieldsToExpression = function fieldsToExpression(fields, options) {
    function validateConstraints(field4, values5, constraints) {
      if (!values5) {
        throw new Error("Validation error, Field " + field4 + " is missing");
      }
      if (values5.length === 0) {
        throw new Error("Validation error, Field " + field4 + " contains no values");
      }
      for (var i2 = 0, c3 = values5.length;i2 < c3; i2++) {
        var value14 = values5[i2];
        if (CronExpression._isValidConstraintChar(constraints, value14)) {
          continue;
        }
        if (typeof value14 !== "number" || Number.isNaN(value14) || value14 < constraints.min || value14 > constraints.max) {
          throw new Error("Constraint error, got value " + value14 + " expected range " + constraints.min + "-" + constraints.max);
        }
      }
    }
    var mappedFields = {};
    for (var i = 0, c2 = CronExpression.map.length;i < c2; ++i) {
      var field3 = CronExpression.map[i];
      var values4 = fields[field3];
      validateConstraints(field3, values4, CronExpression.constraints[i]);
      var copy = [];
      var j = -1;
      while (++j < values4.length) {
        copy[j] = values4[j];
      }
      values4 = copy.sort(CronExpression._sortCompareFn).filter(function(item, pos, ary) {
        return !pos || item !== ary[pos - 1];
      });
      if (values4.length !== copy.length) {
        throw new Error("Validation error, Field " + field3 + " contains duplicate values");
      }
      mappedFields[field3] = values4;
    }
    var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
    mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
    return new CronExpression(mappedFields, options || {});
  };
  module.exports = CronExpression;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var CronParser = function() {
  };
  var CronExpression = require_expression();
  CronParser._parseEntry = function _parseEntry(entry) {
    var atoms = entry.split(" ");
    if (atoms.length === 6) {
      return {
        interval: CronExpression.parse(entry)
      };
    } else if (atoms.length > 6) {
      return {
        interval: CronExpression.parse(atoms.slice(0, 6).join(" ")),
        command: atoms.slice(6, atoms.length)
      };
    } else {
      throw new Error("Invalid entry: " + entry);
    }
  };
  CronParser.parseExpression = function parseExpression(expression, options) {
    return CronExpression.parse(expression, options);
  };
  CronParser.fieldsToExpression = function fieldsToExpression(fields, options) {
    return CronExpression.fieldsToExpression(fields, options);
  };
  CronParser.parseString = function parseString(data) {
    var blocks = data.split("\n");
    var response = {
      variables: {},
      expressions: [],
      errors: {}
    };
    for (var i = 0, c2 = blocks.length;i < c2; i++) {
      var block2 = blocks[i];
      var matches = null;
      var entry = block2.trim();
      if (entry.length > 0) {
        if (entry.match(/^#/)) {
          continue;
        } else if (matches = entry.match(/^(.*)=(.*)$/)) {
          response.variables[matches[1]] = matches[2];
        } else {
          var result = null;
          try {
            result = CronParser._parseEntry("0 " + entry);
            response.expressions.push(result.interval);
          } catch (err) {
            response.errors[entry] = err;
          }
        }
      }
    }
    return response;
  };
  module.exports = CronParser;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/timekeeper.js
var require_timekeeper = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var cronParser = require_parser2();
  var Attorney = require_attorney();
  var pMap = require_p_map();
  var queues = {
    CRON: "__pgboss__cron",
    SEND_IT: "__pgboss__send-it"
  };
  var events2 = {
    error: "error",
    schedule: "schedule"
  };

  class Timekeeper extends EventEmitter {
    constructor(db, config) {
      super();
      this.db = db;
      this.config = config;
      this.manager = config.manager;
      this.skewMonitorIntervalMs = config.clockMonitorIntervalSeconds * 1000;
      this.cronMonitorIntervalMs = config.cronMonitorIntervalSeconds * 1000;
      this.clockSkew = 0;
      this.events = events2;
      this.getTimeCommand = plans.getTime(config.schema);
      this.getSchedulesCommand = plans.getSchedules(config.schema);
      this.scheduleCommand = plans.schedule(config.schema);
      this.unscheduleCommand = plans.unschedule(config.schema);
      this.getCronTimeCommand = plans.getCronTime(config.schema);
      this.setCronTimeCommand = plans.setCronTime(config.schema);
      this.functions = [
        this.schedule,
        this.unschedule,
        this.getSchedules
      ];
      this.stopped = true;
    }
    async start() {
      if (this.config.archiveSeconds < 60 || this.config.archiveFailedSeconds < 60) {
        return;
      }
      await this.cacheClockSkew();
      await this.manager.work(queues.CRON, { newJobCheckIntervalSeconds: this.config.cronWorkerIntervalSeconds }, (job) => this.onCron(job));
      await this.manager.work(queues.SEND_IT, { newJobCheckIntervalSeconds: this.config.cronWorkerIntervalSeconds, teamSize: 50, teamConcurrency: 5 }, (job) => this.onSendIt(job));
      await this.checkSchedulesAsync();
      this.cronMonitorInterval = setInterval(async () => await this.monitorCron(), this.cronMonitorIntervalMs);
      this.skewMonitorInterval = setInterval(async () => await this.cacheClockSkew(), this.skewMonitorIntervalMs);
      this.stopped = false;
    }
    async stop() {
      if (this.stopped) {
        return;
      }
      this.stopped = true;
      await this.manager.offWork(queues.CRON);
      await this.manager.offWork(queues.SEND_IT);
      if (this.skewMonitorInterval) {
        clearInterval(this.skewMonitorInterval);
        this.skewMonitorInterval = null;
      }
      if (this.cronMonitorInterval) {
        clearInterval(this.cronMonitorInterval);
        this.cronMonitorInterval = null;
      }
    }
    async monitorCron() {
      try {
        if (this.config.__test__force_cron_monitoring_error) {
          throw new Error(this.config.__test__force_cron_monitoring_error);
        }
        const { secondsAgo } = await this.getCronTime();
        if (secondsAgo > 60) {
          await this.checkSchedulesAsync();
        }
      } catch (err) {
        this.emit(this.events.error, err);
      }
    }
    async cacheClockSkew() {
      let skew = 0;
      try {
        if (this.config.__test__force_clock_monitoring_error) {
          throw new Error(this.config.__test__force_clock_monitoring_error);
        }
        const { rows } = await this.db.executeSql(this.getTimeCommand);
        const local = Date.now();
        const dbTime = parseFloat(rows[0].time);
        skew = dbTime - local;
        const skewSeconds = Math.abs(skew) / 1000;
        if (skewSeconds >= 60 || this.config.__test__force_clock_skew_warning) {
          Attorney.warnClockSkew(`Instance clock is ${skewSeconds}s ${skew > 0 ? "slower" : "faster"} than database.`);
        }
      } catch (err) {
        this.emit(this.events.error, err);
      } finally {
        this.clockSkew = skew;
      }
    }
    async checkSchedulesAsync() {
      const opts = {
        retryLimit: 2,
        retentionSeconds: 60,
        onComplete: false
      };
      await this.manager.sendDebounced(queues.CRON, null, opts, 60);
    }
    async onCron() {
      if (this.stopped)
        return;
      try {
        if (this.config.__test__throw_clock_monitoring) {
          throw new Error(this.config.__test__throw_clock_monitoring);
        }
        const items = await this.getSchedules();
        const sending = items.filter((i) => this.shouldSendIt(i.cron, i.timezone));
        if (sending.length && !this.stopped) {
          await pMap(sending, (it) => this.send(it), { concurrency: 5 });
        }
        if (this.stopped)
          return;
        await this.setCronTime();
      } catch (err) {
        this.emit(this.events.error, err);
      }
      if (this.stopped)
        return;
      await this.checkSchedulesAsync();
    }
    shouldSendIt(cron, tz) {
      const interval = cronParser.parseExpression(cron, { tz });
      const prevTime = interval.prev();
      const databaseTime = Date.now() + this.clockSkew;
      const prevDiff = (databaseTime - prevTime.getTime()) / 1000;
      return prevDiff < 60;
    }
    async send(job) {
      const options = {
        singletonKey: job.name,
        singletonSeconds: 60,
        onComplete: false
      };
      await this.manager.send(queues.SEND_IT, job, options);
    }
    async onSendIt(job) {
      if (this.stopped)
        return;
      const { name, data, options } = job.data;
      await this.manager.send(name, data, options);
    }
    async getSchedules() {
      const { rows } = await this.db.executeSql(this.getSchedulesCommand);
      return rows;
    }
    async schedule(name, cron, data, options = {}) {
      const { tz = "UTC" } = options;
      cronParser.parseExpression(cron, { tz });
      Attorney.checkSendArgs([name, data, options], this.config);
      const values4 = [name, cron, tz, data, options];
      const result = await this.db.executeSql(this.scheduleCommand, values4);
      return result ? result.rowCount : null;
    }
    async unschedule(name) {
      const result = await this.db.executeSql(this.unscheduleCommand, [name]);
      return result ? result.rowCount : null;
    }
    async setCronTime() {
      await this.db.executeSql(this.setCronTimeCommand);
    }
    async getCronTime() {
      const { rows } = await this.db.executeSql(this.getCronTimeCommand);
      let { cron_on: cronOn, seconds_ago: secondsAgo } = rows[0];
      secondsAgo = secondsAgo !== null ? parseFloat(secondsAgo) : 61;
      return { cronOn, secondsAgo };
    }
  }
  module.exports = Timekeeper;
  module.exports.QUEUES = queues;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/manager.js
var require_manager = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var EventEmitter = import.meta.require("events");
  var delay = require_delay();
  var uuid = require_dist();
  var debounce = require_lodash();
  var { serializeError: stringify4 } = require_serialize_error();
  var Attorney = require_attorney();
  var Worker = require_worker();
  var Db = require_db();
  var pMap = require_p_map();
  var { QUEUES: BOSS_QUEUES } = require_boss();
  var { QUEUES: TIMEKEEPER_QUEUES } = require_timekeeper();
  var INTERNAL_QUEUES = Object.values(BOSS_QUEUES).concat(Object.values(TIMEKEEPER_QUEUES)).reduce((acc, i) => ({ ...acc, [i]: i }), {});
  var plans = require_plans();
  var { COMPLETION_JOB_PREFIX, SINGLETON_QUEUE_KEY } = plans;
  var WIP_EVENT_INTERVAL = 2000;
  var WIP_DEBOUNCE_OPTIONS = { leading: true, trailing: true, maxWait: WIP_EVENT_INTERVAL };
  var events2 = {
    error: "error",
    wip: "wip"
  };
  var resolveWithinSeconds = async (promise4, seconds) => {
    const timeout = Math.max(1, seconds) * 1000;
    const reject2 = delay.reject(timeout, { value: new Error(`handler execution exceeded ${timeout}ms`) });
    let result;
    try {
      result = await Promise.race([promise4, reject2]);
    } finally {
      try {
        reject2.clear();
      } catch {
      }
    }
    return result;
  };

  class Manager extends EventEmitter {
    constructor(db, config) {
      super();
      this.config = config;
      this.db = db;
      this.events = events2;
      this.workers = new Map;
      this.nextJobCommand = plans.fetchNextJob(config.schema);
      this.insertJobCommand = plans.insertJob(config.schema);
      this.insertJobsCommand = plans.insertJobs(config.schema);
      this.completeJobsCommand = plans.completeJobs(config.schema);
      this.cancelJobsCommand = plans.cancelJobs(config.schema);
      this.resumeJobsCommand = plans.resumeJobs(config.schema);
      this.failJobsCommand = plans.failJobs(config.schema);
      this.getJobByIdCommand = plans.getJobById(config.schema);
      this.getArchivedJobByIdCommand = plans.getArchivedJobById(config.schema);
      this.subscribeCommand = plans.subscribe(config.schema);
      this.unsubscribeCommand = plans.unsubscribe(config.schema);
      this.getQueuesForEventCommand = plans.getQueuesForEvent(config.schema);
      this.functions = [
        this.complete,
        this.cancel,
        this.resume,
        this.fail,
        this.fetch,
        this.fetchCompleted,
        this.work,
        this.offWork,
        this.notifyWorker,
        this.onComplete,
        this.offComplete,
        this.publish,
        this.subscribe,
        this.unsubscribe,
        this.insert,
        this.send,
        this.sendDebounced,
        this.sendThrottled,
        this.sendOnce,
        this.sendAfter,
        this.sendSingleton,
        this.deleteQueue,
        this.deleteAllQueues,
        this.clearStorage,
        this.getQueueSize,
        this.getJobById
      ];
      this.emitWipThrottled = debounce(() => this.emit(events2.wip, this.getWipData()), WIP_EVENT_INTERVAL, WIP_DEBOUNCE_OPTIONS);
    }
    start() {
      this.stopping = false;
    }
    async stop() {
      this.stopping = true;
      for (const sub of this.workers.values()) {
        if (!INTERNAL_QUEUES[sub.name]) {
          await this.offWork(sub.name);
        }
      }
    }
    async work(name, ...args) {
      const { options, callback } = Attorney.checkWorkArgs(name, args, this.config);
      return await this.watch(name, options, callback);
    }
    async onComplete(name, ...args) {
      const { options, callback } = Attorney.checkWorkArgs(name, args, this.config);
      return await this.watch(COMPLETION_JOB_PREFIX + name, options, callback);
    }
    addWorker(worker) {
      this.workers.set(worker.id, worker);
    }
    removeWorker(worker) {
      this.workers.delete(worker.id);
    }
    getWorkers() {
      return Array.from(this.workers.values());
    }
    emitWip(name) {
      if (!INTERNAL_QUEUES[name]) {
        this.emitWipThrottled();
      }
    }
    getWipData(options = {}) {
      const { includeInternal = false } = options;
      const data = this.getWorkers().map(({
        id,
        name,
        options: options2,
        state,
        jobs,
        createdOn,
        lastFetchedOn,
        lastJobStartedOn,
        lastJobEndedOn,
        lastError,
        lastErrorOn
      }) => ({
        id,
        name,
        options: options2,
        state,
        count: jobs.length,
        createdOn,
        lastFetchedOn,
        lastJobStartedOn,
        lastJobEndedOn,
        lastError,
        lastErrorOn
      })).filter((i) => i.count > 0 && (!INTERNAL_QUEUES[i.name] || includeInternal));
      return data;
    }
    async watch(name, options, callback) {
      if (this.stopping) {
        throw new Error("Workers are disabled. pg-boss is stopping.");
      }
      const {
        newJobCheckInterval: interval = this.config.newJobCheckInterval,
        batchSize,
        teamSize = 1,
        teamConcurrency = 1,
        teamRefill: refill = false,
        includeMetadata = false,
        enforceSingletonQueueActiveLimit = false
      } = options;
      const id = uuid.v4();
      let queueSize = 0;
      let refillTeamPromise;
      let resolveRefillTeam;
      const createTeamRefillPromise = () => {
        refillTeamPromise = new Promise((resolve) => {
          resolveRefillTeam = resolve;
        });
      };
      createTeamRefillPromise();
      const onRefill = () => {
        queueSize--;
        resolveRefillTeam();
        createTeamRefillPromise();
      };
      const fetch6 = () => this.fetch(name, batchSize || teamSize - queueSize, { includeMetadata, enforceSingletonQueueActiveLimit });
      const onFetch = async (jobs) => {
        if (this.config.__test__throw_worker) {
          throw new Error("__test__throw_worker");
        }
        this.emitWip(name);
        if (batchSize) {
          const maxExpiration = jobs.reduce((acc, i) => Math.max(acc, i.expire_in_seconds), 0);
          await resolveWithinSeconds(Promise.all([callback(jobs)]), maxExpiration).then(() => this.complete(jobs.map((job) => job.id))).catch((err) => this.fail(jobs.map((job) => job.id), err));
        } else {
          if (refill) {
            queueSize += jobs.length || 1;
          }
          const allTeamPromise = pMap(jobs, (job) => resolveWithinSeconds(callback(job), job.expire_in_seconds).then((result) => this.complete(job.id, result)).catch((err) => this.fail(job.id, err)).then(() => refill ? onRefill() : null), { concurrency: teamConcurrency }).catch(() => {
          });
          if (refill) {
            if (queueSize < teamSize) {
              return;
            } else {
              await refillTeamPromise;
            }
          } else {
            await allTeamPromise;
          }
        }
        this.emitWip(name);
      };
      const onError = (error28) => {
        this.emit(events2.error, { ...error28, message: error28.message, stack: error28.stack, queue: name, worker: id });
      };
      const worker = new Worker({ id, name, options, interval, fetch: fetch6, onFetch, onError });
      this.addWorker(worker);
      worker.start();
      return id;
    }
    async offWork(value14) {
      assert(value14, "Missing required argument");
      const query3 = typeof value14 === "string" ? { filter: (i) => i.name === value14 } : typeof value14 === "object" && value14.id ? { filter: (i) => i.id === value14.id } : null;
      assert(query3, "Invalid argument. Expected string or object: { id }");
      const workers = this.getWorkers().filter((i) => query3.filter(i) && !i.stopping && !i.stopped);
      if (workers.length === 0) {
        return;
      }
      for (const worker of workers) {
        worker.stop();
      }
      setImmediate(async () => {
        while (!workers.every((w2) => w2.stopped)) {
          await delay(1000);
        }
        for (const worker of workers) {
          this.removeWorker(worker);
        }
      });
    }
    notifyWorker(workerId) {
      if (this.workers.has(workerId)) {
        this.workers.get(workerId).notify();
      }
    }
    async subscribe(event, name) {
      assert(event, "Missing required argument");
      assert(name, "Missing required argument");
      return await this.db.executeSql(this.subscribeCommand, [event, name]);
    }
    async unsubscribe(event, name) {
      assert(event, "Missing required argument");
      assert(name, "Missing required argument");
      return await this.db.executeSql(this.unsubscribeCommand, [event, name]);
    }
    async publish(event, ...args) {
      assert(event, "Missing required argument");
      const result = await this.db.executeSql(this.getQueuesForEventCommand, [event]);
      if (!result || result.rowCount === 0) {
        return [];
      }
      return await Promise.all(result.rows.map(({ name }) => this.send(name, ...args)));
    }
    async offComplete(value14) {
      if (typeof value14 === "string") {
        value14 = COMPLETION_JOB_PREFIX + value14;
      }
      return await this.offWork(value14);
    }
    async send(...args) {
      const { name, data, options } = Attorney.checkSendArgs(args, this.config);
      return await this.createJob(name, data, options);
    }
    async sendOnce(name, data, options, key) {
      options = options ? { ...options } : {};
      options.singletonKey = key || name;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendSingleton(name, data, options) {
      options = options ? { ...options } : {};
      options.singletonKey = SINGLETON_QUEUE_KEY;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendAfter(name, data, options, after) {
      options = options ? { ...options } : {};
      options.startAfter = after;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendThrottled(name, data, options, seconds, key) {
      options = options ? { ...options } : {};
      options.singletonSeconds = seconds;
      options.singletonNextSlot = false;
      options.singletonKey = key;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendDebounced(name, data, options, seconds, key) {
      options = options ? { ...options } : {};
      options.singletonSeconds = seconds;
      options.singletonNextSlot = true;
      options.singletonKey = key;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async createJob(name, data, options, singletonOffset = 0) {
      const {
        db: wrapper,
        expireIn,
        priority,
        startAfter,
        keepUntil,
        singletonKey = null,
        singletonSeconds,
        retryBackoff,
        retryLimit,
        retryDelay,
        onComplete
      } = options;
      const id = uuid[this.config.uuid]();
      const values4 = [
        id,
        name,
        priority,
        retryLimit,
        startAfter,
        expireIn,
        data,
        singletonKey,
        singletonSeconds,
        singletonOffset,
        retryDelay,
        retryBackoff,
        keepUntil,
        onComplete
      ];
      const db = wrapper || this.db;
      const result = await db.executeSql(this.insertJobCommand, values4);
      if (result && result.rowCount === 1) {
        return result.rows[0].id;
      }
      if (!options.singletonNextSlot) {
        return null;
      }
      options.startAfter = this.getDebounceStartAfter(singletonSeconds, this.timekeeper.clockSkew);
      options.singletonNextSlot = false;
      singletonOffset = singletonSeconds;
      return await this.createJob(name, data, options, singletonOffset);
    }
    async insert(jobs, options = {}) {
      const { db: wrapper } = options;
      const db = wrapper || this.db;
      const checkedJobs = Attorney.checkInsertArgs(jobs);
      const data = JSON.stringify(checkedJobs);
      return await db.executeSql(this.insertJobsCommand, [data]);
    }
    getDebounceStartAfter(singletonSeconds, clockOffset) {
      const debounceInterval = singletonSeconds * 1000;
      const now = Date.now() + clockOffset;
      const slot = Math.floor(now / debounceInterval) * debounceInterval;
      let startAfter = singletonSeconds - Math.floor((now - slot) / 1000) || 1;
      if (singletonSeconds > 1) {
        startAfter++;
      }
      return startAfter;
    }
    async fetch(name, batchSize, options = {}) {
      const values4 = Attorney.checkFetchArgs(name, batchSize, options);
      const db = options.db || this.db;
      const preparedStatement = this.nextJobCommand(options.includeMetadata || false, options.enforceSingletonQueueActiveLimit || false);
      const statementValues = [values4.name, batchSize || 1];
      let result;
      if (options.enforceSingletonQueueActiveLimit && !options.db) {
        const fetchQuery = preparedStatement.replace("$1", Db.quotePostgresStr(statementValues[0])).replace("$2", statementValues[1].toString());
        const [_begin, _setLocal, fetchResult, _commit] = await db.executeSql([
          "BEGIN",
          "SET LOCAL jit = OFF",
          fetchQuery,
          "COMMIT"
        ].join(";\n"));
        result = fetchResult;
      } else {
        result = await db.executeSql(preparedStatement, statementValues);
      }
      if (!result || result.rows.length === 0) {
        return null;
      }
      return result.rows.length === 1 && !batchSize ? result.rows[0] : result.rows;
    }
    async fetchCompleted(name, batchSize, options = {}) {
      return await this.fetch(COMPLETION_JOB_PREFIX + name, batchSize, options);
    }
    mapCompletionIdArg(id, funcName) {
      const errorMessage = `${funcName}() requires an id`;
      assert(id, errorMessage);
      const ids = Array.isArray(id) ? id : [id];
      assert(ids.length, errorMessage);
      return ids;
    }
    mapCompletionDataArg(data) {
      if (data === null || typeof data === "undefined" || typeof data === "function") {
        return null;
      }
      const result = typeof data === "object" && !Array.isArray(data) ? data : { value: data };
      return stringify4(result);
    }
    mapCompletionResponse(ids, result) {
      return {
        jobs: ids,
        requested: ids.length,
        updated: result && result.rows ? parseInt(result.rows[0].count) : 0
      };
    }
    async complete(id, data, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "complete");
      const result = await db.executeSql(this.completeJobsCommand, [ids, this.mapCompletionDataArg(data)]);
      return this.mapCompletionResponse(ids, result);
    }
    async fail(id, data, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "fail");
      const result = await db.executeSql(this.failJobsCommand, [ids, this.mapCompletionDataArg(data)]);
      return this.mapCompletionResponse(ids, result);
    }
    async cancel(id, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "cancel");
      const result = await db.executeSql(this.cancelJobsCommand, [ids]);
      return this.mapCompletionResponse(ids, result);
    }
    async resume(id, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "resume");
      const result = await db.executeSql(this.resumeJobsCommand, [ids]);
      return this.mapCompletionResponse(ids, result);
    }
    async deleteQueue(queue, options) {
      assert(queue, "Missing queue name argument");
      const sql = plans.deleteQueue(this.config.schema, options);
      const result = await this.db.executeSql(sql, [queue]);
      return result ? result.rowCount : null;
    }
    async deleteAllQueues(options) {
      const sql = plans.deleteAllQueues(this.config.schema, options);
      const result = await this.db.executeSql(sql);
      return result ? result.rowCount : null;
    }
    async clearStorage() {
      const sql = plans.clearStorage(this.config.schema);
      await this.db.executeSql(sql);
    }
    async getQueueSize(queue, options) {
      assert(queue, "Missing queue name argument");
      const sql = plans.getQueueSize(this.config.schema, options);
      const result = await this.db.executeSql(sql, [queue]);
      return result ? parseFloat(result.rows[0].count) : null;
    }
    async getJobById(id, options = {}) {
      const db = options.db || this.db;
      const result1 = await db.executeSql(this.getJobByIdCommand, [id]);
      if (result1 && result1.rows && result1.rows.length === 1) {
        return result1.rows[0];
      }
      const result2 = await db.executeSql(this.getArchivedJobByIdCommand, [id]);
      if (result2 && result2.rows && result2.rows.length === 1) {
        return result2.rows[0];
      }
      return null;
    }
  }
  module.exports = Manager;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/index.js
var require_src = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var Attorney = require_attorney();
  var Contractor = require_contractor();
  var Manager = require_manager();
  var Timekeeper = require_timekeeper();
  var Boss = require_boss();
  var Db = require_db();
  var delay = require_delay();
  var events2 = {
    error: "error",
    stopped: "stopped"
  };

  class PgBoss extends EventEmitter {
    static getConstructionPlans(schema3) {
      return Contractor.constructionPlans(schema3);
    }
    static getMigrationPlans(schema3, version2) {
      return Contractor.migrationPlans(schema3, version2);
    }
    static getRollbackPlans(schema3, version2) {
      return Contractor.rollbackPlans(schema3, version2);
    }
    constructor(value14) {
      const config = Attorney.getConfig(value14);
      super();
      const db = getDb(config);
      if (db.isOurs) {
        promoteEvent.call(this, db, "error");
      }
      const manager2 = new Manager(db, config);
      Object.keys(manager2.events).forEach((event) => promoteEvent.call(this, manager2, manager2.events[event]));
      manager2.functions.forEach((func) => promoteFunction.call(this, manager2, func));
      const bossConfig = { ...config, manager: manager2 };
      const boss = new Boss(db, bossConfig);
      Object.keys(boss.events).forEach((event) => promoteEvent.call(this, boss, boss.events[event]));
      boss.functions.forEach((func) => promoteFunction.call(this, boss, func));
      const timekeeper = new Timekeeper(db, bossConfig);
      Object.keys(timekeeper.events).forEach((event) => promoteEvent.call(this, timekeeper, timekeeper.events[event]));
      timekeeper.functions.forEach((func) => promoteFunction.call(this, timekeeper, func));
      manager2.timekeeper = timekeeper;
      this.stoppingOn = null;
      this.stopped = true;
      this.config = config;
      this.db = db;
      this.boss = boss;
      this.contractor = new Contractor(db, config);
      this.manager = manager2;
      this.timekeeper = timekeeper;
      function getDb(config2) {
        if (config2.db) {
          return config2.db;
        }
        const db2 = new Db(config2);
        db2.isOurs = true;
        return db2;
      }
      function promoteFunction(obj, func) {
        this[func.name] = (...args) => {
          const shouldRun = !this.started || !((func.name === "work" || func.name === "onComplete") && (this.stopped || this.stoppingOn));
          if (shouldRun) {
            return func.apply(obj, args);
          } else {
            const state = this.stoppingOn ? "stopping" : this.stopped ? "stopped" : !this.started ? "not started" : "started";
            return Promise.reject(new Error(`pg-boss is ${state}.`));
          }
        };
      }
      function promoteEvent(emitter, event) {
        emitter.on(event, (arg) => this.emit(event, arg));
      }
    }
    async start() {
      if (!this.stopped) {
        return this;
      }
      if (this.db.isOurs && !this.db.opened) {
        await this.db.open();
      }
      await this.contractor.start();
      this.stopped = false;
      this.started = true;
      this.manager.start();
      if (!this.config.noSupervisor) {
        await this.boss.supervise();
      }
      if (!this.config.noScheduling) {
        await this.timekeeper.start();
      }
      return this;
    }
    async stop(options = {}) {
      if (this.stoppingOn) {
        return;
      }
      if (this.stopped) {
        this.emit(events2.stopped);
      }
      let { destroy = false, graceful = true, timeout = 30000 } = options;
      timeout = Math.max(timeout, 1000);
      this.stoppingOn = Date.now();
      await this.manager.stop();
      await this.timekeeper.stop();
      const shutdown = async () => {
        this.stopped = true;
        this.stoppingOn = null;
        if (this.db.isOurs && this.db.opened && destroy) {
          await this.db.close();
        }
        this.emit(events2.stopped);
      };
      if (!graceful) {
        await this.boss.stop();
        await shutdown();
        return;
      }
      setImmediate(async () => {
        let closing = false;
        try {
          while (Date.now() - this.stoppingOn < timeout) {
            if (this.manager.getWipData({ includeInternal: closing }).length === 0) {
              if (closing) {
                break;
              }
              closing = true;
              await this.boss.stop();
            }
            await delay(1000);
          }
          await this.boss.stop();
          await shutdown();
        } catch (err) {
          this.emit(events2.error, err);
        }
      });
    }
  }
  module.exports = PgBoss;
  module.exports.states = plans.states;
});

// /Users/richardguerre/Projects/flow/node_modules/elysia/dist/bun/index.js
var eW = Object.create;
var { defineProperty: S6, getPrototypeOf: $X, getOwnPropertyNames: YX } = Object;
var WX = Object.prototype.hasOwnProperty;
var Q1 = ($, Y, W) => {
  W = $ != null ? eW($X($)) : {};
  const X = Y || !$ || !$.__esModule ? S6(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of YX($))
    if (!WX.call(X, Z))
      S6(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var J0 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var b6 = J0((O7, a$) => {
  var s1 = function() {
  }, QX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, I6 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new QX(W, X || $, Z), J = V0 ? V0 + Y : Y;
    if (!$._events[J])
      $._events[J] = Q, $._eventsCount++;
    else if (!$._events[J].fn)
      $._events[J].push(Q);
    else
      $._events[J] = [$._events[J], Q];
    return $;
  }, K$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new s1;
    else
      delete $._events[Y];
  }, G0 = function() {
    this._events = new s1, this._eventsCount = 0;
  }, ZX = Object.prototype.hasOwnProperty, V0 = "~";
  if (Object.create) {
    if (s1.prototype = Object.create(null), !new s1().__proto__)
      V0 = false;
  }
  G0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (ZX.call(W, X))
        Y.push(V0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  G0.prototype.listeners = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, Q = X.length, J = new Array(Q);Z < Q; Z++)
      J[Z] = X[Z].fn;
    return J;
  };
  G0.prototype.listenerCount = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  G0.prototype.emit = function $(Y, W, X, Z, Q, J) {
    var z = V0 ? V0 + Y : Y;
    if (!this._events[z])
      return false;
    var U = this._events[z], D = arguments.length, B, j;
    if (U.fn) {
      if (U.once)
        this.removeListener(Y, U.fn, undefined, true);
      switch (D) {
        case 1:
          return U.fn.call(U.context), true;
        case 2:
          return U.fn.call(U.context, W), true;
        case 3:
          return U.fn.call(U.context, W, X), true;
        case 4:
          return U.fn.call(U.context, W, X, Z), true;
        case 5:
          return U.fn.call(U.context, W, X, Z, Q), true;
        case 6:
          return U.fn.call(U.context, W, X, Z, Q, J), true;
      }
      for (j = 1, B = new Array(D - 1);j < D; j++)
        B[j - 1] = arguments[j];
      U.fn.apply(U.context, B);
    } else {
      var b = U.length, S;
      for (j = 0;j < b; j++) {
        if (U[j].once)
          this.removeListener(Y, U[j].fn, undefined, true);
        switch (D) {
          case 1:
            U[j].fn.call(U[j].context);
            break;
          case 2:
            U[j].fn.call(U[j].context, W);
            break;
          case 3:
            U[j].fn.call(U[j].context, W, X);
            break;
          case 4:
            U[j].fn.call(U[j].context, W, X, Z);
            break;
          default:
            if (!B)
              for (S = 1, B = new Array(D - 1);S < D; S++)
                B[S - 1] = arguments[S];
            U[j].fn.apply(U[j].context, B);
        }
      }
    }
    return true;
  };
  G0.prototype.on = function $(Y, W, X) {
    return I6(this, Y, W, X, false);
  };
  G0.prototype.once = function $(Y, W, X) {
    return I6(this, Y, W, X, true);
  };
  G0.prototype.removeListener = function $(Y, W, X, Z) {
    var Q = V0 ? V0 + Y : Y;
    if (!this._events[Q])
      return this;
    if (!W)
      return K$(this, Q), this;
    var J = this._events[Q];
    if (J.fn) {
      if (J.fn === W && (!Z || J.once) && (!X || J.context === X))
        K$(this, Q);
    } else {
      for (var z = 0, U = [], D = J.length;z < D; z++)
        if (J[z].fn !== W || Z && !J[z].once || X && J[z].context !== X)
          U.push(J[z]);
      if (U.length)
        this._events[Q] = U.length === 1 ? U[0] : U;
      else
        K$(this, Q);
    }
    return this;
  };
  G0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = V0 ? V0 + Y : Y, this._events[W])
        K$(this, W);
    } else
      this._events = new s1, this._eventsCount = 0;
    return this;
  };
  G0.prototype.off = G0.prototype.removeListener;
  G0.prototype.addListener = G0.prototype.on;
  G0.prefixed = V0;
  G0.EventEmitter = G0;
  if (typeof a$ !== "undefined")
    a$.exports = G0;
});
var x0 = J0((d6) => {
  var JX = function($) {
    return j$($) && (Symbol.asyncIterator in $);
  }, zX = function($) {
    return j$($) && (Symbol.iterator in $);
  }, HX = function($) {
    return ArrayBuffer.isView($);
  }, qX = function($) {
    return $ instanceof Promise;
  }, MX = function($) {
    return $ instanceof Uint8Array;
  }, NX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, FX = function($, Y) {
    return Y in $;
  }, UX = function($) {
    return j$($) && f6($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, AX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E6 = function($) {
    return $ === undefined;
  }, V6 = function($) {
    return $ === null;
  }, x6 = function($) {
    return typeof $ === "boolean";
  }, e$ = function($) {
    return typeof $ === "number";
  }, BX = function($) {
    return e$($) && Number.isInteger($);
  }, k6 = function($) {
    return typeof $ === "bigint";
  }, g6 = function($) {
    return typeof $ === "string";
  }, f6 = function($) {
    return typeof $ === "function";
  }, T6 = function($) {
    return typeof $ === "symbol";
  }, DX = function($) {
    return k6($) || x6($) || V6($) || e$($) || g6($) || T6($) || E6($);
  };
  Object.defineProperty(d6, "__esModule", { value: true });
  d6.IsValueType = d6.IsSymbol = d6.IsFunction = d6.IsString = d6.IsBigInt = d6.IsInteger = d6.IsNumber = d6.IsBoolean = d6.IsNull = d6.IsUndefined = d6.IsArray = d6.IsObject = d6.IsPlainObject = d6.HasPropertyKey = d6.IsDate = d6.IsUint8Array = d6.IsPromise = d6.IsTypedArray = d6.IsIterator = d6.IsAsyncIterator = undefined;
  d6.IsAsyncIterator = JX;
  d6.IsIterator = zX;
  d6.IsTypedArray = HX;
  d6.IsPromise = qX;
  d6.IsUint8Array = MX;
  d6.IsDate = NX;
  d6.HasPropertyKey = FX;
  d6.IsPlainObject = UX;
  d6.IsObject = j$;
  d6.IsArray = AX;
  d6.IsUndefined = E6;
  d6.IsNull = V6;
  d6.IsBoolean = x6;
  d6.IsNumber = e$;
  d6.IsInteger = BX;
  d6.IsBigInt = k6;
  d6.IsString = g6;
  d6.IsFunction = f6;
  d6.IsSymbol = T6;
  d6.IsValueType = DX;
});
var f0 = J0((m6) => {
  Object.defineProperty(m6, "__esModule", { value: true });
  m6.Type = m6.JsonType = m6.JavaScriptTypeBuilder = m6.JsonTypeBuilder = m6.TypeBuilder = m6.TypeBuilderError = m6.TransformEncodeBuilder = m6.TransformDecodeBuilder = m6.TemplateLiteralDslParser = m6.TemplateLiteralGenerator = m6.TemplateLiteralGeneratorError = m6.TemplateLiteralFinite = m6.TemplateLiteralFiniteError = m6.TemplateLiteralParser = m6.TemplateLiteralParserError = m6.TemplateLiteralResolver = m6.TemplateLiteralPattern = m6.TemplateLiteralPatternError = m6.UnionResolver = m6.KeyArrayResolver = m6.KeyArrayResolverError = m6.KeyResolver = m6.ObjectMap = m6.Intrinsic = m6.IndexedAccessor = m6.TypeClone = m6.TypeExtends = m6.TypeExtendsResult = m6.TypeExtendsError = m6.ExtendsUndefined = m6.TypeGuard = m6.TypeGuardUnknownTypeError = m6.ValueGuard = m6.FormatRegistry = m6.TypeBoxError = m6.TypeRegistry = m6.PatternStringExact = m6.PatternNumberExact = m6.PatternBooleanExact = m6.PatternString = m6.PatternNumber = m6.PatternBoolean = m6.Kind = m6.Hint = m6.Optional = m6.Readonly = m6.Transform = undefined;
  m6.Transform = Symbol.for("TypeBox.Transform");
  m6.Readonly = Symbol.for("TypeBox.Readonly");
  m6.Optional = Symbol.for("TypeBox.Optional");
  m6.Hint = Symbol.for("TypeBox.Hint");
  m6.Kind = Symbol.for("TypeBox.Kind");
  m6.PatternBoolean = "(true|false)";
  m6.PatternNumber = "(0|[1-9][0-9]*)";
  m6.PatternString = "(.*)";
  m6.PatternBooleanExact = `^${m6.PatternBoolean}$`;
  m6.PatternNumberExact = `^${m6.PatternNumber}$`;
  m6.PatternStringExact = `^${m6.PatternString}$`;
  var $8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })($8 || (m6.TypeRegistry = $8 = {}));

  class $1 extends Error {
    constructor($) {
      super($);
    }
  }
  m6.TypeBoxError = $1;
  var v6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })(v6 || (m6.FormatRegistry = v6 = {}));
  var V;
  (function($) {
    function Y(D) {
      return Array.isArray(D);
    }
    $.IsArray = Y;
    function W(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = W;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function Q(D) {
      return typeof D === "number";
    }
    $.IsNumber = Q;
    function J(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = J;
    function z(D) {
      return typeof D === "string";
    }
    $.IsString = z;
    function U(D) {
      return D === undefined;
    }
    $.IsUndefined = U;
  })(V || (m6.ValueGuard = V = {}));

  class i6 extends $1 {
  }
  m6.TypeGuardUnknownTypeError = i6;
  var A;
  (function($) {
    function Y(M) {
      try {
        return new RegExp(M), true;
      } catch {
        return false;
      }
    }
    function W(M) {
      if (!V.IsString(M))
        return false;
      for (let l = 0;l < M.length; l++) {
        const S0 = M.charCodeAt(l);
        if (S0 >= 7 && S0 <= 13 || S0 === 27 || S0 === 127)
          return false;
      }
      return true;
    }
    function X(M) {
      return J(M) || X0(M);
    }
    function Z(M) {
      return V.IsUndefined(M) || V.IsBigInt(M);
    }
    function Q(M) {
      return V.IsUndefined(M) || V.IsNumber(M);
    }
    function J(M) {
      return V.IsUndefined(M) || V.IsBoolean(M);
    }
    function z(M) {
      return V.IsUndefined(M) || V.IsString(M);
    }
    function U(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M) && Y(M);
    }
    function D(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M);
    }
    function B(M) {
      return V.IsUndefined(M) || X0(M);
    }
    function j(M) {
      return _(M, "Any") && z(M.$id);
    }
    $.TAny = j;
    function b(M) {
      return _(M, "Array") && M.type === "array" && z(M.$id) && X0(M.items) && Q(M.minItems) && Q(M.maxItems) && J(M.uniqueItems) && B(M.contains) && Q(M.minContains) && Q(M.maxContains);
    }
    $.TArray = b;
    function S(M) {
      return _(M, "AsyncIterator") && M.type === "AsyncIterator" && z(M.$id) && X0(M.items);
    }
    $.TAsyncIterator = S;
    function N(M) {
      return _(M, "BigInt") && M.type === "bigint" && z(M.$id) && Z(M.exclusiveMaximum) && Z(M.exclusiveMinimum) && Z(M.maximum) && Z(M.minimum) && Z(M.multipleOf);
    }
    $.TBigInt = N;
    function O(M) {
      return _(M, "Boolean") && M.type === "boolean" && z(M.$id);
    }
    $.TBoolean = O;
    function P(M) {
      return _(M, "Constructor") && M.type === "Constructor" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TConstructor = P;
    function F(M) {
      return _(M, "Date") && M.type === "Date" && z(M.$id) && Q(M.exclusiveMaximumTimestamp) && Q(M.exclusiveMinimumTimestamp) && Q(M.maximumTimestamp) && Q(M.minimumTimestamp) && Q(M.multipleOfTimestamp);
    }
    $.TDate = F;
    function w(M) {
      return _(M, "Function") && M.type === "Function" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TFunction = w;
    function I(M) {
      return _(M, "Integer") && M.type === "integer" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TInteger = I;
    function G(M) {
      return _(M, "Intersect") && (V.IsString(M.type) && M.type !== "object" ? false : true) && V.IsArray(M.allOf) && M.allOf.every((l) => X0(l) && !w0(l)) && z(M.type) && (J(M.unevaluatedProperties) || B(M.unevaluatedProperties)) && z(M.$id);
    }
    $.TIntersect = G;
    function k(M) {
      return _(M, "Iterator") && M.type === "Iterator" && z(M.$id) && X0(M.items);
    }
    $.TIterator = k;
    function _(M, l) {
      return e(M) && M[m6.Kind] === l;
    }
    $.TKindOf = _;
    function e(M) {
      return V.IsObject(M) && (m6.Kind in M) && V.IsString(M[m6.Kind]);
    }
    $.TKind = e;
    function o(M) {
      return b0(M) && V.IsString(M.const);
    }
    $.TLiteralString = o;
    function r(M) {
      return b0(M) && V.IsNumber(M.const);
    }
    $.TLiteralNumber = r;
    function g0(M) {
      return b0(M) && V.IsBoolean(M.const);
    }
    $.TLiteralBoolean = g0;
    function b0(M) {
      return _(M, "Literal") && z(M.$id) && (V.IsBoolean(M.const) || V.IsNumber(M.const) || V.IsString(M.const));
    }
    $.TLiteral = b0;
    function E0(M) {
      return _(M, "Never") && V.IsObject(M.not) && Object.getOwnPropertyNames(M.not).length === 0;
    }
    $.TNever = E0;
    function H0(M) {
      return _(M, "Not") && X0(M.not);
    }
    $.TNot = H0;
    function z0(M) {
      return _(M, "Null") && M.type === "null" && z(M.$id);
    }
    $.TNull = z0;
    function u0(M) {
      return _(M, "Number") && M.type === "number" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TNumber = u0;
    function a0(M) {
      return _(M, "Object") && M.type === "object" && z(M.$id) && V.IsObject(M.properties) && X(M.additionalProperties) && Q(M.minProperties) && Q(M.maxProperties) && Object.entries(M.properties).every(([l, S0]) => W(l) && X0(S0));
    }
    $.TObject = a0;
    function v0(M) {
      return _(M, "Promise") && M.type === "Promise" && z(M.$id) && X0(M.item);
    }
    $.TPromise = v0;
    function R(M) {
      return _(M, "Record") && M.type === "object" && z(M.$id) && X(M.additionalProperties) && V.IsObject(M.patternProperties) && ((l) => {
        const S0 = Object.getOwnPropertyNames(l.patternProperties);
        return S0.length === 1 && Y(S0[0]) && V.IsObject(l.patternProperties) && X0(l.patternProperties[S0[0]]);
      })(M);
    }
    $.TRecord = R;
    function f(M) {
      return V.IsObject(M) && (m6.Hint in M) && M[m6.Hint] === "Recursive";
    }
    $.TRecursive = f;
    function i(M) {
      return _(M, "Ref") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TRef = i;
    function n(M) {
      return _(M, "String") && M.type === "string" && z(M.$id) && Q(M.minLength) && Q(M.maxLength) && U(M.pattern) && D(M.format);
    }
    $.TString = n;
    function q0(M) {
      return _(M, "Symbol") && M.type === "symbol" && z(M.$id);
    }
    $.TSymbol = q0;
    function B0(M) {
      return _(M, "TemplateLiteral") && M.type === "string" && V.IsString(M.pattern) && M.pattern[0] === "^" && M.pattern[M.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = B0;
    function D0(M) {
      return _(M, "This") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TThis = D0;
    function w0(M) {
      return V.IsObject(M) && (m6.Transform in M);
    }
    $.TTransform = w0;
    function M0(M) {
      return _(M, "Tuple") && M.type === "array" && z(M.$id) && V.IsNumber(M.minItems) && V.IsNumber(M.maxItems) && M.minItems === M.maxItems && (V.IsUndefined(M.items) && V.IsUndefined(M.additionalItems) && M.minItems === 0 || V.IsArray(M.items) && M.items.every((l) => X0(l)));
    }
    $.TTuple = M0;
    function B1(M) {
      return _(M, "Undefined") && M.type === "undefined" && z(M.$id);
    }
    $.TUndefined = B1;
    function K(M) {
      return E(M) && M.anyOf.every((l) => o(l) || r(l));
    }
    $.TUnionLiteral = K;
    function E(M) {
      return _(M, "Union") && z(M.$id) && V.IsObject(M) && V.IsArray(M.anyOf) && M.anyOf.every((l) => X0(l));
    }
    $.TUnion = E;
    function L(M) {
      return _(M, "Uint8Array") && M.type === "Uint8Array" && z(M.$id) && Q(M.minByteLength) && Q(M.maxByteLength);
    }
    $.TUint8Array = L;
    function p(M) {
      return _(M, "Unknown") && z(M.$id);
    }
    $.TUnknown = p;
    function T(M) {
      return _(M, "Unsafe");
    }
    $.TUnsafe = T;
    function d(M) {
      return _(M, "Void") && M.type === "void" && z(M.$id);
    }
    $.TVoid = d;
    function W0(M) {
      return V.IsObject(M) && M[m6.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function j0(M) {
      return V.IsObject(M) && M[m6.Optional] === "Optional";
    }
    $.TOptional = j0;
    function X0(M) {
      return V.IsObject(M) && (j(M) || b(M) || O(M) || N(M) || S(M) || P(M) || F(M) || w(M) || I(M) || G(M) || k(M) || b0(M) || E0(M) || H0(M) || z0(M) || u0(M) || a0(M) || v0(M) || R(M) || i(M) || n(M) || q0(M) || B0(M) || D0(M) || M0(M) || B1(M) || E(M) || L(M) || p(M) || T(M) || d(M) || e(M) && $8.Has(M[m6.Kind]));
    }
    $.TSchema = X0;
  })(A || (m6.TypeGuard = A = {}));
  var p6;
  (function($) {
    function Y(W) {
      return W[m6.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[m6.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[m6.Kind] === "Undefined" ? true : W[m6.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(p6 || (m6.ExtendsUndefined = p6 = {}));

  class Z8 extends $1 {
  }
  m6.TypeExtendsError = Z8;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (m6.TypeExtendsResult = C = {}));
  var j1;
  (function($) {
    function Y(H) {
      return H === C.False ? H : C.True;
    }
    function W(H) {
      throw new Z8(H);
    }
    function X(H) {
      return A.TNever(H) || A.TIntersect(H) || A.TUnion(H) || A.TUnknown(H) || A.TAny(H);
    }
    function Z(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : W("StructuralRight");
    }
    function Q(H, q) {
      return C.True;
    }
    function J(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) && q.anyOf.some(($0) => A.TAny($0) || A.TUnknown($0)) ? C.True : A.TUnion(q) ? C.Union : A.TUnknown(q) ? C.True : A.TAny(q) ? C.True : C.Union;
    }
    function z(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) ? C.True : C.False;
    }
    function U(H, q) {
      return A.TObject(q) && B0(q) ? C.True : X(q) ? Z(H, q) : !A.TArray(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function D(H, q) {
      return X(q) ? Z(H, q) : !A.TAsyncIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function B(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBigInt(q) ? C.True : C.False;
    }
    function j(H, q) {
      return A.TLiteral(H) && V.IsBoolean(H.const) ? C.True : A.TBoolean(H) ? C.True : C.False;
    }
    function b(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBoolean(q) ? C.True : C.False;
    }
    function S(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TConstructor(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function N(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TDate(q) ? C.True : C.False;
    }
    function O(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TFunction(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function P(H, q) {
      return A.TLiteral(H) && V.IsNumber(H.const) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function F(H, q) {
      return A.TInteger(q) || A.TNumber(q) ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : C.False;
    }
    function w(H, q) {
      return q.allOf.every(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function I(H, q) {
      return H.allOf.some(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function G(H, q) {
      return X(q) ? Z(H, q) : !A.TIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function k(H, q) {
      return A.TLiteral(q) && q.const === H.const ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : C.False;
    }
    function _(H, q) {
      return C.False;
    }
    function e(H, q) {
      return C.True;
    }
    function o(H) {
      let [q, $0] = [H, 0];
      while (true) {
        if (!A.TNot(q))
          break;
        q = q.not, $0 += 1;
      }
      return $0 % 2 === 0 ? q : m6.Type.Unknown();
    }
    function r(H, q) {
      return A.TNot(H) ? Q0(o(H), q) : A.TNot(q) ? Q0(H, o(q)) : W("Invalid fallthrough for Not");
    }
    function g0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TNull(q) ? C.True : C.False;
    }
    function b0(H, q) {
      return A.TLiteralNumber(H) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function E0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TInteger(q) || A.TNumber(q) ? C.True : C.False;
    }
    function H0(H, q) {
      return Object.getOwnPropertyNames(H.properties).length === q;
    }
    function z0(H) {
      return B0(H);
    }
    function u0(H) {
      return H0(H, 0) || H0(H, 1) && ("description" in H.properties) && A.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (A.TString(H.properties.description.anyOf[0]) && A.TUndefined(H.properties.description.anyOf[1]) || A.TString(H.properties.description.anyOf[1]) && A.TUndefined(H.properties.description.anyOf[0]));
    }
    function a0(H) {
      return H0(H, 0);
    }
    function v0(H) {
      return H0(H, 0);
    }
    function R(H) {
      return H0(H, 0);
    }
    function f(H) {
      return H0(H, 0);
    }
    function i(H) {
      return B0(H);
    }
    function n(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && ("length" in H.properties) && Y(Q0(H.properties.length, q)) === C.True;
    }
    function q0(H) {
      return H0(H, 0);
    }
    function B0(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && ("length" in H.properties) && Y(Q0(H.properties.length, q)) === C.True;
    }
    function D0(H) {
      const q = m6.Type.Function([m6.Type.Any()], m6.Type.Any());
      return H0(H, 0) || H0(H, 1) && ("then" in H.properties) && Y(Q0(H.properties.then, q)) === C.True;
    }
    function w0(H, q) {
      return Q0(H, q) === C.False ? C.False : A.TOptional(H) && !A.TOptional(q) ? C.False : C.True;
    }
    function M0(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) || A.TLiteralString(H) && z0(q) || A.TLiteralNumber(H) && a0(q) || A.TLiteralBoolean(H) && v0(q) || A.TSymbol(H) && u0(q) || A.TBigInt(H) && R(q) || A.TString(H) && z0(q) || A.TSymbol(H) && u0(q) || A.TNumber(H) && a0(q) || A.TInteger(H) && a0(q) || A.TBoolean(H) && v0(q) || A.TUint8Array(H) && i(q) || A.TDate(H) && f(q) || A.TConstructor(H) && q0(q) || A.TFunction(H) && n(q) ? C.True : A.TRecord(H) && A.TString(E(H)) ? (() => {
        return q[m6.Hint] === "Record" ? C.True : C.False;
      })() : A.TRecord(H) && A.TNumber(E(H)) ? (() => {
        return H0(q, 0) ? C.True : C.False;
      })() : C.False;
    }
    function B1(H, q) {
      return X(q) ? Z(H, q) : A.TRecord(q) ? p(H, q) : !A.TObject(q) ? C.False : (() => {
        for (let $0 of Object.getOwnPropertyNames(q.properties)) {
          if (!($0 in H.properties))
            return C.False;
          if (w0(H.properties[$0], q.properties[$0]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function K(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && D0(q) ? C.True : !A.TPromise(q) ? C.False : Y(Q0(H.item, q.item));
    }
    function E(H) {
      return m6.PatternNumberExact in H.patternProperties ? m6.Type.Number() : (m6.PatternStringExact in H.patternProperties) ? m6.Type.String() : W("Unknown record key pattern");
    }
    function L(H) {
      return m6.PatternNumberExact in H.patternProperties ? H.patternProperties[m6.PatternNumberExact] : (m6.PatternStringExact in H.patternProperties) ? H.patternProperties[m6.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(H, q) {
      const [$0, h0] = [E(q), L(q)];
      return A.TLiteralString(H) && A.TNumber($0) && Y(Q0(H, h0)) === C.True ? C.True : A.TUint8Array(H) && A.TNumber($0) ? Q0(H, h0) : A.TString(H) && A.TNumber($0) ? Q0(H, h0) : A.TArray(H) && A.TNumber($0) ? Q0(H, h0) : A.TObject(H) ? (() => {
        for (let aW of Object.getOwnPropertyNames(H.properties))
          if (w0(h0, H.properties[aW]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function T(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TRecord(q) ? C.False : Q0(L(H), L(q));
    }
    function d(H, q) {
      return A.TLiteral(H) && V.IsString(H.const) ? C.True : A.TString(H) ? C.True : C.False;
    }
    function W0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? C.True : C.False;
    }
    function j0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TSymbol(q) ? C.True : C.False;
    }
    function X0(H, q) {
      return A.TTemplateLiteral(H) ? Q0(J1.Resolve(H), q) : A.TTemplateLiteral(q) ? Q0(H, J1.Resolve(q)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function M(H, q) {
      return A.TArray(q) && H.items !== undefined && H.items.every(($0) => Q0($0, q.items) === C.True);
    }
    function l(H, q) {
      return A.TNever(H) ? C.True : A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : C.False;
    }
    function S0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && B0(q) ? C.True : A.TArray(q) && M(H, q) ? C.True : !A.TTuple(q) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) || !V.IsUndefined(H.items) && V.IsUndefined(q.items) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) ? C.True : H.items.every(($0, h0) => Q0($0, q.items[h0]) === C.True) ? C.True : C.False;
    }
    function l$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TUint8Array(q) ? C.True : C.False;
    }
    function t$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TVoid(q) ? tW(H, q) : A.TUndefined(q) ? C.True : C.False;
    }
    function s$(H, q) {
      return q.anyOf.some(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function cW(H, q) {
      return H.anyOf.every(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function O6(H, q) {
      return C.True;
    }
    function lW(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TAny(q) ? Q(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : A.TArray(q) ? z(H, q) : A.TTuple(q) ? l(H, q) : A.TObject(q) ? M0(H, q) : A.TUnknown(q) ? C.True : C.False;
    }
    function tW(H, q) {
      return A.TUndefined(H) ? C.True : A.TUndefined(H) ? C.True : C.False;
    }
    function sW(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : A.TObject(q) ? M0(H, q) : A.TVoid(q) ? C.True : C.False;
    }
    function Q0(H, q) {
      return A.TTemplateLiteral(H) || A.TTemplateLiteral(q) ? X0(H, q) : A.TNot(H) || A.TNot(q) ? r(H, q) : A.TAny(H) ? J(H, q) : A.TArray(H) ? U(H, q) : A.TBigInt(H) ? B(H, q) : A.TBoolean(H) ? b(H, q) : A.TAsyncIterator(H) ? D(H, q) : A.TConstructor(H) ? S(H, q) : A.TDate(H) ? N(H, q) : A.TFunction(H) ? O(H, q) : A.TInteger(H) ? F(H, q) : A.TIntersect(H) ? I(H, q) : A.TIterator(H) ? G(H, q) : A.TLiteral(H) ? k(H, q) : A.TNever(H) ? e(H, q) : A.TNull(H) ? g0(H, q) : A.TNumber(H) ? E0(H, q) : A.TObject(H) ? B1(H, q) : A.TRecord(H) ? T(H, q) : A.TString(H) ? W0(H, q) : A.TSymbol(H) ? j0(H, q) : A.TTuple(H) ? S0(H, q) : A.TPromise(H) ? K(H, q) : A.TUint8Array(H) ? l$(H, q) : A.TUndefined(H) ? t$(H, q) : A.TUnion(H) ? cW(H, q) : A.TUnknown(H) ? lW(H, q) : A.TVoid(H) ? sW(H, q) : W(`Unknown left type operand '${H[m6.Kind]}'`);
    }
    function rW(H, q) {
      return Q0(H, q);
    }
    $.Extends = rW;
  })(j1 || (m6.TypeExtends = j1 = {}));
  var m;
  (function($) {
    function Y(J) {
      const z = Object.getOwnPropertyNames(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {}), U = Object.getOwnPropertySymbols(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {});
      return { ...z, ...U };
    }
    function W(J) {
      return J.map((z) => X(z));
    }
    function X(J) {
      return V.IsArray(J) ? W(J) : V.IsObject(J) ? Y(J) : J;
    }
    function Z(J) {
      return J.map((z) => Q(z));
    }
    $.Rest = Z;
    function Q(J, z = {}) {
      return { ...X(J), ...z };
    }
    $.Type = Q;
  })(m || (m6.TypeClone = m = {}));
  var Y8;
  (function($) {
    function Y(S) {
      return S.map((N) => {
        const { [m6.Optional]: O, ...P } = m.Type(N);
        return P;
      });
    }
    function W(S) {
      return S.every((N) => A.TOptional(N));
    }
    function X(S) {
      return S.some((N) => A.TOptional(N));
    }
    function Z(S) {
      return W(S.allOf) ? m6.Type.Optional(m6.Type.Intersect(Y(S.allOf))) : S;
    }
    function Q(S) {
      return X(S.anyOf) ? m6.Type.Optional(m6.Type.Union(Y(S.anyOf))) : S;
    }
    function J(S) {
      return S[m6.Kind] === "Intersect" ? Z(S) : S[m6.Kind] === "Union" ? Q(S) : S;
    }
    function z(S, N) {
      const O = S.allOf.reduce((P, F) => {
        const w = j(F, N);
        return w[m6.Kind] === "Never" ? P : [...P, w];
      }, []);
      return J(m6.Type.Intersect(O));
    }
    function U(S, N) {
      const O = S.anyOf.map((P) => j(P, N));
      return J(m6.Type.Union(O));
    }
    function D(S, N) {
      const O = S.properties[N];
      return V.IsUndefined(O) ? m6.Type.Never() : m6.Type.Union([O]);
    }
    function B(S, N) {
      const O = S.items;
      if (V.IsUndefined(O))
        return m6.Type.Never();
      const P = O[N];
      if (V.IsUndefined(P))
        return m6.Type.Never();
      return P;
    }
    function j(S, N) {
      return S[m6.Kind] === "Intersect" ? z(S, N) : S[m6.Kind] === "Union" ? U(S, N) : S[m6.Kind] === "Object" ? D(S, N) : S[m6.Kind] === "Tuple" ? B(S, N) : m6.Type.Never();
    }
    function b(S, N, O = {}) {
      const P = N.map((F) => j(S, F.toString()));
      return J(m6.Type.Union(P, O));
    }
    $.Resolve = b;
  })(Y8 || (m6.IndexedAccessor = Y8 = {}));
  var V1;
  (function($) {
    function Y(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toLowerCase()}${b}`;
    }
    function W(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toUpperCase()}${b}`;
    }
    function X(B) {
      return B.toUpperCase();
    }
    function Z(B) {
      return B.toLowerCase();
    }
    function Q(B, j) {
      const b = f1.ParseExact(B.pattern);
      if (!T1.Check(b))
        return { ...B, pattern: J(B.pattern, j) };
      const O = [...d1.Generate(b)].map((w) => m6.Type.Literal(w)), P = z(O, j), F = m6.Type.Union(P);
      return m6.Type.TemplateLiteral([F]);
    }
    function J(B, j) {
      return typeof B === "string" ? j === "Uncapitalize" ? Y(B) : j === "Capitalize" ? W(B) : j === "Uppercase" ? X(B) : j === "Lowercase" ? Z(B) : B : B.toString();
    }
    function z(B, j) {
      if (B.length === 0)
        return [];
      const [b, ...S] = B;
      return [D(b, j), ...z(S, j)];
    }
    function U(B, j) {
      return A.TTemplateLiteral(B) ? Q(B, j) : A.TUnion(B) ? m6.Type.Union(z(B.anyOf, j)) : A.TLiteral(B) ? m6.Type.Literal(J(B.const, j)) : B;
    }
    function D(B, j) {
      return U(B, j);
    }
    $.Map = D;
  })(V1 || (m6.Intrinsic = V1 = {}));
  var x1;
  (function($) {
    function Y(J, z) {
      return m6.Type.Intersect(J.allOf.map((U) => Z(U, z)), { ...J });
    }
    function W(J, z) {
      return m6.Type.Union(J.anyOf.map((U) => Z(U, z)), { ...J });
    }
    function X(J, z) {
      return z(J);
    }
    function Z(J, z) {
      return J[m6.Kind] === "Intersect" ? Y(J, z) : J[m6.Kind] === "Union" ? W(J, z) : J[m6.Kind] === "Object" ? X(J, z) : J;
    }
    function Q(J, z, U) {
      return { ...Z(m.Type(J), z), ...U };
    }
    $.Map = Q;
  })(x1 || (m6.ObjectMap = x1 = {}));
  var P$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function W(D, B) {
      return D.allOf.reduce((j, b) => [...j, ...J(b, B)], []);
    }
    function X(D, B) {
      const j = D.anyOf.map((b) => J(b, B));
      return [...j.reduce((b, S) => S.map((N) => j.every((O) => O.includes(N)) ? b.add(N) : b)[0], new Set)];
    }
    function Z(D, B) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function Q(D, B) {
      return B.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function J(D, B) {
      return A.TIntersect(D) ? W(D, B) : A.TUnion(D) ? X(D, B) : A.TObject(D) ? Z(D, B) : A.TRecord(D) ? Q(D, B) : [];
    }
    function z(D, B) {
      return [...new Set(J(D, B))];
    }
    $.ResolveKeys = z;
    function U(D) {
      return `^(${z(D, { includePatterns: true }).map((b) => `(${Y(b)})`).join("|")})$`;
    }
    $.ResolvePattern = U;
  })(P$ || (m6.KeyResolver = P$ = {}));

  class Q8 extends $1 {
  }
  m6.KeyArrayResolverError = Q8;
  var r1;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : A.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : A.TLiteral(W) ? [W.const] : A.TTemplateLiteral(W) ? (() => {
        const X = f1.ParseExact(W.pattern);
        if (!T1.Check(X))
          throw new Q8("Cannot resolve keys from infinite template expression");
        return [...d1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(r1 || (m6.KeyArrayResolver = r1 = {}));
  var W8;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m6.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return m6.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(W8 || (m6.UnionResolver = W8 = {}));

  class J8 extends $1 {
  }
  m6.TemplateLiteralPatternError = J8;
  var O$;
  (function($) {
    function Y(Q) {
      throw new J8(Q);
    }
    function W(Q) {
      return Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(Q, J) {
      return A.TTemplateLiteral(Q) ? Q.pattern.slice(1, Q.pattern.length - 1) : A.TUnion(Q) ? `(${Q.anyOf.map((z) => X(z, J)).join("|")})` : A.TNumber(Q) ? `${J}${m6.PatternNumber}` : A.TInteger(Q) ? `${J}${m6.PatternNumber}` : A.TBigInt(Q) ? `${J}${m6.PatternNumber}` : A.TString(Q) ? `${J}${m6.PatternString}` : A.TLiteral(Q) ? `${J}${W(Q.const.toString())}` : A.TBoolean(Q) ? `${J}${m6.PatternBoolean}` : Y(`Unexpected Kind '${Q[m6.Kind]}'`);
    }
    function Z(Q) {
      return `^${Q.map((J) => X(J, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m6.TemplateLiteralPattern = O$ = {}));
  var J1;
  (function($) {
    function Y(W) {
      const X = f1.ParseExact(W.pattern);
      if (!T1.Check(X))
        return m6.Type.String();
      const Z = [...d1.Generate(X)].map((Q) => m6.Type.Literal(Q));
      return m6.Type.Union(Z);
    }
    $.Resolve = Y;
  })(J1 || (m6.TemplateLiteralResolver = J1 = {}));

  class S$ extends $1 {
  }
  m6.TemplateLiteralParserError = S$;
  var f1;
  (function($) {
    function Y(S, N, O) {
      return S[N] === O && S.charCodeAt(N - 1) !== 92;
    }
    function W(S, N) {
      return Y(S, N, "(");
    }
    function X(S, N) {
      return Y(S, N, ")");
    }
    function Z(S, N) {
      return Y(S, N, "|");
    }
    function Q(S) {
      if (!(W(S, 0) && X(S, S.length - 1)))
        return false;
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (N === 0 && O !== S.length - 1)
          return false;
      }
      return true;
    }
    function J(S) {
      return S.slice(1, S.length - 1);
    }
    function z(S) {
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (Z(S, O) && N === 0)
          return true;
      }
      return false;
    }
    function U(S) {
      for (let N = 0;N < S.length; N++)
        if (W(S, N))
          return true;
      return false;
    }
    function D(S) {
      let [N, O] = [0, 0];
      const P = [];
      for (let w = 0;w < S.length; w++) {
        if (W(S, w))
          N += 1;
        if (X(S, w))
          N -= 1;
        if (Z(S, w) && N === 0) {
          const I = S.slice(O, w);
          if (I.length > 0)
            P.push(j(I));
          O = w + 1;
        }
      }
      const F = S.slice(O);
      if (F.length > 0)
        P.push(j(F));
      if (P.length === 0)
        return { type: "const", const: "" };
      if (P.length === 1)
        return P[0];
      return { type: "or", expr: P };
    }
    function B(S) {
      function N(F, w) {
        if (!W(F, w))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let I = 0;
        for (let G = w;G < F.length; G++) {
          if (W(F, G))
            I += 1;
          if (X(F, G))
            I -= 1;
          if (I === 0)
            return [w, G];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function O(F, w) {
        for (let I = w;I < F.length; I++)
          if (W(F, I))
            return [w, I];
        return [w, F.length];
      }
      const P = [];
      for (let F = 0;F < S.length; F++)
        if (W(S, F)) {
          const [w, I] = N(S, F), G = S.slice(w, I + 1);
          P.push(j(G)), F = I;
        } else {
          const [w, I] = O(S, F), G = S.slice(w, I);
          if (G.length > 0)
            P.push(j(G));
          F = I - 1;
        }
      return P.length === 0 ? { type: "const", const: "" } : P.length === 1 ? P[0] : { type: "and", expr: P };
    }
    function j(S) {
      return Q(S) ? j(J(S)) : z(S) ? D(S) : U(S) ? B(S) : { type: "const", const: S };
    }
    $.Parse = j;
    function b(S) {
      return j(S.slice(1, S.length - 1));
    }
    $.ParseExact = b;
  })(f1 || (m6.TemplateLiteralParser = f1 = {}));

  class z8 extends $1 {
  }
  m6.TemplateLiteralFiniteError = z8;
  var T1;
  (function($) {
    function Y(J) {
      throw new z8(J);
    }
    function W(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "0" && J.expr[1].type === "const" && J.expr[1].const === "[1-9][0-9]*";
    }
    function X(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "true" && J.expr[1].type === "const" && J.expr[1].const === "false";
    }
    function Z(J) {
      return J.type === "const" && J.const === ".*";
    }
    function Q(J) {
      return X(J) ? true : W(J) || Z(J) ? false : J.type === "and" ? J.expr.every((z) => Q(z)) : J.type === "or" ? J.expr.every((z) => Q(z)) : J.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = Q;
  })(T1 || (m6.TemplateLiteralFinite = T1 = {}));

  class H8 extends $1 {
  }
  m6.TemplateLiteralGeneratorError = H8;
  var d1;
  (function($) {
    function* Y(J) {
      if (J.length === 1)
        return yield* J[0];
      for (let z of J[0])
        for (let U of Y(J.slice(1)))
          yield `${z}${U}`;
    }
    function* W(J) {
      return yield* Y(J.expr.map((z) => [...Q(z)]));
    }
    function* X(J) {
      for (let z of J.expr)
        yield* Q(z);
    }
    function* Z(J) {
      return yield J.const;
    }
    function* Q(J) {
      return J.type === "and" ? yield* W(J) : J.type === "or" ? yield* X(J) : J.type === "const" ? yield* Z(J) : (() => {
        throw new H8("Unknown expression");
      })();
    }
    $.Generate = Q;
  })(d1 || (m6.TemplateLiteralGenerator = d1 = {}));
  var X8;
  (function($) {
    function* Y(Q) {
      const J = Q.trim().replace(/"|'/g, "");
      return J === "boolean" ? yield m6.Type.Boolean() : J === "number" ? yield m6.Type.Number() : J === "bigint" ? yield m6.Type.BigInt() : J === "string" ? yield m6.Type.String() : yield (() => {
        const z = J.split("|").map((U) => m6.Type.Literal(U.trim()));
        return z.length === 0 ? m6.Type.Never() : z.length === 1 ? z[0] : m6.Type.Union(z);
      })();
    }
    function* W(Q) {
      if (Q[1] !== "{") {
        const J = m6.Type.Literal("$"), z = X(Q.slice(1));
        return yield* [J, ...z];
      }
      for (let J = 2;J < Q.length; J++)
        if (Q[J] === "}") {
          const z = Y(Q.slice(2, J)), U = X(Q.slice(J + 1));
          return yield* [...z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function* X(Q) {
      for (let J = 0;J < Q.length; J++)
        if (Q[J] === "$") {
          const z = m6.Type.Literal(Q.slice(0, J)), U = W(Q.slice(J));
          return yield* [z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(X8 || (m6.TemplateLiteralDslParser = X8 = {}));

  class q8 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new M8(this.schema, $);
    }
  }
  m6.TransformDecodeBuilder = q8;

  class M8 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = m.Type(this.schema);
      return A.TTransform(Y) ? (() => {
        const Z = { Encode: (Q) => Y[m6.Transform].Encode($(Q)), Decode: (Q) => this.decode(Y[m6.Transform].Decode(Q)) };
        return { ...Y, [m6.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [m6.Transform]: W };
      })();
    }
  }
  m6.TransformEncodeBuilder = M8;
  var TX = 0;

  class N8 extends $1 {
  }
  m6.TypeBuilderError = N8;

  class F8 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new N8($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...Q } = W;
        return Q;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m6.TypeBuilder = F8;

  class L$ extends F8 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...m.Type($), [m6.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...m.Type($), [m6.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Array", type: "array", items: m.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = m6.Type.Intersect($, {}), Z = P$.ResolveKeys(W, { includePatterns: false }).reduce((Q, J) => ({ ...Q, [J]: m6.Type.Index(W, [J]) }), {});
      return m6.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const W = Object.getOwnPropertyNames($).filter((Q) => isNaN(Q)).map((Q) => $[Q]), Z = [...new Set(W)].map((Q) => m6.Type.Literal(Q));
      return this.Union(Z, { ...Y, [m6.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (j1.Extends($, Y)) {
        case C.Union:
          return this.Union([m.Type(W, Z), m.Type(X, Z)]);
        case C.True:
          return m.Type(W, Z);
        case C.False:
          return m.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Exclude(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Exclude($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) === C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? this.Never(W) : m.Type($, W);
    }
    Extract($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Extract(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Extract($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) !== C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? m.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return A.TArray($) && A.TNumber(Y) ? (() => {
        return m.Type($.items, W);
      })() : A.TTuple($) && A.TNumber(Y) ? (() => {
        const Z = (V.IsUndefined($.items) ? [] : $.items).map((Q) => m.Type(Q));
        return this.Union(Z, W);
      })() : (() => {
        const X = r1.Resolve(Y), Z = m.Type($);
        return Y8.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m6.Type.Never();
      if ($.length === 1)
        return m.Type($[0], Y);
      if ($.some((Q) => A.TTransform(Q)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((Q) => A.TObject(Q)), X = m.Rest($), Z = A.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: m.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || A.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return A.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === m6.PatternNumberExact ? this.Number(Y) : W === m6.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : A.TTuple($) ? (() => {
        const X = (V.IsUndefined($.items) ? [] : $.items).map((Z, Q) => m6.Type.Literal(Q.toString()));
        return this.Union(X, Y);
      })() : A.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = P$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m6.Kind]: "Not", not: m.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((z) => A.TOptional($[z])), Z = W.filter((z) => !X.includes(z)), Q = A.TSchema(Y.additionalProperties) ? { additionalProperties: m.Type(Y.additionalProperties) } : {}, J = W.reduce((z, U) => ({ ...z, [U]: m.Type($[U]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J, required: Z }) : this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J });
    }
    Omit($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(W.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return A.TTemplateLiteral($) ? (() => {
        const X = f1.ParseExact($.pattern);
        return T1.Check(X) ? this.Object([...d1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: m.Type(Y) }), {}), W) : this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: m.Type(Y) } });
      })() : A.TUnion($) ? (() => {
        const X = W8.Resolve($);
        if (A.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, J) => ({ ...Q, [J.const]: m.Type(Y) }), {});
          return this.Object(Z, { ...W, [m6.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : A.TLiteral($) ? (() => {
        return V.IsString($.const) || V.IsNumber($.const) ? this.Object({ [$.const]: m.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : A.TInteger($) || A.TNumber($) ? (() => {
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [m6.PatternNumberExact]: m.Type(Y) } });
      })() : A.TString($) ? (() => {
        const X = V.IsUndefined($.pattern) ? m6.PatternStringExact : $.pattern;
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [X]: m.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (V.IsUndefined(Y.$id))
        Y.$id = `T${TX++}`;
      const W = $({ [m6.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [m6.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (V.IsString($))
        return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $ });
      if (V.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(W.properties[Q], [m6.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return A.TTuple($) && !V.IsUndefined($.items) ? m.Rest($.items) : A.TIntersect($) ? m.Rest($.allOf) : A.TUnion($) ? m.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = V.IsString($) ? O$.Create(X8.Parse($)) : O$.Create($);
      return this.Create({ ...Y, [m6.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new q8($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], Q = m.Rest($), J = $.length > 0 ? { ...Y, [m6.Kind]: "Tuple", type: "array", items: Q, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [m6.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(J);
    }
    Uncapitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return A.TTemplateLiteral($) ? J1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(m.Type(W[0], Y));
        const X = m.Rest(W);
        return this.Create({ ...Y, [m6.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m6.Kind]: $[m6.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uppercase"), ...Y };
    }
  }
  m6.JsonTypeBuilder = L$;

  class U8 extends L$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "AsyncIterator", type: "AsyncIterator", items: m.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...W(Q)];
      })() : X;
      return A.TIntersect($) ? m6.Type.Intersect(W($.allOf)) : A.TUnion($) ? m6.Type.Union(W($.anyOf)) : A.TPromise($) ? this.Awaited($.item) : m.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Iterator", type: "Iterator", items: m.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Promise", type: "Promise", item: m.Type($) });
    }
    RegExp($, Y = {}) {
      const W = V.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m6.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m6.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Void", type: "void" });
    }
  }
  m6.JavaScriptTypeBuilder = U8;
  m6.JsonType = new L$;
  m6.Type = new U8;
});
var P8 = J0((n6) => {
  var w8 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[z1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(n6, "__esModule", { value: true });
  n6.DefaultErrorFunction = n6.TypeSystemPolicy = n6.TypeSystemErrorFunction = n6.TypeSystem = n6.TypeSystemDuplicateFormat = n6.TypeSystemDuplicateTypeKind = undefined;
  var C$ = x0(), y = $$(), z1 = f0();

  class K8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateTypeKind = K8;

  class j8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateFormat = j8;
  var u6;
  (function($) {
    function Y(X, Z) {
      if (z1.TypeRegistry.Has(X))
        throw new K8(X);
      return z1.TypeRegistry.Set(X, Z), (Q = {}) => z1.Type.Unsafe({ ...Q, [z1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (z1.FormatRegistry.Has(X))
        throw new j8(X);
      return z1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })(u6 || (n6.TypeSystem = u6 = {}));
  var h6;
  (function($) {
    let Y = w8;
    function W() {
      Y = w8;
    }
    $.Reset = W;
    function X(Q) {
      Y = Q;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(h6 || (n6.TypeSystemErrorFunction = h6 = {}));
  var o6;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(J, z) {
      return $.ExactOptionalPropertyTypes ? z in J : J[z] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      const z = (0, C$.IsObject)(J);
      return $.AllowArrayObject ? z : z && !(0, C$.IsArray)(J);
    }
    $.IsObjectLike = W;
    function X(J) {
      return W(J) && !(J instanceof Date) && !(J instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(J) {
      const z = (0, C$.IsNumber)(J);
      return $.AllowNaN ? z : z && Number.isFinite(J);
    }
    $.IsNumberLike = Z;
    function Q(J) {
      const z = (0, C$.IsUndefined)(J);
      return $.AllowNullVoid ? z || J === null : z;
    }
    $.IsVoidLike = Q;
  })(o6 || (n6.TypeSystemPolicy = o6 = {}));
  n6.DefaultErrorFunction = w8;
});
var D1 = J0((l6) => {
  var IZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new O8($);
    return Y[W];
  };
  Object.defineProperty(l6, "__esModule", { value: true });
  l6.Deref = l6.TypeDereferenceError = undefined;
  var CZ = f0();

  class O8 extends CZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l6.TypeDereferenceError = O8;
  l6.Deref = IZ;
});
var Y$ = J0((e6) => {
  function* EZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var VZ = function($) {
    R0(T0.Array);
    for (let Y of $)
      v1(Y);
  }, xZ = function($) {
    R0(T0.Boolean), R0($ ? 1 : 0);
  }, kZ = function($) {
    R0(T0.BigInt), r6.setBigInt64(0, $);
    for (let Y of a6)
      R0(Y);
  }, gZ = function($) {
    R0(T0.Date), v1($.getTime());
  }, fZ = function($) {
    R0(T0.Null);
  }, TZ = function($) {
    R0(T0.Number), r6.setFloat64(0, $);
    for (let Y of a6)
      R0(Y);
  }, dZ = function($) {
    R0(T0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      v1(Y), v1($[Y]);
  }, yZ = function($) {
    R0(T0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of EZ($.charCodeAt(Y)))
        R0(W);
  }, vZ = function($) {
    R0(T0.Symbol), v1($.description);
  }, pZ = function($) {
    R0(T0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      R0($[Y]);
  }, iZ = function($) {
    return R0(T0.Undefined);
  }, v1 = function($) {
    if ((0, o0.IsArray)($))
      return VZ($);
    if ((0, o0.IsBoolean)($))
      return xZ($);
    if ((0, o0.IsBigInt)($))
      return kZ($);
    if ((0, o0.IsDate)($))
      return gZ($);
    if ((0, o0.IsNull)($))
      return fZ($);
    if ((0, o0.IsNumber)($))
      return TZ($);
    if ((0, o0.IsPlainObject)($))
      return dZ($);
    if ((0, o0.IsString)($))
      return yZ($);
    if ((0, o0.IsSymbol)($))
      return vZ($);
    if ((0, o0.IsUint8Array)($))
      return pZ($);
    if ((0, o0.IsUndefined)($))
      return iZ($);
    throw new S8($);
  }, R0 = function($) {
    y1 = y1 ^ _Z[$], y1 = y1 * GZ % RZ;
  }, mZ = function($) {
    return y1 = BigInt("14695981039346656037"), v1($), y1;
  };
  Object.defineProperty(e6, "__esModule", { value: true });
  e6.Hash = e6.ByteMarker = e6.ValueHashError = undefined;
  var o0 = x0();

  class S8 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e6.ValueHashError = S8;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e6.ByteMarker = T0 = {}));
  var y1 = BigInt("14695981039346656037"), [GZ, RZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], _Z = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), s6 = new Float64Array(1), r6 = new DataView(s6.buffer), a6 = new Uint8Array(s6.buffer);
  e6.Hash = mZ;
});
var $$ = J0((WY) => {
  var t = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: p1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* nZ($, Y, W, X) {
  }
  function* cZ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Array, $, W, X);
    if (t($.minItems) && !(X.length >= $.minItems))
      yield g(x.ArrayMinItems, $, W, X);
    if (t($.maxItems) && !(X.length <= $.maxItems))
      yield g(x.ArrayMaxItems, $, W, X);
    for (let J = 0;J < X.length; J++)
      yield* L0($.items, Y, `${W}/${J}`, X[J]);
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let z of X) {
        const U = (0, oZ.Hash)(z);
        if (J.has(U))
          return false;
        else
          J.add(U);
      }
      return true;
    }())
      yield g(x.ArrayUniqueItems, $, W, X);
    if (!(t($.contains) || t($.minContains) || t($.maxContains)))
      return;
    const Z = t($.contains) ? $.contains : p0.Type.Never(), Q = X.reduce((J, z, U) => L0(Z, Y, `${W}${U}`, z).next().done === true ? J + 1 : J, 0);
    if (Q === 0)
      yield g(x.ArrayContains, $, W, X);
    if ((0, U0.IsNumber)($.minContains) && Q < $.minContains)
      yield g(x.ArrayMinContains, $, W, X);
    if ((0, U0.IsNumber)($.maxContains) && Q > $.maxContains)
      yield g(x.ArrayMaxContains, $, W, X);
  }
  function* lZ($, Y, W, X) {
    if (!(0, U0.IsAsyncIterator)(X))
      yield g(x.AsyncIterator, $, W, X);
  }
  function* tZ($, Y, W, X) {
    if (!(0, U0.IsBigInt)(X))
      return yield g(x.BigInt, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.BigIntExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.BigIntExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.BigIntMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.BigIntMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(x.BigIntMultipleOf, $, W, X);
  }
  function* sZ($, Y, W, X) {
    if (!(0, U0.IsBoolean)(X))
      yield g(x.Boolean, $, W, X);
  }
  function* rZ($, Y, W, X) {
    yield* L0($.returns, Y, W, X.prototype);
  }
  function* aZ($, Y, W, X) {
    if (!(0, U0.IsDate)(X))
      return yield g(x.Date, $, W, X);
    if (t($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(x.DateExclusiveMaximumTimestamp, $, W, X);
    if (t($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(x.DateExclusiveMinimumTimestamp, $, W, X);
    if (t($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(x.DateMaximumTimestamp, $, W, X);
    if (t($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(x.DateMinimumTimestamp, $, W, X);
    if (t($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(x.DateMultipleOfTimestamp, $, W, X);
  }
  function* eZ($, Y, W, X) {
    if (!(0, U0.IsFunction)(X))
      yield g(x.Function, $, W, X);
  }
  function* $Q($, Y, W, X) {
    if (!(0, U0.IsInteger)(X))
      return yield g(x.Integer, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.IntegerExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.IntegerExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.IntegerMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.IntegerMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.IntegerMultipleOf, $, W, X);
  }
  function* YQ($, Y, W, X) {
    for (let Z of $.allOf) {
      const Q = L0(Z, Y, W, X).next();
      if (!Q.done)
        yield g(x.Intersect, $, W, X), yield Q.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield g(x.IntersectUnevaluatedProperties, $, `${W}/${Q}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const J = L0($.unevaluatedProperties, Y, `${W}/${Q}`, X[Q]).next();
          if (!J.done)
            yield J.value;
        }
    }
  }
  function* WQ($, Y, W, X) {
    if (!(0, U0.IsIterator)(X))
      yield g(x.Iterator, $, W, X);
  }
  function* XQ($, Y, W, X) {
    if (X !== $.const)
      yield g(x.Literal, $, W, X);
  }
  function* ZQ($, Y, W, X) {
    yield g(x.Never, $, W, X);
  }
  function* QQ($, Y, W, X) {
    if (L0($.not, Y, W, X).next().done === true)
      yield g(x.Not, $, W, X);
  }
  function* JQ($, Y, W, X) {
    if (!(0, U0.IsNull)(X))
      yield g(x.Null, $, W, X);
  }
  function* zQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(x.Number, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.NumberExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.NumberExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.NumberMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.NumberMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.NumberMultipleOf, $, W, X);
  }
  function* HQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), J = Object.getOwnPropertyNames(X);
    for (let z of Z) {
      if (J.includes(z))
        continue;
      yield g(x.ObjectRequiredProperty, $.properties[z], `${W}/${z}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let z of J)
        if (!Q.includes(z))
          yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, X[z]);
    }
    if (typeof $.additionalProperties === "object")
      for (let z of J) {
        if (Q.includes(z))
          continue;
        yield* L0($.additionalProperties, Y, `${W}/${z}`, X[z]);
      }
    for (let z of Q) {
      const U = $.properties[z];
      if ($.required && $.required.includes(z)) {
        if (yield* L0(U, Y, `${W}/${z}`, X[z]), p0.ExtendsUndefined.Check($) && !(z in X))
          yield g(x.ObjectRequiredProperty, U, `${W}/${z}`, undefined);
      } else if (p1.TypeSystemPolicy.IsExactOptionalProperty(X, z))
        yield* L0(U, Y, `${W}/${z}`, X[z]);
    }
  }
  function* qQ($, Y, W, X) {
    if (!(0, U0.IsPromise)(X))
      yield g(x.Promise, $, W, X);
  }
  function* MQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const [Z, Q] = Object.entries($.patternProperties)[0], J = new RegExp(Z);
    for (let [z, U] of Object.entries(X))
      if (J.test(z))
        yield* L0(Q, Y, `${W}/${z}`, U);
    if (typeof $.additionalProperties === "object") {
      for (let [z, U] of Object.entries(X))
        if (!J.test(z))
          yield* L0($.additionalProperties, Y, `${W}/${z}`, U);
    }
    if ($.additionalProperties === false)
      for (let [z, U] of Object.entries(X)) {
        if (J.test(z))
          continue;
        return yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, U);
      }
  }
  function* NQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* FQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (t($.minLength) && !(X.length >= $.minLength))
      yield g(x.StringMinLength, $, W, X);
    if (t($.maxLength) && !(X.length <= $.maxLength))
      yield g(x.StringMaxLength, $, W, X);
    if ((0, U0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(x.StringPattern, $, W, X);
    }
    if ((0, U0.IsString)($.format)) {
      if (!p0.FormatRegistry.Has($.format))
        yield g(x.StringFormatUnknown, $, W, X);
      else if (!p0.FormatRegistry.Get($.format)(X))
        yield g(x.StringFormat, $, W, X);
    }
  }
  function* UQ($, Y, W, X) {
    if (!(0, U0.IsSymbol)(X))
      yield g(x.Symbol, $, W, X);
  }
  function* AQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(x.StringPattern, $, W, X);
  }
  function* BQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* DQ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(x.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(x.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* L0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* wQ($, Y, W, X) {
    if (!(0, U0.IsUndefined)(X))
      yield g(x.Undefined, $, W, X);
  }
  function* KQ($, Y, W, X) {
    let Z = 0;
    for (let Q of $.anyOf) {
      const J = [...L0(Q, Y, W, X)];
      if (J.length === 0)
        return;
      Z += J.length;
    }
    if (Z > 0)
      yield g(x.Union, $, W, X);
  }
  function* jQ($, Y, W, X) {
    if (!(0, U0.IsUint8Array)(X))
      return yield g(x.Uint8Array, $, W, X);
    if (t($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(x.Uint8ArrayMaxByteLength, $, W, X);
    if (t($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(x.Uint8ArrayMinByteLength, $, W, X);
  }
  function* PQ($, Y, W, X) {
  }
  function* OQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsVoidLike(X))
      yield g(x.Void, $, W, X);
  }
  function* SQ($, Y, W, X) {
    if (!p0.TypeRegistry.Get($[p0.Kind])($, X))
      yield g(x.Kind, $, W, X);
  }
  function* L0($, Y, W, X) {
    const Z = t($.$id) ? [...Y, $] : Y, Q = $;
    switch (Q[p0.Kind]) {
      case "Any":
        return yield* nZ(Q, Z, W, X);
      case "Array":
        return yield* cZ(Q, Z, W, X);
      case "AsyncIterator":
        return yield* lZ(Q, Z, W, X);
      case "BigInt":
        return yield* tZ(Q, Z, W, X);
      case "Boolean":
        return yield* sZ(Q, Z, W, X);
      case "Constructor":
        return yield* rZ(Q, Z, W, X);
      case "Date":
        return yield* aZ(Q, Z, W, X);
      case "Function":
        return yield* eZ(Q, Z, W, X);
      case "Integer":
        return yield* $Q(Q, Z, W, X);
      case "Intersect":
        return yield* YQ(Q, Z, W, X);
      case "Iterator":
        return yield* WQ(Q, Z, W, X);
      case "Literal":
        return yield* XQ(Q, Z, W, X);
      case "Never":
        return yield* ZQ(Q, Z, W, X);
      case "Not":
        return yield* QQ(Q, Z, W, X);
      case "Null":
        return yield* JQ(Q, Z, W, X);
      case "Number":
        return yield* zQ(Q, Z, W, X);
      case "Object":
        return yield* HQ(Q, Z, W, X);
      case "Promise":
        return yield* qQ(Q, Z, W, X);
      case "Record":
        return yield* MQ(Q, Z, W, X);
      case "Ref":
        return yield* NQ(Q, Z, W, X);
      case "String":
        return yield* FQ(Q, Z, W, X);
      case "Symbol":
        return yield* UQ(Q, Z, W, X);
      case "TemplateLiteral":
        return yield* AQ(Q, Z, W, X);
      case "This":
        return yield* BQ(Q, Z, W, X);
      case "Tuple":
        return yield* DQ(Q, Z, W, X);
      case "Undefined":
        return yield* wQ(Q, Z, W, X);
      case "Union":
        return yield* KQ(Q, Z, W, X);
      case "Uint8Array":
        return yield* jQ(Q, Z, W, X);
      case "Unknown":
        return yield* PQ(Q, Z, W, X);
      case "Void":
        return yield* OQ(Q, Z, W, X);
      default:
        if (!p0.TypeRegistry.Has(Q[p0.Kind]))
          throw new L8($);
        return yield* SQ(Q, Z, W, X);
    }
  }
  var LQ = function(...$) {
    const Y = $.length === 3 ? L0($[0], $[1], "", $[2]) : L0($[0], [], "", $[1]);
    return new C8(Y);
  };
  Object.defineProperty(WY, "__esModule", { value: true });
  WY.Errors = WY.ValueErrorIterator = WY.ValueErrorsUnknownTypeError = WY.ValueErrorType = undefined;
  var U0 = x0(), p1 = P8(), YY = D1(), oZ = Y$(), p0 = f0(), x;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(x || (WY.ValueErrorType = x = {}));

  class L8 extends p0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  WY.ValueErrorsUnknownTypeError = L8;

  class C8 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  WY.ValueErrorIterator = C8;
  WY.Errors = LQ;
});
var I$ = J0((O1) => {
  var GQ = O1 && O1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), RQ = O1 && O1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        GQ(Y, $, W);
  };
  Object.defineProperty(O1, "__esModule", { value: true });
  RQ($$(), O1);
});
var b$ = J0((QY) => {
  Object.defineProperty(QY, "__esModule", { value: true });
  QY.ValuePointer = QY.ValuePointerRootDeleteError = QY.ValuePointerRootSetError = undefined;

  class I8 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  QY.ValuePointerRootSetError = I8;

  class b8 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  QY.ValuePointerRootDeleteError = b8;
  var ZY;
  (function($) {
    function Y(z) {
      return z.indexOf("~") === -1 ? z : z.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(z) {
      if (z === "")
        return;
      let [U, D] = [0, 0];
      for (let B = 0;B < z.length; B++)
        if (z.charAt(B) === "/")
          if (B === 0)
            U = B + 1;
          else
            D = B, yield Y(z.slice(U, D)), U = B + 1;
        else
          D = B;
      yield Y(z.slice(U));
    }
    $.Format = W;
    function X(z, U, D) {
      if (U === "")
        throw new I8(z, U, D);
      let [B, j, b] = [null, z, ""];
      for (let S of W(U)) {
        if (j[S] === undefined)
          j[S] = {};
        B = j, j = j[S], b = S;
      }
      B[b] = D;
    }
    $.Set = X;
    function Z(z, U) {
      if (U === "")
        throw new b8(z, U);
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined || B[b] === null)
          return;
        D = B, B = B[b], j = b;
      }
      if (Array.isArray(D)) {
        const b = parseInt(j);
        D.splice(b, 1);
      } else
        delete D[j];
    }
    $.Delete = Z;
    function Q(z, U) {
      if (U === "")
        return true;
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined)
          return false;
        D = B, B = B[b], j = b;
      }
      return Object.getOwnPropertyNames(D).includes(j);
    }
    $.Has = Q;
    function J(z, U) {
      if (U === "")
        return z;
      let D = z;
      for (let B of W(U)) {
        if (D[B] === undefined)
          return;
        D = D[B];
      }
      return D;
    }
    $.Get = J;
  })(ZY || (QY.ValuePointer = ZY = {}));
});
var i1 = J0((zY) => {
  var VQ = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: G8($[X]) }), {});
  }, xQ = function($) {
    return $.map((Y) => G8(Y));
  }, kQ = function($) {
    return $.slice();
  }, gQ = function($) {
    return new Date($.toISOString());
  }, fQ = function($) {
    return $;
  }, G8 = function($) {
    if ((0, W$.IsArray)($))
      return xQ($);
    if ((0, W$.IsDate)($))
      return gQ($);
    if ((0, W$.IsPlainObject)($))
      return VQ($);
    if ((0, W$.IsTypedArray)($))
      return kQ($);
    if ((0, W$.IsValueType)($))
      return fQ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zY, "__esModule", { value: true });
  zY.Clone = undefined;
  var W$ = x0();
  zY.Clone = G8;
});
var V8 = J0((NY) => {
  var X$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, qY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, MY = function($) {
    return { type: "delete", path: $ };
  };
  function* TQ($, Y, W) {
    if (!(0, _0.IsPlainObject)(W))
      return yield X$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let Q of X) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && Z.includes(Q))
        yield X$(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if ((0, _0.IsUndefined)(Y[Q]) || (0, _0.IsUndefined)(W[Q]))
        continue;
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      yield* G$(`${$}/${String(Q)}`, Y[Q], W[Q]);
    }
    for (let Q of Z) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(Y[Q]))
        yield qY(`${$}/${String(Q)}`, W[Q]);
    }
    for (let Q of X.reverse()) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && !Z.includes(Q))
        yield MY(`${$}/${String(Q)}`);
    }
  }
  function* dQ($, Y, W) {
    if (!(0, _0.IsArray)(W))
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield qY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield MY(`${$}/${X}`);
    }
  }
  function* yQ($, Y, W) {
    if (!(0, _0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
  }
  function* vQ($, Y, W) {
    if (Y === W)
      return;
    yield X$($, W);
  }
  function* G$($, Y, W) {
    if ((0, _0.IsPlainObject)(Y))
      return yield* TQ($, Y, W);
    if ((0, _0.IsArray)(Y))
      return yield* dQ($, Y, W);
    if ((0, _0.IsTypedArray)(Y))
      return yield* yQ($, Y, W);
    if ((0, _0.IsValueType)(Y))
      return yield* vQ($, Y, W);
    throw new E8(Y);
  }
  var pQ = function($, Y) {
    return [...G$("", $, Y)];
  }, iQ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, mQ = function($) {
    return $.length === 0;
  }, uQ = function($, Y) {
    if (iQ(Y))
      return (0, _8.Clone)(Y[0].value);
    if (mQ(Y))
      return (0, _8.Clone)($);
    const W = (0, _8.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          R8.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(NY, "__esModule", { value: true });
  NY.Patch = NY.Diff = NY.ValueDeltaUnableToDiffUnknownValue = NY.ValueDeltaObjectWithSymbolKeyError = NY.Edit = NY.Delete = NY.Update = NY.Insert = undefined;
  var _0 = x0(), i0 = f0(), R8 = b$(), _8 = i1();
  NY.Insert = i0.Type.Object({ type: i0.Type.Literal("insert"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Update = i0.Type.Object({ type: i0.Type.Literal("update"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Delete = i0.Type.Object({ type: i0.Type.Literal("delete"), path: i0.Type.String() });
  NY.Edit = i0.Type.Union([NY.Insert, NY.Update, NY.Delete]);

  class m1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  NY.ValueDeltaObjectWithSymbolKeyError = m1;

  class E8 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  NY.ValueDeltaUnableToDiffUnknownValue = E8;
  NY.Diff = pQ;
  NY.Patch = uQ;
});
var jY = J0((wY) => {
  var lQ = function($, Y, W, X) {
    if (!(0, d0.IsPlainObject)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      const Z = Object.keys(W), Q = Object.keys(X);
      for (let J of Z)
        if (!Q.includes(J))
          delete W[J];
      for (let J of Q)
        if (!Z.includes(J))
          W[J] = null;
      for (let J of Q)
        f8($, `${Y}/${J}`, W[J], X[J]);
    }
  }, tQ = function($, Y, W, X) {
    if (!(0, d0.IsArray)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        f8($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, sQ = function($, Y, W, X) {
    if ((0, d0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
  }, rQ = function($, Y, W, X) {
    if (W === X)
      return;
    R$.ValuePointer.Set($, Y, X);
  }, f8 = function($, Y, W, X) {
    if ((0, d0.IsArray)(X))
      return tQ($, Y, W, X);
    if ((0, d0.IsTypedArray)(X))
      return sQ($, Y, W, X);
    if ((0, d0.IsPlainObject)(X))
      return lQ($, Y, W, X);
    if ((0, d0.IsValueType)(X))
      return rQ($, Y, W, X);
  }, DY = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, aQ = function($, Y) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(Y) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(Y);
  }, eQ = function($, Y) {
    if (DY($) || DY(Y))
      throw new g8;
    if (aQ($, Y))
      throw new k8;
    f8($, "", $, Y);
  };
  Object.defineProperty(wY, "__esModule", { value: true });
  wY.Mutate = wY.ValueMutateInvalidRootMutationError = wY.ValueMutateTypeMismatchError = undefined;
  var d0 = x0(), R$ = b$(), x8 = i1();

  class k8 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wY.ValueMutateTypeMismatchError = k8;

  class g8 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wY.ValueMutateInvalidRootMutationError = g8;
  wY.Mutate = eQ;
});
var SY = J0((PY) => {
  var W4 = function($, Y) {
    if (!(0, H1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => _$($[Z], Y[Z]));
  }, X4 = function($, Y) {
    return (0, H1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, Z4 = function($, Y) {
    if (!(0, H1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, Q4 = function($, Y) {
    if (!(0, H1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, J4 = function($, Y) {
    return $ === Y;
  }, _$ = function($, Y) {
    if ((0, H1.IsPlainObject)($))
      return W4($, Y);
    if ((0, H1.IsDate)($))
      return X4($, Y);
    if ((0, H1.IsTypedArray)($))
      return Q4($, Y);
    if ((0, H1.IsArray)($))
      return Z4($, Y);
    if ((0, H1.IsValueType)($))
      return J4($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PY, "__esModule", { value: true });
  PY.Equal = undefined;
  var H1 = x0();
  PY.Equal = _$;
});
var E$ = J0((q1) => {
  var z4 = q1 && q1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), H4 = q1 && q1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        z4(Y, $, W);
  };
  Object.defineProperty(q1, "__esModule", { value: true });
  q1.ValueErrorType = undefined;
  var q4 = $$();
  Object.defineProperty(q1, "ValueErrorType", { enumerable: true, get: function() {
    return q4.ValueErrorType;
  } });
  H4(P8(), q1);
});
var Q$ = J0((CY) => {
  var N4 = function($) {
    return $[C0.Kind] === "Any" || $[C0.Kind] === "Unknown";
  }, s = function($) {
    return $ !== undefined;
  }, F4 = function($, Y, W) {
    return true;
  }, U4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if (s($.minItems) && !(W.length >= $.minItems))
      return false;
    if (s($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((Q) => I0($.items, Y, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let J of W) {
        const z = (0, M4.Hash)(J);
        if (Q.has(z))
          return false;
        else
          Q.add(z);
      }
      return true;
    }())
      return false;
    if (!(s($.contains) || (0, A0.IsNumber)($.minContains) || (0, A0.IsNumber)($.maxContains)))
      return true;
    const X = s($.contains) ? $.contains : C0.Type.Never(), Z = W.reduce((Q, J) => I0(X, Y, J) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if ((0, A0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, A0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, A4 = function($, Y, W) {
    return (0, A0.IsAsyncIterator)(W);
  }, B4 = function($, Y, W) {
    if (!(0, A0.IsBigInt)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, D4 = function($, Y, W) {
    return (0, A0.IsBoolean)(W);
  }, w4 = function($, Y, W) {
    return I0($.returns, Y, W.prototype);
  }, K4 = function($, Y, W) {
    if (!(0, A0.IsDate)(W))
      return false;
    if (s($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (s($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (s($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (s($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (s($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, j4 = function($, Y, W) {
    return (0, A0.IsFunction)(W);
  }, P4 = function($, Y, W) {
    if (!(0, A0.IsInteger)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, O4 = function($, Y, W) {
    const X = $.allOf.every((Z) => I0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J));
      return X && Q;
    } else if (C0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J) || I0($.unevaluatedProperties, Y, W[J]));
      return X && Q;
    } else
      return X;
  }, S4 = function($, Y, W) {
    return (0, A0.IsIterator)(W);
  }, L4 = function($, Y, W) {
    return W === $.const;
  }, C4 = function($, Y, W) {
    return false;
  }, I4 = function($, Y, W) {
    return !I0($.not, Y, W);
  }, b4 = function($, Y, W) {
    return (0, A0.IsNull)(W);
  }, G4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, R4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!I0(Q, Y, W[Z]))
          return false;
        if ((C0.ExtendsUndefined.Check(Q) || N4(Q)) && !(Z in W))
          return false;
      } else if (Z$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !I0(Q, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((Q) => X.includes(Q) || I0($.additionalProperties, Y, W[Q]));
    else
      return true;
  }, _4 = function($, Y, W) {
    return (0, A0.IsPromise)(W);
  }, E4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X), J = Object.entries(W).every(([D, B]) => {
      return Q.test(D) ? I0(Z, Y, B) : true;
    }), z = typeof $.additionalProperties === "object" ? Object.entries(W).every(([D, B]) => {
      return !Q.test(D) ? I0($.additionalProperties, Y, B) : true;
    }) : true, U = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((D) => {
      return Q.test(D);
    }) : true;
    return J && z && U;
  }, V4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, x4 = function($, Y, W) {
    if (!(0, A0.IsString)(W))
      return false;
    if (s($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (s($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (s($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (s($.format)) {
      if (!C0.FormatRegistry.Has($.format))
        return false;
      return C0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, k4 = function($, Y, W) {
    return (0, A0.IsSymbol)(W);
  }, g4 = function($, Y, W) {
    return (0, A0.IsString)(W) && new RegExp($.pattern).test(W);
  }, f4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, T4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!I0($.items[X], Y, W[X]))
        return false;
    return true;
  }, d4 = function($, Y, W) {
    return (0, A0.IsUndefined)(W);
  }, y4 = function($, Y, W) {
    return $.anyOf.some((X) => I0(X, Y, W));
  }, v4 = function($, Y, W) {
    if (!(0, A0.IsUint8Array)(W))
      return false;
    if (s($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (s($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, p4 = function($, Y, W) {
    return true;
  }, i4 = function($, Y, W) {
    return Z$.TypeSystemPolicy.IsVoidLike(W);
  }, m4 = function($, Y, W) {
    if (!C0.TypeRegistry.Has($[C0.Kind]))
      return false;
    return C0.TypeRegistry.Get($[C0.Kind])($, W);
  }, I0 = function($, Y, W) {
    const X = s($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[C0.Kind]) {
      case "Any":
        return F4(Z, X, W);
      case "Array":
        return U4(Z, X, W);
      case "AsyncIterator":
        return A4(Z, X, W);
      case "BigInt":
        return B4(Z, X, W);
      case "Boolean":
        return D4(Z, X, W);
      case "Constructor":
        return w4(Z, X, W);
      case "Date":
        return K4(Z, X, W);
      case "Function":
        return j4(Z, X, W);
      case "Integer":
        return P4(Z, X, W);
      case "Intersect":
        return O4(Z, X, W);
      case "Iterator":
        return S4(Z, X, W);
      case "Literal":
        return L4(Z, X, W);
      case "Never":
        return C4(Z, X, W);
      case "Not":
        return I4(Z, X, W);
      case "Null":
        return b4(Z, X, W);
      case "Number":
        return G4(Z, X, W);
      case "Object":
        return R4(Z, X, W);
      case "Promise":
        return _4(Z, X, W);
      case "Record":
        return E4(Z, X, W);
      case "Ref":
        return V4(Z, X, W);
      case "String":
        return x4(Z, X, W);
      case "Symbol":
        return k4(Z, X, W);
      case "TemplateLiteral":
        return g4(Z, X, W);
      case "This":
        return f4(Z, X, W);
      case "Tuple":
        return T4(Z, X, W);
      case "Undefined":
        return d4(Z, X, W);
      case "Union":
        return y4(Z, X, W);
      case "Uint8Array":
        return v4(Z, X, W);
      case "Unknown":
        return p4(Z, X, W);
      case "Void":
        return i4(Z, X, W);
      default:
        if (!C0.TypeRegistry.Has(Z[C0.Kind]))
          throw new T8(Z);
        return m4(Z, X, W);
    }
  }, u4 = function(...$) {
    return $.length === 3 ? I0($[0], $[1], $[2]) : I0($[0], [], $[1]);
  };
  Object.defineProperty(CY, "__esModule", { value: true });
  CY.Check = CY.ValueCheckUnknownTypeError = undefined;
  var A0 = x0(), Z$ = E$(), LY = D1(), M4 = Y$(), C0 = f0();

  class T8 extends C0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CY.ValueCheckUnknownTypeError = T8;
  CY.Check = u4;
});
var u8 = J0((_Y) => {
  var n4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, c4 = function($, Y) {
    if ($.uniqueItems === true && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return y0($.items, Y);
      });
    else
      return [];
  }, l4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, t4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, s4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, r4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = y0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, a4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, e4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, Y);
  }, $J = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, YJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const Q = y0(Z, Y);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!(0, o4.Check)($, Y, W))
        throw new p8($);
      return W;
    }
  }, WJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, XJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, ZJ = function($, Y) {
    throw new y8($);
  }, QJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new v8($);
  }, JJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, zJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, HJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return W.has(Z) ? { ...X, [Z]: y0(Q, Y) } : { ...X };
      }, {});
    }
  }, qJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, Y));
  }, MJ = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === k0.PatternStringExact || W === k0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((Q, J) => {
        return { ...Q, [J]: y0(X, Y) };
      }, {});
    else
      return {};
  }, NJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, FJ = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, UJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, AJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    const W = k0.TemplateLiteralParser.ParseExact($.pattern);
    if (!k0.TemplateLiteralFinite.Check(W))
      throw new i8($);
    return k0.TemplateLiteralGenerator.Generate(W).next().value;
  }, BJ = function($, Y) {
    if (RY++ > bY)
      throw new m8($, bY);
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, DJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => y0($.items[X], Y));
  }, wJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, KJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], Y);
  }, jJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, PJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, OJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, SJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, Y) {
    const W = (0, a.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[k0.Kind]) {
      case "Any":
        return n4(X, W);
      case "Array":
        return c4(X, W);
      case "AsyncIterator":
        return l4(X, W);
      case "BigInt":
        return t4(X, W);
      case "Boolean":
        return s4(X, W);
      case "Constructor":
        return r4(X, W);
      case "Date":
        return a4(X, W);
      case "Function":
        return e4(X, W);
      case "Integer":
        return $J(X, W);
      case "Intersect":
        return YJ(X, W);
      case "Iterator":
        return WJ(X, W);
      case "Literal":
        return XJ(X, W);
      case "Never":
        return ZJ(X, W);
      case "Not":
        return QJ(X, W);
      case "Null":
        return JJ(X, W);
      case "Number":
        return zJ(X, W);
      case "Object":
        return HJ(X, W);
      case "Promise":
        return qJ(X, W);
      case "Record":
        return MJ(X, W);
      case "Ref":
        return NJ(X, W);
      case "String":
        return FJ(X, W);
      case "Symbol":
        return UJ(X, W);
      case "TemplateLiteral":
        return AJ(X, W);
      case "This":
        return BJ(X, W);
      case "Tuple":
        return DJ(X, W);
      case "Undefined":
        return wJ(X, W);
      case "Union":
        return KJ(X, W);
      case "Uint8Array":
        return jJ(X, W);
      case "Unknown":
        return PJ(X, W);
      case "Void":
        return OJ(X, W);
      default:
        if (!k0.TypeRegistry.Has(X[k0.Kind]))
          throw new d8(X);
        return SJ(X, W);
    }
  }, LJ = function(...$) {
    return RY = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_Y, "__esModule", { value: true });
  _Y.Create = _Y.ValueCreateRecursiveInstantiationError = _Y.ValueCreateTempateLiteralTypeError = _Y.ValueCreateIntersectTypeError = _Y.ValueCreateNotTypeError = _Y.ValueCreateNeverTypeError = _Y.ValueCreateUnknownTypeError = undefined;
  var a = x0(), o4 = Q$(), GY = D1(), k0 = f0();

  class d8 extends k0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _Y.ValueCreateUnknownTypeError = d8;

  class y8 extends k0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _Y.ValueCreateNeverTypeError = y8;

  class v8 extends k0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _Y.ValueCreateNotTypeError = v8;

  class p8 extends k0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateIntersectTypeError = p8;

  class i8 extends k0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateTempateLiteralTypeError = i8;

  class m8 extends k0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  _Y.ValueCreateRecursiveInstantiationError = m8;
  var bY = 512, RY = 0;
  _Y.Create = LJ;
});
var dY = J0((fY) => {
  var kY = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y);
  }, o8 = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? W : (0, N1.Create)($, Y);
  }, EJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    const X = (0, w1.IsArray)(W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y), Z = (0, w1.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, J = ((0, w1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((U) => Y1($.items, Y, U));
    if ($.uniqueItems !== true)
      return J;
    const z = [...new Set(J)];
    if (!(0, m0.Check)($, Y, z))
      throw new n8($, z);
    return z;
  }, VJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, N1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, J] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && W.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = Y1(J, Y, W.prototype[Q]);
    }
    return Z;
  }, xJ = function($, Y, W) {
    const X = (0, N1.Create)($, Y), Z = (0, w1.IsPlainObject)(X) && (0, w1.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, m0.Check)($, Y, Z) ? Z : (0, N1.Create)($, Y);
  }, kJ = function($, Y, W) {
    throw new c8($);
  }, gJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, N1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [Q, J] of Object.entries($.properties)) {
      if (!X.has(Q) && W[Q] === undefined)
        continue;
      Z[Q] = Y1(J, Y, W[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let J of Object.getOwnPropertyNames(W)) {
        if (Q.includes(J))
          continue;
        Z[J] = Y1($.additionalProperties, Y, W[J]);
      }
    }
    return Z;
  }, fJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, N1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = Y1(Z, Y, z);
    return Q;
  }, TJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, dJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, yJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (!(0, w1.IsArray)(W))
      return (0, N1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => Y1(X, Y, W[Z]));
  }, vJ = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : h8.Create($, Y, W);
  }, Y1 = function($, Y, W) {
    const X = (0, w1.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[M1.Kind]) {
      case "Array":
        return EJ(Z, X, W);
      case "Constructor":
        return VJ(Z, X, W);
      case "Intersect":
        return xJ(Z, X, W);
      case "Never":
        return kJ(Z, X, W);
      case "Object":
        return gJ(Z, X, W);
      case "Record":
        return fJ(Z, X, W);
      case "Ref":
        return TJ(Z, X, W);
      case "This":
        return dJ(Z, X, W);
      case "Tuple":
        return yJ(Z, X, W);
      case "Union":
        return vJ(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return o8(Z, X, W);
      default:
        if (!M1.TypeRegistry.Has(Z[M1.Kind]))
          throw new l8(Z);
        return o8(Z, X, W);
    }
  }, gY = function(...$) {
    return $.length === 3 ? Y1($[0], $[1], $[2]) : Y1($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Cast = fY.Default = fY.DefaultClone = fY.ValueCastUnknownTypeError = fY.ValueCastRecursiveTypeError = fY.ValueCastNeverTypeError = fY.ValueCastArrayUniqueItemsTypeError = undefined;
  var w1 = x0(), N1 = u8(), m0 = Q$(), u1 = i1(), VY = D1(), M1 = f0();

  class n8 extends M1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  fY.ValueCastArrayUniqueItemsTypeError = n8;

  class c8 extends M1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fY.ValueCastNeverTypeError = c8;

  class xY extends M1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fY.ValueCastRecursiveTypeError = xY;

  class l8 extends M1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCastUnknownTypeError = l8;
  var h8;
  (function($) {
    function Y(Z, Q, J) {
      if (Z[M1.Kind] === "Object" && typeof J === "object" && !(0, w1.IsNull)(J)) {
        const z = Z, U = Object.getOwnPropertyNames(J), D = Object.entries(z.properties), [B, j] = [1 / D.length, D.length];
        return D.reduce((b, [S, N]) => {
          const O = N[M1.Kind] === "Literal" && N.const === J[S] ? j : 0, P = (0, m0.Check)(N, Q, J[S]) ? B : 0, F = U.includes(S) ? B : 0;
          return b + (O + P + F);
        }, 0);
      } else
        return (0, m0.Check)(Z, Q, J) ? 1 : 0;
    }
    function W(Z, Q, J) {
      let [z, U] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const B = Y(D, Q, J);
        if (B > U)
          z = D, U = B;
      }
      return z;
    }
    function X(Z, Q, J) {
      if ("default" in Z)
        return Z.default;
      else {
        const z = W(Z, Q, J);
        return gY(z, Q, J);
      }
    }
    $.Create = X;
  })(h8 || (h8 = {}));
  fY.DefaultClone = kY;
  fY.Default = o8;
  fY.Cast = gY;
});
var hY = J0((mY) => {
  var V$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, lJ = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, J$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, z$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, tJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, $9 = function($, Y) {
    const W = pY($);
    return W === Y ? W : $;
  }, Y9 = function($, Y) {
    const W = iY($);
    return W === Y ? W : $;
  }, W9 = function($, Y) {
    const W = vY($);
    return W === Y ? W : $;
  }, X9 = function($, Y) {
    if (typeof $.const === "string")
      return $9(Y, $.const);
    else if (typeof $.const === "number")
      return Y9(Y, $.const);
    else if (typeof $.const === "boolean")
      return W9(Y, $.const);
    else
      return (0, nJ.Clone)(Y);
  }, vY = function($) {
    return J$($) ? true : z$($) ? false : $;
  }, Z9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : z$($) ? BigInt(0) : J$($) ? BigInt(1) : $;
  }, pY = function($) {
    return lJ($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iY = function($) {
    return V$($) ? parseFloat($) : J$($) ? 1 : z$($) ? 0 : $;
  }, Q9 = function($) {
    return V$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : J$($) ? 1 : z$($) ? 0 : $;
  }, J9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, z9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, H9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : J$($) ? new Date(1) : z$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : sJ($) ? new Date(`1970-01-01T${$}.000Z`) : tJ($) ? new Date(`1970-01-01T${$}`) : aJ($) ? new Date(`${$}.000Z`) : rJ($) ? new Date($) : eJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, t8 = function($) {
    return $;
  }, q9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => n0($.items, Y, X));
    return W;
  }, M9 = function($, Y, W) {
    return Z9(W);
  }, N9 = function($, Y, W) {
    return vY(W);
  }, F9 = function($, Y, W) {
    return H9(W);
  }, U9 = function($, Y, W) {
    return Q9(W);
  }, A9 = function($, Y, W) {
    return $.allOf.every((X) => h1.TypeGuard.TObject(X)) ? n0(h1.Type.Composite($.allOf), Y, W) : n0($.allOf[0], Y, W);
  }, B9 = function($, Y, W) {
    return X9($, W);
  }, D9 = function($, Y, W) {
    return J9(W);
  }, w9 = function($, Y, W) {
    return iY(W);
  }, K9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: n0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, j9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = n0(Z, Y, z);
    return Q;
  }, P9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, O9 = function($, Y, W) {
    return pY(W);
  }, S9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, L9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, C9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? n0($.items[Z], Y, X) : X;
      });
    return W;
  }, I9 = function($, Y, W) {
    return z9(W);
  }, b9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = n0(X, Y, W);
      if ((0, cJ.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, n0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[h1.Kind]) {
      case "Array":
        return q9(Z, X, W);
      case "BigInt":
        return M9(Z, X, W);
      case "Boolean":
        return N9(Z, X, W);
      case "Date":
        return F9(Z, X, W);
      case "Integer":
        return U9(Z, X, W);
      case "Intersect":
        return A9(Z, X, W);
      case "Literal":
        return B9(Z, X, W);
      case "Null":
        return D9(Z, X, W);
      case "Number":
        return w9(Z, X, W);
      case "Object":
        return K9(Z, X, W);
      case "Record":
        return j9(Z, X, W);
      case "Ref":
        return P9(Z, X, W);
      case "String":
        return O9(Z, X, W);
      case "Symbol":
        return S9(Z, X, W);
      case "This":
        return L9(Z, X, W);
      case "Tuple":
        return C9(Z, X, W);
      case "Undefined":
        return I9(Z, X, W);
      case "Union":
        return b9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return t8(W);
      default:
        if (!h1.TypeRegistry.Has(Z[h1.Kind]))
          throw new s8(Z);
        return t8(W);
    }
  }, G9 = function(...$) {
    return $.length === 3 ? n0($[0], $[1], $[2]) : n0($[0], [], $[1]);
  };
  Object.defineProperty(mY, "__esModule", { value: true });
  mY.Convert = mY.Default = mY.ValueConvertUnknownTypeError = undefined;
  var Z0 = x0(), nJ = i1(), cJ = Q$(), yY = D1(), h1 = f0();

  class s8 extends h1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mY.ValueConvertUnknownTypeError = s8;
  mY.Default = t8;
  mY.Convert = G9;
});
var e8 = J0((sY) => {
  Object.defineProperty(sY, "__esModule", { value: true });
  sY.EncodeTransform = sY.DecodeTransform = sY.HasTransform = sY.TransformEncodeError = sY.TransformDecodeError = sY.TransformEncodeCheckError = sY.TransformDecodeCheckError = sY.TransformUnknownTypeError = undefined;
  var c0 = x0(), o1 = D1(), h = f0();

  class H$ extends h.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sY.TransformUnknownTypeError = H$;

  class lY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformDecodeCheckError = lY;

  class tY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformEncodeCheckError = tY;

  class r8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformDecodeError = r8;

  class a8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformEncodeError = a8;
  var oY;
  (function($) {
    function Y(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function W(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function X(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Q(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((G) => O(G, I));
    }
    function J(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.not, I);
    }
    function U(w, I) {
      return h.TypeGuard.TTransform(w) || Object.values(w.properties).some((G) => O(G, I)) || h.TypeGuard.TSchema(w.additionalProperties) && O(w.additionalProperties, I);
    }
    function D(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.item, I);
    }
    function B(w, I) {
      const G = Object.getOwnPropertyNames(w.patternProperties)[0], k = w.patternProperties[G];
      return h.TypeGuard.TTransform(w) || O(k, I) || h.TypeGuard.TSchema(w.additionalProperties) && h.TypeGuard.TTransform(w.additionalProperties);
    }
    function j(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function b(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function S(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TSchema(w.items) && w.items.some((G) => O(G, I));
    }
    function N(w, I) {
      return h.TypeGuard.TTransform(w) || w.anyOf.some((G) => O(G, I));
    }
    function O(w, I) {
      const G = (0, c0.IsString)(w.$id) ? [...I, w] : I, k = w;
      if (w.$id && P.has(w.$id))
        return false;
      if (w.$id)
        P.add(w.$id);
      switch (w[h.Kind]) {
        case "Array":
          return Y(k, G);
        case "AsyncIterator":
          return W(k, G);
        case "Constructor":
          return X(k, G);
        case "Function":
          return Z(k, G);
        case "Intersect":
          return Q(k, G);
        case "Iterator":
          return J(k, G);
        case "Not":
          return z(k, G);
        case "Object":
          return U(k, G);
        case "Promise":
          return D(k, G);
        case "Record":
          return B(k, G);
        case "Ref":
          return j(k, G);
        case "This":
          return b(k, G);
        case "Tuple":
          return S(k, G);
        case "Union":
          return N(k, G);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return h.TypeGuard.TTransform(w);
        default:
          if (!h.TypeRegistry.Has(k[h.Kind]))
            throw new H$(k);
          return h.TypeGuard.TTransform(w);
      }
    }
    const P = new Set;
    function F(w, I) {
      return P.clear(), O(w, I);
    }
    $.Has = F;
  })(oY || (sY.HasTransform = oY = {}));
  var nY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Decode(O) : O;
      } catch (P) {
        throw new r8(N, O, P);
      }
    }
    function W(N, O, P) {
      const F = P.map((w) => j(N.items, O, w));
      return Y(N, F);
    }
    function X(N, O, P) {
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return Y(N, P);
      const F = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), w = Object.entries(P).reduce((G, [k, _]) => {
        return !F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, w);
      const I = Object.entries(w).reduce((G, [k, _]) => {
        return F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
      return Y(N, I);
    }
    function Z(N, O, P) {
      const F = j(N.not, O, P);
      return Y(N, F);
    }
    function Q(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.entries(P).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, F);
      const w = N.additionalProperties, I = Object.entries(F).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(w, O, _) };
      }, {});
      return Y(N, I);
    }
    function J(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.getOwnPropertyNames(N.patternProperties)[0], w = N.patternProperties[F], I = new RegExp(F), G = Object.entries(P).reduce((e, [o, r]) => {
        return !I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(w, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, G);
      const k = N.additionalProperties, _ = Object.entries(G).reduce((e, [o, r]) => {
        return I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(k, O, r) };
      }, {});
      return Y(N, _);
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, P[I])) : [];
      return Y(N, F);
    }
    function B(N, O, P) {
      const F = Y(N, P);
      for (let w of N.anyOf) {
        if (!b(w, O, F))
          continue;
        return j(w, O, F);
      }
      return F;
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "Symbol":
          return Y(w, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Decode = S;
  })(nY || (sY.DecodeTransform = nY = {}));
  var cY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Encode(O) : O;
      } catch (P) {
        throw new a8(N, O, P);
      }
    }
    function W(N, O, P) {
      return Y(N, P).map((w) => j(N.items, O, w));
    }
    function X(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return F;
      const w = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), I = Object.entries(F).reduce((G, [k, _]) => {
        return !w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, I);
      return Object.entries(I).reduce((G, [k, _]) => {
        return w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
    }
    function Z(N, O, P) {
      const F = Y(N, P);
      return Y(N.not, F);
    }
    function Q(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.entries(F).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return w;
      const I = N.additionalProperties;
      return Object.entries(w).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(I, O, _) };
      }, {});
    }
    function J(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.getOwnPropertyNames(N.patternProperties)[0], I = N.patternProperties[w], G = new RegExp(w), k = Object.entries(F).reduce((e, [o, r]) => {
        return !G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(I, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, k);
      const _ = N.additionalProperties;
      return Object.entries(k).reduce((e, [o, r]) => {
        return G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(_, O, r) };
      }, {});
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = Y(N, P);
      return (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, F[I])) : [];
    }
    function B(N, O, P) {
      for (let F of N.anyOf) {
        if (!b(F, O, P))
          continue;
        const w = j(F, O, P);
        return Y(N, w);
      }
      return Y(N, P);
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Encode = S;
  })(cY || (sY.EncodeTransform = cY = {}));
});
var JW = J0((ZW) => {
  Object.defineProperty(ZW, "__esModule", { value: true });
  ZW.Value = undefined;
  var aY = I$(), d9 = jY(), y9 = Y$(), v9 = SY(), eY = dY(), p9 = i1(), $W = hY(), YW = u8(), x$ = Q$(), WW = V8(), k$ = e8(), XW;
  (function($) {
    function Y(...N) {
      return eY.Cast.apply(eY, N);
    }
    $.Cast = Y;
    function W(...N) {
      return YW.Create.apply(YW, N);
    }
    $.Create = W;
    function X(...N) {
      return x$.Check.apply(x$, N);
    }
    $.Check = X;
    function Z(...N) {
      return $W.Convert.apply($W, N);
    }
    $.Convert = Z;
    function Q(N) {
      return p9.Clone(N);
    }
    $.Clone = Q;
    function J(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]];
      if (!X(O, P, F))
        throw new k$.TransformDecodeCheckError(O, F, U(O, P, F).First());
      return k$.DecodeTransform.Decode(O, P, F, x$.Check);
    }
    $.Decode = J;
    function z(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]], w = k$.EncodeTransform.Encode(O, P, F, x$.Check);
      if (!X(O, P, w))
        throw new k$.TransformEncodeCheckError(O, F, U(O, P, F).First());
      return w;
    }
    $.Encode = z;
    function U(...N) {
      return aY.Errors.apply(aY, N);
    }
    $.Errors = U;
    function D(N, O) {
      return v9.Equal(N, O);
    }
    $.Equal = D;
    function B(N, O) {
      return WW.Diff(N, O);
    }
    $.Diff = B;
    function j(N) {
      return y9.Hash(N);
    }
    $.Hash = j;
    function b(N, O) {
      return WW.Patch(N, O);
    }
    $.Patch = b;
    function S(N, O) {
      d9.Mutate(N, O);
    }
    $.Mutate = S;
  })(XW || (ZW.Value = XW = {}));
});
var $6 = J0((W1) => {
  Object.defineProperty(W1, "__esModule", { value: true });
  W1.Value = W1.ValuePointer = W1.Delete = W1.Update = W1.Insert = W1.Edit = W1.ValueErrorIterator = W1.ValueErrorType = undefined;
  var zW = I$();
  Object.defineProperty(W1, "ValueErrorType", { enumerable: true, get: function() {
    return zW.ValueErrorType;
  } });
  Object.defineProperty(W1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zW.ValueErrorIterator;
  } });
  var g$ = V8();
  Object.defineProperty(W1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(W1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(W1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(W1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var i9 = b$();
  Object.defineProperty(W1, "ValuePointer", { enumerable: true, get: function() {
    return i9.ValuePointer;
  } });
  var m9 = JW();
  Object.defineProperty(W1, "Value", { enumerable: true, get: function() {
    return m9.Value;
  } });
});
var UW = J0((NW) => {
  Object.defineProperty(NW, "__esModule", { value: true });
  NW.TypeCompiler = NW.Policy = NW.TypeCompilerTypeGuardError = NW.TypeCompilerUnknownTypeError = NW.TypeCheck = undefined;
  var N$ = e8(), c = x0(), r9 = $$(), F$ = E$(), a9 = D1(), e9 = Y$(), F0 = f0();

  class Q6 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = N$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, r9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new N$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? N$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? N$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new N$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  NW.TypeCheck = Q6;
  var F1;
  (function($) {
    function Y(Q) {
      return Q === 36;
    }
    $.DollarSign = Y;
    function W(Q) {
      return Q === 95;
    }
    $.IsUnderscore = W;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(F1 || (F1 = {}));
  var v$;
  (function($) {
    function Y(Q) {
      if (Q.length === 0)
        return false;
      return F1.IsNumeric(Q.charCodeAt(0));
    }
    function W(Q) {
      if (Y(Q))
        return false;
      for (let J = 0;J < Q.length; J++) {
        const z = Q.charCodeAt(J);
        if (!(F1.IsAlpha(z) || F1.IsNumeric(z) || F1.DollarSign(z) || F1.IsUnderscore(z)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, J) {
      return W(J) ? `${Q}.${J}` : `${Q}['${X(J)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var X6;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const Q = W.charCodeAt(Z);
        if (F1.IsNumeric(Q) || F1.IsAlpha(Q))
          X.push(W.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(X6 || (X6 = {}));
  var Z6;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(Z6 || (Z6 = {}));

  class J6 extends F0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  NW.TypeCompilerUnknownTypeError = J6;

  class p$ extends F0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  NW.TypeCompilerTypeGuardError = p$;
  var L1;
  (function($) {
    function Y(J, z, U) {
      return F$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${z}' in ${J} ? ${U} : true)` : `(${v$.Encode(J, z)} !== undefined ? ${U} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}))` : `(typeof ${J} === 'object' && ${J} !== null)`;
    }
    $.IsObjectLike = W;
    function X(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}) && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))` : `(typeof ${J} === 'object' && ${J} !== null && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(J) {
      return !F$.TypeSystemPolicy.AllowNaN ? `(typeof ${J} === 'number' && Number.isFinite(${J}))` : `typeof ${J} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q(J) {
      return F$.TypeSystemPolicy.AllowNullVoid ? `(${J} === undefined || ${J} === null)` : `${J} === undefined`;
    }
    $.IsVoidLike = Q;
  })(L1 || (NW.Policy = L1 = {}));
  var MW;
  (function($) {
    function Y(K) {
      return K[F0.Kind] === "Any" || K[F0.Kind] === "Unknown";
    }
    function* W(K, E, L) {
      yield "true";
    }
    function* X(K, E, L) {
      yield `Array.isArray(${L})`;
      const [p, T] = [B0("value", "any"), B0("acc", "number")];
      if ((0, c.IsNumber)(K.maxItems))
        yield `${L}.length <= ${K.maxItems}`;
      if ((0, c.IsNumber)(K.minItems))
        yield `${L}.length >= ${K.minItems}`;
      const d = f(K.items, E, "value");
      if (yield `${L}.every((${p}) => ${d})`, F0.TypeGuard.TSchema(K.contains) || (0, c.IsNumber)(K.minContains) || (0, c.IsNumber)(K.maxContains)) {
        const W0 = F0.TypeGuard.TSchema(K.contains) ? K.contains : F0.Type.Never(), j0 = f(W0, E, "value"), X0 = (0, c.IsNumber)(K.minContains) ? [`(count >= ${K.minContains})`] : [], M = (0, c.IsNumber)(K.maxContains) ? [`(count <= ${K.maxContains})`] : [], l = `const count = value.reduce((${T}, ${p}) => ${j0} ? acc + 1 : acc, 0)`, S0 = ["(count > 0)", ...X0, ...M].join(" && ");
        yield `((${p}) => { ${l}; return ${S0}})(${L})`;
      }
      if (K.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${L})`;
    }
    function* Z(K, E, L) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${L})`;
    }
    function* Q(K, E, L) {
      if (yield `(typeof ${L} === 'bigint')`, (0, c.IsBigInt)(K.exclusiveMaximum))
        yield `${L} < BigInt(${K.exclusiveMaximum})`;
      if ((0, c.IsBigInt)(K.exclusiveMinimum))
        yield `${L} > BigInt(${K.exclusiveMinimum})`;
      if ((0, c.IsBigInt)(K.maximum))
        yield `${L} <= BigInt(${K.maximum})`;
      if ((0, c.IsBigInt)(K.minimum))
        yield `${L} >= BigInt(${K.minimum})`;
      if ((0, c.IsBigInt)(K.multipleOf))
        yield `(${L} % BigInt(${K.multipleOf})) === 0`;
    }
    function* J(K, E, L) {
      yield `(typeof ${L} === 'boolean')`;
    }
    function* z(K, E, L) {
      yield* v0(K.returns, E, `${L}.prototype`);
    }
    function* U(K, E, L) {
      if (yield `(${L} instanceof Date) && Number.isFinite(${L}.getTime())`, (0, c.IsNumber)(K.exclusiveMaximumTimestamp))
        yield `${L}.getTime() < ${K.exclusiveMaximumTimestamp}`;
      if ((0, c.IsNumber)(K.exclusiveMinimumTimestamp))
        yield `${L}.getTime() > ${K.exclusiveMinimumTimestamp}`;
      if ((0, c.IsNumber)(K.maximumTimestamp))
        yield `${L}.getTime() <= ${K.maximumTimestamp}`;
      if ((0, c.IsNumber)(K.minimumTimestamp))
        yield `${L}.getTime() >= ${K.minimumTimestamp}`;
      if ((0, c.IsNumber)(K.multipleOfTimestamp))
        yield `(${L}.getTime() % ${K.multipleOfTimestamp}) === 0`;
    }
    function* D(K, E, L) {
      yield `(typeof ${L} === 'function')`;
    }
    function* B(K, E, L) {
      if (yield `(typeof ${L} === 'number' && Number.isInteger(${L}))`, (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* j(K, E, L) {
      const p = K.allOf.map((T) => f(T, E, L)).join(" && ");
      if (K.unevaluatedProperties === false) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key))`;
        yield `(${p} && ${d})`;
      } else if (F0.TypeGuard.TSchema(K.unevaluatedProperties)) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key) || ${f(K.unevaluatedProperties, E, `${L}[key]`)})`;
        yield `(${p} && ${d})`;
      } else
        yield `(${p})`;
    }
    function* b(K, E, L) {
      yield `(typeof value === 'object' && Symbol.iterator in ${L})`;
    }
    function* S(K, E, L) {
      if (typeof K.const === "number" || typeof K.const === "boolean")
        yield `(${L} === ${K.const})`;
      else
        yield `(${L} === '${Z6.Escape(K.const)}')`;
    }
    function* N(K, E, L) {
      yield "false";
    }
    function* O(K, E, L) {
      yield `(!${f(K.not, E, L)})`;
    }
    function* P(K, E, L) {
      yield `(${L} === null)`;
    }
    function* F(K, E, L) {
      if (yield L1.IsNumberLike(L), (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* w(K, E, L) {
      if (yield L1.IsObjectLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const p = Object.getOwnPropertyNames(K.properties);
      for (let T of p) {
        const d = v$.Encode(L, T), W0 = K.properties[T];
        if (K.required && K.required.includes(T)) {
          if (yield* v0(W0, E, d), F0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${T}' in ${L})`;
        } else {
          const j0 = f(W0, E, d);
          yield L1.IsExactOptionalProperty(L, T, j0);
        }
      }
      if (K.additionalProperties === false)
        if (K.required && K.required.length === p.length)
          yield `Object.getOwnPropertyNames(${L}).length === ${p.length}`;
        else {
          const T = `[${p.map((d) => `'${d}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${L}).every(key => ${T}.includes(key))`;
        }
      if (typeof K.additionalProperties === "object") {
        const T = f(K.additionalProperties, E, `${L}[key]`), d = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${L}).every(key => ${d}.includes(key) || ${T}))`;
      }
    }
    function* I(K, E, L) {
      yield `(typeof value === 'object' && typeof ${L}.then === 'function')`;
    }
    function* G(K, E, L) {
      if (yield L1.IsRecordLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const [p, T] = Object.entries(K.patternProperties)[0], d = n(`${new RegExp(p)}`), W0 = f(T, E, "value"), j0 = F0.TypeGuard.TSchema(K.additionalProperties) ? f(K.additionalProperties, E, L) : K.additionalProperties === false ? "false" : "true", X0 = `(${d}.test(key) ? ${W0} : ${j0})`;
      yield `(Object.entries(${L}).every(([key, value]) => ${X0}))`;
    }
    function* k(K, E, L) {
      const p = (0, a9.Deref)(K, E);
      if (R.functions.has(K.$ref))
        return yield `${i(K.$ref)}(${L})`;
      yield* v0(p, E, L);
    }
    function* _(K, E, L) {
      if (yield `(typeof ${L} === 'string')`, (0, c.IsNumber)(K.maxLength))
        yield `${L}.length <= ${K.maxLength}`;
      if ((0, c.IsNumber)(K.minLength))
        yield `${L}.length >= ${K.minLength}`;
      if (K.pattern !== undefined)
        yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
      if (K.format !== undefined)
        yield `format('${K.format}', ${L})`;
    }
    function* e(K, E, L) {
      yield `(typeof ${L} === 'symbol')`;
    }
    function* o(K, E, L) {
      yield `(typeof ${L} === 'string')`, yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
    }
    function* r(K, E, L) {
      yield `${i(K.$ref)}(${L})`;
    }
    function* g0(K, E, L) {
      if (yield `Array.isArray(${L})`, K.items === undefined)
        return yield `${L}.length === 0`;
      yield `(${L}.length === ${K.maxItems})`;
      for (let p = 0;p < K.items.length; p++)
        yield `${f(K.items[p], E, `${L}[${p}]`)}`;
    }
    function* b0(K, E, L) {
      yield `${L} === undefined`;
    }
    function* E0(K, E, L) {
      yield `(${K.anyOf.map((T) => f(T, E, L)).join(" || ")})`;
    }
    function* H0(K, E, L) {
      if (yield `${L} instanceof Uint8Array`, (0, c.IsNumber)(K.maxByteLength))
        yield `(${L}.length <= ${K.maxByteLength})`;
      if ((0, c.IsNumber)(K.minByteLength))
        yield `(${L}.length >= ${K.minByteLength})`;
    }
    function* z0(K, E, L) {
      yield "true";
    }
    function* u0(K, E, L) {
      yield L1.IsVoidLike(L);
    }
    function* a0(K, E, L) {
      const p = R.instances.size;
      R.instances.set(p, K), yield `kind('${K[F0.Kind]}', ${p}, ${L})`;
    }
    function* v0(K, E, L, p = true) {
      const T = (0, c.IsString)(K.$id) ? [...E, K] : E, d = K;
      if (p && (0, c.IsString)(K.$id)) {
        const W0 = i(K.$id);
        if (R.functions.has(W0))
          return yield `${W0}(${L})`;
        else {
          const j0 = q0(W0, K, E, "value", false);
          return R.functions.set(W0, j0), yield `${W0}(${L})`;
        }
      }
      switch (d[F0.Kind]) {
        case "Any":
          return yield* W(d, T, L);
        case "Array":
          return yield* X(d, T, L);
        case "AsyncIterator":
          return yield* Z(d, T, L);
        case "BigInt":
          return yield* Q(d, T, L);
        case "Boolean":
          return yield* J(d, T, L);
        case "Constructor":
          return yield* z(d, T, L);
        case "Date":
          return yield* U(d, T, L);
        case "Function":
          return yield* D(d, T, L);
        case "Integer":
          return yield* B(d, T, L);
        case "Intersect":
          return yield* j(d, T, L);
        case "Iterator":
          return yield* b(d, T, L);
        case "Literal":
          return yield* S(d, T, L);
        case "Never":
          return yield* N(d, T, L);
        case "Not":
          return yield* O(d, T, L);
        case "Null":
          return yield* P(d, T, L);
        case "Number":
          return yield* F(d, T, L);
        case "Object":
          return yield* w(d, T, L);
        case "Promise":
          return yield* I(d, T, L);
        case "Record":
          return yield* G(d, T, L);
        case "Ref":
          return yield* k(d, T, L);
        case "String":
          return yield* _(d, T, L);
        case "Symbol":
          return yield* e(d, T, L);
        case "TemplateLiteral":
          return yield* o(d, T, L);
        case "This":
          return yield* r(d, T, L);
        case "Tuple":
          return yield* g0(d, T, L);
        case "Undefined":
          return yield* b0(d, T, L);
        case "Union":
          return yield* E0(d, T, L);
        case "Uint8Array":
          return yield* H0(d, T, L);
        case "Unknown":
          return yield* z0(d, T, L);
        case "Void":
          return yield* u0(d, T, L);
        default:
          if (!F0.TypeRegistry.Has(d[F0.Kind]))
            throw new J6(K);
          return yield* a0(d, T, L);
      }
    }
    const R = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function f(K, E, L, p = true) {
      return `(${[...v0(K, E, L, p)].join(" && ")})`;
    }
    function i(K) {
      return `check_${X6.Encode(K)}`;
    }
    function n(K) {
      const E = `local_${R.variables.size}`;
      return R.variables.set(E, `const ${E} = ${K}`), E;
    }
    function q0(K, E, L, p, T = true) {
      const [d, W0] = ["\n", (l) => "".padStart(l, " ")], j0 = B0("value", "any"), X0 = D0("boolean"), M = [...v0(E, L, p, T)].map((l) => `${W0(4)}${l}`).join(` &&${d}`);
      return `function ${K}(${j0})${X0} {${d}${W0(2)}return (${d}${M}${d}${W0(2)})\n}`;
    }
    function B0(K, E) {
      const L = R.language === "typescript" ? `: ${E}` : "";
      return `${K}${L}`;
    }
    function D0(K) {
      return R.language === "typescript" ? `: ${K}` : "";
    }
    function w0(K, E, L) {
      const p = q0("check", K, E, "value"), T = B0("value", "any"), d = D0("boolean"), W0 = [...R.functions.values()], j0 = [...R.variables.values()], X0 = (0, c.IsString)(K.$id) ? `return function check(${T})${d} {\n  return ${i(K.$id)}(value)\n}` : `return ${p}`;
      return [...j0, ...W0, X0].join("\n");
    }
    function M0(...K) {
      const E = { language: "javascript" }, [L, p, T] = K.length === 2 && (0, c.IsArray)(K[1]) ? [K[0], K[1], E] : K.length === 2 && !(0, c.IsArray)(K[1]) ? [K[0], [], K[1]] : K.length === 3 ? [K[0], K[1], K[2]] : K.length === 1 ? [K[0], [], E] : [null, [], E];
      if (R.language = T.language, R.variables.clear(), R.functions.clear(), R.instances.clear(), !F0.TypeGuard.TSchema(L))
        throw new p$(L);
      for (let d of p)
        if (!F0.TypeGuard.TSchema(d))
          throw new p$(d);
      return w0(L, p, T);
    }
    $.Code = M0;
    function B1(K, E = []) {
      const L = M0(K, E, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", L), T = new Map(R.instances);
      function d(M, l, S0) {
        if (!F0.TypeRegistry.Has(M) || !T.has(l))
          return false;
        const l$ = F0.TypeRegistry.Get(M), t$ = T.get(l);
        return l$(t$, S0);
      }
      function W0(M, l) {
        if (!F0.FormatRegistry.Has(M))
          return false;
        return F0.FormatRegistry.Get(M)(l);
      }
      function j0(M) {
        return (0, e9.Hash)(M);
      }
      const X0 = p(d, W0, j0);
      return new Q6(K, E, X0, L);
    }
    $.Compile = B1;
  })(MW || (NW.TypeCompiler = MW = {}));
});
var BW = J0((l0) => {
  var Z7 = l0 && l0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), Q7 = l0 && l0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        Z7(Y, $, W);
  };
  Object.defineProperty(l0, "__esModule", { value: true });
  l0.ValueErrorIterator = l0.ValueErrorType = undefined;
  var AW = I$();
  Object.defineProperty(l0, "ValueErrorType", { enumerable: true, get: function() {
    return AW.ValueErrorType;
  } });
  Object.defineProperty(l0, "ValueErrorIterator", { enumerable: true, get: function() {
    return AW.ValueErrorIterator;
  } });
  Q7(UW(), l0);
});
var bW = J0((K5, IW) => {
  var H7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, Q = 0, J = Y, z = LW;
    while (Y > -1 && Y < W) {
      var U = CW($[Y + 1], 4), D = CW($[Y + 2], 0), B = U | D, j = U6[B];
      if (z = U6[256 + z + j], Q = Q << 6 | B & U6[364 + j], z === LW)
        X += $.slice(Z, J), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = Y + 3, Y = J = $.indexOf("%", Z);
      else if (z === z7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, CW = function($, Y) {
    var W = q7[$];
    return W === undefined ? 255 : W << Y;
  }, LW = 12, z7 = 0, U6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], q7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  IW.exports = H7;
});
var VW = J0((j5, EW) => {
  var M7 = function($) {
    const Y = new _W;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", Q = -1, J = -1, z = false, U = false, D = false, B = false, j = false, b = 0;
    for (let S = 0;S < W + 1; S++)
      if (b = S !== W ? $.charCodeAt(S) : 38, b === 38) {
        if (j = J > Q, !j)
          J = S;
        if (X = $.slice(Q + 1, J), j || X.length > 0) {
          if (D)
            X = X.replace(RW, " ");
          if (z)
            X = GW(X) || X;
          if (j) {
            if (Z = $.slice(J + 1, S), B)
              Z = Z.replace(RW, " ");
            if (U)
              Z = GW(Z) || Z;
          }
          const N = Y[X];
          if (N === undefined)
            Y[X] = Z;
          else if (N.pop)
            N.push(Z);
          else
            Y[X] = [N, Z];
        }
        Z = "", Q = S, J = S, z = false, U = false, D = false, B = false;
      } else if (b === 61)
        if (J <= Q)
          J = S;
        else
          U = true;
      else if (b === 43)
        if (J > Q)
          B = true;
        else
          D = true;
      else if (b === 37)
        if (J > Q)
          U = true;
        else
          z = true;
    return Y;
  }, GW = bW(), RW = /\+/g, _W = function() {
  };
  _W.prototype = Object.create(null);
  EW.exports = M7;
});
var kW = J0((P5, xW) => {
  var F7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (N7[Q] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += Z1[Q];
          }
          if (++Z === Y)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, W += Z1[192 | Q >> 6] + Z1[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, W += Z1[224 | Q >> 12] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const J = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | J), W += Z1[240 | Q >> 18] + Z1[128 | Q >> 12 & 63] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, Z1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), N7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  xW.exports = { encodeString: F7 };
});
var TW = J0((O5, fW) => {
  var gW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return A6($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : A6("" + $);
    return "";
  }, U7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let J = 0;J < Z; J++) {
      const z = X[J], U = $[z], D = A6(z) + "=";
      if (J)
        Y += W;
      if (Array.isArray(U)) {
        Q = U.length;
        for (let B = 0;B < Q; B++) {
          if (B)
            Y += W;
          Y += D, Y += gW(U[B]);
        }
      } else
        Y += D, Y += gW(U);
    }
    return Y;
  }, { encodeString: A6 } = kW();
  fW.exports = U7;
});
var B6 = J0((S5, B$) => {
  var dW = VW(), yW = TW(), vW = { parse: dW, stringify: yW };
  B$.exports = vW;
  B$.exports.default = vW;
  B$.exports.parse = dW;
  B$.exports.stringify = yW;
});
var _1 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var L6 = ($, Y) => ({ ...$, part: Y });
var C6 = ($) => ({ paramName: $, store: null, inert: null });

class E1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let Q = Y.split(E1.regex.static), J = Y.match(E1.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = _1("/");
    let z = 0;
    for (let U = 0;U < Q.length; ++U) {
      let D = Q[U];
      if (U > 0) {
        let B = J[z++].slice(1);
        if (X.params === null)
          X.params = C6(B);
        else if (X.params.paramName !== B)
          throw Error(`Cannot create route "${Y}" with parameter "${B}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let j = X.params;
        if (j.inert === null) {
          X = j.inert = _1(D);
          continue;
        }
        X = j.inert;
      }
      for (let B = 0;; ) {
        if (B === D.length) {
          if (B < X.part.length) {
            let j = L6(X, X.part.slice(B));
            Object.assign(X, _1(D, [j]));
          }
          break;
        }
        if (B === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(B))) {
            X = X.inert.get(D.charCodeAt(B)), D = D.slice(B), B = 0;
            continue;
          }
          let j = _1(D.slice(B));
          X.inert.set(D.charCodeAt(B), j), X = j;
          break;
        }
        if (D[B] !== X.part[B]) {
          let j = L6(X, X.part.slice(B)), b = _1(D.slice(B));
          Object.assign(X, _1(X.part.slice(0, B), [j, b])), X = b;
          break;
        }
        ++B;
      }
    }
    if (z < J.length) {
      let U = J[z], D = U.slice(1);
      if (X.params === null)
        X.params = C6(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? r$(Y, Y.length, W, 0) : null;
  }
}
var r$ = ($, Y, W, X) => {
  let Z = W?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > Y)
      return null;
    if (Z.length < 15) {
      for (let J = 1, z = X + 1;J < Z.length; ++J, ++z)
        if (Z.charCodeAt(J) !== $.charCodeAt(z))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let J = W.inert.get($.charCodeAt(Q));
    if (J !== undefined) {
      let z = r$($, Y, J, Q);
      if (z !== null)
        return z;
    }
  }
  if (W.params !== null) {
    let J = W.params, z = $.indexOf("/", Q);
    if (z !== Q) {
      if (z === -1 || z >= Y) {
        if (J.store !== null) {
          let U = {};
          return U[J.paramName] = $.substring(Q, Y), { store: J.store, params: U };
        }
      } else if (J.inert !== null) {
        let U = r$($, Y, J.inert, z);
        if (U !== null)
          return U.params[J.paramName] = $.substring(Q, z), U;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(Q, Y) } } : null;
};
var G6 = Q1(b6(), 1);
var R6 = G6.default;
var _6 = ($, Y) => {
  return async function W(X) {
    const Z = X.id;
    if (X.event === "request" && X.type === "begin") {
      const Q = () => {
        let O, P, F = -1;
        const w = [], I = [];
        let G = false;
        const k = new Promise((o) => {
          O = (r) => {
            if (G)
              return;
            else
              G = true;
            o(r);
          };
        });
        let _ = false;
        const e = new Promise((o) => {
          P = (r) => {
            if (_)
              return;
            else
              _ = true;
            if (F === -1)
              F = 0;
            for (;F < I.length; F++) {
              let g0;
              const b0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((E0) => {
                E0(g0);
              }), children: [] };
              g0 = performance.now(), w[F](b0);
            }
            o(r);
          };
        });
        return { signal: k, consumeChild(o) {
          switch (o.type) {
            case "begin":
              w[++F]({ name: o.name, time: o.time, skip: false, end: new Promise((r) => {
                I.push(r);
              }) });
              break;
            case "end":
              I[F](o.time);
              break;
          }
        }, consume(o) {
          switch (o.type) {
            case "begin":
              const r = [], g0 = o.unit ?? 0;
              for (let b0 = 0;b0 < g0; b0++) {
                let E0;
                r.push(new Promise((H0) => {
                  E0 = H0;
                })), w.push(E0);
              }
              O({ name: o.name, time: o.time, skip: false, end: e, children: r });
              break;
            case "end":
              P(o.time);
              break;
          }
        }, resolve() {
          if (G && _)
            return;
          let o;
          const r = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((g0) => {
            g0(o);
          }), children: [] };
          o = performance.now(), O(r), P(o);
        } };
      }, J = Q(), z = Q(), U = Q(), D = Q(), B = Q(), j = Q(), b = Q(), S = Q();
      J.consume(X);
      const N = (O) => {
        if (O.id === Z)
          switch (O.event) {
            case "request":
              J.consume(O);
              break;
            case "request.unit":
              J.consumeChild(O);
              break;
            case "parse":
              z.consume(O);
              break;
            case "parse.unit":
              z.consumeChild(O);
              break;
            case "transform":
              U.consume(O);
              break;
            case "transform.unit":
              U.consumeChild(O);
              break;
            case "beforeHandle":
              D.consume(O);
              break;
            case "beforeHandle.unit":
              D.consumeChild(O);
              break;
            case "handle":
              B.consume(O);
              break;
            case "afterHandle":
              j.consume(O);
              break;
            case "afterHandle.unit":
              j.consumeChild(O);
              break;
            case "error":
              b.consume(O);
              break;
            case "error.unit":
              b.consumeChild(O);
              break;
            case "response":
              if (O.type === "begin")
                J.resolve(), z.resolve(), U.resolve(), D.resolve(), B.resolve(), j.resolve(), b.resolve();
              else
                $.off("event", N);
              S.consume(O);
              break;
            case "response.unit":
              S.consumeChild(O);
              break;
          }
      };
      $.on("event", N), await Y({ id: X.id, context: X.ctx, set: X.ctx?.set, store: X.ctx?.store, time: X.time, request: J.signal, parse: z.signal, transform: U.signal, beforeHandle: D.signal, handle: B.signal, afterHandle: j.signal, error: b.signal, response: S.signal }), $.emit(`res${Z}`, undefined);
    }
  };
};
var Y6 = Q1($6(), 1);
var HW = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var n1 = Symbol("ErrorCode");
var q$ = (HW?.NODE_ENV ?? HW?.ENV) === "production";

class f$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class S1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class M$ extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class P0 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = q$ ? undefined : Y.Errors(W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, Q = q$ ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(Y6.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(Q);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, P0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return Y6.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W6 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class c1 {
  $;
  Y;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator;
  }
  get publish() {
    return ($, Y = undefined, W) => {
      if (this.validator?.Check(Y) === false)
        throw new P0("message", this.validator, Y);
      if (typeof Y === "object")
        Y = JSON.stringify(Y);
      return this.raw.publish($, Y, W), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new P0("message", this.validator, $);
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var o9 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || c9, Q = 0;
  while (Q < $.length) {
    var J = $.indexOf("=", Q);
    if (J === -1)
      break;
    var z = $.indexOf(";", Q);
    if (z === -1)
      z = $.length;
    else if (z < J) {
      Q = $.lastIndexOf(";", J - 1) + 1;
      continue;
    }
    var U = $.slice(Q, J).trim();
    if (W[U] === undefined) {
      var D = $.slice(J + 1, z).trim();
      if (D.charCodeAt(0) === 34)
        D = D.slice(1, -1);
      W[U] = s9(D, Z);
    }
    Q = z + 1;
  }
  return W;
};
var n9 = function($, Y, W) {
  var X = W || {}, Z = X.encode || l9;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$.test($))
    throw new TypeError("argument name is invalid");
  var Q = Z(Y);
  if (Q && !T$.test(Q))
    throw new TypeError("argument val is invalid");
  var J = $ + "=" + Q;
  if (X.maxAge != null) {
    var z = X.maxAge - 0;
    if (isNaN(z) || !isFinite(z))
      throw new TypeError("option maxAge is invalid");
    J += "; Max-Age=" + Math.floor(z);
  }
  if (X.domain) {
    if (!T$.test(X.domain))
      throw new TypeError("option domain is invalid");
    J += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!T$.test(X.path))
      throw new TypeError("option path is invalid");
    J += "; Path=" + X.path;
  }
  if (X.expires) {
    var U = X.expires;
    if (!t9(U) || isNaN(U.valueOf()))
      throw new TypeError("option expires is invalid");
    J += "; Expires=" + U.toUTCString();
  }
  if (X.httpOnly)
    J += "; HttpOnly";
  if (X.secure)
    J += "; Secure";
  if (X.priority) {
    var D = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (D) {
      case "low":
        J += "; Priority=Low";
        break;
      case "medium":
        J += "; Priority=Medium";
        break;
      case "high":
        J += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var B = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (B) {
      case true:
        J += "; SameSite=Strict";
        break;
      case "lax":
        J += "; SameSite=Lax";
        break;
      case "strict":
        J += "; SameSite=Strict";
        break;
      case "none":
        J += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J;
};
var c9 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var l9 = function($) {
  return encodeURIComponent($);
};
var t9 = function($) {
  return h9.call($) === "[object Date]" || $ instanceof Date;
};
var s9 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$ = o9;
var y$ = n9;
var h9 = Object.prototype.toString;
var T$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$ = Q1(f0(), 1);
var U$ = Q1($6(), 1);
var H6 = Q1(BW(), 1);
var z6 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var J7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || t0(Object.getPrototypeOf($));
var U1 = ($, Y, { skipKeys: W } = {}) => {
  if (z6($) && z6(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!z6(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (J7(Z)) {
        $[X] = Z;
        continue;
      }
      $[X] = U1($[X], Z);
    }
  return $;
};
var DW = ($, Y) => U1($, Y, { skipKeys: ["properties"] });
var O0 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var C1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: U1(Y?.detail ?? {}, $?.detail ?? {}), parse: O0($?.parse ?? [], Y?.parse ?? []), transform: O0($?.transform ?? [], Y?.transform ?? []), beforeHandle: O0($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: O0($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: O0($?.onResponse ?? [], Y?.onResponse ?? []), trace: O0($?.trace ?? [], Y?.trace ?? []), error: O0($?.error ?? [], Y?.error ?? []) };
};
var X1 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => U$.Value.Check(Z, Q), Errors: (Q) => U$.Value.Errors(Z, Q), Code: () => "" };
  return H6.TypeCompiler.Compile(Z);
};
var q6 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, Q = (z) => {
    if (X)
      return { schema: z, references: "", checkFunc: () => {
      }, code: "", Check: (U) => U$.Value.Check(z, U), Errors: (U) => U$.Value.Errors(z, U), Code: () => "" };
    return H6.TypeCompiler.Compile(z);
  };
  if (i$.Kind in Z) {
    if (("additionalProperties" in Z) === false)
      Z.additionalProperties = W;
    return { 200: Q(Z) };
  }
  const J = {};
  return Object.keys(Z).forEach((z) => {
    const U = Z[+z];
    if (typeof U === "string") {
      if (U in Y) {
        const D = Y[U];
        D.type === "object" && ("additionalProperties" in D), J[+z] = (i$.Kind in D) ? Q(D) : D;
      }
      return;
    }
    if (U.type === "object" && ("additionalProperties" in U) === false)
      U.additionalProperties = W;
    J[+z] = (i$.Kind in U) ? Q(U) : U;
  }), J;
};
var M6 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var m$ = ($, Y, W) => {
  const X = (Z) => {
    if (W)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: O0($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: O0($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: O0($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: O0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: O0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: O0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: O0($.onResponse, (Y?.onResponse ?? []).map(X)), trace: O0($.trace, ("trace" in Y ? Y.trace ?? [] : []).map(X)), error: O0($.error, (Y?.error ?? []).map(X)), stop: O0($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var wW = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var l1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var N6 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: l1($?.parse), transform: l1($?.transform), beforeHandle: l1($?.beforeHandle), afterHandle: l1($?.afterHandle), onResponse: l1($?.onResponse), error: l1($?.error) };
};
var F6 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var KW = import.meta.require("crypto");
var I1 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  return $ + "." + KW.createHmac("sha256", Y).update($).digest("base64").replace(/\=+$/, "");
};
var u$ = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  var W = $.slice(0, $.lastIndexOf(".")), X = I1(W, Y), Z = Buffer.from(X), Q = Buffer.from($);
  return Z.length === Q.length && KW.timingSafeEqual(Z, Q) ? W : false;
};

class s0 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({ value: "", expires: new Date });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var jW = ($, Y, W) => new Proxy($, { get(X, Z) {
  if (Z in X)
    return X[Z];
  const Q = new s0(undefined, W ? { ...W } : undefined);
  return Q.setter = Y, Q.name = Z, Q;
}, set(X, Z, Q) {
  if (!(Q instanceof s0))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return Q.setter = Y, Q.name = Z, Q.sync(), X[Z] = Q, true;
} });
var h$ = ($, Y, { secret: W, sign: X, ...Z } = {}) => {
  if (!Y)
    return jW({}, $, Z);
  const Q = {}, J = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const z = Object.keys(d$(Y));
  for (let U = 0;U < z.length; U++) {
    const D = z[U];
    let B = d$(Y)[D];
    if (X === true || X?.includes(D)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (J) {
        if (B = u$(B, W), B === false)
          throw new M$(D);
      } else {
        let S = true;
        for (let N = 0;N < W.length; N++) {
          const O = u$(B, W[N]);
          if (O !== false) {
            B = O, S = false;
            break;
          }
        }
        if (S)
          throw new M$(D);
      }
    }
    const j = B.charCodeAt(0);
    if (j === 123 || j === 91)
      try {
        const S = new s0(JSON.parse(B));
        S.setter = $, S.name = D, Q[D] = S;
        continue;
      } catch {
      }
    if (!Number.isNaN(+B))
      B = +B;
    else if (B === "true")
      B = true;
    else if (B === "false")
      B = false;
    const b = new s0(B, Z);
    b.setter = $, b.name = D, Q[D] = b;
  }
  return jW(Q, $);
};
var PW = "toJSON" in new Headers;
var t0 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var OW = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var SW = ($) => {
  if (!$ || typeof $ !== "object" || !t0($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let Q = X.value[Z];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Y.push(y$(W, Q, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(y$(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var A1 = ($, Y) => {
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((Z) => A1(Z, Y));
      case "Function":
        return A1($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = K1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var r0 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q = r0(Z, Y);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return r0($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = r0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var K1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return A$($);
    case "Promise":
      return $.then((W) => {
        const X = K1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return K1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var A$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var pW = Q1(B6(), 1);
var A7 = new Headers().toJSON;
var iW = new RegExp(" (\\w+) = context", "g");
var mW = { value: 0 };
var uW = ({ hasTrace: $, hasTraceSet: Y = false, addFn: W, condition: X = {} }) => {
  if ($)
    return (Z, { name: Q, attribute: J = "", unit: z = 0 } = {}) => {
      const U = Z.indexOf("."), D = U === -1;
      if (Z !== "request" && Z !== "response" && !X[D ? Z : Z.slice(0, U)])
        return () => {
          if (Y && Z === "afterHandle")
            W("\nawait traceDone\n");
        };
      if (D)
        Q ||= Z;
      else
        Q ||= "anonymous";
      W("\n" + `reporter.emit('event', { 
					id,
					event: '${Z}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${D ? `unit: ${z},` : ""}
					${J}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let B = false;
      return () => {
        if (B)
          return;
        if (B = true, W("\n" + `reporter.emit('event', {
							id,
							event: '${Z}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && Z === "afterHandle")
          W("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var D$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var B7 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var K0 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [W];
  if (Z)
    Q.push(Z);
  for (let z of Y.matchAll(iW))
    Q.push(z[1]);
  const J = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [z] of Y.matchAll(J))
    if (z.includes(`{ ${$}`) || z.includes(`, ${$}`))
      return true;
  return false;
};
var w$ = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let J of $.matchAll(iW))
    Z.push(J[1]);
  for (let J of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t1 = Symbol.for("TypeBox.Kind");
var o$ = ($, Y) => {
  if (!Y)
    return;
  if ((t1 in Y) && Y[t1] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (o$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q = 0;Q < Z.anyOf.length; Q++)
          if (o$($, Z.anyOf[Q]))
            return true;
      }
      if ((t1 in Z) && Z[t1] === $)
        return true;
    }
    return false;
  }
  return Y.properties && (t1 in Y.properties) && Y.properties[t1] === $;
};
var D6 = Symbol.for("TypeBox.Transform");
var b1 = ($) => {
  if (!$)
    return;
  if ($.type === "object") {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (b1(X))
          return true;
      } else if (X.anyOf) {
        for (let Q = 0;Q < X.anyOf.length; Q++)
          if (b1(X.anyOf[Q]))
            return true;
      }
      if (D6 in X)
        return true;
    }
    return false;
  }
  return (D6 in $) || $.properties && (D6 in $.properties);
};
var D7 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && ("anyOf" in Y)) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var w7 = /(?:return|=>) \S*\(/g;
var N0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(w7);
};
var hW = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: Q, definitions: J, schema: z, onRequest: U, config: D, reporter: B }) => {
  const j = D.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, b = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((R, f) => `await res${f}(c)`).join(";")}})();\n` : "", S = W.trace.map((R) => R.toString());
  let N = false;
  if (w$(Z.toString()))
    N = true;
  if (!N)
    for (let [R, f] of Object.entries(W)) {
      if (!Array.isArray(f) || !f.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(R))
        continue;
      for (let i of f) {
        if (typeof i !== "function")
          continue;
        if (w$(i.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const O = { parse: S.some((R) => K0("parse", R)), transform: S.some((R) => K0("transform", R)), handle: S.some((R) => K0("handle", R)), beforeHandle: S.some((R) => K0("beforeHandle", R)), afterHandle: S.some((R) => K0("afterHandle", R)), error: j || S.some((R) => K0("error", R)) }, P = W.trace.length > 0;
  let F = "";
  if (P)
    F += "\nconst id = c.$$requestId\n";
  F += j ? "try {\n" : "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((R) => R.toString()) : [], I = N || Y !== "GET" && Y !== "HEAD" && W.type !== "none" && (!!X.body || !!W.type || w.some((R) => K0("body", R))), G = N || X.headers || w.some((R) => K0("headers", R)), k = N || X.cookie || w.some((R) => K0("cookie", R)), _ = X?.cookie?.schema;
  let e = "";
  if (_?.sign) {
    if (!_.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const R = !_.secrets ? undefined : typeof _.secrets === "string" ? _.secrets : _.secrets[0];
    if (e += `const _setCookie = c.set.cookie
		if(_setCookie) {`, _.sign === true)
      e += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = signCookie(cookie.value, '${R}')
			}`;
    else
      for (let f of _.sign)
        e += `if(_setCookie['${f}']?.value) { c.set.cookie['${f}'].value = signCookie(_setCookie['${f}'].value, '${R}') }\n`;
    e += "}\n";
  }
  const { composeValidation: o, composeResponseValidation: r } = B7(j);
  if (G)
    F += A7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (k) {
    const R = (i, n) => {
      const q0 = _?.[i] ?? n;
      if (!q0)
        return typeof n === "string" ? `${i}: "${n}",` : `${i}: ${n},`;
      if (typeof q0 === "string")
        return `${i}: '${q0}',`;
      if (q0 instanceof Date)
        return `${i}: new Date(${q0.getTime()}),`;
      return `${i}: ${q0},`;
    }, f = _ ? `{
			secret: ${_.secrets !== undefined ? typeof _.secrets === "string" ? `'${_.secrets}'` : "[" + _.secrets.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			sign: ${_.sign === true ? true : _.sign !== undefined ? "[" + _.sign.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			${R("domain")}
			${R("expires")}
			${R("httpOnly")}
			${R("maxAge")}
			${R("path", "/")}
			${R("priority")}
			${R("sameSite")}
			${R("secure")}
		}` : "undefined";
    if (G)
      F += `\nc.cookie = parseCookie(c.set, c.headers.cookie, ${f})\n`;
    else
      F += `\nc.cookie = parseCookie(c.set, c.request.headers.get('cookie'), ${f})\n`;
  }
  if (N || X.query || w.some((R) => K0("query", R)))
    F += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const E0 = W.trace.map((R) => R.toString()).some((R) => K0("set", R) || w$(R));
  N || W.trace.some((R) => K0("set", R.toString()));
  const H0 = E0 || k || w.some((R) => K0("set", R)) || U.some((R) => K0("set", R.toString())), z0 = uW({ hasTrace: P, hasTraceSet: E0, condition: O, addFn: (R) => {
    F += R;
  } });
  if (P)
    F += "\nconst traceDone = new Promise(r => { reporter.once(`res${id}`, r) })\n";
  const u0 = I || E0 || N0(Z) || W.parse.length > 0 || W.afterHandle.some(N0) || W.beforeHandle.some(N0) || W.transform.some(N0), a0 = z0("parse", { unit: W.parse.length });
  if (I) {
    const R = D7(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            F += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            F += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            F += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            F += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            F += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        F += "}}";
    } else {
      const i = (() => {
        if (W.parse.length && R && !Array.isArray(W.type)) {
          const n = X?.body?.schema;
          switch (R) {
            case "object":
              if (o$("File", n) || o$("Files", n))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (i)
        F += i;
      else {
        if (F += "\n", F += G ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", F += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          F += "let used = false\n";
          const n = z0("parse", { unit: W.parse.length });
          for (let q0 = 0;q0 < W.parse.length; q0++) {
            const B0 = z0("parse.unit", { name: W.parse[q0].name }), D0 = `bo${q0}`;
            if (q0 !== 0)
              F += "if(!used) {\n";
            if (F += `let ${D0} = parse[${q0}](c, contentType)\n`, F += `if(${D0} instanceof Promise) ${D0} = await ${D0}\n`, F += `if(${D0} !== undefined) { c.body = ${D0}; used = true }\n`, B0(), q0 !== 0)
              F += "}";
          }
          n();
        }
        if (W.parse.length)
          F += "if (!used)";
        F += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, F += "}\n";
      }
    }
    F += "\n";
  }
  if (a0(), W?.transform) {
    const R = z0("transform", { unit: W.transform.length });
    for (let f = 0;f < W.transform.length; f++) {
      const i = W.transform[f], n = z0("transform.unit", { name: i.name });
      if (i.$elysia === "derive")
        F += N0(W.transform[f]) ? `Object.assign(c, await transform[${f}](c));` : `Object.assign(c, transform[${f}](c));`;
      else
        F += N0(W.transform[f]) ? `await transform[${f}](c);` : `transform[${f}](c);`;
      n();
    }
    R();
  }
  if (X) {
    if (F += "\n", X.headers) {
      if (F += `if(headers.Check(c.headers) === false) {
				${o("headers")}
			}`, b1(X.headers.schema))
        F += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (F += `if(params.Check(c.params) === false) {
				${o("params")}
			}`, b1(X.params.schema))
        F += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (F += `if(query.Check(c.query) === false) {
				${o("query")} 
			}`, b1(X.query.schema))
        F += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (F += `if(body.Check(c.body) === false) { 
				${o("body")}
			}`, b1(X.body.schema))
        F += "\nc.body = body.Decode(c.body)\n";
    }
    if (t0(X.cookie?.schema.properties ?? {})) {
      if (F += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${o("cookie", "cookieValue")}
			}`, b1(X.cookie.schema))
        F += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const R = z0("beforeHandle", { unit: W.beforeHandle.length });
    for (let f = 0;f < W.beforeHandle.length; f++) {
      const i = z0("beforeHandle.unit", { name: W.beforeHandle[f].name }), n = `be${f}`;
      if (!D$(W.beforeHandle[f].toString()))
        F += N0(W.beforeHandle[f]) ? `await beforeHandle[${f}](c);\n` : `beforeHandle[${f}](c);\n`, i();
      else {
        F += N0(W.beforeHandle[f]) ? `let ${n} = await beforeHandle[${f}](c);\n` : `let ${n} = beforeHandle[${f}](c);\n`, i(), F += `if(${n} !== undefined) {\n`;
        const B0 = z0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const D0 = n;
          for (let w0 = 0;w0 < W.afterHandle.length; w0++) {
            const M0 = D$(W.afterHandle[w0].toString()), B1 = z0("afterHandle.unit", { name: W.afterHandle[w0].name });
            if (F += `c.response = ${D0}\n`, !M0)
              F += N0(W.afterHandle[w0]) ? `await afterHandle[${w0}](c, ${D0});\n` : `afterHandle[${w0}](c, ${D0});\n`;
            else {
              const K = `af${w0}`;
              F += N0(W.afterHandle[w0]) ? `const ${K} = await afterHandle[${w0}](c);\n` : `const ${K} = afterHandle[${w0}](c);\n`, F += `if(${K} !== undefined) { c.response = ${D0} = ${K} }\n`;
            }
            B1();
          }
        }
        if (B0(), X.response)
          F += r(n);
        F += e, F += `return mapEarlyResponse(${n}, c.set)}\n`;
      }
    }
    R();
  }
  if (W?.afterHandle.length) {
    const R = z0("handle", { name: Z.name });
    if (W.afterHandle.length)
      F += N0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    R();
    const f = z0("afterHandle", { unit: W.afterHandle.length });
    for (let i = 0;i < W.afterHandle.length; i++) {
      const n = `af${i}`, q0 = D$(W.afterHandle[i].toString()), B0 = z0("afterHandle.unit", { name: W.afterHandle[i].name });
      if (!q0)
        F += N0(W.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`, B0();
      else {
        if (X.response)
          F += N0(W.afterHandle[i]) ? `let ${n} = await afterHandle[${i}](c)\n` : `let ${n} = afterHandle[${i}](c)\n`;
        else
          F += N0(W.afterHandle[i]) ? `let ${n} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${n} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
        if (B0(), X.response)
          F += `if(${n} !== undefined) {`, F += r(n), F += `${n} = mapEarlyResponse(${n}, c.set)\n`, F += `if(${n}) {`, f(), F += `return ${n} } }`;
        else
          F += `if(${n}) {`, f(), F += `return ${n}}\n`;
      }
    }
    if (f(), F += "r = c.response\n", X.response)
      F += r();
    if (F += e, H0)
      F += "return mapResponse(r, c.set)\n";
    else
      F += "return mapCompactResponse(r)\n";
  } else {
    const R = z0("handle", { name: Z.name });
    if (X.response)
      if (F += N0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", R(), F += r(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else if (O.handle || k)
      if (F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", R(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else {
      R();
      const f = N0(Z) ? "await handler(c) " : "handler(c)";
      if (z0("afterHandle")(), H0)
        F += `return mapResponse(${f}, c.set)\n`;
      else
        F += `return mapCompactResponse(${f})\n`;
    }
  }
  if (j || b) {
    if (F += `
} catch(error) {`, !u0)
      F += "return (async () => {";
    F += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const R = z0("error", { unit: W.error.length });
    if (W.error.length)
      for (let f = 0;f < W.error.length; f++) {
        const i = `er${f}`, n = z0("error.unit", { name: W.error[f].name });
        if (F += `\nlet ${i} = handleErrors[${f}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, N0(W.error[f]))
          F += `if (${i} instanceof Promise) ${i} = await ${i}\n`;
        n(), F += `${i} = mapEarlyResponse(${i}, set)\n`, F += `if (${i}) {`, F += `return ${i} }\n`;
      }
    if (R(), F += "return handleError(c, error)\n\n", !u0)
      F += "})()";
    if (F += "}", b || P) {
      F += " finally { ";
      const f = z0("response", { unit: W.onResponse.length });
      F += b, f(), F += "}";
    }
  }
  return F = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		reporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((R, f) => `res${f} = onResponse[${f}]`).join(",")}` : ""}

	return ${u0 ? "async" : ""} function(c) {
		${z && J ? "c.schema = schema; c.defs = definitions;" : ""}
		${F}
	}`, Function("hooks", F)({ handler: Z, hooks: W, validator: X, handleError: Q, utils: { mapResponse: A1, mapCompactResponse: K1, mapEarlyResponse: r0, parseQuery: pW.parse }, error: { NotFoundError: S1, ValidationError: P0, InternalServerError: f$ }, schema: z, definitions: J, ERROR_CODE: n1, reporter: B, requestId: mW, parseCookie: h$, signCookie: I1 });
};
var w6 = ($) => {
  let Y = "", W = "";
  for (let j of Object.keys($.decorators))
    Y += `,${j}: app.decorators.${j}`;
  const { router: X, staticRouter: Z } = $, Q = $.event.trace.length > 0, J = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let z = "";
  for (let [j, { code: b, all: S }] of Object.entries(Z.map))
    z += `case '${j}':\nswitch(request.method) {\n${b}\n${S ?? "default: break map"}}\n\n`;
  const U = $.event.request.some(N0);
  W += `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		reporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${U ? "async" : ""} function map(request) {
	`;
  const D = $.event.trace.map((j) => j.toString()), B = uW({ hasTrace: Q, hasTraceSet: $.event.trace.some((j) => {
    const b = j.toString();
    return K0("set", b) || w$(b);
  }), condition: { request: D.some((j) => K0("request", j) || w$(j)) }, addFn: (j) => {
    W += j;
  } });
  if ($.event.request.length) {
    W += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const j = B("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let b = 0;b < $.event.request.length; b++) {
      const S = $.event.request[b], N = D$(S.toString()), O = N0(S), P = B("request.unit", { name: $.event.request[b].name }), F = `re${b}`;
      if (N)
        W += `const ${F} = mapEarlyResponse(
					${O ? "await" : ""} onRequest[${b}](ctx),
					ctx.set
				)\n`, P(), W += `if(${F}) return ${F}\n`;
      else
        W += `${O ? "await" : ""} onRequest[${b}](ctx)\n`, P();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, j(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Y}
		}`, B("request", { unit: $.event.request.length, attribute: D.some((j) => K0("context", j)) || D.some((j) => K0("store", j)) || D.some((j) => K0("set", j)) ? "ctx" : "" })();
  return W += `
		map: switch(path) {
			${z}

			default:
				break
		}

		${J}
	}`, $.handleError = K6($), Function("data", W)({ app: $, mapEarlyResponse: r0, NotFoundError: S1, reporter: $.reporter, requestId: mW });
};
var K6 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(N0) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${N0(X) ? "await " : ""}onError[${W}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (D$(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) return mapResponse(r${W}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: A1, ERROR_CODE: n1 });
};
var n$ = Q1(B6(), 1);
var j6 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, Q = Z.indexOf("/", 11), J = Z.indexOf("?", Q + 1), z = J === -1 ? Z.substring(Q) : Z.substring(Q, J);
  try {
    for (let P = 0;P < $.event.request.length; P++) {
      const F = $.event.request[P];
      let w = F(X);
      if (w instanceof Promise)
        w = await w;
      if (w = r0(w, W), w)
        return w;
    }
    const U = $.dynamicRouter.find(Y.method, z) ?? $.dynamicRouter.find("ALL", z);
    if (!U)
      throw new S1;
    const { handle: D, hooks: B, validator: j, content: b } = U.store;
    let S;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (b)
        switch (b) {
          case "application/json":
            S = await Y.json();
            break;
          case "text/plain":
            S = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            S = n$.parse(await Y.text());
            break;
          case "application/octet-stream":
            S = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            S = {};
            const P = await Y.formData();
            for (let F of P.keys()) {
              if (S[F])
                continue;
              const w = P.getAll(F);
              if (w.length === 1)
                S[F] = w[0];
              else
                S[F] = w;
            }
            break;
        }
      else {
        let P = Y.headers.get("content-type");
        if (P) {
          const F = P.indexOf(";");
          if (F !== -1)
            P = P.slice(0, F);
          for (let w = 0;w < $.event.parse.length; w++) {
            let I = $.event.parse[w](X, P);
            if (I instanceof Promise)
              I = await I;
            if (I) {
              S = I;
              break;
            }
          }
          if (S === undefined)
            switch (P) {
              case "application/json":
                S = await Y.json();
                break;
              case "text/plain":
                S = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                S = n$.parse(await Y.text());
                break;
              case "application/octet-stream":
                S = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                S = {};
                const w = await Y.formData();
                for (let I of w.keys()) {
                  if (S[I])
                    continue;
                  const G = w.getAll(I);
                  if (G.length === 1)
                    S[I] = G[0];
                  else
                    S[I] = G;
                }
                break;
            }
        }
      }
    X.body = S, X.params = U?.params || undefined, X.query = J === -1 ? {} : n$.parse(Z.substring(J + 1)), X.headers = {};
    for (let [P, F] of Y.headers.entries())
      X.headers[P] = F;
    const N = j?.cookie?.schema;
    X.cookie = h$(X.set, X.headers.cookie, N ? { secret: N.secrets !== undefined ? typeof N.secrets === "string" ? N.secrets : N.secrets.join(",") : undefined, sign: N.sign === true ? true : N.sign !== undefined ? typeof N.sign === "string" ? N.sign : N.sign.join(",") : undefined } : undefined);
    for (let P = 0;P < B.transform.length; P++) {
      const F = B.transform[P](X);
      if (B.transform[P].$elysia === "derive")
        if (F instanceof Promise)
          Object.assign(X, await F);
        else
          Object.assign(X, F);
      else if (F instanceof Promise)
        await F;
    }
    if (j) {
      if (j.headers) {
        const P = {};
        for (let F in Y.headers)
          P[F] = Y.headers.get(F);
        if (j.headers.Check(P) === false)
          throw new P0("header", j.headers, P);
      }
      if (j.params?.Check(X.params) === false)
        throw new P0("params", j.params, X.params);
      if (j.query?.Check(X.query) === false)
        throw new P0("query", j.query, X.query);
      if (j.cookie) {
        const P = {};
        for (let [F, w] of Object.entries(X.cookie))
          P[F] = w.value;
        if (j.cookie?.Check(P) === false)
          throw new P0("cookie", j.cookie, P);
      }
      if (j.body?.Check(S) === false)
        throw new P0("body", j.body, S);
    }
    for (let P = 0;P < B.beforeHandle.length; P++) {
      let F = B.beforeHandle[P](X);
      if (F instanceof Promise)
        F = await F;
      if (F !== undefined) {
        X.response = F;
        for (let I = 0;I < B.afterHandle.length; I++) {
          let G = B.afterHandle[I](X);
          if (G instanceof Promise)
            G = await G;
          if (G)
            F = G;
        }
        const w = r0(F, X.set);
        if (w)
          return w;
      }
    }
    let O = D(X);
    if (O instanceof Promise)
      O = await O;
    if (!B.afterHandle.length) {
      const P = j?.response?.[O.status];
      if (P?.Check(O) === false)
        throw new P0("response", P, O);
    } else {
      X.response = O;
      for (let P = 0;P < B.afterHandle.length; P++) {
        let F = B.afterHandle[P](X);
        if (F instanceof Promise)
          F = await F;
        const w = r0(F, X.set);
        if (w !== undefined) {
          const I = j?.response?.[O.status];
          if (I?.Check(w) === false)
            throw new P0("response", I, w);
          return w;
        }
      }
    }
    if (X.set.cookie && N?.sign) {
      const P = !N.secrets ? undefined : typeof N.secrets === "string" ? N.secrets : N.secrets[0];
      if (N.sign === true)
        for (let [F, w] of Object.entries(X.set.cookie))
          X.set.cookie[F].value = I1(w.value, "${secret}");
      else
        for (let F of N.sign) {
          if (!(F in N.properties))
            continue;
          if (X.set.cookie[F]?.value)
            X.set.cookie[F].value = I1(X.set.cookie[F].value, P);
        }
    }
    return A1(O, X.set);
  } catch (U) {
    if (U.status)
      W.status = U.status;
    return $.handleError(X, U);
  } finally {
    for (let U of $.event.onResponse)
      await U(X);
  }
};
var oW = ($) => async (Y, W) => {
  const X = Object.assign(Y, W);
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z](X);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return A1(Q, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var G1 = Q1(E$(), 1);
var Y0 = Q1(f0(), 1);
try {
  G1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), G1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), G1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), G1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var nW = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P6 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < nW($.minSize))
    return false;
  if ($.maxSize && Y.size > nW($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var K7 = G1.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return P6($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!P6($, Y[W]))
      return false;
  return true;
});
Y0.FormatRegistry.Set("numeric", ($) => !isNaN(+$));
Y0.FormatRegistry.Set("ObjectString", ($) => {
  let Y = $.charCodeAt(0);
  if (Y === 9 || Y === 10 || Y === 32)
    Y = $.trimStart().charCodeAt(0);
  if (Y !== 123 && Y !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var R1 = { Numeric: ($) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "numeric", default: 0 }), Y0.Type.Number($)])).Decode((Y) => {
  const W = +Y;
  if (isNaN(W))
    return Y;
  return W;
}).Encode((Y) => Y), ObjectString: ($, Y) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "ObjectString", default: "" }), Y0.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: G1.TypeSystem.Type("File", P6), Files: ($ = {}) => Y0.Type.Transform(Y0.Type.Union([K7($)])).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => Y0.Type.Union([Y0.Type.Null(), $]), MaybeEmpty: ($) => Y0.Type.Union([Y0.Type.Null(), Y0.Type.Undefined(), $]), Cookie: ($, Y) => Y0.Type.Object($, Y) };
Y0.Type.ObjectString = R1.ObjectString;
Y0.Type.Numeric = R1.Numeric;
Y0.Type.File = ($ = {}) => R1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
Y0.Type.Files = ($ = {}) => R1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
Y0.Type.Nullable = ($) => R1.Nullable($);
Y0.Type.MaybeEmpty = R1.MaybeEmpty;
Y0.Type.Cookie = R1.Cookie;

class c$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new R6;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new E1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  dynamicRouter = new E1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let J of Y) {
      if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix && !Q)
        J = this.config.prefix + J;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const z = this.definitions.type;
      let U = X1(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: z, additionalProperties: true });
      if (t0(this.config.cookie ?? {}))
        if (U)
          U.schema = DW(U.schema, this.config.cookie ?? {});
        else
          U = X1(Y0.Type.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: z, additionalProperties: true });
      const D = { body: X1(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: z }), headers: X1(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: z, additionalProperties: true }), params: X1(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: z }), query: X1(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: z }), cookie: U, response: q6(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: z }) }, B = C1(this.event, X), j = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J, { validator: D, hooks: B, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, j, { validator: D, hooks: B, content: X?.type, handle: W });
        this.routes.push({ method: $, path: J, composed: null, handler: W, hooks: B });
        return;
      }
      const b = hW({ path: J, method: $, hooks: B, validator: D, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, reporter: this.reporter }), S = this.routes.findIndex((N) => N.path === J && N.method === $);
      if (S !== -1)
        this.routes.splice(S, 1);
      if (this.routes.push({ method: $, path: J, composed: b, handler: W, hooks: B }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
        const N = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(b), this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`, !this.staticRouter.map[J])
          this.staticRouter.map[J] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J].all = `default: return st${N}(ctx)\n`;
        else
          this.staticRouter.map[J].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[J].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[j])
            this.staticRouter.map[j] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[j].all = `default: return st${N}(ctx)\n`;
          else
            this.staticRouter.map[j].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[j].code}`;
        }
      } else if (this.router.add($, J, b), !this.config.strictPath)
        this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", b);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _6(this.reporter, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[n1] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[n1] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = wW(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new c$({ ...this.config, prefix: "" });
    X.store = this.store;
    const Z = typeof Y === "object", Q = (Z ? W : Y)(X);
    if (this.decorators = U1(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    return this.model(Q.definitions.type), Object.values(X.routes).forEach(({ method: J, path: z, handler: U, hooks: D }) => {
      if (z = (Z ? "" : this.config.prefix) + $ + z, Z) {
        const B = Y, j = D;
        this.add(J, z, U, C1(B, { ...j, error: !j.error ? Q.event.error : Array.isArray(j.error) ? [...j.error, ...Q.event.error] : [j.error, ...Q.event.error] }));
      } else
        this.add(J, z, U, C1(D, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = m$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new c$;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = U1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: Q, handler: J, hooks: z }) => {
      this.add(Z, Q, J, C1($, { ...z, error: !z.error ? X.event.error : Array.isArray(z.error) ? [...z.error, ...X.event.error] : [z.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q) => {
          if (typeof Q === "function")
            return Q(this);
          if (typeof Q.default === "function")
            return Q.default(this);
          return this._use(Q);
        }).then((Q) => Q.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config;
    $.getServer = () => this.getServer();
    const X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Q = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((J) => Q === J))
          return this;
        this.dependencies[Y].push(Q);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Q) => {
        Object.assign(Q, this.decorators), Object.assign(Q.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const Z = this.mount($.fetch);
      return this.routes = this.routes.concat(Z.routes), this;
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q, handler: J, hooks: z } of Object.values($.routes))
      this.add(Z, Q, J, C1(z, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z), this.event = m$(this.event, N6($.event), Z);
      } else
        this.event = m$(this.event, N6($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, Q = async ({ request: J, path: z }) => Z(new Request("http://a.cc" + z || "/", J));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: Q }) => Y(new Request("http://a.cc" + Q.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    let X = null;
    const Z = X1(Y?.body, { models: this.definitions.type }), Q = X1(Y?.response, { models: this.definitions.type }), J = (z) => {
      const U = z.charCodeAt(0);
      if (U === 47 || U === 123)
        try {
          z = JSON.parse(z);
        } catch {
        }
      else if (!Number.isNaN(+z))
        z = +z;
      if (W?.length)
        for (let D = 0;D < W.length; D++) {
          const B = W[D](z);
          if (B !== undefined)
            z = B;
        }
      return z;
    };
    return this.get($, (z) => {
      const { set: U, path: D, qi: B, headers: j, query: b, params: S } = z;
      if (X === null)
        X = this.getServer();
      if (X?.upgrade(z.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(z) : Y.upgrade, data: { validator: Q, open(N) {
        Y.open?.(new c1(N, z));
      }, message: (N, O) => {
        const P = J(O);
        if (Z?.Check(P) === false)
          return void N.send(new P0("message", Z, P).message);
        Y.message?.(new c1(N, z), P);
      }, drain(N) {
        Y.drain?.(new c1(N, z));
      }, close(N, O, P) {
        Y.close?.(new c1(N, z), O, P);
      } } }))
        return;
      return U.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = U1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = U1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (U) => U[0].toUpperCase() + U.slice(1), Q = $ === "prefix" ? (U, D) => X.includes(U.at(-1) ?? "") ? U + D : U + Z(D) : X.includes(W.at(-1) ?? "") ? (U, D) => D + U : (U, D) => D + Z(U), J = (U) => {
      const D = {};
      switch (U) {
        case "decorator":
          for (let B in this.decorators)
            D[Q(W, B)] = this.decorators[B];
          this.decorators = D;
          break;
        case "state":
          for (let B in this.store)
            D[Q(W, B)] = this.store[B];
          this.store = D;
          break;
        case "model":
          for (let B in this.definitions.type)
            D[Q(W, B)] = this.definitions.type[B];
          this.definitions.type = D;
          break;
        case "error":
          for (let B in this.definitions.error)
            D[Q(W, B)] = this.definitions.error[B];
          this.definitions.error = D;
          break;
      }
    }, z = Array.isArray(Y) ? Y : [Y];
    for (let U of z.some((D) => D === "all") ? ["decorator", "state", "model", "error"] : z)
      J(U);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? w6(this) : j6(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w6(this) : j6(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? K6(this) : oW(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !q$, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W6 }, fetch: W, error: this.outerErrorHandler } : { development: !q$, ...this.config.serve, websocket: { ...this.config.websocket, ...W6 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X), this.event.start.length)
      (async () => {
        const Z = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Q = 0;Q < this.event.transform.length; Q++) {
          const J = this.event.transform[Q](Z);
          if (this.event.transform[Q].$elysia === "derive")
            if (J instanceof Promise)
              Object.assign(Z, await J);
            else
              Object.assign(Z, J);
        }
        for (let Q = 0;Q < this.event.start.length; Q++)
          this.event.start[Q](Z);
      })();
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      (async () => {
        const $ = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Y = 0;Y < this.event.transform.length; Y++) {
          const W = this.event.transform[Y]($);
          if (this.event.transform[Y].$elysia === "derive")
            if (W instanceof Promise)
              Object.assign($, await W);
            else
              Object.assign($, W);
        }
        for (let Y = 0;Y < this.event.stop.length; Y++)
          this.event.stop[Y]($);
      })();
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = Y0.Type;

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && (Symbol.asyncIterator in value);
}
function IsIterator(value) {
  return IsObject(value) && (Symbol.iterator in value);
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsUint8Array(value) {
  return value instanceof Uint8Array;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsPlainObject(value) {
  return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return IsNumber(value) && Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    const isNumber = IsNumber(value);
    return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  CloneType: () => {
    {
      return CloneType;
    }
  },
  CloneRest: () => {
    {
      return CloneRest;
    }
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined2;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol2;
    }
  },
  IsString: () => {
    {
      return IsString2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject2;
    }
  },
  IsNumber: () => {
    {
      return IsNumber2;
    }
  },
  IsNull: () => {
    {
      return IsNull2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction2;
    }
  },
  IsDate: () => {
    {
      return IsDate2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean2;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt2;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator2;
    }
  },
  IsArray: () => {
    {
      return IsArray2;
    }
  }
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && (Symbol.asyncIterator in value);
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && (Symbol.iterator in value);
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit = function(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey = function(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
};
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined3;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array3;
    }
  },
  IsTuple: () => {
    {
      return IsTuple;
    }
  },
  IsTransform: () => {
    {
      return IsTransform;
    }
  },
  IsThis: () => {
    {
      return IsThis;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol3;
    }
  },
  IsString: () => {
    {
      return IsString3;
    }
  },
  IsSchema: () => {
    {
      return IsSchema;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp2;
    }
  },
  IsRef: () => {
    {
      return IsRef;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise2;
    }
  },
  IsOptional: () => {
    {
      return IsOptional;
    }
  },
  IsObject: () => {
    {
      return IsObject3;
    }
  },
  IsNumber: () => {
    {
      return IsNumber3;
    }
  },
  IsNull: () => {
    {
      return IsNull3;
    }
  },
  IsNot: () => {
    {
      return IsNot;
    }
  },
  IsNever: () => {
    {
      return IsNever;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf;
    }
  },
  IsKind: () => {
    {
      return IsKind;
    }
  },
  IsIterator: () => {
    {
      return IsIterator3;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect;
    }
  },
  IsInteger: () => {
    {
      return IsInteger2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction3;
    }
  },
  IsDate: () => {
    {
      return IsDate3;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean3;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt3;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator3;
    }
  },
  IsArray: () => {
    {
      return IsArray3;
    }
  },
  IsAny: () => {
    {
      return IsAny;
    }
  }
});
var IsPattern = function(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value2) {
  if (!IsString2(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value2) {
  return IsOptionalBoolean(value2) || IsSchema(value2);
};
var IsOptionalBigInt = function(value2) {
  return IsUndefined2(value2) || IsBigInt2(value2);
};
var IsOptionalNumber = function(value2) {
  return IsUndefined2(value2) || IsNumber2(value2);
};
var IsOptionalBoolean = function(value2) {
  return IsUndefined2(value2) || IsBoolean2(value2);
};
var IsOptionalString = function(value2) {
  return IsUndefined2(value2) || IsString2(value2);
};
var IsOptionalPattern = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
};
var IsOptionalFormat = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2);
};
var IsOptionalSchema = function(value2) {
  return IsUndefined2(value2) || IsSchema(value2);
};
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsProperties(value2) {
  return IsObject2(value2) && Object.entries(value2).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect") && (IsString2(value2.type) && value2.type !== "object" ? false : true) && IsArray2(value2.allOf) && value2.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && (Kind in value2) && value2[Kind] === kind;
}
function IsLiteralString(value2) {
  return IsLiteral(value2) && IsString2(value2.const);
}
function IsLiteralNumber(value2) {
  return IsLiteral(value2) && IsNumber2(value2.const);
}
function IsLiteralBoolean(value2) {
  return IsLiteral(value2) && IsBoolean2(value2.const);
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
}
function IsLiteralValue(value2) {
  return IsBoolean2(value2) || IsNumber2(value2) || IsString2(value2);
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey") && IsArray2(value2.keys) && value2.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
}
function IsNever(value2) {
  return IsKindOf(value2, "Never") && IsObject2(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot(value2) {
  return IsKindOf(value2, "Not") && IsSchema(value2.not);
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && IsObject2(value2.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive(value2) {
  return IsObject2(value2) && (Hint in value2) && value2[Hint] === "Recursive";
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && IsString2(value2.source) && IsString2(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
}
function IsString3(value2) {
  return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && IsString2(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis(value2) {
  return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsTransform(value2) {
  return IsObject2(value2) && (TransformKind in value2);
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && IsNumber2(value2.minItems) && IsNumber2(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined2(value2.items) && IsUndefined2(value2.additionalItems) && value2.minItems === 0 || IsArray2(value2.items) && value2.items.every((schema) => IsSchema(schema)));
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
}
function IsUnionLiteral(value2) {
  return IsUnion(value2) && value2.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && IsObject2(value2) && IsArray2(value2.anyOf) && value2.anyOf.every((schema) => IsSchema(schema));
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
}
function IsKind(value2) {
  return IsObject2(value2) && (Kind in value2) && IsString2(value2[Kind]) && !KnownTypes.includes(value2[Kind]);
}
function IsSchema(value2) {
  return IsObject2(value2) && (IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
};
var AddOptional = function(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional(P[K2], F) };
  }, {});
};
var FromMappedResult = function(R, F) {
  return FromProperties(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(T) {
  return T.every((L) => IsOptional(L));
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var RemoveOptionalFromRest = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
};
var ResolveIntersect = function(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
};
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional = function(T) {
  return T.some((L) => IsOptional(L));
};
var RemoveOptionalFromRest2 = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
};
var RemoveOptionalFromType2 = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
};
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape = function(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
};
var FromUnion2 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, ...IndexPropertyKeys(L)];
  }, []);
};
var FromLiteral = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties2 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };
  }, {});
};
var FromMappedResult2 = function(T, R, options) {
  return FromProperties2(T, R.properties, options);
};
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest = function(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
};
var FromIntersectRest = function(T) {
  return T.filter((L) => !IsNever(L));
};
var FromIntersect = function(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
};
var FromUnionRest = function(T) {
  return T;
};
var FromUnion3 = function(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
};
var FromTuple = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
};
var FromArray = function(T, K) {
  return K === "[number]" ? T : Never();
};
var FromProperty = function(T, K) {
  return K in T ? T[K] : Never();
};
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
var FromSchema = function(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
};
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(T, K, options) {
  return { [K]: Index(T, [K], options) };
};
var MappedIndexPropertyKeys = function(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
};
var MappedIndexProperties = function(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
};
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
};
var AddReadonly = function(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties3 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly(K[K2], F) };
  }, {});
};
var FromMappedResult3 = function(R, F) {
  return FromProperties3(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  return T.reduce((Acc, L) => [...Acc, ...L], []);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult4 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  return P.reduce((Acc, L) => {
    return { ...Acc, [L]: Literal(L) };
  }, {});
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties4 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
  }, {});
};
var FromSchemaType = function(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
};
function MappedFunctionReturnType(K, T, Acc = {}) {
  return K.reduce((Acc2, L) => {
    return { ...Acc2, [L]: FromSchemaType(L, T) };
  }, {});
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest3 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, KeyOfPropertyKeys(L)];
  }, []);
};
var FromIntersect2 = function(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
};
var FromUnion4 = function(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
};
var FromTuple2 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf(K[K2], options) };
  }, {});
};
var FromMappedResult5 = function(R, options) {
  return FromProperties6(R.properties, options);
};
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction(error8) {
  switch (error8.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error8.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error8.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error8.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error8.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error8.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error8.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error8.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error8.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error8.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error8.schema.const === "string" ? `'${error8.schema.const}'` : error8.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error8.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error8.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error8.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error8.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error8.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error8.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error8.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error8.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error8.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error8.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error8.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}

class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
};
var BooleanType = function(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
};
var BigIntType = function(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
};
var NullType = function(value3) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
};
var StringType = function(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
};
var Uint8ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
};
var UndefinedType = function(value3) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit3 = function(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsPlainObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  value;
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined = function(value3) {
  return value3 !== undefined;
};
var Create = function(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
};
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  iterator;
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type3.IsNever(right) || exports_type3.IsIntersect(right) || exports_type3.IsUnion(right) || exports_type3.IsUnknown(right) || exports_type3.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type3.IsNever(right) ? FromNeverRight(left, right) : exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny2 = function(left, right) {
  return exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) && right.anyOf.some((schema) => exports_type3.IsAny(schema) || exports_type3.IsUnknown(schema)) ? ExtendsResult.True : exports_type3.IsUnion(right) ? ExtendsResult.Union : exports_type3.IsUnknown(right) ? ExtendsResult.True : exports_type3.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : exports_type3.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type3.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromAsyncIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromBigInt2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type3.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type3.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromDate2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type3.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type3.IsNumber(left) || exports_type3.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger2 = function(left, right) {
  return exports_type3.IsInteger(right) || exports_type3.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromLiteral3 = function(left, right) {
  return exports_type3.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsString(right) ? FromStringRight(left, right) : exports_type3.IsNumber(right) ? FromNumberRight(left, right) : exports_type3.IsInteger(right) ? FromIntegerRight(left, right) : exports_type3.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever2 = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type3.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot2 = function(left, right) {
  return exports_type3.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type3.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type3.IsLiteralNumber(left) ? ExtendsResult.True : exports_type3.IsNumber(left) || exports_type3.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsInteger(right) || exports_type3.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("description" in schema.properties) && exports_type3.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type3.IsString(schema.properties.description.anyOf[0]) && exports_type3.IsUndefined(schema.properties.description.anyOf[1]) || exports_type3.IsString(schema.properties.description.anyOf[1]) && exports_type3.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("length" in schema.properties) && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("length" in schema.properties) && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("then" in schema.properties) && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type3.IsOptional(left) && !exports_type3.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : exports_type3.IsNever(left) || exports_type3.IsLiteralString(left) && IsObjectStringLike(right) || exports_type3.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type3.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type3.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type3.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type3.IsString(left) && IsObjectStringLike(right) || exports_type3.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type3.IsNumber(left) && IsObjectNumberLike(right) || exports_type3.IsInteger(left) && IsObjectNumberLike(right) || exports_type3.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type3.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type3.IsDate(left) && IsObjectDateLike(right) || exports_type3.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type3.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type3.IsRecord(left) && exports_type3.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type3.IsRecord(left) && exports_type3.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : !exports_type3.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type3.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type3.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type3.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type3.IsLiteralString(left) && exports_type3.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type3.IsUint8Array(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsString(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsArray(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
};
var FromRegExp2 = function(left, right) {
  const L = exports_type3.IsRegExp(left) ? String2() : left;
  const R = exports_type3.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type3.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type3.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral3 = function(left, right) {
  return exports_type3.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type3.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type3.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type3.IsNever(left) ? ExtendsResult.True : exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple4 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type3.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type3.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsVoid(right) ? FromVoidRight(left, right) : exports_type3.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown2 = function(left, right) {
  return exports_type3.IsNever(right) ? FromNeverRight(left, right) : exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : exports_type3.IsString(right) ? FromStringRight(left, right) : exports_type3.IsNumber(right) ? FromNumberRight(left, right) : exports_type3.IsInteger(right) ? FromIntegerRight(left, right) : exports_type3.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type3.IsArray(right) ? FromArrayRight(left, right) : exports_type3.IsTuple(right) ? FromTupleRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type3.IsUndefined(left) ? ExtendsResult.True : exports_type3.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid2 = function(left, right) {
  return exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit5 = function(left, right) {
  return exports_type3.IsTemplateLiteral(left) || exports_type3.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type3.IsRegExp(left) || exports_type3.IsRegExp(right) ? FromRegExp2(left, right) : exports_type3.IsNot(left) || exports_type3.IsNot(right) ? FromNot2(left, right) : exports_type3.IsAny(left) ? FromAny2(left, right) : exports_type3.IsArray(left) ? FromArray4(left, right) : exports_type3.IsBigInt(left) ? FromBigInt2(left, right) : exports_type3.IsBoolean(left) ? FromBoolean2(left, right) : exports_type3.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type3.IsConstructor(left) ? FromConstructor2(left, right) : exports_type3.IsDate(left) ? FromDate2(left, right) : exports_type3.IsFunction(left) ? FromFunction2(left, right) : exports_type3.IsInteger(left) ? FromInteger2(left, right) : exports_type3.IsIntersect(left) ? FromIntersect4(left, right) : exports_type3.IsIterator(left) ? FromIterator2(left, right) : exports_type3.IsLiteral(left) ? FromLiteral3(left, right) : exports_type3.IsNever(left) ? FromNever2(left, right) : exports_type3.IsNull(left) ? FromNull2(left, right) : exports_type3.IsNumber(left) ? FromNumber2(left, right) : exports_type3.IsObject(left) ? FromObject2(left, right) : exports_type3.IsRecord(left) ? FromRecord2(left, right) : exports_type3.IsString(left) ? FromString2(left, right) : exports_type3.IsSymbol(left) ? FromSymbol2(left, right) : exports_type3.IsTuple(left) ? FromTuple4(left, right) : exports_type3.IsPromise(left) ? FromPromise2(left, right) : exports_type3.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type3.IsUndefined(left) ? FromUndefined2(left, right) : exports_type3.IsUnion(left) ? FromUnion6(left, right) : exports_type3.IsUnknown(left) ? FromUnknown2(left, right) : exports_type3.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties7 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined2 = function(value3) {
  return value3 !== undefined;
};
var FromAny3 = function(schema, references, value3) {
  return true;
};
var FromArray5 = function(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator3 = function(schema, references, value3) {
  return IsAsyncIterator(value3);
};
var FromBigInt3 = function(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean3 = function(schema, references, value3) {
  return IsBoolean(value3);
};
var FromConstructor3 = function(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
};
var FromDate3 = function(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction3 = function(schema, references, value3) {
  return IsFunction(value3);
};
var FromInteger3 = function(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect5 = function(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator3 = function(schema, references, value3) {
  return IsIterator(value3);
};
var FromLiteral4 = function(schema, references, value3) {
  return value3 === schema.const;
};
var FromNever3 = function(schema, references, value3) {
  return false;
};
var FromNot3 = function(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
};
var FromNull3 = function(schema, references, value3) {
  return IsNull(value3);
};
var FromNumber3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
};
var FromPromise3 = function(schema, references, value3) {
  return IsPromise(value3);
};
var FromRecord3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromRegExp3 = function(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
};
var FromString3 = function(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
};
var FromSymbol3 = function(schema, references, value3) {
  return IsSymbol(value3);
};
var FromTemplateLiteral4 = function(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
};
var FromThis2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromTuple5 = function(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
};
var FromUndefined3 = function(schema, references, value3) {
  return IsUndefined(value3);
};
var FromUnion7 = function(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
};
var FromUint8Array3 = function(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown3 = function(schema, references, value3) {
  return true;
};
var FromVoid3 = function(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
};
var FromKind2 = function(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
};
var Visit6 = function(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType3 = function(value3) {
  const keys = [...Object.getOwnPropertyNames(value3), ...Object.getOwnPropertySymbols(value3)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone2(value3[key]) }), {});
};
var ArrayType3 = function(value3) {
  return value3.map((element) => Clone2(element));
};
var TypedArrayType = function(value3) {
  return value3.slice();
};
var DateType3 = function(value3) {
  return new Date(value3.toISOString());
};
var ValueType = function(value3) {
  return value3;
};
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsPlainObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault = function(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArray6 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if (("contains" in schema) && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
};
var FromIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    return FromDefault(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit7(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord4 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit7(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion8 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
};
var SelectUnion = function(union9, references, value3) {
  let [select, best] = [union9.anyOf[0], 0];
  for (const schema of union9.anyOf) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
};
var DefaultClone = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
};
var Default = function(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
};
var FromArray7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
};
var FromIntersect7 = function(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsPlainObject(created) && IsPlainObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
};
var FromNever5 = function(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
};
var FromRecord5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromThis4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromTuple7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
};
var FromUnion9 = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
};
var Visit8 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var FromArray8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
};
var FromIntersect8 = function(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
};
var FromObject6 = function(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRecord6 = function(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRef5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromThis5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromTuple8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
};
var FromUnion10 = function(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
};
var Visit9 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys = function(T) {
  return T.reduce((Acc, L) => {
    return SetDistinct([...Acc, ...KeyOfPropertyKeys(L)]);
  }, []);
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  return T.reduce((Acc, L) => {
    return FilterNever([...Acc, ...IndexFromPropertyKeys(L, [K])]);
  }, []);
};
var CompositeProperties = function(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
};
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric = function(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
};
var IsValueToString = function(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
};
var IsValueTrue = function(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
};
var IsValueFalse = function(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
};
var IsTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsDateTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateString = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
};
var TryConvertLiteralString = function(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralNumber = function(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralBoolean = function(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteral = function(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
};
var TryConvertBoolean = function(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
};
var TryConvertBigInt = function(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
};
var TryConvertString = function(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
};
var TryConvertNumber = function(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertInteger = function(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertNull = function(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
};
var TryConvertUndefined = function(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
};
var TryConvertDate = function(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
};
var Default2 = function(value3) {
  return value3;
};
var FromArray9 = function(schema, references, value3) {
  if (IsArray(value3)) {
    return value3.map((value4) => Visit10(schema.items, references, value4));
  }
  return value3;
};
var FromBigInt5 = function(schema, references, value3) {
  return TryConvertBigInt(value3);
};
var FromBoolean5 = function(schema, references, value3) {
  return TryConvertBoolean(value3);
};
var FromDate5 = function(schema, references, value3) {
  return TryConvertDate(value3);
};
var FromInteger5 = function(schema, references, value3) {
  return TryConvertInteger(value3);
};
var FromIntersect9 = function(schema, references, value3) {
  const allObjects = schema.allOf.every((schema2) => IsObject3(schema2));
  if (allObjects)
    return Visit10(Composite(schema.allOf), references, value3);
  return Visit10(schema.allOf[0], references, value3);
};
var FromLiteral6 = function(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
};
var FromNull5 = function(schema, references, value3) {
  return TryConvertNull(value3);
};
var FromNumber5 = function(schema, references, value3) {
  return TryConvertNumber(value3);
};
var FromObject7 = function(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  return Object.getOwnPropertyNames(schema.properties).reduce((value4, key) => {
    return !IsUndefined(value4[key]) ? { ...value4, [key]: Visit10(schema.properties[key], references, value4[key]) } : { ...value4 };
  }, value3);
};
var FromRecord7 = function(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
};
var FromRef6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromString5 = function(schema, references, value3) {
  return TryConvertString(value3);
};
var FromSymbol5 = function(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
};
var FromThis6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromTuple9 = function(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
};
var FromUndefined5 = function(schema, references, value3) {
  return TryConvertUndefined(value3);
};
var FromUnion11 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (Check(subschema, references, converted)) {
      return converted;
    }
  }
  return value3;
};
var Visit10 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault = function(schema, value3) {
  return value3 === undefined && ("default" in schema) ? Clone2(schema.default) : value3;
};
var IsCheckable2 = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var IsDefaultSchema = function(value3) {
  return IsSchema(value3) && ("default" in value3);
};
var FromArray10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
};
var FromThis7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
};
var FromTuple10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion12 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit11 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
};
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate = function(path, value3) {
  return { type: "update", path, value: value3 };
};
var CreateInsert = function(path, value3) {
  return { type: "insert", path, value: value3 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
function* ObjectType4(path, current, next) {
  if (!IsPlainObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsPlainObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  value;
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType5 = function(left, right) {
  if (!IsPlainObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType4 = function(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
};
var ArrayType5 = function(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var TypedArrayType3 = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var ValueType3 = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsPlainObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType6 = function(root, path, current, next) {
  if (!IsPlainObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType6 = function(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType4 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType4 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit13 = function(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsPlainObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
};
var IsNonMutableValue = function(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
};
var IsMismatchedValue = function(current, next) {
  return IsPlainObject(current) && IsArray(next) || IsArray(current) && IsPlainObject(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default4 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, value3, error19);
  }
};
var FromArray11 = function(schema, references, value3) {
  return IsArray(value3) ? Default4(schema, value3.map((value4) => Visit14(schema.items, references, value4))) : Default4(schema, value3);
};
var FromIntersect11 = function(schema, references, value3) {
  if (!IsPlainObject(value3) || IsValueType(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(Index(schema, [key]), references, value4[key]) } : value4;
  }, value3);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromNot5 = function(schema, references, value3) {
  return Default4(schema, Visit14(schema.not, references, value3));
};
var FromObject9 = function(schema, references, value3) {
  if (!IsPlainObject(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(schema.properties[key], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRecord9 = function(schema, references, value3) {
  if (!IsPlainObject(value3))
    return Default4(schema, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit14(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRef8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromThis8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromTuple11 = function(schema, references, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, schema.items.map((schema2, index) => Visit14(schema2, references, value3[index]))) : Default4(schema, value3);
};
var FromUnion13 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, value3);
    return Default4(schema, decoded);
  }
  return Default4(schema, value3);
};
var Visit14 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, value3);
    case "Not":
      return FromNot5(schema_, references_, value3);
    case "Object":
      return FromObject9(schema_, references_, value3);
    case "Record":
      return FromRecord9(schema_, references_, value3);
    case "Ref":
      return FromRef8(schema_, references_, value3);
    case "Symbol":
      return Default4(schema_, value3);
    case "This":
      return FromThis8(schema_, references_, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, value3);
    case "Union":
      return FromUnion13(schema_, references_, value3);
    default:
      return Default4(schema_, value3);
  }
};
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error19) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error19) {
    super(`${error19 instanceof Error ? error19.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default5 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, value3, error20);
  }
};
var FromArray12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  return IsArray(defaulted) ? defaulted.map((value4) => Visit15(schema.items, references, value4)) : defaulted;
};
var FromIntersect12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3) || IsValueType(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in defaulted ? { ...value4, [key]: Visit15(Index(schema, [key]), references, value4[key]) } : value4;
  }, defaulted);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromNot6 = function(schema, references, value3) {
  return Default5(schema.not, Default5(schema, value3));
};
var FromObject10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit15(schema.properties[key], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRecord10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit15(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRef9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromThis9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromTuple12 = function(schema, references, value3) {
  const value1 = Default5(schema, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, value1[index])) : [];
};
var FromUnion14 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, value3);
    return Default5(schema, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, value1);
  }
  return Default5(schema, value3);
};
var Visit15 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, value3);
    case "Not":
      return FromNot6(schema_, references_, value3);
    case "Object":
      return FromObject10(schema_, references_, value3);
    case "Record":
      return FromRecord10(schema_, references_, value3);
    case "Ref":
      return FromRef9(schema_, references_, value3);
    case "This":
      return FromThis9(schema_, references_, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, value3);
    case "Union":
      return FromUnion14(schema_, references_, value3);
    default:
      return Default5(schema_, value3);
  }
};
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error20) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray13 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromAsyncIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromConstructor6 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromFunction5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromIntersect13 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
};
var FromIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.not, references);
};
var FromObject11 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
};
var FromPromise5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.item, references);
};
var FromRecord11 = function(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform(schema) || Visit16(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromThis10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromTuple13 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
};
var FromUnion15 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
};
var Visit16 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => {
    {
      return Patch2;
    }
  },
  Mutate: () => {
    {
      return Mutate2;
    }
  },
  Hash: () => {
    {
      return Hash2;
    }
  },
  Errors: () => {
    {
      return Errors2;
    }
  },
  Equal: () => {
    {
      return Equal2;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Diff: () => {
    {
      return Diff2;
    }
  },
  Default: () => {
    {
      return Default6;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create3;
    }
  },
  Convert: () => {
    {
      return Convert2;
    }
  },
  Clone: () => {
    {
      return Clone3;
    }
  },
  Clean: () => {
    {
      return Clean2;
    }
  },
  Check: () => {
    {
      return Check2;
    }
  },
  Cast: () => {
    {
      return Cast2;
    }
  }
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return TransformDecode(schema, references, value3);
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode(schema, references, value3);
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest4 = function(T) {
  return T.map((L) => AwaitedResolve(L));
};
var FromIntersect14 = function(T) {
  return Intersect(FromRest4(T));
};
var FromUnion16 = function(T) {
  return Union(FromRest4(T));
};
var FromPromise6 = function(T) {
  return AwaitedResolve(T);
};
var AwaitedResolve = function(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
};
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray14 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties8 = function(value4) {
  return globalThis.Object.getOwnPropertyNames(value4).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value4[key], false)) };
  }, {});
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value4, root) {
  return IsAsyncIterator2(value4) ? ConditionalReadonly(Any(), root) : IsIterator2(value4) ? ConditionalReadonly(Any(), root) : IsArray2(value4) ? Readonly(Tuple(FromArray14(value4))) : IsUint8Array2(value4) ? Uint8Array2() : IsDate2(value4) ? Date2() : IsObject2(value4) ? ConditionalReadonly(Object2(FromProperties8(value4)), root) : IsFunction2(value4) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value4) ? Undefined() : IsNull2(value4) ? Null() : IsSymbol2(value4) ? Symbol2() : IsBigInt2(value4) ? BigInt2() : IsNumber2(value4) ? Literal(value4) : IsBoolean2(value4) ? Literal(value4) : IsString2(value4) ? Literal(value4) : Object2({});
};
function Const(T, options = {}) {
  return exports_type2.CloneType(FromValue(T, true), options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest5 = function(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
};
var FromProperties9 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref2(properties[key], references) };
  }, {});
};
var FromConstructor7 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromFunction6 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromIntersect15 = function(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
};
var FromUnion17 = function(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
};
var FromTuple14 = function(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
};
var FromArray15 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromObject12 = function(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
};
var FromPromise7 = function(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
};
var FromAsyncIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromRef11 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
};
var DerefResolve = function(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
};
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value6) => Literal(value6));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties10 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
};
var FromMappedResult7 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties11 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
};
var FromMappedResult8 = function(R, T) {
  return FromProperties11(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value6) {
  const [first, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value6) {
  const [first, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value6) {
  return value6.toUpperCase();
};
var ApplyLowercase = function(value6) {
  return value6.toLowerCase();
};
var FromTemplateLiteral6 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value6) => Literal(value6));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
};
var FromLiteralValue = function(value6, mode) {
  return typeof value6 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value6) : mode === "Capitalize" ? ApplyCapitalize(value6) : mode === "Uppercase" ? ApplyUppercase(value6) : mode === "Lowercase" ? ApplyLowercase(value6) : value6 : value6.toString();
};
var FromRest6 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
};
var FromMappedResult9 = function(R, K, options) {
  return FromProperties12(R.properties, K, options);
};
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect16 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromUnion18 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromProperty2 = function(T, K) {
  const { [K]: _, ...R } = T;
  return R;
};
var FromProperties13 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty2(T2, K2);
  }, T);
};
var OmitResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
};
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
};
var FromPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
};
var FromMappedKey3 = function(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
};
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest7 = function(T) {
  return T.map((L) => PartialResolve(L));
};
var FromProperties14 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
};
var PartialResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
};
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties15 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
};
var FromMappedResult10 = function(R, options) {
  return FromProperties15(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties16 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
};
var FromMappedResult11 = function(R, K, options) {
  return FromProperties16(R.properties, K, options);
};
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect17 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromUnion19 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromProperties17 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
};
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
};
var FromPropertyKeys3 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
};
var FromMappedKey4 = function(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
};
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern = function(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
};
var RecordCreateFromKeys = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object2(P, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
};
var FromLiteralKey = function(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
};
var FromRegExpKey = function(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
};
var FromStringKey = function(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
};
var FromIntegerKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
var FromNumberKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest8 = function(T) {
  return T.map((L) => RequiredResolve(L));
};
var FromProperties18 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
};
var RequiredResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
};
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
};
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema) {
  return JSON.parse(JSON.stringify(schema));
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

class TransformDecodeBuilder {
  schema;
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  schema;
  decode;
  constructor(schema, decode2) {
    this.schema = schema;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema) {
    const Encode2 = (value10) => schema[TransformKind].Encode(encode2(value10));
    const Decode2 = (value10) => this.decode(schema[TransformKind].Decode(value10));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema = CloneType(this.schema);
    return IsTransform(schema) ? this.EncodeTransform(encode2, schema) : this.EncodeSchema(encode2, schema);
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type4 = {};
__export(exports_type4, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  Strict: () => {
    {
      return Strict;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Deref: () => {
    {
      return Deref2;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean2;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = exports_type4;
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Errors(value10) {
    return Errors(this.schema, this.references, value10);
  }
  Check(value10) {
    return this.checkFunc(value10);
  }
  Decode(value10) {
    if (!this.checkFunc(value10))
      throw new TransformDecodeCheckError(this.schema, value10, this.Errors(value10).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value10) : value10;
  }
  Encode(value10) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value10) : value10;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value10, this.Errors(value10).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value10) {
    if (value10.length === 0)
      return false;
    return Character.IsNumeric(value10.charCodeAt(0));
  }
  function IsAccessor(value10) {
    if (IsFirstCharacterNumeric(value10))
      return false;
    for (let i = 0;i < value10.length; i++) {
      const code = value10.charCodeAt(i);
      const check10 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check10)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object12, key) {
    return IsAccessor(key) ? `${object12}.${key}` : `${object12}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value10, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value10} ? ${expression} : true)` : `(${MemberExpression.Encode(value10, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value10) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value10} === 'object' && ${value10} !== null && !Array.isArray(${value10}))` : `(typeof ${value10} === 'object' && ${value10} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value10) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value10} === 'object' && ${value10} !== null && !Array.isArray(${value10}) && !(${value10} instanceof Date) && !(${value10} instanceof Uint8Array))` : `(typeof ${value10} === 'object' && ${value10} !== null && !(${value10} instanceof Date) && !(${value10} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value10) {
    return !TypeSystemPolicy.AllowNaN ? `(typeof ${value10} === 'number' && Number.isFinite(${value10}))` : `typeof ${value10} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value10) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value10} === undefined || ${value10} === null)` : `${value10} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value10) {
    yield "true";
  }
  function* FromArray16(schema, references, value10) {
    yield `Array.isArray(${value10})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema.maxItems))
      yield `${value10}.length <= ${schema.maxItems}`;
    if (IsNumber(schema.minItems))
      yield `${value10}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value10}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {
      const containsSchema = IsSchema(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check10 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check10}})(${value10})`;
    }
    if (schema.uniqueItems === true) {
      const check10 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check10} }`;
      yield `((${parameter}) => { ${block} )(${value10})`;
    }
  }
  function* FromAsyncIterator7(schema, references, value10) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value10})`;
  }
  function* FromBigInt6(schema, references, value10) {
    yield `(typeof ${value10} === 'bigint')`;
    if (IsBigInt(schema.exclusiveMaximum))
      yield `${value10} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt(schema.exclusiveMinimum))
      yield `${value10} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt(schema.maximum))
      yield `${value10} <= BigInt(${schema.maximum})`;
    if (IsBigInt(schema.minimum))
      yield `${value10} >= BigInt(${schema.minimum})`;
    if (IsBigInt(schema.multipleOf))
      yield `(${value10} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value10) {
    yield `(typeof ${value10} === 'boolean')`;
  }
  function* FromConstructor8(schema, references, value10) {
    yield* Visit17(schema.returns, references, `${value10}.prototype`);
  }
  function* FromDate6(schema, references, value10) {
    yield `(${value10} instanceof Date) && Number.isFinite(${value10}.getTime())`;
    if (IsNumber(schema.exclusiveMaximumTimestamp))
      yield `${value10}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema.exclusiveMinimumTimestamp))
      yield `${value10}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema.maximumTimestamp))
      yield `${value10}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber(schema.minimumTimestamp))
      yield `${value10}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber(schema.multipleOfTimestamp))
      yield `(${value10}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema, references, value10) {
    yield `(typeof ${value10} === 'function')`;
  }
  function* FromInteger6(schema, references, value10) {
    yield `(typeof ${value10} === 'number' && Number.isInteger(${value10}))`;
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value10} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value10} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value10} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value10} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value10} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema, references, value10) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value10)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value10}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value10}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value10}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema, references, value10) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value10})`;
  }
  function* FromLiteral7(schema, references, value10) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value10} === ${schema.const})`;
    } else {
      yield `(${value10} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value10) {
    yield `false`;
  }
  function* FromNot8(schema, references, value10) {
    const expression = CreateExpression(schema.not, references, value10);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value10) {
    yield `(${value10} === null)`;
  }
  function* FromNumber6(schema, references, value10) {
    yield Policy.IsNumberLike(value10);
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value10} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value10} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value10} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value10} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value10} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject13(schema, references, value10) {
    yield Policy.IsObjectLike(value10);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value10}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value10}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value10, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value10})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value10, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value10}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value10}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value10}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value10}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value10) {
    yield `(typeof value === 'object' && typeof ${value10}.then === 'function')`;
  }
  function* FromRecord12(schema, references, value10) {
    yield Policy.IsRecordLike(value10);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value10}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value10}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value10) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value10}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema, references, value10) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value10})`;
    yield* Visit17(target, references, value10);
  }
  function* FromRegExp5(schema, references, value10) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value10} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value10}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value10}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value10})`;
  }
  function* FromString6(schema, references, value10) {
    yield `(typeof ${value10} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value10}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value10}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value10})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value10})`;
    }
  }
  function* FromSymbol6(schema, references, value10) {
    yield `(typeof ${value10} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value10) {
    yield `(typeof ${value10} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value10})`;
  }
  function* FromThis11(schema, references, value10) {
    yield `${CreateFunctionName(schema.$ref)}(${value10})`;
  }
  function* FromTuple15(schema, references, value10) {
    yield `Array.isArray(${value10})`;
    if (schema.items === undefined)
      return yield `${value10}.length === 0`;
    yield `(${value10}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value10}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value10) {
    yield `${value10} === undefined`;
  }
  function* FromUnion20(schema, references, value10) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value10));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value10) {
    yield `${value10} instanceof Uint8Array`;
    if (IsNumber(schema.maxByteLength))
      yield `(${value10}.length <= ${schema.maxByteLength})`;
    if (IsNumber(schema.minByteLength))
      yield `(${value10}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value10) {
    yield "true";
  }
  function* FromVoid5(schema, references, value10) {
    yield Policy.IsVoidLike(value10);
  }
  function* FromKind4(schema, references, value10) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value10})`;
  }
  function* Visit17(schema, references, value10, useHoisting = true) {
    const references_ = IsString(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value10})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value10})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value10);
      case "Array":
        return yield* FromArray16(schema_, references_, value10);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value10);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value10);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value10);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value10);
      case "Date":
        return yield* FromDate6(schema_, references_, value10);
      case "Function":
        return yield* FromFunction7(schema_, references_, value10);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value10);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value10);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value10);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value10);
      case "Never":
        return yield* FromNever6(schema_, references_, value10);
      case "Not":
        return yield* FromNot8(schema_, references_, value10);
      case "Null":
        return yield* FromNull6(schema_, references_, value10);
      case "Number":
        return yield* FromNumber6(schema_, references_, value10);
      case "Object":
        return yield* FromObject13(schema_, references_, value10);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value10);
      case "Record":
        return yield* FromRecord12(schema_, references_, value10);
      case "Ref":
        return yield* FromRef12(schema_, references_, value10);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value10);
      case "String":
        return yield* FromString6(schema_, references_, value10);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value10);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value10);
      case "This":
        return yield* FromThis11(schema_, references_, value10);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value10);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value10);
      case "Union":
        return yield* FromUnion20(schema_, references_, value10);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value10);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value10);
      case "Void":
        return yield* FromVoid5(schema_, references_, value10);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value10);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value10, useHoisting = true) {
    return `(${[...Visit17(schema, references, value10, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value10, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value10, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type73) {
    const annotation = state.language === "typescript" ? `: ${type73}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type73) {
    return state.language === "typescript" ? `: ${type73}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value10) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value10);
    }
    function formatRegistryFunction(format, value10) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value10);
    }
    function hashFunction(value10) {
      return Hash(value10);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/node_modules/elysia/dist/bun/index.js
var Z$ = Object.create;
var { defineProperty: z1, getPrototypeOf: W$, getOwnPropertyNames: X$ } = Object;
var B$ = Object.prototype.hasOwnProperty;
var S0 = ($, J, Z) => {
  Z = $ != null ? Z$(W$($)) : {};
  const W = J || !$ || !$.__esModule ? z1(Z, "default", { value: $, enumerable: true }) : Z;
  for (let X of X$($))
    if (!B$.call(W, X))
      z1(W, X, { get: () => $[X], enumerable: true });
  return W;
};
var B0 = ($, J) => () => (J || $((J = { exports: {} }).exports, J), J.exports);
var I12 = B0((k$, i0) => {
  var O02 = function() {
  }, Q$2 = function($, J, Z) {
    this.fn = $, this.context = J, this.once = Z || false;
  }, O1 = function($, J, Z, W, X) {
    if (typeof Z !== "function")
      throw new TypeError("The listener must be a function");
    var B = new Q$2(Z, W || $, X), Y = f ? f + J : J;
    if (!$._events[Y])
      $._events[Y] = B, $._eventsCount++;
    else if (!$._events[Y].fn)
      $._events[Y].push(B);
    else
      $._events[Y] = [$._events[Y], B];
    return $;
  }, E0 = function($, J) {
    if (--$._eventsCount === 0)
      $._events = new O02;
    else
      delete $._events[J];
  }, g = function() {
    this._events = new O02, this._eventsCount = 0;
  }, Y$2 = Object.prototype.hasOwnProperty, f = "~";
  if (Object.create) {
    if (O02.prototype = Object.create(null), !new O02().__proto__)
      f = false;
  }
  g.prototype.eventNames = function $() {
    var J = [], Z, W;
    if (this._eventsCount === 0)
      return J;
    for (W in Z = this._events)
      if (Y$2.call(Z, W))
        J.push(f ? W.slice(1) : W);
    if (Object.getOwnPropertySymbols)
      return J.concat(Object.getOwnPropertySymbols(Z));
    return J;
  };
  g.prototype.listeners = function $(J) {
    var Z = f ? f + J : J, W = this._events[Z];
    if (!W)
      return [];
    if (W.fn)
      return [W.fn];
    for (var X = 0, B = W.length, Y = new Array(B);X < B; X++)
      Y[X] = W[X].fn;
    return Y;
  };
  g.prototype.listenerCount = function $(J) {
    var Z = f ? f + J : J, W = this._events[Z];
    if (!W)
      return 0;
    if (W.fn)
      return 1;
    return W.length;
  };
  g.prototype.emit = function $(J, Z, W, X, B, Y) {
    var D = f ? f + J : J;
    if (!this._events[D])
      return false;
    var Q = this._events[D], G = arguments.length, z, U;
    if (Q.fn) {
      if (Q.once)
        this.removeListener(J, Q.fn, undefined, true);
      switch (G) {
        case 1:
          return Q.fn.call(Q.context), true;
        case 2:
          return Q.fn.call(Q.context, Z), true;
        case 3:
          return Q.fn.call(Q.context, Z, W), true;
        case 4:
          return Q.fn.call(Q.context, Z, W, X), true;
        case 5:
          return Q.fn.call(Q.context, Z, W, X, B), true;
        case 6:
          return Q.fn.call(Q.context, Z, W, X, B, Y), true;
      }
      for (U = 1, z = new Array(G - 1);U < G; U++)
        z[U - 1] = arguments[U];
      Q.fn.apply(Q.context, z);
    } else {
      var V = Q.length, N;
      for (U = 0;U < V; U++) {
        if (Q[U].once)
          this.removeListener(J, Q[U].fn, undefined, true);
        switch (G) {
          case 1:
            Q[U].fn.call(Q[U].context);
            break;
          case 2:
            Q[U].fn.call(Q[U].context, Z);
            break;
          case 3:
            Q[U].fn.call(Q[U].context, Z, W);
            break;
          case 4:
            Q[U].fn.call(Q[U].context, Z, W, X);
            break;
          default:
            if (!z)
              for (N = 1, z = new Array(G - 1);N < G; N++)
                z[N - 1] = arguments[N];
            Q[U].fn.apply(Q[U].context, z);
        }
      }
    }
    return true;
  };
  g.prototype.on = function $(J, Z, W) {
    return O1(this, J, Z, W, false);
  };
  g.prototype.once = function $(J, Z, W) {
    return O1(this, J, Z, W, true);
  };
  g.prototype.removeListener = function $(J, Z, W, X) {
    var B = f ? f + J : J;
    if (!this._events[B])
      return this;
    if (!Z)
      return E0(this, B), this;
    var Y = this._events[B];
    if (Y.fn) {
      if (Y.fn === Z && (!X || Y.once) && (!W || Y.context === W))
        E0(this, B);
    } else {
      for (var D = 0, Q = [], G = Y.length;D < G; D++)
        if (Y[D].fn !== Z || X && !Y[D].once || W && Y[D].context !== W)
          Q.push(Y[D]);
      if (Q.length)
        this._events[B] = Q.length === 1 ? Q[0] : Q;
      else
        E0(this, B);
    }
    return this;
  };
  g.prototype.removeAllListeners = function $(J) {
    var Z;
    if (J) {
      if (Z = f ? f + J : J, this._events[Z])
        E0(this, Z);
    } else
      this._events = new O02, this._eventsCount = 0;
    return this;
  };
  g.prototype.off = g.prototype.removeListener;
  g.prototype.addListener = g.prototype.on;
  g.prefixed = f;
  g.EventEmitter = g;
  if (typeof i0 !== "undefined")
    i0.exports = g;
});
var W1 = B0((D72, E12) => {
  var N$ = function($) {
    var J = $.indexOf("%");
    if (J === -1)
      return $;
    var Z = $.length, W = "", X = 0, B = 0, Y = J, D = R12;
    while (J > -1 && J < Z) {
      var Q = S12($[J + 1], 4), G = S12($[J + 2], 0), z = Q | G, U = Z1[z];
      if (D = Z1[256 + D + U], B = B << 6 | z & Z1[364 + U], D === R12)
        W += $.slice(X, Y), W += B <= 65535 ? String.fromCharCode(B) : String.fromCharCode(55232 + (B >> 10), 56320 + (B & 1023)), B = 0, X = J + 3, J = Y = $.indexOf("%", X);
      else if (D === F$)
        return null;
      else {
        if (J += 3, J < Z && $.charCodeAt(J) === 37)
          continue;
        return null;
      }
    }
    return W + $.slice(X);
  }, S12 = function($, J) {
    var Z = j$[$];
    return Z === undefined ? 255 : Z << J;
  }, R12 = 12, F$ = 0, Z1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], j$ = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  E12.exports = N$;
});
var g1 = B0((G7, x1) => {
  var V$ = function($) {
    const J = new L1;
    if (typeof $ !== "string")
      return J;
    let Z = $.length, W = "", X = "", B = -1, Y = -1, D = false, Q = false, G = false, z = false, U = false, V = 0;
    for (let N = 0;N < Z + 1; N++)
      if (V = N !== Z ? $.charCodeAt(N) : 38, V === 38) {
        if (U = Y > B, !U)
          Y = N;
        if (W = $.slice(B + 1, Y), U || W.length > 0) {
          if (G)
            W = W.replace(b12, " ");
          if (D)
            W = H1(W) || W;
          if (U) {
            if (X = $.slice(Y + 1, N), z)
              X = X.replace(b12, " ");
            if (Q)
              X = H1(X) || X;
          }
          const K = J[W];
          if (K === undefined)
            J[W] = X;
          else if (K.pop)
            K.push(X);
          else
            J[W] = [K, X];
        }
        X = "", B = N, Y = N, D = false, Q = false, G = false, z = false;
      } else if (V === 61)
        if (Y <= B)
          Y = N;
        else
          Q = true;
      else if (V === 43)
        if (Y > B)
          z = true;
        else
          G = true;
      else if (V === 37)
        if (Y > B)
          Q = true;
        else
          D = true;
    return J;
  }, H1 = W1(), b12 = /\+/g, L1 = function() {
  };
  L1.prototype = Object.create(null);
  x1.exports = V$;
});
var y1 = B0((z7, f1) => {
  var q$2 = function($) {
    const J = $.length;
    if (J === 0)
      return "";
    let Z = "", W = 0, X = 0;
    $:
      for (;X < J; X++) {
        let B = $.charCodeAt(X);
        while (B < 128) {
          if (T$2[B] !== 1) {
            if (W < X)
              Z += $.slice(W, X);
            W = X + 1, Z += i[B];
          }
          if (++X === J)
            break $;
          B = $.charCodeAt(X);
        }
        if (W < X)
          Z += $.slice(W, X);
        if (B < 2048) {
          W = X + 1, Z += i[192 | B >> 6] + i[128 | B & 63];
          continue;
        }
        if (B < 55296 || B >= 57344) {
          W = X + 1, Z += i[224 | B >> 12] + i[128 | B >> 6 & 63] + i[128 | B & 63];
          continue;
        }
        if (++X, X >= J)
          throw new Error("URI malformed");
        const Y = $.charCodeAt(X) & 1023;
        W = X + 1, B = 65536 + ((B & 1023) << 10 | Y), Z += i[240 | B >> 18] + i[128 | B >> 12 & 63] + i[128 | B >> 6 & 63] + i[128 | B & 63];
      }
    if (W === 0)
      return $;
    if (W < J)
      return Z + $.slice(W);
    return Z;
  }, i = Array.from({ length: 256 }, ($, J) => "%" + ((J < 16 ? "0" : "") + J.toString(16)).toUpperCase()), T$2 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  f1.exports = { encodeString: q$2 };
});
var u1 = B0((K72, k1) => {
  var v1 = function($) {
    const J = typeof $;
    if (J === "string")
      return X12($);
    else if (J === "bigint")
      return $.toString();
    else if (J === "boolean")
      return $ ? "true" : "false";
    else if (J === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : X12("" + $);
    return "";
  }, w$2 = function($) {
    let J = "";
    if ($ === null || typeof $ !== "object")
      return J;
    const Z = "&", W = Object.keys($), X = W.length;
    let B = 0;
    for (let Y = 0;Y < X; Y++) {
      const D = W[Y], Q = $[D], G = X12(D) + "=";
      if (Y)
        J += Z;
      if (Array.isArray(Q)) {
        B = Q.length;
        for (let z = 0;z < B; z++) {
          if (z)
            J += Z;
          J += G, J += v1(Q[z]);
        }
      } else
        J += G, J += v1(Q);
    }
    return J;
  }, { encodeString: X12 } = y1();
  k1.exports = w$2;
});
var B1 = B0((U7, N02) => {
  var m1 = g1(), h1 = u1(), c12 = { parse: m1, stringify: h1 };
  N02.exports = c12;
  N02.exports.default = c12;
  N02.exports.parse = m1;
  N02.exports.stringify = h1;
});
var Y02 = ($, J) => ({ part: $, store: null, inert: J !== undefined ? new Map(J.map((Z) => [Z.part.charCodeAt(0), Z])) : null, params: null, wildcardStore: null });
var K12 = ($, J) => ({ ...$, part: J });
var U12 = ($) => ({ paramName: $, store: null, inert: null });

class s {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, J, Z) {
    let W;
    if (typeof J != "string")
      throw TypeError("Route path must be a string");
    J === "" ? J = "/" : J[0] !== "/" && (J = `/${J}`), this.history.push([$, J, Z]);
    let X = J[J.length - 1] === "*";
    X && (J = J.slice(0, -1));
    let B = J.split(s.regex.static), Y = J.match(s.regex.params) || [];
    B[B.length - 1] === "" && B.pop(), W = this.root[$] ? this.root[$] : this.root[$] = Y02("/");
    let D = 0;
    for (let Q = 0;Q < B.length; ++Q) {
      let G = B[Q];
      if (Q > 0) {
        let z = Y[D++].slice(1);
        if (W.params === null)
          W.params = U12(z);
        else if (W.params.paramName !== z)
          throw Error(`Cannot create route "${J}" with parameter "${z}" because a route already exists with a different parameter name ("${W.params.paramName}") in the same location`);
        let U = W.params;
        if (U.inert === null) {
          W = U.inert = Y02(G);
          continue;
        }
        W = U.inert;
      }
      for (let z = 0;; ) {
        if (z === G.length) {
          if (z < W.part.length) {
            let U = K12(W, W.part.slice(z));
            Object.assign(W, Y02(G, [U]));
          }
          break;
        }
        if (z === W.part.length) {
          if (W.inert === null)
            W.inert = new Map;
          else if (W.inert.has(G.charCodeAt(z))) {
            W = W.inert.get(G.charCodeAt(z)), G = G.slice(z), z = 0;
            continue;
          }
          let U = Y02(G.slice(z));
          W.inert.set(G.charCodeAt(z), U), W = U;
          break;
        }
        if (G[z] !== W.part[z]) {
          let U = K12(W, W.part.slice(z)), V = Y02(G.slice(z));
          Object.assign(W, Y02(W.part.slice(0, z), [U, V])), W = V;
          break;
        }
        ++z;
      }
    }
    if (D < Y.length) {
      let Q = Y[D], G = Q.slice(1);
      if (W.params === null)
        W.params = U12(G);
      else if (W.params.paramName !== G)
        throw Error(`Cannot create route "${J}" with parameter "${G}" because a route already exists with a different parameter name ("${W.params.paramName}") in the same location`);
      return W.params.store === null && (W.params.store = Z), W.params.store;
    }
    return X ? (W.wildcardStore === null && (W.wildcardStore = Z), W.wildcardStore) : (W.store === null && (W.store = Z), W.store);
  }
  find($, J) {
    let Z = this.root[$];
    return Z ? p0(J, J.length, Z, 0) : null;
  }
}
var p0 = ($, J, Z, W) => {
  let X = Z?.part, B = W + X.length;
  if (X.length > 1) {
    if (B > J)
      return null;
    if (X.length < 15) {
      for (let Y = 1, D = W + 1;Y < X.length; ++Y, ++D)
        if (X.charCodeAt(Y) !== $.charCodeAt(D))
          return null;
    } else if ($.substring(W, B) !== X)
      return null;
  }
  if (B === J)
    return Z.store !== null ? { store: Z.store, params: {} } : Z.wildcardStore !== null ? { store: Z.wildcardStore, params: { "*": "" } } : null;
  if (Z.inert !== null) {
    let Y = Z.inert.get($.charCodeAt(B));
    if (Y !== undefined) {
      let D = p0($, J, Y, B);
      if (D !== null)
        return D;
    }
  }
  if (Z.params !== null) {
    let Y = Z.params, D = $.indexOf("/", B);
    if (D !== B) {
      if (D === -1 || D >= J) {
        if (Y.store !== null) {
          let Q = {};
          return Q[Y.paramName] = $.substring(B, J), { store: Y.store, params: Q };
        }
      } else if (Y.inert !== null) {
        let Q = p0($, J, Y.inert, D);
        if (Q !== null)
          return Q.params[Y.paramName] = $.substring(B, D), Q;
      }
    }
  }
  return Z.wildcardStore !== null ? { store: Z.wildcardStore, params: { "*": $.substring(B, J) } } : null;
};
var M1 = S0(I12(), 1);
var A12 = M1.default;
var H0 = () => {
  let $;
  return [new Promise((Z) => {
    $ = Z;
  }), $];
};
var t = () => {
  const [$, J] = H0(), [Z, W] = H0(), X = [], B = [];
  return { signal: $, consume: (Y) => {
    switch (Y.type) {
      case "begin":
        if (Y.unit && X.length === 0)
          for (let D = 0;D < Y.unit; D++) {
            const [Q, G] = H0(), [z, U] = H0();
            X.push(Q), B.push([(V) => {
              G({ children: [], end: z, name: V.name ?? "", skip: false, time: V.time });
            }, (V) => {
              U(V);
            }]);
          }
        J({ children: X, end: Z, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        W(Y.time);
        break;
    }
  }, consumeChild(Y) {
    switch (Y.type) {
      case "begin":
        if (!B[0])
          return;
        const [D] = B[0];
        D({ children: [], end: Z, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        const Q = B.shift();
        if (!Q)
          return;
        Q[1](Y.time);
    }
  }, resolve() {
    J({ children: [], end: new Promise((Y) => Y(0)), name: "", skip: true, time: 0 });
    for (let [Y, D] of B)
      Y({ children: [], end: new Promise((Q) => Q(0)), name: "", skip: true, time: 0 }), D(0);
    W(0);
  } };
};
var P1 = ($, J, Z) => {
  return async function W(W) {
    if (W.event !== "request" || W.type !== "begin")
      return;
    const X = W.id, B = $(), Y = t(), D = t(), Q = t(), G = t(), z = t(), U = t(), V = t(), N = t();
    Y.consume(W);
    const K = (j) => {
      if (j.id === X)
        switch (j.event) {
          case "request":
            Y.consume(j);
            break;
          case "request.unit":
            Y.consumeChild(j);
            break;
          case "parse":
            D.consume(j);
            break;
          case "parse.unit":
            D.consumeChild(j);
            break;
          case "transform":
            Q.consume(j);
            break;
          case "transform.unit":
            Q.consumeChild(j);
            break;
          case "beforeHandle":
            G.consume(j);
            break;
          case "beforeHandle.unit":
            G.consumeChild(j);
            break;
          case "handle":
            z.consume(j);
            break;
          case "afterHandle":
            U.consume(j);
            break;
          case "afterHandle.unit":
            U.consumeChild(j);
            break;
          case "error":
            V.consume(j);
            break;
          case "error.unit":
            V.consumeChild(j);
            break;
          case "response":
            if (j.type === "begin")
              Y.resolve(), D.resolve(), Q.resolve(), G.resolve(), z.resolve(), U.resolve(), V.resolve();
            else
              B.off("event", K);
            N.consume(j);
            break;
          case "response.unit":
            N.consumeChild(j);
            break;
          case "exit":
            Y.resolve(), D.resolve(), Q.resolve(), G.resolve(), z.resolve(), U.resolve(), V.resolve();
            break;
        }
    };
    B.on("event", K), await Z({ id: X, context: W.ctx, set: W.ctx?.set, store: W.ctx?.store, time: W.time, request: Y.signal, parse: D.signal, transform: Q.signal, beforeHandle: G.signal, handle: z.signal, afterHandle: U.signal, error: V.signal, response: N.signal }), B.emit(`res${X}.${J}`, undefined);
  };
};
var D$2 = function($, J) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var Z = {}, W = J || {}, X = W.decode || z$, B = 0;
  while (B < $.length) {
    var Y = $.indexOf("=", B);
    if (Y === -1)
      break;
    var D = $.indexOf(";", B);
    if (D === -1)
      D = $.length;
    else if (D < Y) {
      B = $.lastIndexOf(";", Y - 1) + 1;
      continue;
    }
    var Q = $.slice(B, Y).trim();
    if (Z[Q] === undefined) {
      var G = $.slice(Y + 1, D).trim();
      if (G.charCodeAt(0) === 34)
        G = G.slice(1, -1);
      Z[Q] = O$(G, X);
    }
    B = D + 1;
  }
  return Z;
};
var G$ = function($, J, Z) {
  var W = Z || {}, X = W.encode || K$;
  if (typeof X !== "function")
    throw new TypeError("option encode is invalid");
  if (!b0.test($))
    throw new TypeError("argument name is invalid");
  var B = X(J);
  if (B && !b0.test(B))
    throw new TypeError("argument val is invalid");
  var Y = $ + "=" + B;
  if (W.maxAge != null) {
    var D = W.maxAge - 0;
    if (isNaN(D) || !isFinite(D))
      throw new TypeError("option maxAge is invalid");
    Y += "; Max-Age=" + Math.floor(D);
  }
  if (W.domain) {
    if (!b0.test(W.domain))
      throw new TypeError("option domain is invalid");
    Y += "; Domain=" + W.domain;
  }
  if (W.path) {
    if (!b0.test(W.path))
      throw new TypeError("option path is invalid");
    Y += "; Path=" + W.path;
  }
  if (W.expires) {
    var Q = W.expires;
    if (!U$2(Q) || isNaN(Q.valueOf()))
      throw new TypeError("option expires is invalid");
    Y += "; Expires=" + Q.toUTCString();
  }
  if (W.httpOnly)
    Y += "; HttpOnly";
  if (W.secure)
    Y += "; Secure";
  if (W.partitioned)
    Y += "; Partitioned";
  if (W.priority) {
    var G = typeof W.priority === "string" ? W.priority.toLowerCase() : W.priority;
    switch (G) {
      case "low":
        Y += "; Priority=Low";
        break;
      case "medium":
        Y += "; Priority=Medium";
        break;
      case "high":
        Y += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (W.sameSite) {
    var z = typeof W.sameSite === "string" ? W.sameSite.toLowerCase() : W.sameSite;
    switch (z) {
      case true:
        Y += "; SameSite=Strict";
        break;
      case "lax":
        Y += "; SameSite=Lax";
        break;
      case "strict":
        Y += "; SameSite=Strict";
        break;
      case "none":
        Y += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Y;
};
var z$ = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var K$ = function($) {
  return encodeURIComponent($);
};
var U$2 = function($) {
  return _$.call($) === "[object Date]" || $ instanceof Date;
};
var O$ = function($, J) {
  try {
    return J($);
  } catch (Z) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var L0 = D$2;
var x02 = G$;
var _$ = Object.prototype.toString;
var b0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

class u {
  $;
  J;
  name;
  setter;
  constructor($, J = {}) {
    this._value = $;
    this.property = J;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const J = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in J)
      this._value = J.value, delete J.value;
    return this.property = J, this.sync();
  }
  set($) {
    const J = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in J)
      this._value = J.value, delete J.value;
    return this.property = J, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var F1 = ($, J, Z) => new Proxy($, { get(W, X) {
  if (X in W)
    return W[X];
  const B = new u(undefined, Z ? { ...Z } : undefined);
  return B.setter = J, B.name = X, B;
}, set(W, X, B) {
  if (!(B instanceof u))
    return false;
  if (!J.cookie)
    J.cookie = {};
  return B.setter = J, B.name = X, B.sync(), W[X] = B, true;
} });
var g0 = async ($, J, { secret: Z, sign: W, ...X } = {}) => {
  if (!J)
    return F1({}, $, X);
  const B = {}, Y = typeof Z === "string";
  if (W && W !== true && !Array.isArray(W))
    W = [W];
  const D = Object.keys(L0(J));
  for (let Q = 0;Q < D.length; Q++) {
    const G = D[Q];
    let z = L0(J)[G];
    if (W === true || W?.includes(G)) {
      if (!Z)
        throw new Error("No secret is provided to cookie plugin");
      if (Y) {
        if (z = await l0(z, Z), z === false)
          throw new I0(G);
      } else {
        let N = true;
        for (let K = 0;K < Z.length; K++) {
          const j = await l0(z, Z[K]);
          if (j !== false) {
            z = j, N = false;
            break;
          }
        }
        if (N)
          throw new I0(G);
      }
    }
    if (z === undefined)
      continue;
    const U = z.charCodeAt(0);
    if (U === 123 || U === 91)
      try {
        const N = new u(JSON.parse(z));
        N.setter = $, N.name = G, B[G] = N;
        continue;
      } catch {
      }
    if (f02(z))
      z = +z;
    else if (z === "true")
      z = true;
    else if (z === "false")
      z = false;
    const V = new u(z, X);
    V.setter = $, V.name = G, B[G] = V;
  }
  return F1(B, $);
};
var M0 = "toJSON" in new Headers;
var m = ($) => {
  for (let J in $)
    return true;
  return false;
};
var A0 = ($, J) => {
  const Z = $.size;
  if (Z && J && J.status !== 206 && J.status !== 304 && J.status !== 412 && J.status !== 416 || !J && Z) {
    if (J) {
      if (J.headers instanceof Headers) {
        if (M0)
          J.headers = J.headers.toJSON();
        else
          for (let [W, X] of J.headers.entries())
            if (W in J.headers)
              J.headers[W] = X;
      }
      return new Response($, { status: J.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${Z - 1}/${Z}` }, J.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${Z - 1}/${Z}` } });
  }
  return new Response($);
};
var N1 = ($, J) => {
  if (!$ || !Array.isArray(J))
    return $;
  $.delete("Set-Cookie");
  for (let Z = 0;Z < J.length; Z++) {
    const W = J[Z].indexOf("=");
    $.append("Set-Cookie", `${J[Z].slice(0, W)}=${J[Z].slice(W + 1)}`);
  }
  return $;
};
var j1 = ($) => {
  if (!$ || typeof $ !== "object" || !m($))
    return;
  const J = [];
  for (let [Z, W] of Object.entries($)) {
    if (!Z || !W)
      continue;
    if (Array.isArray(W.value))
      for (let X = 0;X < W.value.length; X++) {
        let B = W.value[X];
        if (B === undefined || B === null)
          continue;
        if (typeof B === "object")
          B = JSON.stringify(B);
        J.push(x02(Z, B, W));
      }
    else {
      let X = W.value;
      if (X === undefined || X === null)
        continue;
      if (typeof X === "object")
        X = JSON.stringify(X);
      J.push(x02(Z, W.value, W));
    }
  }
  if (J.length === 0)
    return;
  if (J.length === 1)
    return J[0];
  return J;
};
var k = ($, J) => {
  if ($?.[$.$passthrough])
    $ = $[$.$passthrough];
  if ($?.[c])
    J.status = $[c], $ = $.response;
  if (m(J.headers) || J.status !== 200 || J.redirect || J.cookie) {
    if (typeof J.status === "string")
      J.status = P02[J.status];
    if (J.redirect) {
      if (J.headers.Location = J.redirect, !J.status || J.status < 300 || J.status >= 400)
        J.status = 302;
    }
    if (J.cookie && m(J.cookie))
      J.headers["Set-Cookie"] = j1(J.cookie);
    if (J.headers["Set-Cookie"] && Array.isArray(J.headers["Set-Cookie"]))
      J.headers = N1(new Headers(J.headers), J.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, J);
      case "Blob":
        return A0($, J);
      case "Object":
      case "Array":
        return Response.json($, J);
      case "ReadableStream":
        if (!J.headers["content-type"]?.startsWith("text/event-stream"))
          J.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, J);
      case undefined:
        if (!$)
          return new Response("", J);
        return Response.json($, J);
      case "Response":
        const Z = { ...J.headers };
        if (M0)
          J.headers = $.headers.toJSON();
        else
          for (let [X, B] of $.headers.entries())
            if (X in J.headers)
              J.headers[X] = B;
        for (let X in Z)
          $.headers.append(X, Z[X]);
        return $;
      case "Error":
        return h($, J);
      case "Promise":
        return $.then((X) => k(X, J));
      case "Function":
        return k($(), J);
      case "Number":
      case "Boolean":
        return new Response($.toString(), J);
      case "Cookie":
        if ($ instanceof u)
          return new Response($.value, J);
        return new Response($?.toString(), J);
      default:
        if ($ instanceof Response) {
          const X = { ...J.headers };
          if (M0)
            J.headers = $.headers.toJSON();
          else
            for (let [B, Y] of $.headers.entries())
              if (B in J.headers)
                J.headers[B] = Y;
          for (let B in X)
            $.headers.append(B, X[B]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((X) => k(X, J));
        if ($ instanceof Error)
          return h($, J);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!J.headers["Content-Type"])
            J.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), J);
        }
        return new Response(W, J);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return A0($, J);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return h($, J);
      case "Promise":
        return $.then((W) => {
          const X = l(W);
          if (X !== undefined)
            return X;
          return new Response("");
        });
      case "Function":
        return l($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof u)
          return new Response($.value, J);
        return new Response($?.toString(), J);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => k(W, J));
        if ($ instanceof Error)
          return h($, J);
        const Z = JSON.stringify($);
        if (Z.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(Z);
    }
};
var y = ($, J) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    J.status = $[c], $ = $.response;
  if (m(J.headers) || J.status !== 200 || J.redirect || J.cookie) {
    if (typeof J.status === "string")
      J.status = P02[J.status];
    if (J.redirect) {
      if (J.headers.Location = J.redirect, !J.status || J.status < 300 || J.status >= 400)
        J.status = 302;
    }
    if (J.cookie && m(J.cookie))
      J.headers["Set-Cookie"] = j1(J.cookie);
    if (J.headers["Set-Cookie"] && Array.isArray(J.headers["Set-Cookie"]))
      J.headers = N1(new Headers(J.headers), J.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, J);
      case "Blob":
        return A0($, J);
      case "Object":
      case "Array":
        return Response.json($, J);
      case "ReadableStream":
        if (!J.headers["content-type"]?.startsWith("text/event-stream"))
          J.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, J);
      case undefined:
        if (!$)
          return;
        return Response.json($, J);
      case "Response":
        const Z = Object.assign({}, J.headers);
        if (M0)
          J.headers = $.headers.toJSON();
        else
          for (let [X, B] of $.headers.entries())
            if (!(X in J.headers))
              J.headers[X] = B;
        for (let X in Z)
          $.headers.append(X, Z[X]);
        if ($.status !== J.status)
          J.status = $.status;
        return $;
      case "Promise":
        return $.then((X) => {
          const B = y(X, J);
          if (B !== undefined)
            return B;
          return;
        });
      case "Error":
        return h($, J);
      case "Function":
        return y($(), J);
      case "Number":
      case "Boolean":
        return new Response($.toString(), J);
      case "Cookie":
        if ($ instanceof u)
          return new Response($.value, J);
        return new Response($?.toString(), J);
      default:
        if ($ instanceof Response) {
          const X = { ...J.headers };
          if (M0)
            J.headers = $.headers.toJSON();
          else
            for (let [B, Y] of $.headers.entries())
              if (B in J.headers)
                J.headers[B] = Y;
          for (let B in X)
            $.headers.append(B, X[B]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((X) => y(X, J));
        if ($ instanceof Error)
          return h($, J);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!J.headers["Content-Type"])
            J.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), J);
        }
        return new Response(W, J);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return A0($, J);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((W) => {
          const X = y(W, J);
          if (X !== undefined)
            return X;
          return;
        });
      case "Error":
        return h($, J);
      case "Function":
        return l($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof u)
          return new Response($.value, J);
        return new Response($?.toString(), J);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => y(W, J));
        if ($ instanceof Error)
          return h($, J);
        const Z = JSON.stringify($);
        if (Z.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(Z);
    }
};
var l = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    return k($.response, { status: $[c], headers: {} });
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return A0($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return h($);
    case "Promise":
      return $.then(l);
    case "Function":
      return l($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return new Response($.body, { headers: { "Content-Type": "application/json" } });
      if ($ instanceof Promise)
        return $.then(l);
      if ($ instanceof Error)
        return h($);
      const J = JSON.stringify($);
      if (J.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(J);
  }
};
var h = ($, J) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: J?.status !== 200 ? J?.status ?? 500 : 500, headers: J?.headers });
var r02 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var t02 = ($, J) => {
  const Z = new URL($);
  return Z.pathname = J, Z.toString();
};
var I$2 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || m(Object.getPrototypeOf($));
var d = ($, J, { skipKeys: Z } = {}) => {
  if (r02($) && r02(J))
    for (let [W, X] of Object.entries(J)) {
      if (Z?.includes(W))
        continue;
      if (!r02(X)) {
        $[W] = X;
        continue;
      }
      if (!(W in $)) {
        $[W] = X;
        continue;
      }
      if (I$2(X)) {
        $[W] = X;
        continue;
      }
      $[W] = d($[W], X);
    }
  return $;
};
var T1 = ($, J) => d($, J, { skipKeys: ["properties"] });
var H = ($, J) => {
  if (!$)
    return [];
  const Z = [...Array.isArray($) ? $ : [$]], W = [];
  for (let X of Z)
    if (X.$elysiaChecksum)
      W.push(X.$elysiaChecksum);
  for (let X of Array.isArray(J) ? J : [J])
    if (!W.includes(X?.$elysiaChecksum))
      Z.push(X);
  return Z;
};
var a0 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "onResponse", "mapResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var a = ($, J) => {
  return { ...$, ...J, body: J?.body ?? $?.body, headers: J?.headers ?? $?.headers, params: J?.params ?? $?.params, query: J?.query ?? $?.query, response: J?.response ?? $?.response, type: $?.type || J?.type, detail: d(J?.detail ?? {}, $?.detail ?? {}), parse: H($?.parse ?? [], J?.parse ?? []), transform: H($?.transform ?? [], J?.transform ?? []), beforeHandle: H($?.beforeHandle ?? [], J?.beforeHandle ?? []), afterHandle: H($?.afterHandle ?? [], J?.afterHandle ?? []), onResponse: H($?.onResponse ?? [], J?.onResponse ?? []), mapResponse: H($?.mapResponse ?? [], J?.mapResponse ?? []), trace: H($?.trace ?? [], J?.trace ?? []), error: H($?.error ?? [], J?.error ?? []) };
};
var p = ($, { models: J = {}, additionalProperties: Z = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in J))
    return;
  const X = typeof $ === "string" ? J[$] : $;
  if (X.type === "object" && ("additionalProperties" in X) === false)
    X.additionalProperties = Z;
  if (W)
    return { schema: X, references: "", checkFunc: () => {
    }, code: "", Check: (B) => exports_value2.Check(X, B), Errors: (B) => exports_value2.Errors(X, B), Code: () => "" };
  return TypeCompiler.Compile(X, Object.values(J));
};
var s02 = ($, { models: J = {}, additionalProperties: Z = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in J))
    return;
  const X = typeof $ === "string" ? J[$] : $, B = (D, Q) => {
    if (W)
      return { schema: D, references: "", checkFunc: () => {
      }, code: "", Check: (G) => exports_value2.Check(D, G), Errors: (G) => exports_value2.Errors(D, G), Code: () => "" };
    return TypeCompiler.Compile(D, Q);
  };
  if (Kind in X) {
    if (("additionalProperties" in X) === false)
      X.additionalProperties = Z;
    return { 200: B(X, Object.values(J)) };
  }
  const Y = {};
  return Object.keys(X).forEach((D) => {
    const Q = X[+D];
    if (typeof Q === "string") {
      if (Q in J) {
        const G = J[Q];
        G.type === "object" && ("additionalProperties" in G), Y[+D] = (Kind in G) ? B(G, Object.values(J)) : G;
      }
      return;
    }
    if (Q.type === "object" && ("additionalProperties" in Q) === false)
      Q.additionalProperties = Z;
    Y[+D] = (Kind in Q) ? B(Q, Object.values(J)) : Q;
  }), Y;
};
var M$2 = typeof Bun !== "undefined";
var A$2 = M$2 && typeof Bun.hash === "function";
var _0 = ($) => {
  if (A$2)
    return Bun.hash($);
  let J = 9;
  for (let Z = 0;Z < $.length; )
    J = Math.imul(J ^ $.charCodeAt(Z++), 387420489);
  return J = J ^ J >>> 9;
};
var v0 = ($, J, Z) => {
  const W = (X) => {
    if (Z && !X.$elysiaChecksum)
      X.$elysiaChecksum = Z;
    return X;
  };
  return { ...$, ...J, start: H($.start, ("start" in J ? J.start ?? [] : []).map(W)), request: H($.request, ("request" in J ? J.request ?? [] : []).map(W)), parse: H($.parse, "parse" in J ? J?.parse ?? [] : []).map(W), transform: H($.transform, (J?.transform ?? []).map(W)), beforeHandle: H($.beforeHandle, (J?.beforeHandle ?? []).map(W)), afterHandle: H($.afterHandle, (J?.afterHandle ?? []).map(W)), mapResponse: H($.mapResponse, (J?.mapResponse ?? []).map(W)), onResponse: H($.onResponse, (J?.onResponse ?? []).map(W)), trace: $.trace, error: H($.error, (J?.error ?? []).map(W)), stop: H($.stop, ("stop" in J ? J.stop ?? [] : []).map(W)) };
};
var q1 = ($, J = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (J)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((Z) => {
    if (J)
      Z.$elysiaHookType = "global";
    else
      Z.$elysiaHookType = undefined;
    return Z;
  });
};
var Q0 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((J) => J.$elysiaHookType === "global");
};
var o0 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: Q0($?.parse), transform: Q0($?.transform), beforeHandle: Q0($?.beforeHandle), afterHandle: Q0($?.afterHandle), onResponse: Q0($?.onResponse), error: Q0($?.error) };
};
var P02 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var D0 = async ($, J) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (J === null)
    throw new TypeError("Secret key must be provided.");
  const Z = new TextEncoder, W = await crypto.subtle.importKey("raw", Z.encode(J), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), X = await crypto.subtle.sign("HMAC", W, Z.encode($)), B = Array.from(new Uint8Array(X)), Y = btoa(String.fromCharCode(...B));
  return `${$}.${Y.replace(/=+$/, "")}`;
};
var l0 = async ($, J) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (J === null)
    throw new TypeError("Secret key must be provided.");
  const Z = $.slice(0, $.lastIndexOf("."));
  return await D0(Z, J) === $ ? Z : false;
};
var e0 = ($, J, Z = J) => {
  for (let [W, X] of Object.entries(J ?? {})) {
    if (a0.includes(W) || !(W in $))
      continue;
    if (typeof $[W] === "function")
      $[W](X);
    else if (typeof $[W] === "object")
      e0($[W], X, Z);
  }
};
var f02 = ($) => $.trim().length !== 0 && !Number.isNaN(Number($));
var w1 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var G0 = Symbol("ElysiaErrorCode");
var c = Symbol("ElysiaResponse");
var F0 = (w1?.NODE_ENV ?? w1?.ENV) === "production";
class k0 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class o extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class I0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, J) {
    super(J ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class S extends Error {
  $;
  J;
  Z;
  code = "VALIDATION";
  status = 400;
  constructor($, J, Z) {
    const W = F0 ? undefined : ("Errors" in J) ? J.Errors(Z).First() : exports_value2.Errors(J, Z).First(), X = W?.schema.error ? typeof W.schema.error === "function" ? W.schema.error($, J, Z) : W.schema.error : undefined, B = W?.path?.slice(1) || "root";
    let Y = "";
    if (X)
      Y = typeof X === "object" ? JSON.stringify(X) : X + "";
    else if (F0)
      Y = JSON.stringify({ type: $, message: W?.message });
    else
      Y = JSON.stringify({ type: $, at: B, message: W?.message, expected: exports_value2.Create(J.schema), found: Z, errors: [...J.Errors(Z)] }, null, 2);
    super(Y);
    this.type = $;
    this.validator = J;
    this.value = Z;
    Object.setPrototypeOf(this, S.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel($) {
    const J = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(J);
    } catch {
      return J;
    }
  }
  get model() {
    return S.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var J1 = { open($) {
  $.data.open?.($);
}, message($, J) {
  $.data.message?.($, J);
}, drain($) {
  $.data.drain?.($);
}, close($, J, Z) {
  $.data.close?.($, J, Z);
} };

class z0 {
  $;
  J;
  validator;
  constructor($, J) {
    this.raw = $;
    this.data = J;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else {
      const Z = new Uint32Array(1);
      crypto.getRandomValues(Z), this.id = Z[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, J = undefined, Z) => {
      if (this.validator?.Check(J) === false)
        throw new S("message", this.validator, J);
      if (typeof J === "object")
        J = JSON.stringify(J);
      return this.raw.publish($, J, Z), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new S("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var d1 = S0(B1(), 1);
var p1 = S0(W1(), 1);
var C$ = new Headers().toJSON;
var i12 = new RegExp(" (\\w+) = context", "g");
var l12 = { value: 0 };
var n12 = ({ hasTrace: $, hasTraceSet: J = false, addFn: Z, condition: W = {} }) => {
  if ($)
    return Z("\nconst reporter = getReporter()\n"), (X, { name: B, attribute: Y = "", unit: D = 0 } = {}) => {
      const Q = X.indexOf("."), G = Q === -1;
      if (X !== "request" && X !== "response" && !W[G ? X : X.slice(0, Q)])
        return () => {
          if (J && X === "afterHandle")
            Z("\nawait traceDone\n");
        };
      if (G)
        B ||= X;
      else
        B ||= "anonymous";
      Z("\n" + `reporter.emit('event', {
					id,
					event: '${X}',
					type: 'begin',
					name: '${B}',
					time: performance.now(),
					${G ? `unit: ${D},` : ""}
					${Y}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let z = false;
      return () => {
        if (z)
          return;
        if (z = true, Z("\n" + `reporter.emit('event', {
							id,
							event: '${X}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), J && X === "afterHandle")
          Z("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var V0 = ($) => {
  const J = $.indexOf(")");
  if ($.charCodeAt(J + 2) === 61 && $.charCodeAt(J + 5) !== 123)
    return true;
  return $.includes("return");
};
var R$ = ($, { injectResponse: J = "" } = {}) => ({ composeValidation: (Z, W = `c.${Z}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${Z}',
${Z},
${W}
)` : `c.set.status = 400; return new ValidationError(
	'${Z}',
	${Z},
	${W}
).toResponse(c.set.headers)`, composeResponseValidation: (Z = "r") => {
  const W = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${Z}
)` : `return new ValidationError(
'response',
response[c.set.status],
${Z}
).toResponse(c.set.headers)`;
  return `\n${J}
		if(!(${Z} instanceof Response) && response[c.set.status]?.Check(${Z}) === false) {
	if(!(response instanceof Error))
		${W}
}\n`;
} });
var b = ($, J) => {
  if (J.startsWith("[object "))
    return false;
  if (J = J.trimStart(), J = J.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(J))
    J = J.slice(J.indexOf("("));
  const Z = J.charCodeAt(0) === 40 || J.startsWith("function") ? J.slice(J.indexOf("(") + 1, J.indexOf(")")) : J.slice(0, J.indexOf("=") - 1);
  if (Z === "")
    return false;
  const W = Z.charCodeAt(0) === 123 ? Z.indexOf("...") : -1;
  if (Z.charCodeAt(0) === 123) {
    if (Z.includes($))
      return true;
    if (W === -1)
      return false;
  }
  if (J.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const X = W !== -1 ? Z.slice(W + 3, Z.indexOf(" ", W + 3)) : undefined;
  if (J.match(new RegExp(`${X}(.${$}|\\["${$}"\\])`)))
    return true;
  const B = [Z];
  if (X)
    B.push(X);
  for (let D of J.matchAll(i12))
    B.push(D[1]);
  const Y = new RegExp(`{.*?} = (${B.join("|")})`, "g");
  for (let [D] of J.matchAll(Y))
    if (D.includes(`{ ${$}`) || D.includes(`, ${$}`))
      return true;
  return false;
};
var T0 = ($) => {
  if ($ = $.trimStart(), $.startsWith("[object"))
    return false;
  if ($ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const J = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (J === "")
    return false;
  const Z = J.charCodeAt(0) === 123 ? J.indexOf("...") : -1, W = Z !== -1 ? J.slice(Z + 3, J.indexOf(" ", Z + 3)) : undefined, X = [J];
  if (W)
    X.push(W);
  for (let Y of $.matchAll(i12))
    X.push(Y[1]);
  for (let Y of X)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  const B = new RegExp(`{.*?} = (${X.join("|")})`, "g");
  for (let [Y] of $.matchAll(B))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var K02 = Symbol.for("TypeBox.Kind");
var u0 = ($, J) => {
  if (!J)
    return;
  if ((K02 in J) && J[K02] === $)
    return true;
  if (J.type === "object") {
    const Z = J.properties;
    for (let W of Object.keys(Z)) {
      const X = Z[W];
      if (X.type === "object") {
        if (u0($, X))
          return true;
      } else if (X.anyOf) {
        for (let B = 0;B < X.anyOf.length; B++)
          if (u0($, X.anyOf[B]))
            return true;
      }
      if ((K02 in X) && X[K02] === $)
        return true;
    }
    return false;
  }
  return J.properties && (K02 in J.properties) && J.properties[K02] === $;
};
var e = ($, J) => {
  if (!J)
    return;
  if (J.type === "object") {
    const Z = J.properties;
    if (!Z)
      return false;
    for (let W of Object.keys(Z)) {
      const X = Z[W];
      if ($ in X)
        return true;
      if (X.type === "object") {
        if (e($, X))
          return true;
      } else if (X.anyOf) {
        for (let B = 0;B < X.anyOf.length; B++)
          if (e($, X.anyOf[B]))
            return true;
      }
    }
    return false;
  }
  return $ in J;
};
var Y1 = Symbol.for("TypeBox.Transform");
var $0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const J = $.properties;
    for (let Z of Object.keys(J)) {
      const W = J[Z];
      if (W.type === "object") {
        if ($0(W))
          return true;
      } else if (W.anyOf) {
        for (let B = 0;B < W.anyOf.length; B++)
          if ($0(W.anyOf[B]))
            return true;
      }
      if (Y1 in W)
        return true;
    }
    return false;
  }
  return (Y1 in $) || $.properties && (Y1 in $.properties);
};
var S$ = ($) => {
  if (!$)
    return;
  const J = $?.schema;
  if (J && ("anyOf" in J)) {
    let Z = false;
    const W = J.anyOf[0].type;
    for (let X of J.anyOf)
      if (X.type !== W) {
        Z = true;
        break;
      }
    if (!Z)
      return W;
  }
  return $.schema?.type;
};
var E$2 = /(?:return|=>) \S+\(/g;
var L = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  const J = $.toString();
  if (J.includes("=> response.clone("))
    return false;
  return !!J.match(E$2);
};
var H$ = ($) => {
  if (!$.includes("query: {") || $.includes("query,") || $.includes("query }"))
    return false;
  const J = $.indexOf("query: {");
  return $ = $.slice(J + 9), $ = $.slice(0, $.indexOf("}")), $.split(",").map((Z) => {
    const W = Z.indexOf(":");
    if (W === -1)
      return Z.trim();
    return Z.slice(0, W).trim();
  });
};
var r1 = ({ path: $, method: J, hooks: Z, validator: W, handler: X, handleError: B, definitions: Y, schema: D, onRequest: Q, config: G, getReporter: z, setHeader: U }) => {
  const V = G.forceErrorEncapsulation || Z.error.length > 0 || typeof Bun === "undefined" || Z.onResponse.length > 0 || !!Z.trace.length, N = typeof X === "function", K = N ? "handler(c)" : "handler", j = Z.onResponse.length ? `\n;(async () => {${Z.onResponse.map((I, M) => `await res${M}(c)`).join(";")}})();\n` : "", O = Z.trace.map((I) => I.toString());
  let P = false;
  if (N && T0(X.toString()))
    P = true;
  if (!P)
    for (let [I, M] of Object.entries(Z)) {
      if (!Array.isArray(M) || !M.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(I))
        continue;
      for (let F of M) {
        if (typeof F !== "function")
          continue;
        if (T0(F.toString())) {
          P = true;
          break;
        }
      }
      if (P)
        break;
    }
  const A = { parse: O.some((I) => b("parse", I)), transform: O.some((I) => b("transform", I)), handle: O.some((I) => b("handle", I)), beforeHandle: O.some((I) => b("beforeHandle", I)), afterHandle: O.some((I) => b("afterHandle", I)), error: V || O.some((I) => b("error", I)) }, T = Z.trace.length > 0;
  let _ = "";
  const v = W || J !== "GET" && J !== "HEAD" ? [X, ...Z.transform, ...Z.beforeHandle, ...Z.afterHandle, ...Z.mapResponse].map((I) => typeof I === "function" ? I.toString() : `${I}`) : [], Z0 = J !== "GET" && J !== "HEAD" && (P || Z.type !== "none" && (!!W.body || !!Z.type || v.some((I) => b("body", I)))), h0 = P || W.headers || v.some((I) => b("headers", I)) || U && Object.keys(U).length, q0 = P || !!W.cookie || v.some((I) => b("cookie", I)), x = W?.cookie?.schema;
  let r = "";
  if (x?.sign) {
    if (!x.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${J}) ${$}.`);
    const I = !x.secrets ? undefined : typeof x.secrets === "string" ? x.secrets : x.secrets[0];
    if (r += `const _setCookie = c.set.cookie
		if(_setCookie) {`, x.sign === true)
      r += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${I}')
			}`;
    else
      for (let M of x.sign)
        r += `if(_setCookie['${M}']?.value) { c.set.cookie['${M}'].value = await signCookie(_setCookie['${M}'].value, '${I}') }\n`;
    r += "}\n";
  }
  const { composeValidation: W0, composeResponseValidation: w0 } = R$(V);
  if (h0)
    _ += C$ ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (q0) {
    const I = (F, q) => {
      const C = x?.[F] ?? q;
      if (!C)
        return typeof q === "string" ? `${F}: "${q}",` : `${F}: ${q},`;
      if (typeof C === "string")
        return `${F}: '${C}',`;
      if (C instanceof Date)
        return `${F}: new Date(${C.getTime()}),`;
      return `${F}: ${C},`;
    }, M = x ? `{
			secret: ${x.secrets !== undefined ? typeof x.secrets === "string" ? `'${x.secrets}'` : "[" + x.secrets.reduce((F, q) => F + `'${q}',`, "") + "]" : "undefined"},
			sign: ${x.sign === true ? true : x.sign !== undefined ? "[" + x.sign.reduce((F, q) => F + `'${q}',`, "") + "]" : "undefined"},
			${I("domain")}
			${I("expires")}
			${I("httpOnly")}
			${I("maxAge")}
			${I("path", "/")}
			${I("priority")}
			${I("sameSite")}
			${I("secure")}
		}` : "undefined";
    if (h0)
      _ += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${M})\n`;
    else
      _ += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${M})\n`;
  }
  if (P || W.query || v.some((I) => b("query", I))) {
    let I = [], M = false;
    if (W.query && W.query.schema.type === "object")
      I = Object.keys(W.query.schema.properties);
    else
      for (let F of v) {
        const q = H$(F);
        if (!q) {
          M = true;
          continue;
        }
        for (let C of q)
          if (I.indexOf(C) === -1)
            I.push(C);
      }
    if (!M && I.length)
      _ += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${I.map((F, q) => `
						memory = url.indexOf('${F}=')

						const a${q} = memory === -1 ? undefined : url.slice(memory = memory + ${F.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join("\n")}

				c.query = {
					${I.map((F, q) => `${F}: a${q}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    else
      _ += "c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}";
  }
  const C0 = Z.trace.map((I) => I.toString()).some((I) => b("set", I) || T0(I));
  P || Z.trace.some((I) => b("set", I.toString()));
  const R0 = U && Object.keys(U).length || C0 || q0 || v.some((I) => b("set", I)) || Q.some((I) => b("set", I.toString()));
  if (T)
    _ += "\nconst id = c.$$requestId\n";
  const E = n12({ hasTrace: T, hasTraceSet: C0, condition: A, addFn: (I) => {
    _ += I;
  } });
  if (_ += V ? "\n try {\n" : "", C0) {
    _ += "\nconst traceDone = Promise.all([";
    for (let I = 0;I < Z.trace.length; I++)
      _ += `new Promise(r => { reporter.once(\`res\${id}.${I}\`, r) }),`;
    _ += "])\n";
  }
  const X0 = typeof X === "function" && L(X), c0 = q0 || Z0 || C0 || X0 || !!Z.mapResponse.length || Z.parse.length > 0 || Z.afterHandle.some(L) || Z.beforeHandle.some(L) || Z.transform.some(L), e1 = E("parse", { unit: Z.parse.length });
  if (Z0) {
    const I = S$(W?.body);
    if (Z.type && !Array.isArray(Z.type)) {
      if (Z.type)
        switch (Z.type) {
          case "json":
          case "application/json":
            _ += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            _ += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            _ += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            _ += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            _ += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (Z.parse.length)
        _ += "}}";
    } else {
      const F = (() => {
        if (Z.parse.length && I && !Array.isArray(Z.type)) {
          const q = W?.body?.schema;
          switch (I) {
            case "object":
              if (u0("File", q) || u0("Files", q))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (F)
        _ += F;
      else {
        if (_ += "\n", _ += h0 ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", _ += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, Z.parse.length) {
          _ += "let used = false\n";
          const q = E("parse", { unit: Z.parse.length });
          for (let C = 0;C < Z.parse.length; C++) {
            const d0 = E("parse.unit", { name: Z.parse[C].name }), R = `bo${C}`;
            if (C !== 0)
              _ += "if(!used) {\n";
            if (_ += `let ${R} = parse[${C}](c, contentType)\n`, _ += `if(${R} instanceof Promise) ${R} = await ${R}\n`, _ += `if(${R} !== undefined) { c.body = ${R}; used = true }\n`, d0(), C !== 0)
              _ += "}";
          }
          q();
        }
        if (Z.parse.length)
          _ += "if (!used)";
        _ += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}\n`, _ += "}\n";
      }
    }
    _ += "\n";
  }
  if (e1(), Z?.transform) {
    const I = E("transform", { unit: Z.transform.length });
    for (let M = 0;M < Z.transform.length; M++) {
      const F = Z.transform[M], q = E("transform.unit", { name: F.name });
      if (F.$elysia === "derive")
        _ += L(F) ? `Object.assign(c, await transform[${M}](c));` : `Object.assign(c, transform[${M}](c));`;
      else
        _ += L(F) ? `await transform[${M}](c);` : `transform[${M}](c);`;
      q();
    }
    I();
  }
  if (W) {
    if (_ += "\n", W.headers) {
      if (e("default", W.headers.params))
        for (let [I, M] of Object.entries(exports_value2.Default(W.headers.schema, {}))) {
          const F = typeof M === "object" ? JSON.stringify(M) : `'${M}'`;
          if (F)
            _ += `c.headers['${I}'] ??= ${F}\n`;
        }
      if (_ += `if(headers.Check(c.headers) === false) {
				${W0("headers")}
			}`, $0(W.headers.schema))
        _ += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (W.params) {
      if (e("default", W.params.schema))
        for (let [I, M] of Object.entries(exports_value2.Default(W.params.schema, {}))) {
          const F = typeof M === "object" ? JSON.stringify(M) : `'${M}'`;
          if (F)
            _ += `c.params['${I}'] ??= ${F}\n`;
        }
      if (_ += `if(params.Check(c.params) === false) {
				${W0("params")}
			}`, $0(W.params.schema))
        _ += "\nc.params = params.Decode(c.params)\n";
    }
    if (W.query) {
      if (e("default", W.query.schema))
        for (let [I, M] of Object.entries(exports_value2.Default(W.query.schema, {}))) {
          const F = typeof M === "object" ? JSON.stringify(M) : `'${M}'`;
          if (F)
            _ += `c.query['${I}'] ??= ${F}\n`;
        }
      if (_ += `if(query.Check(c.query) === false) {
				${W0("query")}
			}`, $0(W.query.schema))
        _ += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (W.body) {
      if (e("default", W.body.schema))
        _ += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(W.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${W0("body")}
     			}
            }`;
      else
        _ += `if(body.Check(c.body) === false) {
			${W0("body")}
		}`;
      if ($0(W.body.schema))
        _ += "\nc.body = body.Decode(c.body)\n";
    }
    if (m(W.cookie?.schema.properties ?? {})) {
      if (_ += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, e("default", W.cookie.schema))
        for (let [I, M] of Object.entries(exports_value2.Default(W.cookie.schema, {})))
          _ += `cookieValue['${I}'] = ${typeof M === "object" ? JSON.stringify(M) : M}\n`;
      if (_ += `if(cookie.Check(cookieValue) === false) {
				${W0("cookie", "cookieValue")}
			}`, $0(W.cookie.schema))
        _ += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (Z?.beforeHandle) {
    const I = E("beforeHandle", { unit: Z.beforeHandle.length });
    for (let M = 0;M < Z.beforeHandle.length; M++) {
      const F = Z.beforeHandle[M], q = E("beforeHandle.unit", { name: F.name }), C = V0(F.toString());
      if (F.$elysia === "resolve")
        _ += L(F) ? `Object.assign(c, await beforeHandle[${M}](c));` : `Object.assign(c, beforeHandle[${M}](c));`;
      else if (!C)
        _ += L(F) ? `await beforeHandle[${M}](c);\n` : `beforeHandle[${M}](c);\n`, q();
      else {
        _ += L(F) ? `be = await beforeHandle[${M}](c);\n` : `be = beforeHandle[${M}](c);\n`, q(), _ += "if(be !== undefined) {\n";
        const d0 = E("afterHandle", { unit: Z.transform.length });
        if (Z.afterHandle) {
          E("handle", { name: N ? X.name : undefined })();
          for (let R = 0;R < Z.afterHandle.length; R++) {
            const $$2 = V0(Z.afterHandle[R].toString()), J$ = E("afterHandle.unit", { name: Z.afterHandle[R].name });
            if (_ += "c.response = be\n", !$$2)
              _ += L(Z.afterHandle[R]) ? `await afterHandle[${R}](c, be)\n` : `afterHandle[${R}](c, be)\n`;
            else
              _ += L(Z.afterHandle[R]) ? `af = await afterHandle[${R}](c)\n` : `af = afterHandle[${R}](c)\n`, _ += "if(af !== undefined) { c.response = be = af }\n";
            J$();
          }
        }
        if (d0(), W.response)
          _ += w0("be");
        if (Z.mapResponse.length) {
          _ += "c.response = be";
          for (let R = 0;R < Z.mapResponse.length; R++)
            _ += `\nif(mr === undefined) {
							mr = onMapResponse[${R}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}\n`;
        }
        _ += r, _ += "return mapEarlyResponse(be, c.set)}\n";
      }
    }
    I();
  }
  if (Z?.afterHandle.length) {
    const I = E("handle", { name: N ? X.name : undefined });
    if (Z.afterHandle.length)
      _ += X0 ? `let r = c.response = await ${K};\n` : `let r = c.response = ${K};\n`;
    else
      _ += X0 ? `let r = await ${K};\n` : `let r = ${K};\n`;
    I();
    const M = E("afterHandle", { unit: Z.afterHandle.length });
    for (let F = 0;F < Z.afterHandle.length; F++) {
      const q = V0(Z.afterHandle[F].toString()), C = E("afterHandle.unit", { name: Z.afterHandle[F].name });
      if (!q)
        _ += L(Z.afterHandle[F]) ? `await afterHandle[${F}](c)\n` : `afterHandle[${F}](c)\n`, C();
      else if (_ += L(Z.afterHandle[F]) ? `af = await afterHandle[${F}](c)\n` : `af = afterHandle[${F}](c)\n`, C(), W.response)
        _ += "if(af !== undefined) {", M(), _ += w0("af"), _ += "c.response = af }";
      else
        _ += "if(af !== undefined) {", M(), _ += "c.response = af}\n";
    }
    if (M(), _ += "r = c.response\n", W.response)
      _ += w0();
    if (_ += r, Z.mapResponse.length)
      for (let F = 0;F < Z.mapResponse.length; F++)
        _ += `\nmr = onMapResponse[${F}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr\n`;
    if (R0)
      _ += "return mapResponse(r, c.set)\n";
    else
      _ += "return mapCompactResponse(r)\n";
  } else {
    const I = E("handle", { name: N ? X.name : undefined });
    if (W.response || Z.mapResponse.length) {
      if (_ += X0 ? `let r = await ${K};\n` : `let r = ${K};\n`, I(), W.response)
        _ += w0();
      if (E("afterHandle")(), Z.mapResponse.length) {
        _ += "c.response = r";
        for (let M = 0;M < Z.mapResponse.length; M++)
          _ += `\nif(mr === undefined) { 
						mr = onMapResponse[${M}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}\n`;
      }
      if (_ += r, X instanceof Response)
        _ += `return ${K}.clone()\n`;
      else if (R0)
        _ += "return mapResponse(r, c.set)\n";
      else
        _ += "return mapCompactResponse(r)\n";
    } else if (A.handle || q0) {
      if (_ += X0 ? `let r = await ${K};\n` : `let r = ${K};\n`, I(), E("afterHandle")(), Z.mapResponse.length) {
        _ += "c.response = r";
        for (let M = 0;M < Z.mapResponse.length; M++)
          _ += `\nif(mr === undefined) {
							mr = onMapResponse[${M}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}\n`;
      }
      if (_ += r, R0)
        _ += "return mapResponse(r, c.set)\n";
      else
        _ += "return mapCompactResponse(r)\n";
    } else {
      I();
      const M = X0 ? `await ${K}` : K;
      if (E("afterHandle")(), X instanceof Response)
        _ += `return ${K}.clone()\n`;
      else if (R0)
        _ += `return mapResponse(${M}, c.set)\n`;
      else
        _ += `return mapCompactResponse(${M})\n`;
    }
  }
  if (V || j) {
    if (_ += `
} catch(error) {`, !c0)
      _ += "return (async () => {";
    _ += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const I = E("error", { unit: Z.error.length });
    if (Z.error.length) {
      _ += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let M = 0;M < Z.error.length; M++) {
        const F = `er${M}`, q = E("error.unit", { name: Z.error[M].name });
        if (_ += `\nlet ${F} = handleErrors[${M}](c)\n`, L(Z.error[M]))
          _ += `if (${F} instanceof Promise) ${F} = await ${F}\n`;
        q(), _ += `${F} = mapEarlyResponse(${F}, set)\n`, _ += `if (${F}) {`, _ += `return ${F} }\n`;
      }
    }
    if (I(), _ += "return handleError(c, error)\n\n", !c0)
      _ += "})()";
    if (_ += "}", j || T) {
      _ += " finally { ";
      const M = E("response", { unit: Z.onResponse.length });
      _ += j, M(), _ += "}";
    }
  }
  return _ = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${Z.onResponse.length ? `const ${Z.onResponse.map((I, M) => `res${M} = onResponse[${M}]`).join(",")}` : ""}

	return ${c0 ? "async" : ""} function handle(c) {
		${Z.beforeHandle.length ? "let be" : ""}
		${Z.afterHandle.length ? "let af" : ""}
		${Z.mapResponse.length ? "let mr" : ""}

		${D && Y ? "c.schema = schema; c.defs = definitions;" : ""}
		${_}
	}`, Function("hooks", _)({ handler: X, hooks: Z, validator: W, handleError: B, utils: { mapResponse: k, mapCompactResponse: l, mapEarlyResponse: y, parseQuery: d1.parse }, error: { NotFoundError: o, ValidationError: S, InternalServerError: k0 }, schema: D, definitions: Y, ERROR_CODE: G0, getReporter: z, requestId: l12, parseCookie: g0, signCookie: D0, decodeURIComponent: p1.default });
};
var Q12 = ($) => {
  let J = "", Z = "";
  for (let K of Object.keys($.decorators))
    J += `,${K}: app.decorators.${K}`;
  const { router: W, staticRouter: X } = $, B = $.event.trace.length > 0, Y = `
	const route = router.find(request.method, path) ${W.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params

	return route.store(ctx)`;
  let D = "";
  for (let [K, { code: j, all: O }] of Object.entries(X.map))
    D += `case '${K}':\nswitch(request.method) {\n${j}\n${O ?? "default: break map"}}\n\n`;
  const Q = $.event.request.some(L);
  if (Z += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}
	${X.variables}
	${$.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${Q ? "async" : ""} function map(request) {\n`, $.event.request.length)
    Z += "let re";
  const G = $.event.trace.map((K) => K.toString()), z = n12({ hasTrace: B, hasTraceSet: $.event.trace.some((K) => {
    const j = K.toString();
    return b("set", j) || T0(j);
  }), condition: { request: G.some((K) => b("request", K) || T0(K)) }, addFn: (K) => {
    Z += K;
  } });
  if ($.event.request.length) {
    Z += `
			${B ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${B ? ",$$requestId: +id" : ""}
				${J}
			}
		`;
    const K = z("request", { attribute: "ctx", unit: $.event.request.length });
    Z += "\n try {\n";
    for (let j = 0;j < $.event.request.length; j++) {
      const O = $.event.request[j], P = V0(O.toString()), A = L(O), T = z("request.unit", { name: $.event.request[j].name });
      if (P) {
        if (Z += `re = mapEarlyResponse(
					${A ? "await" : ""} onRequest[${j}](ctx),
					ctx.set
				)\n`, T(), P)
          Z += "if(re !== undefined) return re\n";
      } else
        Z += `${A ? "await" : ""} onRequest[${j}](ctx)\n`, T();
    }
    Z += `} catch (error) {
			return app.handleError(ctx, error)
		}`, K(), Z += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else
    Z += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${B ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${B ? ",$$requestId: id" : ""}
			${J}
		}`, z("request", { unit: $.event.request.length, attribute: G.some((K) => b("context", K)) || G.some((K) => b("store", K)) || G.some((K) => b("set", K)) ? "ctx" : "" })();
  const { wsPaths: U, wsRouter: V } = $;
  if (Object.keys(U).length || V.history.length) {
    Z += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [K, j] of Object.entries(U))
      Z += `
					case '${K}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${j}(ctx)

						break`;
    Z += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  Z += `
		map: switch(path) {
			${D}

			default:
				break
		}

		${Y}
	}`;
  const N = _12($);
  return $.handleError = N, Function("data", Z)({ app: $, mapEarlyResponse: y, NotFoundError: o, getReporter: () => $.reporter, requestId: l12, handleError: N });
};
var _12 = ($) => {
  let J = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${$.event.error.find(L) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    const W = $.event.error[Z], X = `${L(W) ? "await " : ""}onError[${Z}](context)`;
    if (V0(W.toString()))
      J += `r = ${X}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}\n`;
    else
      J += X + "\n";
  }
  return J += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`, Function("inject", J)({ app: $, mapResponse: k, ERROR_CODE: G0, ELYSIA_RESPONSE: c });
};
var m0 = S0(B1(), 1);
var D12 = ($) => async (J) => {
  const Z = { cookie: {}, status: 200, headers: {} };
  let W;
  if ($.decorators)
    W = $.decorators, W.request = J, W.set = Z, W.store = $.store;
  else
    W = { set: Z, store: $.store, request: J };
  const X = J.url, B = X.indexOf("/", 11), Y = X.indexOf("?", B + 1), D = Y === -1 ? X.substring(B) : X.substring(B, Y);
  try {
    for (let O = 0;O < $.event.request.length; O++) {
      const P = $.event.request[O];
      let A = P(W);
      if (A instanceof Promise)
        A = await A;
      if (A = y(A, Z), A)
        return A;
    }
    const Q = $.dynamicRouter.find(J.method, D) ?? $.dynamicRouter.find("ALL", D);
    if (!Q)
      throw new o;
    const { handle: G, hooks: z, validator: U, content: V } = Q.store;
    let N;
    if (J.method !== "GET" && J.method !== "HEAD")
      if (V)
        switch (V) {
          case "application/json":
            N = await J.json();
            break;
          case "text/plain":
            N = await J.text();
            break;
          case "application/x-www-form-urlencoded":
            N = m0.parse(await J.text());
            break;
          case "application/octet-stream":
            N = await J.arrayBuffer();
            break;
          case "multipart/form-data":
            N = {};
            const O = await J.formData();
            for (let P of O.keys()) {
              if (N[P])
                continue;
              const A = O.getAll(P);
              if (A.length === 1)
                N[P] = A[0];
              else
                N[P] = A;
            }
            break;
        }
      else {
        let O = J.headers.get("content-type");
        if (O) {
          const P = O.indexOf(";");
          if (P !== -1)
            O = O.slice(0, P);
          for (let A = 0;A < $.event.parse.length; A++) {
            let T = $.event.parse[A](W, O);
            if (T instanceof Promise)
              T = await T;
            if (T) {
              N = T;
              break;
            }
          }
          if (N === undefined)
            switch (O) {
              case "application/json":
                N = await J.json();
                break;
              case "text/plain":
                N = await J.text();
                break;
              case "application/x-www-form-urlencoded":
                N = m0.parse(await J.text());
                break;
              case "application/octet-stream":
                N = await J.arrayBuffer();
                break;
              case "multipart/form-data":
                N = {};
                const A = await J.formData();
                for (let T of A.keys()) {
                  if (N[T])
                    continue;
                  const _ = A.getAll(T);
                  if (_.length === 1)
                    N[T] = _[0];
                  else
                    N[T] = _;
                }
                break;
            }
        }
      }
    W.body = N, W.params = Q?.params || undefined, W.query = Y === -1 ? {} : m0.parse(X.substring(Y + 1)), W.headers = {};
    for (let [O, P] of J.headers.entries())
      W.headers[O] = P;
    const K = U?.cookie?.schema;
    W.cookie = await g0(W.set, W.headers.cookie, K ? { secret: K.secrets !== undefined ? typeof K.secrets === "string" ? K.secrets : K.secrets.join(",") : undefined, sign: K.sign === true ? true : K.sign !== undefined ? typeof K.sign === "string" ? K.sign : K.sign.join(",") : undefined } : undefined);
    for (let O = 0;O < z.transform.length; O++) {
      const P = z.transform[O](W);
      if (z.transform[O].$elysia === "derive")
        if (P instanceof Promise)
          Object.assign(W, await P);
        else
          Object.assign(W, P);
      else if (P instanceof Promise)
        await P;
    }
    if (U) {
      if (U.headers) {
        const O = {};
        for (let P in J.headers)
          O[P] = J.headers.get(P);
        if (U.headers.Check(O) === false)
          throw new S("header", U.headers, O);
      }
      if (U.params?.Check(W.params) === false)
        throw new S("params", U.params, W.params);
      if (U.query?.Check(W.query) === false)
        throw new S("query", U.query, W.query);
      if (U.cookie) {
        const O = {};
        for (let [P, A] of Object.entries(W.cookie))
          O[P] = A.value;
        if (U.cookie?.Check(O) === false)
          throw new S("cookie", U.cookie, O);
      }
      if (U.body?.Check(N) === false)
        throw new S("body", U.body, N);
    }
    for (let O = 0;O < z.beforeHandle.length; O++) {
      let P = z.beforeHandle[O](W);
      if (P instanceof Promise)
        P = await P;
      if (P !== undefined) {
        W.response = P;
        for (let T = 0;T < z.afterHandle.length; T++) {
          let _ = z.afterHandle[T](W);
          if (_ instanceof Promise)
            _ = await _;
          if (_)
            P = _;
        }
        const A = y(P, W.set);
        if (A)
          return A;
      }
    }
    let j = G(W);
    if (j instanceof Promise)
      j = await j;
    if (!z.afterHandle.length) {
      const O = U?.response?.[j.status];
      if (O?.Check(j) === false)
        throw new S("response", O, j);
    } else {
      W.response = j;
      for (let O = 0;O < z.afterHandle.length; O++) {
        let P = z.afterHandle[O](W);
        if (P instanceof Promise)
          P = await P;
        const A = y(P, W.set);
        if (A !== undefined) {
          const T = U?.response?.[j.status];
          if (T?.Check(A) === false)
            throw new S("response", T, A);
          return A;
        }
      }
    }
    if (W.set.cookie && K?.sign) {
      const O = !K.secrets ? undefined : typeof K.secrets === "string" ? K.secrets : K.secrets[0];
      if (K.sign === true)
        for (let [P, A] of Object.entries(W.set.cookie))
          W.set.cookie[P].value = await D0(A.value, "${secret}");
      else
        for (let P of K.sign) {
          if (!(P in K.properties))
            continue;
          if (W.set.cookie[P]?.value)
            W.set.cookie[P].value = await D0(W.set.cookie[P].value, O);
        }
    }
    return k(j, W.set);
  } catch (Q) {
    if (Q.status)
      Z.status = Q.status;
    return $.handleError(W, Q);
  } finally {
    for (let Q of $.event.onResponse)
      await Q(W);
  }
};
var t12 = ($) => async (J, Z) => {
  const W = Object.assign(J, { error: Z, code: Z.code });
  W.set = J.set;
  for (let X = 0;X < $.event.error.length; X++) {
    let B = $.event.error[X](W);
    if (B instanceof Promise)
      B = await B;
    if (B !== undefined && B !== null)
      return k(B, J.set);
  }
  return new Response(typeof Z.cause === "string" ? Z.cause : Z.message, { headers: J.set.headers, status: Z.status ?? 500 });
};
var w = Object.assign({}, Type);
try {
  TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch {
}
var a1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var G12 = ($, J) => {
  if (!(J instanceof Blob))
    return false;
  if ($.minSize && J.size < a1($.minSize))
    return false;
  if ($.maxSize && J.size > a1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!J.type.startsWith($.extension))
        return false;
    } else {
      for (let Z = 0;Z < $.extension.length; Z++)
        if (J.type.startsWith($.extension[Z]))
          return true;
      return false;
    }
  return true;
};
var L$ = TypeSystem.Type("Files", ($, J) => {
  if (!Array.isArray(J))
    return G12($, J);
  if ($.minItems && J.length < $.minItems)
    return false;
  if ($.maxItems && J.length > $.maxItems)
    return false;
  for (let Z = 0;Z < J.length; Z++)
    if (!G12($, J[Z]))
      return false;
  return true;
});
exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
exports_format.Set("ObjectString", ($) => {
  let J = $.charCodeAt(0);
  if (J === 9 || J === 10 || J === 32)
    J = $.trimStart().charCodeAt(0);
  if (J !== 123 && J !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var J02 = { Numeric: ($) => {
  const J = Type.Number($);
  return w.Transform(w.Union([w.String({ format: "numeric", default: 0 }), w.Number($)], $)).Decode((Z) => {
    const W = +Z;
    if (isNaN(W))
      return Z;
    if ($ && !exports_value2.Check(J, W))
      throw new S("property", J, W);
    return W;
  }).Encode((Z) => Z);
}, ObjectString: ($, J) => w.Transform(w.Union([w.String({ format: "ObjectString", default: "" }), w.Object($, J)], J)).Decode((Z) => {
  if (typeof Z === "string")
    try {
      return JSON.parse(Z);
    } catch {
      return Z;
    }
  return Z;
}).Encode((Z) => JSON.stringify(Z)), File: TypeSystem.Type("File", G12), Files: ($ = {}) => w.Transform(w.Union([L$($)])).Decode((J) => {
  if (Array.isArray(J))
    return J;
  return [J];
}).Encode((J) => J), Nullable: ($) => w.Union([w.Null(), $]), MaybeEmpty: ($) => w.Union([w.Null(), w.Undefined(), $]), Cookie: ($, J) => w.Object($, J) };
w.ObjectString = J02.ObjectString;
w.Numeric = J02.Numeric;
w.File = ($ = {}) => J02.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
w.Files = ($ = {}) => J02.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
w.Nullable = ($) => J02.Nullable($);
w.MaybeEmpty = J02.MaybeEmpty;
w.Cookie = J02.Cookie;

class n {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  macros = [];
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new A12;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new s;
  wsRouter = new s;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new s;
  lazyLoadModules = [];
  path = "";
  stack = undefined;
  constructor($) {
    if (this.config = { forceErrorEncapsulation: true, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, analytic: false, ...$, seed: $?.seed === undefined ? "" : $?.seed }, $?.analytic && ($?.name || $?.seed !== undefined))
      this.stack = new Error().stack;
  }
  add($, J, Z, W, { allowMeta: X = false, skipPrefix: B = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof J === "string")
      J = [J];
    for (let Y of J) {
      if (Y = Y === "" ? Y : Y.charCodeAt(0) === 47 ? Y : `/${Y}`, this.config.prefix && !B)
        Y = this.config.prefix + Y;
      if (W?.type)
        switch (W.type) {
          case "text":
            W.type = "text/plain";
            break;
          case "json":
            W.type = "application/json";
            break;
          case "formdata":
            W.type = "multipart/form-data";
            break;
          case "urlencoded":
            W.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            W.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const D = this.definitions.type;
      let Q = p(W?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: D, additionalProperties: true });
      if (m(this.config.cookie ?? {}))
        if (Q)
          Q.schema = T1(Q.schema, this.config.cookie ?? {});
        else
          Q = p(w.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: D, additionalProperties: true });
      const G = { body: p(W?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: D }), headers: p(W?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: D, additionalProperties: true }), params: p(W?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: D }), query: p(W?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: D }), cookie: Q, response: s02(W?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: D }) }, z = this.event, U = Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
      if (this.macros.length) {
        const O = (A) => (T, _) => {
          if (typeof T === "function" || Array.isArray(T)) {
            if (!W[A])
              W[A] = [];
            if (typeof W[A] === "function")
              W[A] = [W[A]];
            if (Array.isArray(T))
              W[A] = W[A].concat(T);
            else
              W[A].push(T);
            return;
          }
          const { insert: v = "after", stack: Z0 = "local" } = T;
          if (Z0 === "global") {
            if (!Array.isArray(_))
              if (v === "before")
                z[A].unshift(_);
              else
                z[A].push(_);
            else if (v === "before")
              z[A] = _.concat(z[A]);
            else
              z[A] = z[A].concat(_);
            return;
          } else {
            if (!W[A])
              W[A] = [];
            if (typeof W[A] === "function")
              W[A] = [W[A]];
            if (!Array.isArray(_))
              if (v === "before")
                W[A].unshift(_);
              else
                W[A].push(_);
            else if (v === "before")
              W[A] = _.concat(W[A]);
            else
              W[A] = W[A].concat(_);
            return;
          }
        }, P = { events: { global: z, local: W }, onParse: O("parse"), onTransform: O("transform"), onBeforeHandle: O("beforeHandle"), onAfterHandle: O("afterHandle"), onResponse: O("onResponse"), onError: O("error") };
        for (let A of this.macros) {
          const T = {};
          for (let [v, Z0] of Object.entries(W ?? {})) {
            if (a0.includes(v))
              continue;
            T[v] = Z0;
          }
          if (!A.$elysiaChecksum)
            A.$elysiaChecksum = [];
          const _ = _0(JSON.stringify(T));
          if (A.$elysiaChecksum.includes(_))
            continue;
          A.$elysiaChecksum.push(_0(JSON.stringify(T))), e0(A(P), W);
        }
      }
      const V = a(z, W), N = typeof Z === "function";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, Y, { validator: G, hooks: V, content: W?.type, handle: Z }), this.config.strictPath === false)
          this.dynamicRouter.add($, U, { validator: G, hooks: V, content: W?.type, handle: Z });
        this.routes.push({ method: $, path: Y, composed: null, handler: Z, hooks: V });
        return;
      }
      const K = r1({ path: Y, method: $, hooks: V, validator: G, handler: Z, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: X ? this.definitions.type : undefined, schema: X ? this.schema : undefined, getReporter: () => this.reporter, setHeader: this.setHeaders });
      if (!N) {
        const O = Object.assign({ headers: {}, query: {}, params: {}, body: undefined, request: new Request(`http://localhost${Y}`), store: this.store, path: Y, set: { headers: this.setHeaders ?? {}, status: 200 } }, this.decorators);
        let P;
        for (let A of Object.values(V.request))
          try {
            const T = y(A(O), O.set);
            if (T !== undefined) {
              P = T;
              break;
            }
          } catch (T) {
            P = this.handleError(O, T);
            break;
          }
        if (P)
          K.response = P;
        else
          try {
            K.response = K(O);
          } catch (A) {
            K.response = this.handleError(O, A);
          }
      }
      const j = this.routes.findIndex((O) => O.path === Y && O.method === $);
      if (j !== -1)
        this.routes.splice(j, 1);
      if (this.routes.push({ method: $, path: Y, composed: K, handler: Z, hooks: V }), $ === "$INTERNALWS") {
        const O = this.config.strictPath ? undefined : Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
        if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
          const P = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(K), K.response instanceof Response)
            this.staticRouter.variables += `const st${P} = staticRouter.handlers[${P}].response\n`;
          else
            this.staticRouter.variables += `const st${P} = staticRouter.handlers[${P}]\n`;
          if (this.wsPaths[Y] = P, O)
            this.wsPaths[O] = P;
        } else if (this.wsRouter.add("ws", Y, K), O)
          this.wsRouter.add("ws", O, K);
        return;
      }
      if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
        const O = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(K), K.response instanceof Response)
          this.staticRouter.variables += `const st${O} = staticRouter.handlers[${O}].response\n`;
        else
          this.staticRouter.variables += `const st${O} = staticRouter.handlers[${O}]\n`;
        if (!this.staticRouter.map[Y])
          this.staticRouter.map[Y] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[Y].all = `default: return st${O}(ctx)\n`;
        else if (K.response instanceof Response)
          this.staticRouter.map[Y].code = `case '${$}': return st${O}.clone()\n${this.staticRouter.map[Y].code}`;
        else
          this.staticRouter.map[Y].code = `case '${$}': return st${O}(ctx)\n${this.staticRouter.map[Y].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[U])
            this.staticRouter.map[U] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[U].all = `default: return st${O}(ctx)\n`;
          else if (K.response instanceof Response)
            this.staticRouter.map[U].code = `case '${$}': return st${O}.clone()\n${this.staticRouter.map[U].code}`;
          else
            this.staticRouter.map[U].code = `case '${$}': return st${O}(ctx)\n${this.staticRouter.map[U].code}`;
        }
      } else if (this.router.add($, Y, K), !this.config.strictPath)
        this.router.add($, Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/", K);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  resolve($) {
    return $.$elysia = "resolve", this.onBeforeHandle($);
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  mapResponse($) {
    return this.on("mapResponse", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", P1(() => this.reporter, this.event.trace.length, $)), this.on("trace", $), this;
  }
  error($, J) {
    switch (typeof $) {
      case "string":
        return J.prototype[G0] = $, this.definitions.error[$] = J, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [Z, W] of Object.entries($))
      W.prototype[G0] = Z, this.definitions.error[Z] = W;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, J) {
    for (let Z of Array.isArray(J) ? J : [J])
      switch (Z = q1(Z), $) {
        case "start":
          this.event.start.push(Z);
          break;
        case "request":
          this.event.request.push(Z);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, Z);
          break;
        case "transform":
          this.event.transform.push(Z);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(Z);
          break;
        case "afterHandle":
          this.event.afterHandle.push(Z);
          break;
        case "mapResponse":
          this.event.mapResponse.push(Z);
          break;
        case "response":
          this.event.onResponse.push(Z);
          break;
        case "trace":
          this.event.trace.push(Z);
          break;
        case "error":
          this.event.error.push(Z);
          break;
        case "stop":
          this.event.stop.push(Z);
          break;
      }
    return this;
  }
  group($, J, Z) {
    const W = new n({ ...this.config, prefix: "" });
    W.store = this.store, W.definitions = this.definitions, W.getServer = () => this.server;
    const X = typeof J === "object", B = (X ? Z : J)(W);
    if (this.decorators = d(this.decorators, W.decorators), B.event.request.length)
      this.event.request = [...this.event.request, ...B.event.request];
    if (B.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...B.event.onResponse];
    return this.model(B.definitions.type), Object.values(W.routes).forEach(({ method: Y, path: D, handler: Q, hooks: G }) => {
      if (D = (X ? "" : this.config.prefix) + $ + D, X) {
        const z = J, U = G;
        this.add(Y, D, Q, a(z, { ...U, error: !U.error ? B.event.error : Array.isArray(U.error) ? [...U.error, ...B.event.error] : [U.error, ...B.event.error] }));
      } else
        this.add(Y, D, Q, a(G, { error: B.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, J) {
    if (!J)
      return this.event = v0(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const Z = new n({ ...this.config, prefix: "" });
    Z.store = this.store, Z.definitions = this.definitions;
    const W = J(Z);
    if (this.decorators = d(this.decorators, Z.decorators), W.event.request.length)
      this.event.request = [...this.event.request, ...W.event.request];
    if (W.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...W.event.onResponse];
    return this.model(W.definitions.type), Object.values(Z.routes).forEach(({ method: X, path: B, handler: Y, hooks: D }) => {
      this.add(X, B, Y, a($, { ...D, error: !D.error ? W.event.error : Array.isArray(D.error) ? [...D.error, ...W.event.error] : [D.error, ...W.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((J) => {
        if (typeof J === "function")
          return J(this);
        if (typeof J.default === "function")
          return J.default(this);
        return this._use(J);
      }).then((J) => J.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const X = $(this);
      if (X instanceof Promise)
        return this.lazyLoadModules.push(X.then((B) => {
          if (B instanceof n) {
            this.compile();
            for (let { method: Y, path: D, handler: Q, hooks: G } of Object.values(B.routes))
              this.add(Y, D, Q, a(G, { error: B.event.error }));
            return B;
          }
          if (typeof B === "function")
            return B(this);
          if (typeof B.default === "function")
            return B.default(this);
          return this._use(B);
        }).then((B) => B.compile())), this;
      return X;
    }
    const { name: J, seed: Z } = $.config;
    $.getServer = () => this.getServer(), this.headers($.setHeaders);
    const W = $.config.scoped;
    if (W) {
      if (J) {
        if (!(J in this.dependencies))
          this.dependencies[J] = [];
        const B = Z !== undefined ? _0(J + JSON.stringify(Z)) : 0;
        if (this.dependencies[J].some(({ checksum: Y }) => B === Y))
          return this;
        this.dependencies[J].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: B, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: B, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })) });
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.macros = [...this.macros, ...$.macros], $.onRequest((B) => {
        Object.assign(B, this.decorators), Object.assign(B.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const X = this.mount($.fetch);
      return this.routes = this.routes.concat(X.routes), this;
    } else {
      $.reporter = this.reporter;
      for (let X of $.event.trace)
        this.trace(X);
      if (J) {
        if (!(J in this.dependencies))
          this.dependencies[J] = [];
        const X = Z !== undefined ? _0(J + JSON.stringify(Z)) : 0;
        if (!this.dependencies[J].some(({ checksum: B }) => X === B))
          this.macros.push(...$.macros);
      }
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: X, path: B, handler: Y, hooks: D } of Object.values($.routes))
      this.add(X, B, Y, a(D, { error: $.event.error }));
    if (!W)
      if (J) {
        if (!(J in this.dependencies))
          this.dependencies[J] = [];
        const X = Z !== undefined ? _0(J + JSON.stringify(Z)) : 0;
        if (this.dependencies[J].some(({ checksum: B }) => X === B))
          return this;
        this.dependencies[J].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: X, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: X, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((B) => B?.$elysia === "derive").map((B) => ({ fn: B.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((B) => B?.$elysia === "resolve").map((B) => ({ fn: B.toString(), stack: new Error().stack ?? "" })) }), this.event = v0(this.event, o0($.event), X);
      } else
        this.event = v0(this.event, o0($.event));
    return this;
  }
  macro($) {
    return this.macros.push($), this;
  }
  mount($, J) {
    if ($ instanceof n || typeof $ === "function" || $.length === 0 || $ === "/") {
      const X = typeof $ === "function" ? $ : $ instanceof n ? $.compile().fetch : J instanceof n ? J.compile().fetch : J, B = async ({ request: Y, path: D }) => X(new Request(t02(Y.url, D || "/"), Y));
      return this.all("/", B, { type: "none" }), this.all("/*", B, { type: "none" }), this;
    }
    const Z = $.length;
    if (J instanceof n)
      J = J.compile().fetch;
    const W = async ({ request: X, path: B }) => J(new Request(t02(X.url, B.slice(Z) || "/"), X));
    return this.all($, W, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), W, { type: "none" }), this;
  }
  get($, J, Z) {
    return this.add("GET", $, J, Z), this;
  }
  post($, J, Z) {
    return this.add("POST", $, J, Z), this;
  }
  put($, J, Z) {
    return this.add("PUT", $, J, Z), this;
  }
  patch($, J, Z) {
    return this.add("PATCH", $, J, Z), this;
  }
  delete($, J, Z) {
    return this.add("DELETE", $, J, Z), this;
  }
  options($, J, Z) {
    return this.add("OPTIONS", $, J, Z), this;
  }
  all($, J, Z) {
    return this.add("ALL", $, J, Z), this;
  }
  head($, J, Z) {
    return this.add("HEAD", $, J, Z), this;
  }
  connect($, J, Z) {
    return this.add("CONNECT", $, J, Z), this;
  }
  ws($, J) {
    const Z = J.transformMessage ? Array.isArray(J.transformMessage) ? J.transformMessage : [J.transformMessage] : undefined;
    let W = null;
    const X = p(J?.body, { models: this.definitions.type }), B = p(J?.response, { models: this.definitions.type }), Y = (D) => {
      if (typeof D === "string") {
        const Q = D?.charCodeAt(0);
        if (Q === 47 || Q === 123)
          try {
            D = JSON.parse(D);
          } catch {
          }
        else if (f02(D))
          D = +D;
      }
      if (Z?.length)
        for (let Q = 0;Q < Z.length; Q++) {
          const G = Z[Q](D);
          if (G !== undefined)
            D = G;
        }
      return D;
    };
    return this.route("$INTERNALWS", $, (D) => {
      const { set: Q, path: G, qi: z, headers: U, query: V, params: N } = D;
      if (W === null)
        W = this.getServer();
      if (W?.upgrade(D.request, { headers: typeof J.upgrade === "function" ? J.upgrade(D) : J.upgrade, data: { validator: B, open(K) {
        J.open?.(new z0(K, D));
      }, message: (K, j) => {
        const O = Y(j);
        if (X?.Check(O) === false)
          return void K.send(new S("message", X, O).message);
        J.message?.(new z0(K, D), O);
      }, drain(K) {
        J.drain?.(new z0(K, D));
      }, close(K, j, O) {
        J.close?.(new z0(K, D), j, O);
      } } }))
        return;
      return Q.status = 400, "Expected a websocket connection";
    }, { beforeHandle: J.beforeHandle, transform: J.transform, headers: J.headers, params: J.params, query: J.query }), this;
  }
  route($, J, Z, { config: W, ...X } = { config: { allowMeta: false } }) {
    return this.add($, J, Z, X, W), this;
  }
  state($, J) {
    switch (typeof $) {
      case "object":
        return this.store = d(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = J;
    return this;
  }
  decorate($, J) {
    switch (typeof $) {
      case "object":
        return this.decorators = d(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = J;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, J) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([Z, W]) => {
          if (!(Z in this.definitions.type))
            this.definitions.type[Z] = W;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = J, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, J, Z) {
    if (Z === "")
      return this;
    const W = ["_", "-", " "], X = (Q) => Q[0].toUpperCase() + Q.slice(1), B = $ === "prefix" ? (Q, G) => W.includes(Q.at(-1) ?? "") ? Q + G : Q + X(G) : W.includes(Z.at(-1) ?? "") ? (Q, G) => G + Q : (Q, G) => G + X(Q), Y = (Q) => {
      const G = {};
      switch (Q) {
        case "decorator":
          for (let z in this.decorators)
            G[B(Z, z)] = this.decorators[z];
          this.decorators = G;
          break;
        case "state":
          for (let z in this.store)
            G[B(Z, z)] = this.store[z];
          this.store = G;
          break;
        case "model":
          for (let z in this.definitions.type)
            G[B(Z, z)] = this.definitions.type[z];
          this.definitions.type = G;
          break;
        case "error":
          for (let z in this.definitions.error)
            G[B(Z, z)] = this.definitions.error[z];
          this.definitions.error = G;
          break;
      }
    }, D = Array.isArray(J) ? J : [J];
    for (let Q of D.some((G) => G === "all") ? ["decorator", "state", "model", "error"] : D)
      Y(Q);
    return this;
  }
  prefix($, J) {
    return this.affix("prefix", $, J);
  }
  suffix($, J) {
    return this.affix("suffix", $, J);
  }
  compile() {
    if (this.fetch = this.config.aot ? Q12(this) : D12(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? Q12(this) : D12(this))($);
  };
  handleError = async ($, J) => (this.handleError = this.config.aot ? _12(this) : t12(this))($, J);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, J) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const Z = this.fetch, W = typeof $ === "object" ? { development: !F0, reusePort: true, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...J1 }, fetch: Z, error: this.outerErrorHandler } : { development: !F0, reusePort: true, ...this.config.serve, websocket: { ...this.config.websocket, ...J1 }, port: $, fetch: Z, error: this.outerErrorHandler };
    if (this.server = Bun?.serve(W), this.event.start.length)
      for (let X = 0;X < this.event.start.length; X++)
        this.event.start[X](this);
    if (J)
      J(this.server);
    return process.on("beforeExit", () => {
      for (let X = 0;X < this.event.stop.length; X++)
        this.event.stop[X](this);
    }), Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      for (let $ = 0;$ < this.event.stop.length; $++)
        this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: "*",
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: false,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
  const app = new n({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart === -1)
          return false;
        return origin2 === from.slice(protocolStart + 3);
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers["Vary"] = "*";
      set2.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value14 = processOrigin(origins[i], request, from);
        if (value14 === true) {
          set2.headers["Vary"] = origin ? "Origin" : "*";
          set2.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
          return;
        }
        if (value14)
          headers.push(value14);
      }
    }
    set2.headers["Vary"] = "Origin";
    set2.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set2) => {
    if (!methods?.length)
      return;
    if (methods === "*")
      return set2.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["Access-Control-Allow-Methods"] = methods;
    set2.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set: set2, request }) => {
      handleOrigin(set2, request);
      handleMethod(set2);
      if (exposedHeaders.length)
        set2.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set2.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set: set2, request }) => {
      handleOrigin(set2, request);
      handleMethod(set2);
      if (exposedHeaders.length)
        set2.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set2.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  return app.onRequest(({ set: set2, request }) => {
    handleOrigin(set2, request);
    handleMethod(set2);
    if (allowedHeaders.length)
      set2.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
    if (exposedHeaders.length)
      set2.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
    if (credentials)
      set2.headers["Access-Control-Allow-Credentials"] = "true";
  });
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 6,
  patch: 0,
  preReleaseTag: null
});
// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value14) {
  return typeof (value14 === null || value14 === undefined ? undefined : value14.then) === "function";
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value14) {
  return typeof value14 == "object" && value14 !== null;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp = /\r\n|[\n\r]/g;

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0;i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
var printPrefixedLines = function(lines) {
  const existingLines = lines.filter(([_, line]) => line !== undefined);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/error/GraphQLError.mjs
var toNormalizedOptions = function(args) {
  const firstArg = args[0];
  if (firstArg == null || ("kind" in firstArg) || ("length" in firstArg)) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
};
var undefinedIfEmpty = function(array4) {
  return array4 === undefined || array4.length === 0 ? undefined : array4;
};
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== undefined ? path : undefined;
    this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
    this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
    this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== undefined && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location3 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location3);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}

class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}

class Token {
  constructor(kind, start, end, line, column, value14) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value14;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/kinds.mjs
var Kind2;
(function(Kind3) {
  Kind3["NAME"] = "Name";
  Kind3["DOCUMENT"] = "Document";
  Kind3["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind3["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind3["SELECTION_SET"] = "SelectionSet";
  Kind3["FIELD"] = "Field";
  Kind3["ARGUMENT"] = "Argument";
  Kind3["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind3["INLINE_FRAGMENT"] = "InlineFragment";
  Kind3["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind3["VARIABLE"] = "Variable";
  Kind3["INT"] = "IntValue";
  Kind3["FLOAT"] = "FloatValue";
  Kind3["STRING"] = "StringValue";
  Kind3["BOOLEAN"] = "BooleanValue";
  Kind3["NULL"] = "NullValue";
  Kind3["ENUM"] = "EnumValue";
  Kind3["LIST"] = "ListValue";
  Kind3["OBJECT"] = "ObjectValue";
  Kind3["OBJECT_FIELD"] = "ObjectField";
  Kind3["DIRECTIVE"] = "Directive";
  Kind3["NAMED_TYPE"] = "NamedType";
  Kind3["LIST_TYPE"] = "ListType";
  Kind3["NON_NULL_TYPE"] = "NonNullType";
  Kind3["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind3["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind3["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind3["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind3["FIELD_DEFINITION"] = "FieldDefinition";
  Kind3["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind3["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind3["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind3["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind3["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind3["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind3["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind3["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind3["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind3["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind3["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind3["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind3["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind3["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind2 || (Kind2 = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0;i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent = leadingWhitespace(line);
    if (indent === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent < commonIndent) {
      commonIndent = indent;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
};
function isPrintableAsBlockString(value14) {
  if (value14 === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0;i < value14.length; ++i) {
    switch (value14.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value14, options) {
  const escapedValue = value14.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value14.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value14.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value14.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value14.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
var isUnicodeScalarValue = function(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
};
var isSupplementaryCodePoint = function(body, location3) {
  return isLeadingSurrogate(body.charCodeAt(location3)) && isTrailingSurrogate(body.charCodeAt(location3 + 1));
};
var isLeadingSurrogate = function(code) {
  return code >= 55296 && code <= 56319;
};
var isTrailingSurrogate = function(code) {
  return code >= 56320 && code <= 57343;
};
var printCodePointAt = function(lexer, location3) {
  const code = lexer.source.body.codePointAt(location3);
  if (code === undefined) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? "'\"'" : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
};
var createToken = function(lexer, kind, start, end, value14) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value14);
};
var readNextToken = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
};
var readComment = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
};
var readNumber = function(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
};
var readDigits = function(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
};
var readString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value14 = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value14 += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value14);
    }
    if (code === 92) {
      value14 += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value14 += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readEscapedUnicodeVariableWidth = function(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
};
var readEscapedUnicodeFixedWidth = function(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
};
var read16BitHexCode = function(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
};
var readHexDigit = function(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
};
var readEscapedCharacter = function(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: `\r`,
        size: 2
      };
    case 116:
      return {
        value: "\t",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
};
var readBlockString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readName = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
};

class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/inspect.mjs
function inspect(value14) {
  return formatValue(value14, []);
}
var formatValue = function(value14, seenValues) {
  switch (typeof value14) {
    case "string":
      return JSON.stringify(value14);
    case "function":
      return value14.name ? `[function ${value14.name}]` : "[function]";
    case "object":
      return formatObjectValue(value14, seenValues);
    default:
      return String(value14);
  }
};
var formatObjectValue = function(value14, previouslySeenValues) {
  if (value14 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value14)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value14];
  if (isJSONable(value14)) {
    const jsonValue = value14.toJSON();
    if (jsonValue !== value14) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value14)) {
    return formatArray(value14, seenValues);
  }
  return formatObject(value14, seenValues);
};
var isJSONable = function(value14) {
  return typeof value14.toJSON === "function";
};
var formatObject = function(object12, seenValues) {
  const entries = Object.entries(object12);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object12) + "]";
  }
  const properties = entries.map(([key, value14]) => key + ": " + formatValue(value14, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray = function(array4, seenValues) {
  if (array4.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array4.length);
  const remaining = array4.length - len;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array4[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object12) {
  const tag = Object.prototype.toString.call(object12).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object12.constructor === "function") {
    const name = object12.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = function instanceOf3(value14, constructor4) {
  if (value14 instanceof constructor4) {
    return true;
  }
  if (typeof value14 === "object" && value14 !== null) {
    var _value$constructor;
    const className = constructor4.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value14 ? value14[Symbol.toStringTag] : (_value$constructor = value14.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value14);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}

class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/parser.mjs
function parse4(source2, options) {
  const parser = new Parser(source2, options);
  return parser.parseDocument();
}
var getTokenDesc = function(token) {
  const value14 = token.value;
  return getTokenKindDesc(token.kind) + (value14 != null ? ` "${value14}"` : "");
};
var getTokenKindDesc = function(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
};

class Parser {
  constructor(source2, options = {}) {
    const sourceObj = isSource(source2) ? source2 : new Source(source2);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind2.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind2.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind2.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind2.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind2.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind2.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind2.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind2.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind2.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind2.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind2.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind2.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind2.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind2.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind2.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind2.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind2.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind2.NULL
            });
          default:
            return this.node(token, {
              kind: Kind2.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind2.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind2.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind2.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind2.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind2.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type73;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type73 = this.node(start, {
        kind: Kind2.LIST_TYPE,
        type: innerType
      });
    } else {
      type73 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind2.NON_NULL_TYPE,
        type: type73
      });
    }
    return type73;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind2.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind2.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type73 = this.parseNamedType();
    return this.node(start, {
      kind: Kind2.OPERATION_TYPE_DEFINITION,
      operation,
      type: type73
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind2.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind2.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type73 = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind2.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type: type73,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type73 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind2.INPUT_VALUE_DEFINITION,
      description,
      name,
      type: type73,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind2.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind2.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind2.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind2.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind2.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind2.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind2.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value14) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value14) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value14}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value14) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value14) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
      }
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS = 5;

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map3, fn) {
  const result = Object.create(null);
  for (const key of Object.keys(map3)) {
    result[key] = fn(map3[key], key);
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var isDigit2 = function(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
};
var DIGIT_0 = 48;
var DIGIT_9 = 57;

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== undefined) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a2, b2) => {
    const distanceDiff = optionsByDistance[a2] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a2, b2);
  });
}
var stringToArray = function(str) {
  const strLength = str.length;
  const array4 = new Array(strLength);
  for (let i = 0;i < strLength; ++i) {
    array4[i] = str.charCodeAt(i);
  }
  return array4;
};

class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a2 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a2.length < b2.length) {
      const tmp = a2;
      a2 = b2;
      b2 = tmp;
    }
    const aLength = a2.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return;
    }
    const rows = this._rows;
    for (let j = 0;j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1;i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1;j <= bLength; j++) {
        const cost = a2[i - 1] === b2[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a2[i - 1] === b2[j - 2] && a2[i - 2] === b2[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : undefined;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map3 = Object.create(null);
  for (const [key, value14] of Object.entries(obj)) {
    map3[key] = value14;
  }
  return map3;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedReplacer = function(str) {
  return escapeSequences[str.charCodeAt(0)];
};
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = new Map;
  for (const kind of Object.values(Kind2)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = undefined;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = undefined;
  let parent = undefined;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === undefined) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== undefined) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== undefined);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = Object.create(null);
  for (const kind of Object.values(Kind2)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(undefined);
    const leaveList = new Array(visitors.length).fill(undefined);
    for (let i = 0;i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: undefined
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK = Object.freeze({});

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/printer.mjs
function print(ast4) {
  return visit(ast4, printDocASTReducer);
}
var join2 = function(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
};
var block = function(array4) {
  return wrap("{\n", indent(join2(array4, "\n")), "\n}");
};
var wrap = function(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
};
var indent = function(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
};
var hasMultilineItems = function(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
};
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2([
        node.operation,
        join2([node.name, varDefs]),
        join2(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type73, defaultValue, directives }) => variable + ": " + type73 + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value: value14 }) => name + ": " + value14
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join2(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join2([
      "...",
      wrap("on ", typeCondition),
      join2(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value: value14 }) => value14
  },
  FloatValue: {
    leave: ({ value: value14 }) => value14
  },
  StringValue: {
    leave: ({ value: value14, block: isBlockString }) => isBlockString ? printBlockString(value14) : printString(value14)
  },
  BooleanValue: {
    leave: ({ value: value14 }) => value14 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value14 }) => value14
  },
  ListValue: {
    leave: ({ values }) => "[" + join2(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value: value14 }) => name + ": " + value14
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type: type73 }) => "[" + type73 + "]"
  },
  NonNullType: {
    leave: ({ type: type73 }) => type73 + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join2(["schema", join2(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type73 }) => operation + ": " + type73
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join2(["scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join2([
      "type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type: type73, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type73 + wrap(" ", join2(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type: type73, defaultValue, directives }) => wrap("", description, "\n") + join2([name + ": " + type73, wrap("= ", defaultValue), join2(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join2([
      "interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join2(["union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join2(["enum", name, join2(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join2([name, join2(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join2(["input", name, join2(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join2([
      "extend union",
      name,
      join2(directives, " "),
      wrap("= ", join2(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block(fields)], " ")
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind2.NULL:
      return null;
    case Kind2.INT:
      return parseInt(valueNode.value, 10);
    case Kind2.FLOAT:
      return parseFloat(valueNode.value);
    case Kind2.STRING:
    case Kind2.ENUM:
    case Kind2.BOOLEAN:
      return valueNode.value;
    case Kind2.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind2.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind2.VARIABLE:
      return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1;i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/definition.mjs
function isType(type73) {
  return isScalarType(type73) || isObjectType(type73) || isInterfaceType(type73) || isUnionType(type73) || isEnumType(type73) || isInputObjectType(type73) || isListType(type73) || isNonNullType(type73);
}
function isScalarType(type73) {
  return instanceOf(type73, GraphQLScalarType);
}
function isObjectType(type73) {
  return instanceOf(type73, GraphQLObjectType);
}
function isInterfaceType(type73) {
  return instanceOf(type73, GraphQLInterfaceType);
}
function isUnionType(type73) {
  return instanceOf(type73, GraphQLUnionType);
}
function isEnumType(type73) {
  return instanceOf(type73, GraphQLEnumType);
}
function isInputObjectType(type73) {
  return instanceOf(type73, GraphQLInputObjectType);
}
function isListType(type73) {
  return instanceOf(type73, GraphQLList);
}
function isNonNullType(type73) {
  return instanceOf(type73, GraphQLNonNull);
}
function isInputType(type73) {
  return isScalarType(type73) || isEnumType(type73) || isInputObjectType(type73) || isWrappingType(type73) && isInputType(type73.ofType);
}
function isOutputType(type73) {
  return isScalarType(type73) || isObjectType(type73) || isInterfaceType(type73) || isUnionType(type73) || isEnumType(type73) || isWrappingType(type73) && isOutputType(type73.ofType);
}
function isLeafType(type73) {
  return isScalarType(type73) || isEnumType(type73);
}
function isCompositeType(type73) {
  return isObjectType(type73) || isInterfaceType(type73) || isUnionType(type73);
}
function isAbstractType(type73) {
  return isInterfaceType(type73) || isUnionType(type73);
}
function isWrappingType(type73) {
  return isListType(type73) || isNonNullType(type73);
}
function isNullableType(type73) {
  return isType(type73) && !isNonNullType(type73);
}
function getNullableType(type73) {
  if (type73) {
    return isNonNullType(type73) ? type73.ofType : type73;
  }
}
function isNamedType(type73) {
  return isScalarType(type73) || isObjectType(type73) || isInterfaceType(type73) || isUnionType(type73) || isEnumType(type73) || isInputObjectType(type73);
}
function getNamedType(type73) {
  if (type73) {
    let unwrappedType = type73;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var defineInterfaces = function(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
};
var defineFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
var isPlainObj = function(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
};
var fieldsToFieldsConfig = function(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
};
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === undefined;
}
var defineTypes = function(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
  return types;
};
var didYouMeanEnumValue = function(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value14) => value14.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
};
var defineEnumValues = function(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== undefined ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
};
var defineInputFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === undefined;
}

class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);
    config.serialize == null || typeof config.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLEnumType {
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
    this._nameLookup = keyMap(this._values, (value14) => value14.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === undefined) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind2.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value14) => value14.name, (value14) => ({
      description: value14.description,
      value: value14.value,
      deprecationReason: value14.deprecationReason,
      extensions: value14.extensions,
      astNode: value14.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(undefined, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type73) => schema.isSubType(typeB, type73));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type73) {
  return specifiedScalarTypes.some(({ name }) => type73.name === name);
}
var serializeObject = function(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
};
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind2.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
        nodes: valueNode
      });
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind2.FLOAT && valueNode.kind !== Kind2.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind2.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind2.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind2.STRING && valueNode.kind !== Kind2.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}

class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(false, `@${config.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value14, type73) {
  if (isNonNullType(type73)) {
    const astValue = astFromValue(value14, type73.ofType);
    if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === Kind2.NULL) {
      return null;
    }
    return astValue;
  }
  if (value14 === null) {
    return {
      kind: Kind2.NULL
    };
  }
  if (value14 === undefined) {
    return null;
  }
  if (isListType(type73)) {
    const itemType = type73.ofType;
    if (isIterableObject(value14)) {
      const valuesNodes = [];
      for (const item of value14) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind2.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value14, itemType);
  }
  if (isInputObjectType(type73)) {
    if (!isObjectLike(value14)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type73.getFields())) {
      const fieldValue = astFromValue(value14[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind2.OBJECT_FIELD,
          name: {
            kind: Kind2.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind2.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type73)) {
    const serialized = type73.serialize(value14);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind2.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind2.INT,
        value: stringNum
      } : {
        kind: Kind2.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type73)) {
        return {
          kind: Kind2.ENUM,
          value: serialized
        };
      }
      if (type73 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind2.INT,
          value: serialized
        };
      }
      return {
        kind: Kind2.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type73));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type73) {
  return introspectionTypes.some(({ name }) => type73.name === name);
}
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type73) {
        if (isScalarType(type73)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type73)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type73)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type73)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type73)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type73)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type73)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type73)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type73)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type73) => ("name" in type73) ? type73.name : undefined
    },
    description: {
      type: GraphQLString,
      resolve: (type73) => ("description" in type73) ? type73.description : undefined
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type73, { includeDeprecated }) {
        if (isObjectType(type73) || isInterfaceType(type73)) {
          const fields = Object.values(type73.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type73) {
        if (isObjectType(type73) || isInterfaceType(type73)) {
          return type73.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type73, _args, _context, { schema }) {
        if (isAbstractType(type73)) {
          return schema.getPossibleTypes(type73);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type73, { includeDeprecated }) {
        if (isEnumType(type73)) {
          const values = type73.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type73, { includeDeprecated }) {
        if (isInputObjectType(type73)) {
          const values = Object.values(type73.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type73) => ("ofType" in type73) ? type73.ofType : undefined
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type73, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type73);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: undefined,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: undefined,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
var collectReferencedTypes = function(type73, typeSet) {
  const namedType = getNamedType(type73);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
};

class GraphQLSchema {
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : undefined;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect(config.types)}.`);
    !config.directives || Array.isArray(config.directives) || devAssert(false, '"directives" must be Array if provided but got: ' + `${inspect(config.directives)}.`);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type73 of config.types) {
        allReferencedTypes.delete(type73);
        collectReferencedTypes(type73, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = Object.create(null);
    this._subTypeMap = Object.create(null);
    this._implementationsMap = Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(false, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== undefined) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== undefined ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map3 = this._subTypeMap[abstractType.name];
    if (map3 === undefined) {
      map3 = Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type73 of abstractType.getTypes()) {
          map3[type73.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type73 of implementations.objects) {
          map3[type73.name] = true;
        }
        for (const type73 of implementations.interfaces) {
          map3[type73.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map3;
    }
    return map3[maybeSubType.name] !== undefined;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== undefined
    };
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/validate.mjs
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  const context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors4 = context.getErrors();
  schema2.__validationErrors = errors4;
  return errors4;
}
function assertValidSchema(schema2) {
  const errors4 = validateSchema(schema2);
  if (errors4.length !== 0) {
    throw new Error(errors4.map((error21) => error21.message).join("\n\n"));
  }
}
var validateRootTypes = function(context) {
  const schema2 = context.schema;
  const queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema2, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema2, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema2, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
};
var getOperationTypeNode = function(schema2, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap((schemaNode) => {
    var _schemaNode$operation;
    return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
};
var validateDirectives = function(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
        ]);
      }
    }
  }
};
var validateName = function(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
  }
};
var validateTypes = function(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type73 of Object.values(typeMap)) {
    if (!isNamedType(type73)) {
      context.reportError(`Expected GraphQL named type but got: ${inspect(type73)}.`, type73.astNode);
      continue;
    }
    if (!isIntrospectionType(type73)) {
      validateName(context, type73);
    }
    if (isObjectType(type73)) {
      validateFields(context, type73);
      validateInterfaces(context, type73);
    } else if (isInterfaceType(type73)) {
      validateFields(context, type73);
      validateInterfaces(context, type73);
    } else if (isUnionType(type73)) {
      validateUnionMembers(context, type73);
    } else if (isEnumType(type73)) {
      validateEnumValues(context, type73);
    } else if (isInputObjectType(type73)) {
      validateInputFields(context, type73);
      validateInputObjectCircularRefs(type73);
    }
  }
};
var validateFields = function(context, type73) {
  const fields = Object.values(type73.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type73.name} must define one or more fields.`, [
      type73.astNode,
      ...type73.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(`The type of ${type73.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(`The type of ${type73.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(`Required argument ${type73.name}.${field.name}(${argName}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
        ]);
      }
    }
  }
};
var validateInterfaces = function(context, type73) {
  const ifaceTypeNames = Object.create(null);
  for (const iface of type73.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(`Type ${inspect(type73)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type73, iface));
      continue;
    }
    if (type73 === iface) {
      context.reportError(`Type ${type73.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type73, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(`Type ${type73.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type73, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type73, iface);
    validateTypeImplementsInterface(context, type73, iface);
  }
};
var validateTypeImplementsInterface = function(context, type73, iface) {
  const typeFieldMap = type73.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type73.name} does not provide it.`, [ifaceField.astNode, type73.astNode, ...type73.extensionASTNodes]);
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type73.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
      ]);
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type73.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type73.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
        ]);
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(`Object field ${type73.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
      }
    }
  }
};
var validateTypeImplementsAncestors = function(context, type73, iface) {
  const ifaceInterfaces = type73.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(transitive === type73 ? `Type ${type73.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type73.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
        ...getAllImplementsInterfaceNodes(iface, transitive),
        ...getAllImplementsInterfaceNodes(type73, iface)
      ]);
    }
  }
};
var validateUnionMembers = function(context, union21) {
  const memberTypes = union21.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(`Union type ${union21.name} must define one or more member types.`, [union21.astNode, ...union21.extensionASTNodes]);
  }
  const includedTypeNames = Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(`Union type ${union21.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union21, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(`Union type ${union21.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union21, String(memberType)));
    }
  }
};
var validateEnumValues = function(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
};
var validateInputFields = function(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
      ]);
    }
  }
};
var createInputObjectCircularRefsValidator = function(context) {
  const visitedTypes = Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === undefined) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = undefined;
  }
};
var getAllImplementsInterfaceNodes = function(type73, iface) {
  const { astNode, extensionASTNodes } = type73;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
};
var getUnionMemberTypeNodes = function(union21, typeName) {
  const { astNode, extensionASTNodes } = union21;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
  }).filter((typeNode) => typeNode.name.value === typeName);
};
var getDeprecatedDirectiveNode = function(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);
};

class SchemaValidationContext {
  constructor(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(new GraphQLError(message, {
      nodes: _nodes
    }));
  }
  getErrors() {
    return this._errors;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema2, typeNode) {
  switch (typeNode.kind) {
    case Kind2.LIST_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind2.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind2.NAMED_TYPE:
      return schema2.getType(typeNode.name.value);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/TypeInfo.mjs
var getFieldDef = function(schema2, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
};
function visitWithTypeInfo(typeInfo, visitor3) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor3, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor3, args);
        if (result !== undefined) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor3, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor3, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

class TypeInfo {
  constructor(schema2, initialType, getFieldDefFn) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema2 = this._schema;
    switch (node.kind) {
      case Kind2.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);
        break;
      }
      case Kind2.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);
        break;
      }
      case Kind2.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind2.OPERATION_DEFINITION: {
        const rootType = schema2.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);
        break;
      }
      case Kind2.INLINE_FRAGMENT:
      case Kind2.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);
        break;
      }
      case Kind2.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);
        break;
      }
      case Kind2.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);
        break;
      }
      case Kind2.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(undefined);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);
        break;
      }
      case Kind2.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);
        break;
      }
      case Kind2.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind2.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind2.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind2.DIRECTIVE:
        this._directive = null;
        break;
      case Kind2.OPERATION_DEFINITION:
      case Kind2.INLINE_FRAGMENT:
      case Kind2.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind2.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind2.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind2.LIST:
      case Kind2.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind2.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind2.OPERATION_DEFINITION || node.kind === Kind2.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind2.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind2.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind2.SCALAR_TYPE_DEFINITION || node.kind === Kind2.OBJECT_TYPE_DEFINITION || node.kind === Kind2.INTERFACE_TYPE_DEFINITION || node.kind === Kind2.UNION_TYPE_DEFINITION || node.kind === Kind2.ENUM_TYPE_DEFINITION || node.kind === Kind2.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind2.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind2.SCALAR_TYPE_EXTENSION || node.kind === Kind2.OBJECT_TYPE_EXTENSION || node.kind === Kind2.INTERFACE_TYPE_EXTENSION || node.kind === Kind2.UNION_TYPE_EXTENSION || node.kind === Kind2.ENUM_TYPE_EXTENSION || node.kind === Kind2.INPUT_OBJECT_TYPE_EXTENSION;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition10 of node.definitions) {
        if (!isExecutableDefinitionNode(definition10)) {
          const defName = definition10.kind === Kind2.SCHEMA_DEFINITION || definition10.kind === Kind2.SCHEMA_EXTENSION ? "schema" : '"' + definition10.name.value + '"';
          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, {
            nodes: definition10
          }));
        }
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type73 = context.getParentType();
      if (type73) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema2 = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema2, type73, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type73, fieldName));
          }
          context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type73.name}".` + suggestion, {
            nodes: node
          }));
        }
      }
    }
  };
}
var getSuggestedTypeNames = function(schema2, type73, fieldName) {
  if (!isAbstractType(type73)) {
    return [];
  }
  const suggestedTypes = new Set;
  const usageCount = Object.create(null);
  for (const possibleType of schema2.getPossibleTypes(type73)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
};
var getSuggestedFieldNames = function(type73, fieldName) {
  if (isObjectType(type73) || isInterfaceType(type73)) {
    const possibleFieldNames = Object.keys(type73.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type73 = typeFromAST(context.getSchema(), typeCondition);
        if (type73 && !isCompositeType(type73)) {
          const typeStr = print(typeCondition);
          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
            nodes: typeCondition
          }));
        }
      }
    },
    FragmentDefinition(node) {
      const type73 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type73 && !isCompositeType(type73)) {
        const typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
          nodes: node.typeCondition
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), {
          nodes: argNode
        }));
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind2.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), {
              nodes: argNode
            }));
          }
        }
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind2.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(new GraphQLError(`Unknown directive "@${name}".`, {
          nodes: node
        }));
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
          nodes: node
        }));
      }
    }
  };
}
var getDirectiveLocationForASTPath = function(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  ("kind" in appliedTo) || invariant(false);
  switch (appliedTo.kind) {
    case Kind2.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind2.FIELD:
      return DirectiveLocation.FIELD;
    case Kind2.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind2.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind2.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind2.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind2.SCHEMA_DEFINITION:
    case Kind2.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind2.SCALAR_TYPE_DEFINITION:
    case Kind2.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind2.OBJECT_TYPE_DEFINITION:
    case Kind2.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind2.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind2.INTERFACE_TYPE_DEFINITION:
    case Kind2.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind2.UNION_TYPE_DEFINITION:
    case Kind2.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind2.ENUM_TYPE_DEFINITION:
    case Kind2.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind2.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind2.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind2.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind2.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      ("kind" in parentNode) || invariant(false);
      return parentNode.kind === Kind2.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
};
var getDirectiveLocationForOperation = function(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, {
          nodes: node.name
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypesMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _13, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), {
          nodes: node
        }));
      }
    }
  };
}
var isSDLNode = function(value14) {
  return ("kind" in value14) && (isTypeSystemDefinitionNode(value14) || isTypeSystemExtensionNode(value14));
};
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type73) => type73.name);

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter((definition12) => definition12.kind === Kind2.OPERATION_DEFINITION).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", {
          nodes: node
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", {
          nodes: node
        }));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", {
          nodes: node
        }));
      }
      ++schemaDefinitionsCount;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === undefined) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s2) => '"' + s2.name.value + '"').join(", ");
        context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
          nodes: cyclePath
        }));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = undefined;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "\$${varName}" is not defined.`, {
              nodes: [node, operation]
            }));
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, {
              nodes: fragmentDef
            }));
          }
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "\$${variableName}" is never used.`, {
              nodes: variableDef
            }));
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind2.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind2.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind2.INT:
    case Kind2.FLOAT:
    case Kind2.STRING:
    case Kind2.BOOLEAN:
    case Kind2.NULL:
    case Kind2.ENUM:
    case Kind2.VARIABLE:
      return valueNode;
  }
}
var sortFields = function(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
var reasonMessage = function(reason) {
  if (Array.isArray(reason)) {
    return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
  }
  return reason;
};
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet;
  const cachedFieldsAndFragmentNames = new Map;
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
          nodes: fields1.concat(fields2)
        }));
      }
    }
  };
}
var findConflictsWithinSelectionSet = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (let i = 0;i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (let j = i + 1;j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
};
var collectConflictsBetweenFieldsAndFragment = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
      continue;
    }
    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
  }
};
var collectConflictsBetweenFragments = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
  }
};
var findConflictsBetweenSubSelectionSets = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
    }
  }
  return conflicts;
};
var collectConflictsWithin = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0;i < fields.length; i++) {
        for (let j = i + 1;j < fields.length; j++) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var collectConflictsBetween = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var findConflict = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
  const type210 = def2 === null || def2 === undefined ? undefined : def2.type;
  if (type1 && type210 && doTypesConflict(type1, type210)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(type210)}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type210), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
};
var stringifyArguments = function(fieldNode) {
  var _fieldNode$arguments;
  const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== undefined ? _fieldNode$arguments : [];
  const inputObjectWithArgs = {
    kind: Kind2.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind2.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
};
var doTypesConflict = function(type1, type210) {
  if (isListType(type1)) {
    return isListType(type210) ? doTypesConflict(type1.ofType, type210.ofType) : true;
  }
  if (isListType(type210)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type210) ? doTypesConflict(type1.ofType, type210.ofType) : true;
  }
  if (isNonNullType(type210)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type210)) {
    return type1 !== type210;
  }
  return false;
};
var getFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = Object.create(null);
  const fragmentNames = Object.create(null);
  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
};
var getReferencedFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
};
var _collectFieldsAndFragmentNames = function(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind2.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind2.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind2.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
};
var subfieldConflicts = function(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
};

class PairSet {
  constructor() {
    this._data = new Map;
  }
  has(a2, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a2 < b2 ? [a2, b2] : [b2, a2];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(key2);
    if (result === undefined) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a2, b2, areMutuallyExclusive) {
    const [key1, key2] = a2 < b2 ? [a2, b2] : [b2, a2];
    const map3 = this._data.get(key1);
    if (map3 === undefined) {
      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));
    } else {
      map3.set(key2, areMutuallyExclusive);
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    }
  };
}
var getFragmentType = function(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type73 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type73)) {
      return type73;
    }
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema2 = context.getSchema();
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema2 === null || schema2 === undefined ? undefined : schema2.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
          nodes: defNode ? [defNode, node] : node
        }));
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema2 === null || schema2 === undefined ? undefined : schema2.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
        nodes: node.name
      }));
    }
  }
}
var typeToExtKind = function(type73) {
  if (isScalarType(type73)) {
    return Kind2.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type73)) {
    return Kind2.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type73)) {
    return Kind2.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type73)) {
    return Kind2.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type73)) {
    return Kind2.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type73)) {
    return Kind2.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type73));
};
var extensionKindToTypeName = function(kind) {
  switch (kind) {
    case Kind2.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind2.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind2.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind2.UNION_TYPE_EXTENSION:
      return "union";
    case Kind2.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind2.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
};
var defKindToExtKind = {
  [Kind2.SCALAR_TYPE_DEFINITION]: Kind2.SCALAR_TYPE_EXTENSION,
  [Kind2.OBJECT_TYPE_DEFINITION]: Kind2.OBJECT_TYPE_EXTENSION,
  [Kind2.INTERFACE_TYPE_DEFINITION]: Kind2.INTERFACE_TYPE_EXTENSION,
  [Kind2.UNION_TYPE_DEFINITION]: Kind2.UNION_TYPE_EXTENSION,
  [Kind2.ENUM_TYPE_DEFINITION]: Kind2.ENUM_TYPE_EXTENSION,
  [Kind2.INPUT_OBJECT_TYPE_DEFINITION]: Kind2.INPUT_OBJECT_TYPE_EXTENSION
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
              nodes: fieldNode
            }));
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === undefined ? undefined : schema2.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), (arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind2.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                nodes: directiveNode
              }));
            }
          }
        }
      }
    }
  };
}
var isRequiredArgumentNode = function(arg) {
  return arg.type.kind === Kind2.NON_NULL_TYPE && arg.defaultValue == null;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type73 = context.getType();
      const selectionSet = node.selectionSet;
      if (type73) {
        if (isLeafType(getNamedType(type73))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type73);
            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
              nodes: selectionSet
            }));
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type73);
          context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
            nodes: node
          }));
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type73, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type73, onError, undefined);
}
var defaultOnError = function(path, invalidValue, error21) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error21.message = errorPrefix + ": " + error21.message;
  throw error21;
};
var coerceInputValueImpl = function(inputValue, type73, onError, path) {
  if (isNonNullType(type73)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type73.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect(type73)}" not to be null.`));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type73)) {
    const itemType = type73.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, undefined);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type73)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type73.name}" to be an object.`));
      return;
    }
    const coercedValue = {};
    const fieldDefs = type73.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === undefined) {
        if (field.defaultValue !== undefined) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type73.name));
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(fieldName, Object.keys(type73.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type73.name}".` + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type73)) {
    let parseResult;
    try {
      parseResult = type73.parseValue(inputValue);
    } catch (error21) {
      if (error21 instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error21);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type73.name}". ` + error21.message, {
          originalError: error21
        }));
      }
      return;
    }
    if (parseResult === undefined) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type73.name}".`));
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type73));
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type73, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind2.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === undefined) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type73)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type73)) {
    if (valueNode.kind === Kind2.NULL) {
      return;
    }
    return valueFromAST(valueNode, type73.ofType, variables);
  }
  if (valueNode.kind === Kind2.NULL) {
    return null;
  }
  if (isListType(type73)) {
    const itemType = type73.ofType;
    if (valueNode.kind === Kind2.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === undefined) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === undefined) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type73)) {
    if (valueNode.kind !== Kind2.OBJECT) {
      return;
    }
    const coercedObj = Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type73.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === undefined) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type73)) {
    let result;
    try {
      result = type73.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === undefined) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type73));
}
var isMissingVariable = function(valueNode, variables) {
  return valueNode.kind === Kind2.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", {
          nodes: node
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind2.NULL;
    if (valueNode.kind === Kind2.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: valueNode
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", {
        nodes: valueNode
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw new GraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: valueNode
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
var hasOwnProperty = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/execution/collectFields.mjs
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new Map;
  collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
  return fields;
}
function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new Map;
  const visitedFragmentNames = new Set;
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
var collectFieldsImpl = function(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind2.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== undefined) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind2.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind2.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
};
var shouldIncludeNode = function(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return false;
  }
  return true;
};
var doesFragmentConditionMatch = function(schema2, fragment, type73) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type73) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema2.isSubType(conditionalType, type73);
  }
  return false;
};
var getFieldEntryKey = function(node) {
  return node.alias ? node.alias.value : node.name.value;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema2 = context.getSchema();
        const subscriptionType = schema2.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = Object.create(null);
          const document2 = context.getDocument();
          const fragments = Object.create(null);
          for (const definition21 of document2.definitions) {
            if (definition21.kind === Kind2.FRAGMENT_DEFINITION) {
              fragments[definition21.name.value] = definition21;
            }
          }
          const fields = collectFields(schema2, fragments, variableValues, subscriptionType, node.selectionSet);
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
              nodes: extraFieldSelections
            }));
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                nodes: fieldNodes
              }));
            }
          }
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = new Map;
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === undefined) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema2 !== null && schema2 !== undefined && schema2.getDirective(directiveName)) {
        context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
          nodes: node.name
        }));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
          nodes: [knownDirectiveNames[directiveName], node.name]
        }));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind2.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = Object.create(null);
  const typeDirectivesMap = Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind2.SCHEMA_DEFINITION || node.kind === Kind2.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === undefined) {
          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
        }
      } else {
        seenDirectives = Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
              nodes: [seenDirectives[directiveName], directive]
            }));
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: valueDef.name
        }));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
          nodes: [valueNames[valueName], valueDef.name]
        }));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: fieldDef.name
        }));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
          nodes: [fieldNames[fieldName], fieldDef.name]
        }));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
var hasField = function(type73, fieldName) {
  if (isObjectType(type73) || isInterfaceType(type73) || isInputObjectType(type73)) {
    return type73.getFields()[fieldName] != null;
  }
  return false;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
          nodes: [knownFragmentNames[fragmentName], node.name]
        }));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, {
          nodes: [knownNames[fieldName], node.name]
        }));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
            nodes: [
              knownOperationNames[operationName.value],
              operationName
            ]
          }));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema2 = context.getSchema();
  const definedOperationTypes = Object.create(null);
  const existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
          nodes: operationType
        }));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, {
          nodes: [alreadyDefinedOperationType, operationType]
        }));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema2 !== null && schema2 !== undefined && schema2.getType(typeName)) {
      context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
        nodes: node.name
      }));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, {
        nodes: [knownTypeNames[typeName], node.name]
      }));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(new GraphQLError(`There can be only one variable named "\$${variableName}".`, {
            nodes: variableNodes.map((node) => node.variable.name)
          }));
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type73 = getNullableType(context.getParentInputType());
      if (!isListType(type73)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type73 = getNamedType(context.getInputType());
      if (!isInputObjectType(type73)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type73.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(new GraphQLError(`Field "${type73.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
            nodes: node
          }));
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), {
          nodes: node
        }));
      }
    },
    NullValue(node) {
      const type73 = context.getInputType();
      if (isNonNullType(type73)) {
        context.reportError(new GraphQLError(`Expected value of type "${inspect(type73)}", found ${print(node)}.`, {
          nodes: node
        }));
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
var isValidValueNode = function(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type73 = getNamedType(locationType);
  if (!isLeafType(type73)) {
    const typeStr = inspect(locationType);
    context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
      nodes: node
    }));
    return;
  }
  try {
    const parseResult = type73.parseLiteral(node, undefined);
    if (parseResult === undefined) {
      const typeStr = inspect(locationType);
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
        nodes: node
      }));
    }
  } catch (error21) {
    const typeStr = inspect(locationType);
    if (error21 instanceof GraphQLError) {
      context.reportError(error21);
    } else {
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}; ` + error21.message, {
        nodes: node,
        originalError: error21
      }));
    }
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type73 = typeFromAST(context.getSchema(), node.type);
      if (type73 !== undefined && !isInputType(type73)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(new GraphQLError(`Variable "\$${variableName}" cannot be non-input type "${typeName}".`, {
          nodes: node.type
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type: type73, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type73) {
            const schema2 = context.getSchema();
            const varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(schema2, varType, varDef.defaultValue, type73, defaultValue)) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type73);
              context.reportError(new GraphQLError(`Variable "\$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                nodes: [varDef, node]
              }));
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
var allowedVariableUsage = function(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind2.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== undefined;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/ValidationContext.mjs
class ASTValidationContext {
  constructor(ast8, onError) {
    this._ast = ast8;
    this._fragments = undefined;
    this._fragmentSpreads = new Map;
    this._recursivelyReferencedFragments = new Map;
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error21) {
    this._onError(error21);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind2.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set2;
      while (set2 = setsToVisit.pop()) {
        for (const selection of set2.selections) {
          if (selection.kind === Kind2.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}

class SDLValidationContext extends ASTValidationContext {
  constructor(ast8, schema2, onError) {
    super(ast8, onError);
    this._schema = schema2;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}

class ValidationContext extends ASTValidationContext {
  constructor(schema2, ast8, typeInfo, onError) {
    super(ast8, onError);
    this._schema = schema2;
    this._typeInfo = typeInfo;
    this._variableUsages = new Map;
    this._recursiveVariableUsages = new Map;
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: () => false,
        Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/validate.mjs
function validate2(schema2, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema2)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema2);
  const abortObj = Object.freeze({});
  const errors4 = [];
  const context = new ValidationContext(schema2, documentAST, typeInfo, (error21) => {
    if (errors4.length >= maxErrors) {
      errors4.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors4.push(error21);
  });
  const visitor5 = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor5));
  } catch (e2) {
    if (e2 !== abortObj) {
      throw e2;
    }
  }
  return errors4;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a12, a2, a3) {
    if (cache0 === undefined) {
      cache0 = new WeakMap;
    }
    let cache1 = cache0.get(a12);
    if (cache1 === undefined) {
      cache1 = new WeakMap;
      cache0.set(a12, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === undefined) {
      cache2 = new WeakMap;
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === undefined) {
      fnResult = fn(a12, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}

class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
var isLocatedGraphQLError = function(error21) {
  return Array.isArray(error21.path);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var defaultTypeResolver = function(value14, contextValue, info, abstractType) {
  if (isObjectLike(value14) && typeof value14.__typename === "string") {
    return value14.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type73 = possibleTypes[i];
    if (type73.isTypeOf) {
      const isTypeOfResult = type73.isTypeOf(value14, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type73.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source2, args, contextValue, info) {
  if (isObjectLike(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition26 of documentAST.definitions) {
    if (definition26.kind === Kind2.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition26;
      } else if (((_definition$name = definition26.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
        return definition26;
      }
    }
  }
  return operation;
}
// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema3) {
  const schemaConfig = schema3.toConfig();
  const typeMap = keyValMap(sortByName(schemaConfig.types), (type73) => type73.name, sortNamedType);
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type73) {
    if (isListType(type73)) {
      return new GraphQLList(replaceType(type73.ofType));
    } else if (isNonNullType(type73)) {
      return new GraphQLNonNull(replaceType(type73.ofType));
    }
    return replaceNamedType(type73);
  }
  function replaceNamedType(type73) {
    return typeMap[type73.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array4) {
    return sortByName(array4).map(replaceNamedType);
  }
  function sortNamedType(type73) {
    if (isScalarType(type73) || isIntrospectionType(type73)) {
      return type73;
    }
    if (isObjectType(type73)) {
      const config = type73.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type73)) {
      const config = type73.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type73)) {
      const config = type73.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type73)) {
      const config = type73.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value14) => value14)
      });
    }
    if (isInputObjectType(type73)) {
      const config = type73.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type73));
  }
}
var sortObjMap = function(map3, sortValueFn) {
  const sortedMap = Object.create(null);
  for (const key of Object.keys(map3).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map3[key]);
  }
  return sortedMap;
};
var sortByName = function(array4) {
  return sortBy(array4, (obj) => obj.name);
};
var sortBy = function(array4, mapToKey) {
  return array4.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
};
// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema3) {
  return printFilteredSchema(schema3, (n2) => !isSpecifiedDirective(n2), isDefinedType);
}
var isDefinedType = function(type73) {
  return !isSpecifiedScalarType(type73) && !isIntrospectionType(type73);
};
var printFilteredSchema = function(schema3, directiveFilter, typeFilter) {
  const directives10 = schema3.getDirectives().filter(directiveFilter);
  const types = Object.values(schema3.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema3),
    ...directives10.map((directive) => printDirective(directive)),
    ...types.map((type73) => printType(type73))
  ].filter(Boolean).join("\n\n");
};
var printSchemaDefinition = function(schema3) {
  if (schema3.description == null && isSchemaOfCommonNames(schema3)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema3.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema3) + `schema {\n${operationTypes.join("\n")}\n}`;
};
var isSchemaOfCommonNames = function(schema3) {
  const queryType = schema3.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema3.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
};
function printType(type73) {
  if (isScalarType(type73)) {
    return printScalar(type73);
  }
  if (isObjectType(type73)) {
    return printObject(type73);
  }
  if (isInterfaceType(type73)) {
    return printInterface(type73);
  }
  if (isUnionType(type73)) {
    return printUnion(type73);
  }
  if (isEnumType(type73)) {
    return printEnum(type73);
  }
  if (isInputObjectType(type73)) {
    return printInputObject(type73);
  }
  invariant(false, "Unexpected type: " + inspect(type73));
}
var printScalar = function(type73) {
  return printDescription(type73) + `scalar ${type73.name}` + printSpecifiedByURL(type73);
};
var printImplementedInterfaces = function(type73) {
  const interfaces = type73.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
};
var printObject = function(type73) {
  return printDescription(type73) + `type ${type73.name}` + printImplementedInterfaces(type73) + printFields(type73);
};
var printInterface = function(type73) {
  return printDescription(type73) + `interface ${type73.name}` + printImplementedInterfaces(type73) + printFields(type73);
};
var printUnion = function(type73) {
  const types = type73.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type73) + "union " + type73.name + possibleTypes;
};
var printEnum = function(type73) {
  const values2 = type73.getValues().map((value14, i) => printDescription(value14, "  ", !i) + "  " + value14.name + printDeprecated(value14.deprecationReason));
  return printDescription(type73) + `enum ${type73.name}` + printBlock(values2);
};
var printInputObject = function(type73) {
  const fields = Object.values(type73.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
  return printDescription(type73) + `input ${type73.name}` + printBlock(fields);
};
var printFields = function(type73) {
  const fields = Object.values(type73.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
  return printBlock(fields);
};
var printBlock = function(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
};
var printArgs = function(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
};
var printInputValue = function(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
};
var printDirective = function(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
};
var printDeprecated = function(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind2.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
};
var printSpecifiedByURL = function(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind2.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
};
var printDescription = function(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString4 = print({
    kind: Kind2.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString4.replace(/\n/g, "\n" + indentation) + "\n";
};
// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/errors.js
var isGraphQLErrorLike = function(error21) {
  return error21 != null && typeof error21 === "object" && Object.keys(error21).every((key) => possibleGraphQLErrorProperties.includes(key));
};
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/inspect.js
function inspect25(value14) {
  return formatValue2(value14, []);
}
var formatValue2 = function(value14, seenValues) {
  switch (typeof value14) {
    case "string":
      return JSON.stringify(value14);
    case "function":
      return value14.name ? `[function ${value14.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value14, seenValues);
    default:
      return String(value14);
  }
};
var formatError2 = function(value14) {
  if (value14 instanceof GraphQLError) {
    return value14.toString();
  }
  return `${value14.name}: ${value14.message};\n ${value14.stack}`;
};
var formatObjectValue2 = function(value14, previouslySeenValues) {
  if (value14 === null) {
    return "null";
  }
  if (value14 instanceof Error) {
    if (value14.name === "AggregateError") {
      return formatError2(value14) + "\n" + formatArray2(value14.errors, previouslySeenValues);
    }
    return formatError2(value14);
  }
  if (previouslySeenValues.includes(value14)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value14];
  if (isJSONable2(value14)) {
    const jsonValue = value14.toJSON();
    if (jsonValue !== value14) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value14)) {
    return formatArray2(value14, seenValues);
  }
  return formatObject2(value14, seenValues);
};
var isJSONable2 = function(value14) {
  return typeof value14.toJSON === "function";
};
var formatObject2 = function(object12, seenValues) {
  const entries = Object.entries(object12);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object12) + "]";
  }
  const properties = entries.map(([key, value14]) => key + ": " + formatValue2(value14, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray2 = function(array4, seenValues) {
  if (array4.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array4.length;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue2(array4[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag2 = function(object12) {
  const tag = Object.prototype.toString.call(object12).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object12.constructor === "function") {
    const name = object12.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_RECURSIVE_DEPTH2 = 3;

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject4(value14) {
  return value14 != null && typeof value14 === "object" && (Symbol.iterator in value14);
}
function isObjectLike10(value14) {
  return typeof value14 === "object" && value14 !== null;
}
function isPromise3(value14) {
  return value14?.then != null;
}
function promiseReduce(values2, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value14 of values2) {
    accumulator = isPromise3(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value14)) : callbackFn(accumulator, value14);
  }
  return accumulator;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues2(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== undefined) {
        coercedValues[name] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect25(argType)}" ` + "was not provided.", {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind2.NULL;
    if (valueNode.kind === Kind2.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect25(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect25(argType)}" ` + "must not be null.", {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = new WeakMap;
  return function memoized(a12) {
    const cachedValue = memoize1cache.get(a12);
    if (cachedValue === undefined) {
      const newValue = fn(a12);
      memoize1cache.set(a12, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize33(fn) {
  const memoize3Cache = new WeakMap;
  return function memoized(a12, a2, a3) {
    let cache2 = memoize3Cache.get(a12);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize3Cache.set(a12, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const newValue = fn(a12, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const newValue = fn(a12, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === undefined) {
      const newValue = fn(a12, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = new WeakMap;
  return function memoized(a12, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a12);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize5Cache.set(a12, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const cache42 = new WeakMap;
      cache32.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a12, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const cache42 = new WeakMap;
      cache3.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a12, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = new WeakMap;
      cache3.set(a3, cache4);
      const cache52 = new WeakMap;
      cache4.set(a4, cache52);
      const newValue = fn(a12, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = new WeakMap;
      cache4.set(a4, cache5);
      const newValue = fn(a12, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === undefined) {
      const newValue = fn(a12, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema3, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema3);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema3) {
  const rootTypes = getRootTypes(schema3);
  return new Set([...rootTypes].map((type73) => type73.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema3) {
  const rootTypeMap = getRootTypeMap(schema3);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema3) {
  const rootTypeMap = new Map;
  const queryType = schema3.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator4, callback, rejectCallback) {
  let $return;
  let abruptClose;
  if (typeof iterator4.return === "function") {
    $return = iterator4.return;
    abruptClose = (error21) => {
      const rethrow = () => Promise.reject(error21);
      return $return.call(iterator4).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (rejectCallback) {
    const reject = rejectCallback;
    mapReject = (error21) => asyncMapValue(error21, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator4.next().then(mapResult, mapReject);
    },
    return() {
      return $return ? $return.call(iterator4).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
    },
    throw(error21) {
      if (typeof iterator4.throw === "function") {
        return iterator4.throw(error21).then(mapResult, mapReject);
      }
      return Promise.reject(error21).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var asyncMapValue = function(value14, callback) {
  return new Promise((resolve) => resolve(callback(value14)));
};
var iteratorResult = function(value14) {
  return { value: value14, done: false };
};

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
class AccumulatorMap extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === undefined) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/directives.js
var GraphQLDeferDirective = new GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FIELD],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/collectFields.js
var collectFieldsImpl2 = function(schema3, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind2.FIELD: {
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey2(selection), selection);
        break;
      }
      case Kind2.INLINE_FRAGMENT: {
        if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema3, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind2.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch2(schema3, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
};
function collectFields4(schema3, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap;
  const patches = [];
  collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set);
  return { fields, patches };
}
function shouldIncludeNode2(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch2(schema3, fragment, type73) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema3, typeConditionNode);
  if (conditionalType === type73) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema3.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type73);
  }
  return false;
}
function getFieldEntryKey2(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : undefined
  };
}
var collectSubFields = memoize5(function collectSubfields3(schema3, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap;
  const visitedFragmentNames = new Set;
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl2(schema3, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value14) {
  return value14?.[Symbol.asyncIterator] != null;
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/Path.js
function addPath2(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray2(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray3(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/error.js
var isAggregateError = function(obj) {
  return obj != null && typeof obj === "object" && ("errors" in obj);
};
var hasToString = function(obj) {
  return obj != null && typeof obj.toString === "function";
};
function isGraphQLError(val) {
  return val instanceof GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error21, maskedErrorsOpts, logger) {
  const errors6 = new Set;
  if (isAggregateError(error21)) {
    for (const singleError of error21.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors6.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error21, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error21) {
      logger.error(error21);
    }
    errors6.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error21)) {
    errors6.add(error21);
  } else if (error21 instanceof Error) {
    errors6.add(createGraphQLError(error21.message, {
      originalError: error21
    }));
  } else if (typeof error21 === "string") {
    errors6.add(createGraphQLError(error21, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error21)) {
    errors6.add(createGraphQLError(error21.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error21);
    errors6.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors6);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if (("extensions" in result) && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if (("errors" in result) && result.errors?.length) {
    for (const error21 of result.errors) {
      if (error21.extensions?.http) {
        if (error21.extensions.http.headers) {
          Object.assign(headers, error21.extensions.http.headers);
        }
        if (isApplicationJson && error21.extensions.http.spec) {
          continue;
        }
        if (error21.extensions.http.status && (!status || error21.extensions.http.status > status)) {
          status = error21.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error21) || error21.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.some(isGraphQLError);
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = "<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\"https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/yoga-graphiql.es.js\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>";

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
function useGraphiQL(config) {
  const logger = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || url.pathname === config.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse(response);
        }
      }
    }
  };
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-schema.js
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema3;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema3 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema3) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema3);
      }
    };
  }
  const schemaByRequest = new WeakMap;
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema3 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema3);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema3 = schemaByRequest.get(context.request);
      if (schema3 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema3);
    }
  };
};

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = new WeakMap;

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/utils.js
var getSubscribeArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
};
function mapAsyncIterator2(source2, mapper) {
  const iterator4 = source2[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error21) {
      try {
        await iterator4.return?.();
      } catch (_error) {
      }
      throw error21;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator4.next());
    },
    async return() {
      const promise4 = iterator4.return?.();
      return promise4 ? await mapResult(await promise4) : { value: undefined, done: true };
    },
    async throw(error21) {
      const promise4 = iterator4.throw?.();
      if (promise4) {
        return await mapResult(await promise4);
      }
      throw error21;
    }
  };
  return stream;
}
var getExecuteArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
};
function isAsyncIterable2(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable2(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return;
}
function finalAsyncIterator(source2, onFinal) {
  const iterator4 = source2[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator4.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise4 = iterator4.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise4 ? await promise4 : { done: true, value: undefined };
    },
    async throw(error21) {
      const promise4 = iterator4.throw?.();
      if (promise4) {
        return await promise4;
      }
      throw error21;
    }
  };
  return stream;
}
function errorAsyncIterator(source2, onError) {
  const iterator4 = source2[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator4.next();
      } catch (error21) {
        onError(error21);
        return { done: true, value: undefined };
      }
    },
    async return() {
      const promise4 = iterator4.return?.();
      return promise4 ? await promise4 : { done: true, value: undefined };
    },
    async throw(error21) {
      const promise4 = iterator4.throw?.();
      if (promise4) {
        return await promise4;
      }
      throw error21;
    }
  };
  return stream;
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/orchestrator.js
var throwEngineFunctionError = function(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
};
function createEnvelopOrchestrator({ plugins }) {
  let schema3 = null;
  let initDone = false;
  const parse5 = () => throwEngineFunctionError("parse");
  const validate3 = () => throwEngineFunctionError("validate");
  const execute2 = () => throwEngineFunctionError("execute");
  const subscribe2 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema3 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema3,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin] of plugins.entries()) {
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        plugins.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source2, parseOptions) => {
    let result = null;
    let parseFn = parse5;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source: source2, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source2, parseOptions);
      } catch (e2) {
        result = e2;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source2.toString());
    return result;
  } : () => parse5;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema4, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : undefined;
    let validateFn = validate3;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema4,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema4, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate3;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error21 = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error: error21,
          setError: (err2) => {
            error21 = err2;
          }
        });
      }
      throw error21;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe2;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await subscribeFn({
        ...args,
        contextValue: context
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable2(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error21 = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error: error21,
            setError: (err2) => {
              error21 = err2;
            }
          });
        }
        throw error21;
      });
    }
    return result;
  }) : makeSubscribe(subscribe2);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute2;
    let result;
    const afterCalls = [];
    const context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute2);
  initDone = true;
  if (schema3) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema3,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema3;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/create.js
var notEmpty = function(value14) {
  return value14 != null;
};
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator2 = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator2;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/plugins/use-masked-errors.js
function isGraphQLError2(error21) {
  return error21 instanceof Error && error21.name === "GraphQLError";
}
function isOriginalGraphQLError2(error21) {
  if (isGraphQLError2(error21)) {
    if (error21.originalError != null) {
      return isOriginalGraphQLError2(error21.originalError);
    }
    return true;
  }
  return false;
}
var createSerializableGraphQLError = function(message, originalError, isDev) {
  const error21 = new Error(message);
  error21.name = "GraphQLError";
  if (isDev) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error21, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error21, "toJSON", {
    value() {
      return {
        message: error21.message,
        extensions: error21.extensions
      };
    }
  });
  return error21;
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error: error21, setError }) => {
        setError(maskError(error21, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error: error21, setError }) {
          setError(maskError(error21, message));
        }
      };
    }
  };
}
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var createDefaultMaskError = (isDev) => (error21, message) => {
  if (isOriginalGraphQLError2(error21)) {
    return error21;
  }
  return createSerializableGraphQLError(message, error21, isDev);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error21) => maskError(error21, message)) });
  }
};

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// /Users/richardguerre/Projects/flow/node_modules/value-or-promise/build/module/ValueOrPromise.js
var isPromiseLike = function(object12) {
  return object12 != null && typeof object12.then === "function";
};
var defaultOnRejectedFn = (reason) => {
  throw reason;
};

class ValueOrPromise {
  state;
  constructor(executor) {
    let value14;
    try {
      value14 = executor();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike(value14)) {
      this.state = { status: "pending", value: value14 };
      return;
    }
    this.state = { status: "fulfilled", value: value14 };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
      return onFulfilledFn === undefined ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e2) {
      return new ValueOrPromise(() => onRejectedFn(e2));
    }
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let rejected = false;
    let reason;
    let containsPromise = false;
    const values2 = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        if (rejected) {
          continue;
        }
        rejected = true;
        reason = state.value;
        continue;
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values2.push(state.value);
    }
    if (containsPromise) {
      if (rejected) {
        Promise.all(values2).catch(() => {
        });
        return new ValueOrPromise(() => {
          throw reason;
        });
      }
      return new ValueOrPromise(() => Promise.all(values2));
    }
    return new ValueOrPromise(() => values2);
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: undefined, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = undefined;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = undefined;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: undefined, done: true };
    },
    async throw(error21) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error21), topIterator.throw?.(error21)]);
      throw error21;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant12(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object12, signal) {
  const resolvedObject = Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      resolve();
    });
    Promise.all(Object.entries(object12).map(async ([key, value14]) => {
      resolvedObject[key] = await value14;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/values.js
function getVariableValues2(schema3, varDefNodes, inputs, options) {
  const errors6 = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema3, varDefNodes, inputs, (error21) => {
      if (maxErrors != null && errors6.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors6.push(error21);
    });
    if (errors6.length === 0) {
      return { coerced };
    }
  } catch (error21) {
    errors6.push(error21);
  }
  return { errors: errors6 };
}
var coerceVariableValues = function(schema3, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema3, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(createGraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty2(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect25(varType);
        onError(createGraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value14 = inputs[varName];
    if (value14 === null && isNonNullType(varType)) {
      const varTypeStr = inspect25(varType);
      onError(createGraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value14, varType, (path, invalidValue, error21) => {
      let prefix = `Variable "\$${varName}" got invalid value ` + inspect25(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray3(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error21.message, {
        nodes: varDefNode,
        originalError: error21.originalError
      }));
    });
  }
  return coercedValues;
};

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/execute.js
function execute2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e2) => {
        Object.defineProperty(e2, "extensions", {
          value: {
            ...e2.extensions,
            http: {
              ...e2.extensions?.["http"],
              status: 400
            }
          }
        });
        return e2;
      })
    };
  }
  return executeImpl(exeContext);
}
var executeImpl = function(exeContext) {
  return new ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error21) => {
    exeContext.errors.push(error21);
    return buildResponse(null, exeContext.errors);
  }).resolve();
};
var buildResponse = function(data, errors6) {
  return errors6.length === 0 ? { data } : { errors: errors6, data };
};
function buildExecutionContext(args) {
  const { schema: schema3, document: document2, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args;
  assertValidSchema(schema3);
  const fragments = getFragmentsFromDocument(document2);
  let operation;
  for (const definition28 of document2.definitions) {
    switch (definition28.kind) {
      case Kind2.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== undefined) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition28;
        } else if (definition28.name?.value === operationName) {
          operation = definition28;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues2(schema3, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema3,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver2,
    typeResolver: typeResolver ?? defaultTypeResolver2,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver2,
    subsequentPayloads: new Set,
    errors: [],
    signal
  };
}
var buildPerEventExecutionContext = function(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: new Set,
    errors: []
  };
};
var executeOperation = function(exeContext) {
  const { operation, schema: schema3, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema3, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields4(schema3, fragments, variableValues, rootType, operation.selectionSet);
  const path = undefined;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
};
var executeFieldsSerially = function(exeContext, parentType, sourceValue, path, fields) {
  let abortErrorThrown = false;
  return promiseReduce(fields, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath2(path, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      results[responseName] = null;
      return results;
    }
    return new ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray2(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
      return results;
    });
  }, Object.create(null)).resolve();
};
var executeFields = function(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {
  const results = Object.create(null);
  let containsPromise = false;
  let abortErrorThrown = false;
  try {
    for (const [responseName, fieldNodes] of fields) {
      if (exeContext.signal?.aborted) {
        results[responseName] = null;
        continue;
      }
      const fieldPath = addPath2(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== undefined) {
        results[responseName] = result;
        if (isPromise3(result)) {
          containsPromise = true;
        }
      }
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray2(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
    }
  } catch (error21) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error21;
      });
    }
    throw error21;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
};
var executeField = function(exeContext, parentType, source2, fieldNodes, path, asyncPayloadRecord) {
  const errors6 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source2, args, contextValue, info);
    let completed;
    if (isPromise3(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise3(completed)) {
      return completed.then(undefined, (rawError) => {
        const error21 = locatedError(rawError, fieldNodes, pathToArray2(path));
        const handledError = handleFieldError(error21, returnType, errors6);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    const error21 = locatedError(rawError, fieldNodes, pathToArray2(path));
    const handledError = handleFieldError(error21, returnType, errors6);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
};
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
var handleFieldError = function(error21, returnType, errors6) {
  if (isNonNullType(returnType)) {
    throw error21;
  }
  errors6.push(error21);
  return null;
};
var completeValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect25(returnType));
};
var getStreamValues = function(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant12(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant12(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : undefined
  };
};
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator4, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator4.return?.();
    exeContext.errors.push(createGraphQLError("Execution aborted", {
      nodes: fieldNodes,
      path: pathToArray2(path),
      originalError: exeContext.signal?.reason
    }));
  });
  const errors6 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator4, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath2(path, index, undefined);
    let iteration;
    try {
      iteration = await iterator4.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
      completedResults.push(handleFieldError(error21, itemType, errors6));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors6, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
var completeListValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors6 = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator4 = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator4, asyncPayloadRecord);
  }
  if (!isIterableObject4(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath2(path, index, undefined);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors6, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
};
var completeListItemValue = function(item, completedResults, errors6, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise3(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise3(completedItem)) {
      completedResults.push(completedItem.then(undefined, (rawError) => {
        const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error21, itemType, errors6);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const handledError = handleFieldError(error21, itemType, errors6);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
};
var completeLeafValue = function(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect25(returnType)}.serialize(${inspect25(result)})\` to ` + `return non-nullable value, returned: ${inspect25(serializedResult)}`);
  }
  return serializedResult;
};
var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise3(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
};
var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (isObjectType(runtimeTypeName)) {
    throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect25(result)}, received "${inspect25(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
};
var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise3(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
};
var invalidReturnTypeError = function(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect25(result)}.`, {
    nodes: fieldNodes
  });
};
var collectAndExecuteSubfields = function(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields4(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
};
function subscribe2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e2) => {
        Object.defineProperty(e2, "extensions", {
          value: {
            ...e2.extensions,
            http: {
              ...e2.extensions?.["http"],
              status: 400
            }
          }
        });
        return e2;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise3(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults, signal) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  signal?.addEventListener("abort", () => {
    done = true;
    subsequentIterator.throw?.(signal?.reason);
  });
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: undefined,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error21) {
      done = true;
      return subsequentIterator.throw(error21);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult, signal) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult, signal);
  } else {
    yield someExecutionResult;
  }
}
var mapSourceToResponse = function(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream[Symbol.asyncIterator](), async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload)), exeContext.signal), async function* (error21) {
    const wrappedError = createGraphQLError(error21.message, {
      originalError: error21,
      nodes: [exeContext.operation]
    });
    yield {
      errors: [wrappedError]
    };
  }));
};
var createSourceEventStreamImpl = function(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise3(eventStream)) {
      return eventStream.then(undefined, (error21) => ({ errors: [error21] }));
    }
    return eventStream;
  } catch (error21) {
    return { errors: [error21] };
  }
};
var executeSubscription = function(exeContext) {
  const { schema: schema3, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema3.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields4(schema3, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef2(schema3, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path = addPath2(undefined, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise3(result)) {
      return result.then(assertEventStream).then(undefined, (error21) => {
        throw locatedError(error21, fieldNodes, pathToArray2(path));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error21) {
    throw locatedError(error21, fieldNodes, pathToArray2(path));
  }
};
var assertEventStream = function(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError("Subscription field must return Async Iterable. " + `Received: ${inspect25(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
};
var executeDeferredFragment = function(exeContext, parentType, sourceValue, fields, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);
    if (isPromise3(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e2) => {
        asyncPayloadRecord.errors.push(e2);
        return null;
      });
    }
  } catch (e2) {
    asyncPayloadRecord.errors.push(e2);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
};
var executeStreamField = function(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise3(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise3(completedItem)) {
        completedItem = completedItem.then(undefined, (rawError) => {
          const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
          const handledError = handleFieldError(error21, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
      completedItem = handleFieldError(error21, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error21) {
    asyncPayloadRecord.errors.push(error21);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise3(completedItem)) {
    completedItems = completedItem.then((value14) => [value14], (error21) => {
      asyncPayloadRecord.errors.push(error21);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
};
async function executeStreamIteratorItem(iterator4, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value: value14, done } = await iterator4.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: undefined };
    }
    item = value14;
  } catch (rawError) {
    const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value14 = handleFieldError(error21, itemType, asyncPayloadRecord.errors);
    return { done: true, value: value14 };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise3(completedItem)) {
      completedItem = completedItem.then(undefined, (rawError) => {
        const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error21, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error21 = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value14 = handleFieldError(error21, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value: value14 };
  }
}
async function executeStreamIterator(initialIndex, iterator4, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? undefined;
  while (true) {
    const itemPath = addPath2(path, index, undefined);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator: iterator4,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator4, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error21) {
      asyncPayloadRecord.errors.push(error21);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator4?.return) {
        iterator4.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise3(completedItem)) {
      completedItems = completedItem.then((value14) => [value14], (error21) => {
        asyncPayloadRecord.errors.push(error21);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
var filterSubsequentPayloads = function(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray2(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0;i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
};
var getCompletedIncrementalResults = function(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
};
var yieldSubsequentPayloads = function(exeContext) {
  let isDone = false;
  async function next() {
    if (isDone) {
      return { value: undefined, done: true };
    }
    await Promise.race(Array.from(exeContext.subsequentPayloads).map((p2) => p2.promise));
    if (isDone) {
      return { value: undefined, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: undefined, done: true };
    },
    async throw(error21) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error21);
    }
  };
};
var isStreamPayload = function(asyncPayload) {
  return asyncPayload.type === "stream";
};
function getFieldDef2(schema3, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema3.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema3.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields4 = memoize33((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document2) {
  const fragments = Object.create(null);
  for (const definition28 of document2.definitions) {
    if (definition28.kind === Kind2.FRAGMENT_DEFINITION) {
      fragments[definition28.name.value] = definition28;
    }
  }
  return fragments;
});
var defaultTypeResolver2 = function(value14, contextValue, info, abstractType) {
  if (isObjectLike10(value14) && typeof value14["__typename"] === "string") {
    return value14["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type73 = possibleTypes[i];
    if (type73.isTypeOf) {
      const isTypeOfResult = type73.isTypeOf(value14, contextValue, info);
      if (isPromise3(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type73.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver2 = function(source2, args, contextValue, info) {
  if (isObjectLike10(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};

class DeferredFragmentRecord {
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
}

class StreamRecord {
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
function normalizedExecutor(args) {
  const operationAST = getOperationAST(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe2(args);
  }
  return new ValueOrPromise(() => execute2(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result, args.signal);
    }
    return result;
  }).resolve();
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill = {};
__export(exports_node_ponyfill, {
  fetch: () => {
    {
      return $fetch;
    }
  },
  crypto: () => {
    {
      return $crypto;
    }
  },
  createFetch: () => {
    {
      return $createFetch;
    }
  },
  btoa: () => {
    {
      return $btoa;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern;
    }
  },
  URL: () => {
    {
      return $URL;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder;
    }
  },
  Response: () => {
    {
      return $Response;
    }
  },
  Request: () => {
    {
      return $Request;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream;
    }
  },
  Headers: () => {
    {
      return $Headers;
    }
  },
  FormData: () => {
    {
      return $FormData;
    }
  },
  File: () => {
    {
      return $File;
    }
  },
  Blob: () => {
    {
      return $Blob;
    }
  }
});
var createNodePonyfill = require_create_node_ponyfill();
var ponyfills = createNodePonyfill();
if (!globalThis.Deno && !process.versions.bun) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || import.meta.require(nodelibcurlName);
  } catch (e2) {
  }
}
var $fetch = ponyfills.fetch;
var $Headers = ponyfills.Headers;
var $Request = ponyfills.Request;
var $Response = ponyfills.Response;
var $FormData = ponyfills.FormData;
var $ReadableStream = ponyfills.ReadableStream;
var $WritableStream = ponyfills.WritableStream;
var $TransformStream = ponyfills.TransformStream;
var $Blob = ponyfills.Blob;
var $File = ponyfills.File;
var $crypto = ponyfills.crypto;
var $btoa = ponyfills.btoa;
var $TextEncoder = ponyfills.TextEncoder;
var $TextDecoder = ponyfills.TextDecoder;
var $URLPattern = ponyfills.URLPattern;
var $URL = ponyfills.URL;
var $URLSearchParams = ponyfills.URLSearchParams;
var $createFetch = createNodePonyfill;

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/utils.js
function isAsyncIterable3(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
var getPort = function(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
};
var getHostnameWithPort = function(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
};
var buildFullUrl = function(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || "http";
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
};
var isRequestBody = function(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable3(body)) {
    return true;
  }
  return false;
};
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new $URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  const signal = new ServerAdapterRequestAbortSignal;
  if (rawRequest.once) {
    rawRequest.once("end", () => signal.sendAbort());
    rawRequest.once("close", () => signal.sendAbort());
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: nodeRequest.headers,
    body: rawRequest,
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
var configureSocket = function(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
};
var endResponse = function(serverResponse) {
  serverResponse.end(null, null, null);
};
async function sendAsyncIterable(serverResponse, asyncIterable) {
  for await (const chunk of asyncIterable) {
    if (!serverResponse.write(chunk)) {
      break;
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  fetchResponse.headers.forEach((value14, key) => {
    if (key === "set-cookie") {
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value14);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable3(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source2) => {
    const descriptors = Object.getOwnPropertyNames(source2).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source2, key);
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source2).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise4(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator4 = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value: value14 } = iterator4.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value14, stopEarlyFn);
    if (isPromise4(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error21, ResponseCtor) {
  return new ResponseCtor(error21.stack || error21.message || error21.toString(), {
    status: error21.status || 500
  });
}

class ServerAdapterRequestAbortSignal extends EventTarget {
  constructor() {
    super(...arguments);
    this.aborted = false;
    this._onabort = null;
  }
  throwIfAborted() {
    if (this.aborted) {
      throw new DOMException("Aborted", "AbortError");
    }
  }
  sendAbort() {
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value14) {
    this._onabort = value14;
    if (value14) {
      this.addEventListener("abort", value14);
    } else {
      this.removeEventListener("abort", value14);
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    body = new fetchAPI.ReadableStream({});
    const readable = body.readable;
    res.onAborted(() => {
      readable.push(null);
    });
    let multipleChunks = false;
    res.onData(function(ab, isLast) {
      const chunk = Buffer.from(ab, 0, ab.byteLength);
      if (!multipleChunks && isLast) {
        readable.push(chunk);
      } else {
        readable.push(Buffer.from(chunk));
      }
      if (isLast) {
        readable.push(null);
      }
      multipleChunks = true;
    });
  }
  const headers = new fetchAPI.Headers;
  req.forEach((key, value14) => {
    headers.set(key, value14);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal: new ServerAdapterRequestAbortSignal
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse) {
  let resAborted = false;
  uwsResponse.onAborted(function() {
    resAborted = true;
  });
  for await (const chunk of fetchResponse.body) {
    if (resAborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value14] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value14);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse);
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  const waitUntils = await Promise.allSettled(waitUntilPromises);
  waitUntils.forEach((waitUntil) => {
    if (waitUntil.status === "rejected") {
      console.error(waitUntil.reason);
    }
  });
}
var isRequestAccessible = function(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
};
var addWaitUntil = function(serverContext, waitUntilPromises) {
  serverContext["waitUntil"] = function(promise4) {
    if (promise4 != null) {
      waitUntilPromises.push(promise4);
    }
  };
};
var createServerAdapter = function(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...exports_node_ponyfill,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onRequestHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise4(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise4(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise4(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function requestListener(nodeRequest, serverResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: serverResponse
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    let response$;
    try {
      response$ = handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e2) => handleErrorFromRequestHandler(e2, fetchAPI.Response)).then((response) => sendNodeResponse(response, serverResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, serverResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    const serverContext = ctx.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI
    });
    let resAborted = false;
    res.onAborted(() => {
      resAborted = true;
      request.signal.sendAbort();
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e2) => handleErrorFromRequestHandler(e2, fetchAPI.Response)).then((response) => {
        if (!resAborted) {
          return sendResponseToUwsOpts(res, response);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendResponseToUwsOpts(res, response$);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const serverContext = ctx.length > 0 ? Object.assign({}, event, ...ctx) : event;
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const serverContext = (ctx.length > 1 ? completeAssign(...ctx) : ctx[0]) || {};
    if (serverContext.waitUntil == null) {
      const waitUntilPromises = [];
      addWaitUntil(serverContext, waitUntilPromises);
      const response$ = handleRequest(request, serverContext);
      if (waitUntilPromises.length > 0) {
        return handleWaitUntils(waitUntilPromises).then(() => response$);
      }
      return response$;
    }
    return handleRequest(request, serverContext);
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || ("href" in input)) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
      }
      return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
    }
    return handleRequestWithWaitUntil(input, ...maybeCtx);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest,
    fetch: fetchFn,
    handleNodeRequest,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    has: (_, prop) => {
      return (prop in adapterObj) || (prop in genericRequestHandler) || serverAdapterBaseObject && (prop in serverAdapterBaseObject);
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
};
var EMPTY_OBJECT = {};

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      }
      headers["Vary"] = "Access-Control-Request-Headers";
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
function createDefaultErrorHandler(ResponseCtor = $Response) {
  return function defaultErrorHandler(e2) {
    if (e2.details || e2.status || e2.headers || e2.name === "HTTPError") {
      return new ResponseCtor(typeof e2.details === "object" ? JSON.stringify(e2.details) : e2.message, {
        status: e2.status,
        headers: e2.headers || {}
      });
    }
    console.error(e2);
    return ResponseCtor.error();
  };
}
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
        try {
          const response$ = requestHandler(request, serverContext);
          if (isPromise4(response$)) {
            return response$.catch((e2) => errorHandler(e2, request, serverContext));
          }
          return response$;
        } catch (e2) {
          return errorHandler(e2, request, serverContext);
        }
      });
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || undefined;
  const query = searchParams.get("query") || undefined;
  const variablesStr = searchParams.get("variables") || undefined;
  const extensionsStr = searchParams.get("extensions") || undefined;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : undefined,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new $URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new $URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// /Users/richardguerre/Projects/flow/node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l2 = keys.length, t2 = obj, x, k2;
  while (i < l2) {
    k2 = keys[i++];
    if (k2 === "__proto__" || k2 === "constructor" || k2 === "prototype")
      break;
    t2 = t2[k2] = i === l2 ? val : typeof (x = t2[k2]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e2) {
    if (e2 instanceof Error && e2.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e2.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e2;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map3;
    try {
      map3 = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map3) {
      const file = requestBody.get(fileIndex);
      const keys = map3[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
var extendedTypeof = function(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
};
var isObject = function(val) {
  return extendedTypeof(val) === "object";
};
var expectedParameters = new Set(["query", "variables", "operationName", "extensions"]);

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error21 of result) {
            error21.extensions.http = {
              ...error21.extensions.http,
              spec: error21.extensions.http?.spec ?? true,
              status: error21.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
function assertMutationViaGet(method, document2, operationName) {
  const operation = document2 ? getOperationAST(document2, operationName) ?? undefined : undefined;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type73, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type73, code, fn) : console.error(`[${code}] ${type73}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s2 = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s2;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c2) {
    return {
      starts: c2.#starts,
      ttls: c2.#ttls,
      sizes: c2.#sizes,
      keyMap: c2.#keyMap,
      keyList: c2.#keyList,
      valList: c2.#valList,
      next: c2.#next,
      prev: c2.#prev,
      get head() {
        return c2.#head;
      },
      get tail() {
        return c2.#tail;
      },
      free: c2.#free,
      isBackgroundFetch: (p2) => c2.#isBackgroundFetch(p2),
      backgroundFetch: (k2, index, options, context) => c2.#backgroundFetch(k2, index, options, context),
      moveToTail: (index) => c2.#moveToTail(index),
      indexes: (options) => c2.#indexes(options),
      rindexes: (options) => c2.#rindexes(options),
      isStale: (index) => c2.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t2 = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t2.unref) {
          t2.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n2 = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n2;
        const t2 = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t2.unref) {
          t2.unref();
        }
      }
      return n2;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (ttl === 0 || start === 0) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k2, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k2);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value14 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value14 === undefined)
        continue;
      if (fn(value14, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value14 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value14 === undefined)
        continue;
      fn.call(thisp, value14, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value14 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value14 === undefined)
        continue;
      fn.call(thisp, value14, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value14 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value14 === undefined || key === undefined)
        continue;
      const entry = { value: value14 };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k2, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k2, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k2);
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k2);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k2;
      this.#valList[index] = v;
      this.#keyMap.set(k2, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s2 } = oldVal;
          if (s2 !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s2, k2, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s2, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k2, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k2, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k2 = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k2, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k2, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k2);
    this.#size--;
    return head;
  }
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k2);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k2);
    if (index !== undefined && (allowStale || !this.#isStale(index))) {
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
  }
  #backgroundFetch(k2, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p2;
      if (this.#valList[index] === p2) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k2);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p2;
      if (this.#valList[index] === p2) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.delete(k2);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k2, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p2 = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p2, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k2, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k2);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p2) {
    if (!this.#hasFetchMethod)
      return false;
    const b2 = p2;
    return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k2);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p2 = this.#backgroundFetch(k2, index, options, context);
      return p2.__returned = p2;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p2 = this.#backgroundFetch(k2, index, options, context);
      const hasStale = p2.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k2);
    if (index !== undefined) {
      const value14 = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value14);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k2);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value14 : undefined;
        } else {
          if (status && allowStale && value14.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value14.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value14.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value14;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p2, n2) {
    this.#prev[n2] = p2;
    this.#next[p2] = n2;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k2) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k2);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k2, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k2, "delete"]);
            }
          }
          this.#keyMap.delete(k2);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#next[this.#prev[index]] = this.#next[index];
            this.#prev[this.#next[index]] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k2, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k2, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/utils/create-lru-cache.js
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 3600000;

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document2 = documentCache.get(strDocument);
      if (document2) {
        setParsedDocument(document2);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema3, documentAST, rules },
      setResult
    }) {
      if (schema3 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = new WeakMap;
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema3);
        if (!validationCacheByDocument) {
          validationCacheByDocument = new WeakMap;
          validationCacheBySchema.set(schema3, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-request-parser.js
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}
var DEFAULT_MATCHER = () => true;

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : undefined;
    }
    return newResult;
  }
  return result;
}
var omitInternalsFromError = function(err) {
  if (isGraphQLError(err)) {
    const serializedError = ("toJSON" in err) && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || undefined),
      extensions: Object.keys(extensions).length ? extensions : undefined
    });
  }
  return err;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator4;
  const textEncoder = new fetchAPI.TextEncoder;
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable2(result)) {
        iterator4 = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator4 = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value: value14 } = await iterator4.next();
      if (value14 != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value14);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e2) {
      await iterator4.return?.(e2);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions.originalError || isGraphQLError(err.extensions.originalError)));
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12000;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator4;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder;
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable2(result)) {
          iterator4 = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator4 = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value: value14 } = await iterator4.next();
        if (value14 != null) {
          controller.enqueue(textEncoder.encode(`event: next\n`));
          const chunk = jsonStringifyResultWithoutInternals(value14);
          controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete\n\n`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e2) {
        clearInterval(pingInterval);
        await iterator4.return?.(e2);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var getSSEProcessorConfig = function() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
};
function useResultProcessors() {
  const isSubscriptionRequestMap = new WeakMap;
  const sse2 = getSSEProcessorConfig();
  const defaultList = [sse2, multipart2, regular2];
  const subscriptionList = [sse2, regular2];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable2(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}
var multipart2 = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
var regular2 = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && url.pathname !== args.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/process-request.js
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document2 = enveloped.parse(params.query);
  const errors6 = enveloped.validate(enveloped.schema, document2);
  if (errors6.length > 0) {
    return { errors: errors6 };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document: document2,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = getOperationAST(document2, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error27, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error27)) {
    if (error27.originalError) {
      if (error27.originalError.name === "GraphQLError") {
        return error27;
      }
      const extensions = {
        ...error27.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error27.originalError.message,
          stack: error27.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error27.nodes,
        source: error27.source,
        positions: error27.positions,
        path: error27.path,
        extensions
      });
    }
    return error27;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error27 instanceof Error ? {
        message: error27.message,
        stack: error27.stack
      } : error27 : undefined
    }
  });
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/server.js
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

class YogaServer {
  constructor(options) {
    this.handle = async (request, serverContext) => {
      let url = new Proxy({}, {
        get: (_target, prop, _receiver) => {
          url = new this.fetchAPI.URL(request.url, "http://localhost");
          return Reflect.get(url, prop, url);
        }
      });
      let requestParser;
      const onRequestParseDoneList = [];
      for (const onRequestParse of this.onRequestParseHooks) {
        const onRequestParseResult = await onRequestParse({
          request,
          url,
          requestParser,
          serverContext,
          setRequestParser(parser) {
            requestParser = parser;
          }
        });
        if (onRequestParseResult?.onRequestParseDone != null) {
          onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
        }
      }
      this.logger.debug(`Parsing request to extract GraphQL parameters`);
      if (!requestParser) {
        return new this.fetchAPI.Response(null, {
          status: 415,
          statusText: "Unsupported Media Type"
        });
      }
      let requestParserResult = await requestParser(request);
      for (const onRequestParseDone of onRequestParseDoneList) {
        await onRequestParseDone({
          requestParserResult,
          setRequestParserResult(newParams) {
            requestParserResult = newParams;
          }
        });
      }
      const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
        params,
        request
      }, serverContext))) : this.getResultForParams({
        params: requestParserResult,
        request
      }, serverContext));
      return processResult({
        request,
        result,
        fetchAPI: this.fetchAPI,
        onResultProcessHooks: this.onResultProcessHooks
      });
    };
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...exports_node_ponyfill
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger2 = options?.logging == null ? true : options.logging;
    this.logger = typeof logger2 === "boolean" ? logger2 === true ? createLogger() : createLogger("silent") : typeof logger2 === "string" ? createLogger(logger2) : logger2;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = new WeakSet;
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error28, message) => {
        if (maskedErrorSet.has(error28)) {
          return error28;
        }
        const newError = maskErrorFn(error28, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error28) {
          this.logger.error(error28);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse: parse4,
        validate: validate2,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules
      }),
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      useResultProcessors(),
      useErrorHandling((error28, request) => {
        const errors6 = handleError(error28, this.maskedErrorsOpts, this.logger);
        const result = {
          errors: errors6
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache));
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(useUnhandledRoute({
            graphqlEndpoint,
            showLandingPage: options?.landingPage ?? true
          }));
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(useHTTPValidationError());
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const serverContext = args[0];
        const initialContext = {
          ...serverContext,
          request,
          params
        };
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error28) {
      const errors6 = handleError(error28, this.maskedErrorsOpts, this.logger);
      const result = {
        errors: errors6
      };
      return result;
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@repeaterjs/repeater/repeater.js
var __extends = function(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value14) {
    return value14 instanceof P ? value14 : new P(function(resolve) {
      resolve(value14);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value14) {
      try {
        step(generator.next(value14));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value14) {
      try {
        step(generator["throw"](value14));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y2, t2, g;
  return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : undefined, done: true };
  }
};
var __values = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = undefined;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g[n2])
      i[n2] = function(v) {
        return new Promise(function(a2, b2) {
          q.push([n2, v, a2, b2]) > 1 || resume(n2, v);
        });
      };
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value14) {
    resume("next", value14);
  }
  function reject(value14) {
    resume("throw", value14);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
};
var swallow = function(value14) {
  if (value14 != null && typeof value14.then === "function") {
    value14.then(NOOP, NOOP);
  }
};
var consumeExecution = function(r) {
  var err = r.err;
  var execution = Promise.resolve(r.execution).then(function(value14) {
    if (err != null) {
      throw err;
    }
    return value14;
  });
  r.err = undefined;
  r.execution = execution.then(function() {
    return;
  }, function() {
    return;
  });
  return r.pending === undefined ? execution : r.pending.then(function() {
    return execution;
  });
};
var createIteration = function(r, value14) {
  var done = r.state >= Done;
  return Promise.resolve(value14).then(function(value15) {
    if (!done && r.state >= Rejected) {
      return consumeExecution(r).then(function(value16) {
        return {
          value: value16,
          done: true
        };
      });
    }
    return { value: value15, done };
  });
};
var stop = function(r, err) {
  var e_1, _a;
  if (r.state >= Stopped) {
    return;
  }
  r.state = Stopped;
  r.onnext();
  r.onstop();
  if (r.err == null) {
    r.err = err;
  }
  if (r.pushes.length === 0 && (typeof r.buffer === "undefined" || r.buffer.empty)) {
    finish(r);
  } else {
    try {
      for (var _b = __values(r.pushes), _d = _b.next();!_d.done; _d = _b.next()) {
        var push_1 = _d.value;
        push_1.resolve();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
};
var finish = function(r) {
  var e_2, _a;
  if (r.state >= Done) {
    return;
  }
  if (r.state < Stopped) {
    stop(r);
  }
  r.state = Done;
  r.buffer = undefined;
  try {
    for (var _b = __values(r.nexts), _d = _b.next();!_d.done; _d = _b.next()) {
      var next = _d.value;
      var execution = r.pending === undefined ? consumeExecution(r) : r.pending.then(function() {
        return consumeExecution(r);
      });
      next.resolve(createIteration(r, execution));
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  r.pushes = [];
  r.nexts = [];
};
var reject = function(r) {
  if (r.state >= Rejected) {
    return;
  }
  if (r.state < Done) {
    finish(r);
  }
  r.state = Rejected;
};
var push = function(r, value14) {
  swallow(value14);
  if (r.pushes.length >= MAX_QUEUE_LENGTH) {
    throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
  } else if (r.state >= Stopped) {
    return Promise.resolve(undefined);
  }
  var valueP = r.pending === undefined ? Promise.resolve(value14) : r.pending.then(function() {
    return value14;
  });
  valueP = valueP.catch(function(err) {
    if (r.state < Stopped) {
      r.err = err;
    }
    reject(r);
    return;
  });
  var nextP;
  if (r.nexts.length) {
    var next_1 = r.nexts.shift();
    next_1.resolve(createIteration(r, valueP));
    if (r.nexts.length) {
      nextP = Promise.resolve(r.nexts[0].value);
    } else {
      nextP = new Promise(function(resolve) {
        return r.onnext = resolve;
      });
    }
  } else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
    r.buffer.add(valueP);
    nextP = Promise.resolve(undefined);
  } else {
    nextP = new Promise(function(resolve) {
      return r.pushes.push({ resolve, value: valueP });
    });
  }
  var floating = true;
  var next = {};
  var unhandled = nextP.catch(function(err) {
    if (floating) {
      throw err;
    }
    return;
  });
  next.then = function(onfulfilled, onrejected) {
    floating = false;
    return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
  };
  next.catch = function(onrejected) {
    floating = false;
    return Promise.prototype.catch.call(nextP, onrejected);
  };
  next.finally = nextP.finally.bind(nextP);
  r.pending = valueP.then(function() {
    return unhandled;
  }).catch(function(err) {
    r.err = err;
    reject(r);
  });
  return next;
};
var createStop = function(r) {
  var stop1 = stop.bind(null, r);
  var stopP = new Promise(function(resolve) {
    return r.onstop = resolve;
  });
  stop1.then = stopP.then.bind(stopP);
  stop1.catch = stopP.catch.bind(stopP);
  stop1.finally = stopP.finally.bind(stopP);
  return stop1;
};
var execute4 = function(r) {
  if (r.state >= Started) {
    return;
  }
  r.state = Started;
  var push1 = push.bind(null, r);
  var stop1 = createStop(r);
  r.execution = new Promise(function(resolve) {
    return resolve(r.executor(push1, stop1));
  });
  r.execution.catch(function() {
    return stop(r);
  });
};
var getIterators = function(values3, options) {
  var e_3, _a;
  var iters = [];
  var _loop_1 = function(value15) {
    if (value15 != null && typeof value15[Symbol.asyncIterator] === "function") {
      iters.push(value15[Symbol.asyncIterator]());
    } else if (value15 != null && typeof value15[Symbol.iterator] === "function") {
      iters.push(value15[Symbol.iterator]());
    } else {
      iters.push(function valueToAsyncIterator() {
        return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!options.yieldValues)
                  return [3, 3];
                return [4, __await(value15)];
              case 1:
                return [4, _a2.sent()];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (!options.returnValues)
                  return [3, 5];
                return [4, __await(value15)];
              case 4:
                return [2, _a2.sent()];
              case 5:
                return [2];
            }
          });
        });
      }());
    }
  };
  try {
    for (var values_1 = __values(values3), values_1_1 = values_1.next();!values_1_1.done; values_1_1 = values_1.next()) {
      var value14 = values_1_1.value;
      _loop_1(value14);
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (values_1_1 && !values_1_1.done && (_a = values_1.return))
        _a.call(values_1);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  return iters;
};
var race = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, stopped, finalIteration, iteration, i_1, _loop_2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            iteration = undefined;
            i_1 = 0;
            _loop_2 = function() {
              var j, iters_1, iters_1_1, iter;
              var e_4, _a2;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    j = i_1;
                    try {
                      for (iters_1 = (e_4 = undefined, __values(iters)), iters_1_1 = iters_1.next();!iters_1_1.done; iters_1_1 = iters_1.next()) {
                        iter = iters_1_1.value;
                        Promise.resolve(iter.next()).then(function(iteration2) {
                          if (iteration2.done) {
                            stop2();
                            if (finalIteration === undefined) {
                              finalIteration = iteration2;
                            }
                          } else if (i_1 === j) {
                            i_1++;
                            advance(iteration2);
                          }
                        }, function(err) {
                          return stop2(err);
                        });
                      }
                    } catch (e_4_1) {
                      e_4 = { error: e_4_1 };
                    } finally {
                      try {
                        if (iters_1_1 && !iters_1_1.done && (_a2 = iters_1.return))
                          _a2.call(iters_1);
                      } finally {
                        if (e_4)
                          throw e_4.error;
                      }
                    }
                    return [4, new Promise(function(resolve) {
                      return advance = resolve;
                    })];
                  case 1:
                    iteration = _b.sent();
                    if (!(iteration !== undefined))
                      return [3, 3];
                    return [4, push2(iteration.value)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    return [2];
                }
              });
            };
            _a.label = 2;
          case 2:
            if (!!stopped)
              return [3, 4];
            return [5, _loop_2()];
          case 3:
            _a.sent();
            return [3, 2];
          case 4:
            return [2, finalIteration && finalIteration.value];
          case 5:
            stop2();
            return [4, Promise.race(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [7];
          case 7:
            return [2];
        }
      });
    });
  });
};
var merge = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { yieldValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advances, stopped, finalIteration;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_5, _a2;
              stopped = true;
              try {
                for (var advances_1 = __values(advances), advances_1_1 = advances_1.next();!advances_1_1.done; advances_1_1 = advances_1.next()) {
                  var advance = advances_1_1.value;
                  advance();
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (advances_1_1 && !advances_1_1.done && (_a2 = advances_1.return))
                    _a2.call(advances_1);
                } finally {
                  if (e_5)
                    throw e_5.error;
                }
              }
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, undefined, undefined, function() {
                var iteration, _a2;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, , 6, 9]);
                      _b.label = 1;
                    case 1:
                      if (!!stopped)
                        return [3, 5];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _b.sent();
                      if (!(iteration !== undefined))
                        return [3, 4];
                      if (iteration.done) {
                        finalIteration = iteration;
                        return [2];
                      }
                      return [4, push2(iteration.value)];
                    case 3:
                      _b.sent();
                      _b.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      _a2 = iter.return;
                      if (!_a2)
                        return [3, 8];
                      return [4, iter.return()];
                    case 7:
                      _a2 = _b.sent();
                      _b.label = 8;
                    case 8:
                      return [7];
                    case 9:
                      return [2];
                  }
                });
              });
            }))];
          case 2:
            _a.sent();
            return [2, finalIteration && finalIteration.value];
          case 3:
            stop2();
            return [7];
          case 4:
            return [2];
        }
      });
    });
  });
};
var zip = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, stopped, iterations, values3;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 6, 8]);
            _a.label = 2;
          case 2:
            if (!!stopped)
              return [3, 5];
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations2) {
              return advance(iterations2);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 3:
            iterations = _a.sent();
            if (iterations === undefined) {
              return [2];
            }
            values3 = iterations.map(function(iteration) {
              return iteration.value;
            });
            if (iterations.some(function(iteration) {
              return iteration.done;
            })) {
              return [2, values3];
            }
            return [4, push2(values3)];
          case 4:
            _a.sent();
            return [3, 2];
          case 5:
            return [3, 8];
          case 6:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 7:
            _a.sent();
            return [7];
          case 8:
            return [2];
        }
      });
    });
  });
};
var latest = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, {
    yieldValues: true,
    returnValues: true
  });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, advances, stopped, iterations_1, values_2;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_6, _a2;
              advance();
              try {
                for (var advances_2 = __values(advances), advances_2_1 = advances_2.next();!advances_2_1.done; advances_2_1 = advances_2.next()) {
                  var advance1 = advances_2_1.value;
                  advance1();
                }
              } catch (e_6_1) {
                e_6 = { error: e_6_1 };
              } finally {
                try {
                  if (advances_2_1 && !advances_2_1.done && (_a2 = advances_2.return))
                    _a2.call(advances_2);
                } finally {
                  if (e_6)
                    throw e_6.error;
                }
              }
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations) {
              return advance(iterations);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 2:
            iterations_1 = _a.sent();
            if (iterations_1 === undefined) {
              return [2];
            }
            values_2 = iterations_1.map(function(iteration) {
              return iteration.value;
            });
            if (iterations_1.every(function(iteration) {
              return iteration.done;
            })) {
              return [2, values_2];
            }
            return [4, push2(values_2.slice())];
          case 3:
            _a.sent();
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, undefined, undefined, function() {
                var iteration;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (iterations_1[i].done) {
                        return [2, iterations_1[i].value];
                      }
                      _a2.label = 1;
                    case 1:
                      if (!!stopped)
                        return [3, 4];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        return advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _a2.sent();
                      if (iteration === undefined) {
                        return [2, iterations_1[i].value];
                      } else if (iteration.done) {
                        return [2, iteration.value];
                      }
                      values_2[i] = iteration.value;
                      return [4, push2(values_2.slice())];
                    case 3:
                      _a2.sent();
                      return [3, 1];
                    case 4:
                      return [2];
                  }
                });
              });
            }))];
          case 4:
            return [2, _a.sent()];
          case 5:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [7];
          case 7:
            return [2];
        }
      });
    });
  });
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
var RepeaterOverflowError = function(_super) {
  __extends(RepeaterOverflowError2, _super);
  function RepeaterOverflowError2(message) {
    var _this = _super.call(this, message) || this;
    Object.defineProperty(_this, "name", {
      value: "RepeaterOverflowError",
      enumerable: false
    });
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(_this, _this.constructor.prototype);
    } else {
      _this.__proto__ = _this.constructor.prototype;
    }
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(_this, _this.constructor);
    }
    return _this;
  }
  return RepeaterOverflowError2;
}(Error);
var FixedBuffer = function() {
  function FixedBuffer2(capacity) {
    if (capacity < 0) {
      throw new RangeError("Capacity may not be less than 0");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(FixedBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FixedBuffer2.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: false,
    configurable: true
  });
  FixedBuffer2.prototype.add = function(value14) {
    if (this.full) {
      throw new Error("Buffer full");
    } else {
      this._q.push(value14);
    }
  };
  FixedBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return FixedBuffer2;
}();
var SlidingBuffer = function() {
  function SlidingBuffer2(capacity) {
    if (capacity < 1) {
      throw new RangeError("Capacity may not be less than 1");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(SlidingBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SlidingBuffer2.prototype, "full", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  SlidingBuffer2.prototype.add = function(value14) {
    while (this._q.length >= this._c) {
      this._q.shift();
    }
    this._q.push(value14);
  };
  SlidingBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return SlidingBuffer2;
}();
var DroppingBuffer = function() {
  function DroppingBuffer2(capacity) {
    if (capacity < 1) {
      throw new RangeError("Capacity may not be less than 1");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(DroppingBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DroppingBuffer2.prototype, "full", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  DroppingBuffer2.prototype.add = function(value14) {
    if (this._q.length < this._c) {
      this._q.push(value14);
    }
  };
  DroppingBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return DroppingBuffer2;
}();
var Initial = 0;
var Started = 1;
var Stopped = 2;
var Done = 3;
var Rejected = 4;
var MAX_QUEUE_LENGTH = 1024;
var NOOP = function() {
};
var records = new WeakMap;
var Repeater = function() {
  function Repeater2(executor2, buffer) {
    records.set(this, {
      executor: executor2,
      buffer,
      err: undefined,
      state: Initial,
      pushes: [],
      nexts: [],
      pending: undefined,
      execution: undefined,
      onnext: NOOP,
      onstop: NOOP
    });
  }
  Repeater2.prototype.next = function(value14) {
    swallow(value14);
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    if (r.nexts.length >= MAX_QUEUE_LENGTH) {
      throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
    }
    if (r.state <= Initial) {
      execute4(r);
    }
    r.onnext(value14);
    if (typeof r.buffer !== "undefined" && !r.buffer.empty) {
      var result = createIteration(r, r.buffer.remove());
      if (r.pushes.length) {
        var push_2 = r.pushes.shift();
        r.buffer.add(push_2.value);
        r.onnext = push_2.resolve;
      }
      return result;
    } else if (r.pushes.length) {
      var push_3 = r.pushes.shift();
      r.onnext = push_3.resolve;
      return createIteration(r, push_3.value);
    } else if (r.state >= Stopped) {
      finish(r);
      return createIteration(r, consumeExecution(r));
    }
    return new Promise(function(resolve) {
      return r.nexts.push({ resolve, value: value14 });
    });
  };
  Repeater2.prototype.return = function(value14) {
    swallow(value14);
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    finish(r);
    r.execution = Promise.resolve(r.execution).then(function() {
      return value14;
    });
    return createIteration(r, consumeExecution(r));
  };
  Repeater2.prototype.throw = function(err) {
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    if (r.state <= Initial || r.state >= Stopped || typeof r.buffer !== "undefined" && !r.buffer.empty) {
      finish(r);
      if (r.err == null) {
        r.err = err;
      }
      return createIteration(r, consumeExecution(r));
    }
    return this.next(Promise.reject(err));
  };
  Repeater2.prototype[Symbol.asyncIterator] = function() {
    return this;
  };
  Repeater2.race = race;
  Repeater2.merge = merge;
  Repeater2.zip = zip;
  Repeater2.latest = latest;
  return Repeater2;
}();

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/events/dist/node-ponyfill.js
var $CustomEvent = globalThis.CustomEvent;
if (!$CustomEvent) {
  $CustomEvent = class CustomEvent extends Event {
    constructor(type73, options) {
      super(type73, options);
      this.detail = options?.detail ?? null;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/subscription/esm/create-pub-sub.js
var createPubSub = (config) => {
  const target = config?.eventTarget ?? new EventTarget;
  return {
    publish(routingKey, ...args) {
      const payload = args[1] ?? args[0] ?? null;
      const topic = args[1] === undefined ? routingKey : `${routingKey}:${args[0]}`;
      const event = new $CustomEvent(topic, {
        detail: payload
      });
      target.dispatchEvent(event);
    },
    subscribe(...[routingKey, id]) {
      const topic = id === undefined ? routingKey : `${routingKey}:${id}`;
      return new Repeater(function subscriptionRepeater(next, stop2) {
        stop2.then(function subscriptionRepeaterStopHandler() {
          target.removeEventListener(topic, pubsubEventListener);
        });
        target.addEventListener(topic, pubsubEventListener);
        function pubsubEventListener(event) {
          next(event.detail);
        }
      });
    }
  };
};
// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/subscription/esm/operator/map.js
var map3 = (mapper) => (source2) => new Repeater(async (push2, stop2) => {
  const iterable = source2[Symbol.asyncIterator]();
  stop2.then(() => {
    iterable.return?.();
  });
  let latest2;
  while ((latest2 = await iterable.next()).done === false) {
    await push2(await mapper(latest2.value));
  }
  stop2();
});
// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/subscription/esm/utils/pipe.js
function pipe(a2, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a2;
    case 2:
      return ab(a2);
    case 3:
      return bc(ab(a2));
    case 4:
      return cd(bc(ab(a2)));
    case 5:
      return de(cd(bc(ab(a2))));
    case 6:
      return ef(de(cd(bc(ab(a2)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a2))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a2)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a2))))))));
    default:
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/builder.js
var _defineProperty22 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/build-cache.js
var _defineProperty9 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/errors.js
class PothosError extends Error {
  constructor(message) {
    super(message);
    this.name = "PothosError";
  }
}

class PothosSchemaError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosSchemaError";
  }
}

class PothosValidationError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosValidationError";
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/merge-plugins.js
var _defineProperty2 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/plugin.js
var _defineProperty = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/context-cache.js
function createContextCache(create4) {
  const cache = new WeakMap;
  return (context, ...args) => {
    const cacheKey = context[contextCacheSymbol] || context;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const entry = create4(context, ...args);
    cache.set(cacheKey, entry);
    return entry;
  };
}
var contextCacheSymbol = Symbol.for("Pothos.contextCache");

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/plugin.js
var runCache = new WeakMap;

class BasePlugin {
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  beforeBuild() {
  }
  afterBuild(schema3) {
    return schema3;
  }
  wrapResolve(resolver, fieldConfig) {
    return resolver;
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return subscribe3;
  }
  wrapResolveType(resolveType, typeConfig) {
    return resolveType;
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, new Map);
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  createRequestData(context) {
    throw new PothosError("createRequestData not implemented");
  }
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    _defineProperty(this, "name", undefined);
    _defineProperty(this, "builder", undefined);
    _defineProperty(this, "buildCache", undefined);
    _defineProperty(this, "options", undefined);
    _defineProperty(this, "requestDataMap", createContextCache((ctx) => this.createRequestData(ctx)));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/merge-plugins.js
class MergedPlugins extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onTypeConfig(config), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onInputFieldConfig(config), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onOutputFieldConfig(config), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onEnumValueConfig(config), valueConfig);
  }
  beforeBuild() {
    for (const plugin2 of this.plugins) {
      plugin2.beforeBuild();
    }
  }
  afterBuild(schema3) {
    return this.plugins.reduceRight((nextSchema, plugin2) => plugin2.afterBuild(nextSchema), schema3);
  }
  wrapResolve(resolve, fieldConfig) {
    return this.plugins.reduceRight((nextResolve, plugin2) => plugin2.wrapResolve(nextResolve, fieldConfig), resolve);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return this.plugins.reduceRight((nextSubscribe, plugin2) => plugin2.wrapSubscribe(nextSubscribe, fieldConfig), subscribe3);
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin2) => plugin2.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin2) => plugin2.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin");
    _defineProperty2(this, "plugins", undefined);
    this.plugins = plugins;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/builtin-scalar.js
var _defineProperty5 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/scalar.js
var _defineProperty4 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/types/type-params.js
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/base.js
var _defineProperty3 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

class BaseTypeRef {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  constructor(kind, name) {
    _defineProperty3(this, "kind", undefined);
    _defineProperty3(this, "name", undefined);
    this.kind = kind;
    this.name = name;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/scalar.js
var _outputShapeKey = outputShapeKey;
var _parentShapeKey = parentShapeKey;
var _inputShapeKey = inputShapeKey;

class ScalarRef extends BaseTypeRef {
  constructor(name) {
    super("Scalar", name);
    _defineProperty4(this, "kind", "Scalar");
    _defineProperty4(this, _outputShapeKey, undefined);
    _defineProperty4(this, _parentShapeKey, undefined);
    _defineProperty4(this, _inputShapeKey, undefined);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/builtin-scalar.js
class BuiltinScalarRef extends ScalarRef {
  constructor(type73) {
    super(type73.name);
    _defineProperty5(this, "type", undefined);
    this.type = type73;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input-object.js
var _defineProperty6 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _inputShapeKey2 = inputShapeKey;

class InputObjectRef extends BaseTypeRef {
  constructor(name) {
    super("InputObject", name);
    _defineProperty6(this, "kind", "InputObject");
    _defineProperty6(this, _inputShapeKey2, undefined);
  }
}
class ImplementableInputObjectRef extends InputObjectRef {
  implement(options) {
    this.builder.inputType(this, options);
    return this;
  }
  constructor(builder, name) {
    super(name);
    _defineProperty6(this, "builder", undefined);
    this.builder = builder;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input-list.js
var _defineProperty7 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _inputShapeKey3 = inputShapeKey;

class InputObjectRef2 extends BaseTypeRef {
  constructor(listType, required4) {
    super("InputList", `InputList<${String(listType)}>`);
    _defineProperty7(this, "kind", "InputList");
    _defineProperty7(this, _inputShapeKey3, undefined);
    _defineProperty7(this, "listType", undefined);
    _defineProperty7(this, "required", undefined);
    this.listType = listType;
    this.required = required4;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/list.js
var _defineProperty8 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputShapeKey2 = outputShapeKey;
var _parentShapeKey2 = parentShapeKey;

class ListRef extends BaseTypeRef {
  constructor(listType, nullable) {
    super("List", `List<${String(listType)}>`);
    _defineProperty8(this, "kind", "List");
    _defineProperty8(this, _outputShapeKey2, undefined);
    _defineProperty8(this, _parentShapeKey2, undefined);
    _defineProperty8(this, "listType", undefined);
    _defineProperty8(this, "nullable", undefined);
    this.listType = listType;
    this.nullable = nullable;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/base64.js
function encodeBase64(value14) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.btoa === "function") {
    return globalThis1.btoa(value14);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value14).toString("base64");
  }
  throw new Error("Unable to locate global `btoa` or `Buffer`");
}
function decodeBase64(value14) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.atob === "function") {
    return globalThis1.atob(value14);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value14, "base64").toString();
  }
  throw new Error("Unable to locate global `atob` or `Buffer`");
}
var getGlobalThis = () => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (true)
    return null;
  throw new Error("Unable to locate global `this`");
};
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values3) {
  const result = {};
  if (Array.isArray(values3)) {
    values3.forEach((key) => {
      result[String(key)] = {
        pothosOptions: {}
      };
    });
  } else {
    Object.entries(values3).forEach(([key, value14]) => {
      if (value14 && typeof value14 === "object") {
        result[key] = {
          ...value14,
          pothosOptions: value14
        };
      } else if (typeof value14 === "string") {
        result[value14] = {
          pothosOptions: {}
        };
      }
    });
  }
  return result;
}
function valuesFromEnum(Enum2, values3) {
  const result = {};
  Object.keys(Enum2).filter((key) => typeof Enum2[Enum2[key]] !== "number").forEach((key) => {
    result[key] = {
      value: Enum2[key],
      pothosOptions: {},
      ...values3 === null || values3 === undefined ? undefined : values3[key]
    };
  });
  return result;
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/params.js
function typeFromParam(param, configStore, nullableOption) {
  const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
  const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromParam(param[0], configStore, itemNullable),
      nullable
    };
  }
  if (param instanceof ListRef) {
    return {
      kind: "List",
      type: typeFromParam(param.listType, configStore, param.nullable),
      nullable
    };
  }
  const ref3 = configStore.getOutputTypeRef(param);
  const kind = ref3 instanceof BaseTypeRef ? ref3.kind : configStore.getTypeConfig(ref3).graphqlKind;
  const name = ref3 instanceof BaseTypeRef ? ref3.name : configStore.getTypeConfig(ref3).name;
  if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
    return {
      kind,
      ref: ref3,
      nullable
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function unwrapInputFieldType(type73) {
  if (type73.kind === "List") {
    return unwrapInputFieldType(type73.type);
  }
  return type73.ref;
}
function inputTypeFromParam(param, configStore, requiredOption) {
  const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
  const required4 = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromParam(param[0], configStore, itemRequired),
      required: required4
    };
  }
  if (param instanceof InputObjectRef2) {
    return {
      kind: "List",
      type: inputTypeFromParam(param.listType, configStore, param.required),
      required: required4
    };
  }
  const ref3 = configStore.getInputTypeRef(param);
  const kind = ref3 instanceof BaseTypeRef ? ref3.kind : configStore.getTypeConfig(ref3).graphqlKind;
  const name = ref3 instanceof BaseTypeRef ? ref3.name : configStore.getTypeConfig(ref3).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref: ref3,
      required: required4
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/input.js
function resolveInputTypeConfig(type73, buildCache) {
  if (type73.kind === "List") {
    return resolveInputTypeConfig(type73.type, buildCache);
  }
  const config = buildCache.getTypeConfig(type73.ref);
  if (config.kind === "Enum" || config.kind === "Scalar" || config.kind === "InputObject") {
    return config;
  }
  throw new PothosSchemaError(`Unexpected config type ${config.kind} for input ref ${String(type73.ref)}`);
}
function mapInputFields(inputs, buildCache, mapper) {
  const filterMappings = new Map;
  return filterMapped(internalMapInputFields(inputs, buildCache, mapper, new Map));
  function filterMapped(map4) {
    if (filterMappings.has(map4)) {
      return filterMappings.get(map4);
    }
    const filtered = new Map;
    filterMappings.set(map4, filtered);
    map4.forEach((mapping, fieldName) => {
      if (mapping.kind === "Enum" || mapping.kind === "Scalar") {
        filtered.set(fieldName, mapping);
        return;
      }
      const hasNestedMappings = checkForMappings(mapping.fields.map);
      if (mapping.value !== null || hasNestedMappings) {
        const filteredTypeFields = filterMapped(mapping.fields.map);
        const mappingForType = {
          ...mapping,
          fields: {
            configs: mapping.fields.configs,
            map: filteredTypeFields
          }
        };
        filtered.set(fieldName, mappingForType);
      }
    });
    return filtered.size > 0 ? filtered : null;
  }
  function checkForMappings(map4, hasMappings = new Map) {
    if (hasMappings.has(map4)) {
      return hasMappings.get(map4);
    }
    hasMappings.set(map4, false);
    let result = false;
    map4.forEach((mapping) => {
      if (mapping.value !== null) {
        result = true;
      } else if (mapping.kind === "InputObject" && mapping.fields.map && checkForMappings(mapping.fields.map, hasMappings)) {
        result = true;
      }
    });
    hasMappings.set(map4, result);
    return result;
  }
}
var internalMapInputFields = function(inputs, buildCache, mapper, seenTypes) {
  const map4 = new Map;
  Object.keys(inputs).forEach((fieldName) => {
    const inputField = inputs[fieldName];
    const typeConfig = resolveInputTypeConfig(inputField.type, buildCache);
    const fieldMapping = mapper(inputField);
    if (typeConfig.kind === "Enum" || typeConfig.kind === "Scalar") {
      if (fieldMapping !== null) {
        map4.set(fieldName, {
          kind: typeConfig.kind,
          isList: inputField.type.kind === "List",
          config: inputField,
          value: fieldMapping
        });
      }
      return;
    }
    const inputFieldConfigs = buildCache.getInputTypeFieldConfigs(unwrapInputFieldType(inputField.type));
    if (!seenTypes.has(typeConfig.name)) {
      const typeEntry = {
        configs: inputFieldConfigs,
        map: new Map
      };
      seenTypes.set(typeConfig.name, typeEntry);
      typeEntry.map = internalMapInputFields(inputFieldConfigs, buildCache, mapper, seenTypes);
    }
    const typeFields = seenTypes.get(typeConfig.name);
    map4.set(fieldName, {
      kind: typeConfig.kind,
      isList: inputField.type.kind === "List",
      config: inputField,
      value: fieldMapping,
      fields: typeFields
    });
  });
  return map4;
};
function createInputValueMapper(argMap, mapValue3) {
  return function mapObject(obj, map4 = argMap, ...args) {
    const mapped19 = {
      ...obj
    };
    map4.forEach((field, fieldName) => {
      let fieldVal = obj[fieldName];
      if (fieldVal === null || fieldVal === undefined) {
        return;
      }
      if (field.kind === "InputObject" && field.fields.map) {
        fieldVal = field.isList ? fieldVal.map((val) => val && mapObject(val, field.fields.map, ...args)) : mapObject(fieldVal, field.fields.map, ...args);
        mapped19[fieldName] = fieldVal;
      }
      if (field.kind !== "InputObject" || field.value !== null) {
        mapped19[fieldName] = field.isList ? fieldVal.map((val) => mapValue3(val, field, ...args)) : mapValue3(fieldVal, field, ...args);
      }
    });
    return mapped19;
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/index.js
function assertNever(value14) {
  throw new TypeError(`Unexpected value: ${value14}`);
}
function assertArray(value14) {
  if (!Array.isArray(value14)) {
    throw new PothosValidationError("List resolvers must return arrays");
  }
  return true;
}
function isThenable(value14) {
  return !!(value14 && (typeof value14 === "object" || typeof value14 === "function") && typeof value14.then === "function");
}
function verifyRef(ref3) {
  if (ref3 === undefined) {
    throw new PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new PothosSchemaError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === undefined) {
      throw new PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function brandWithType(val, type73) {
  if (typeof val !== "object" || val === null) {
    return;
  }
  Object.defineProperty(val, typeBrandKey, {
    enumerable: false,
    value: type73
  });
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && (typeBrandKey in val)) {
    return val[typeBrandKey];
  }
  return null;
}
function unwrapListParam(param) {
  if (Array.isArray(param)) {
    return unwrapListParam(param[0]);
  }
  if (param instanceof ListRef || param instanceof InputObjectRef2) {
    return unwrapListParam(param.listType);
  }
  return param;
}
function completeValue2(valOrPromise, onSuccess, onError) {
  if (isThenable(valOrPromise)) {
    return Promise.resolve(valOrPromise).then(onSuccess, onError);
  }
  const result = onSuccess(valOrPromise);
  if (isThenable(result)) {
    return Promise.resolve(result);
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/build-cache.js
class BuildCache {
  getTypeConfig(ref3, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref3, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref3) {
    const typeConfig = this.getTypeConfig(ref3, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields = builtType.getFields();
    const fieldConfigs = {};
    Object.keys(fields).forEach((fieldName) => {
      var _fields_fieldName_extensions;
      fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields[fieldName].extensions) === null || _fields_fieldName_extensions === undefined ? undefined : _fields_fieldName_extensions.pothosConfig;
    });
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((type73) => type73.kind === "Object" && type73.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "InputObject") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type73) => {
      if (type73 instanceof GraphQLInputObjectType) {
        type73.getFields();
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Interface") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Object") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Union") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type73) => {
      if (type73 instanceof GraphQLObjectType || type73 instanceof GraphQLInterfaceType) {
        type73.getFields();
      } else if (type73 instanceof GraphQLUnionType) {
        type73.getTypes();
      }
    });
  }
  buildTypeFromConfig(baseConfig) {
    const config = this.getTypeConfig(baseConfig.name);
    const { name } = config;
    this.typeConfigs.set(name, config);
    switch (config.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config));
        break;
      default:
        assertNever(config);
    }
  }
  addType(ref3, type73) {
    if (this.types.has(ref3)) {
      throw new PothosSchemaError(`reference or name has already been used to create another type (${type73.name})`);
    }
    this.types.set(ref3, type73);
  }
  buildOutputTypeParam(type73) {
    if (type73.kind === "List") {
      if (type73.nullable) {
        return new GraphQLList(this.buildOutputTypeParam(type73.type));
      }
      return new GraphQLNonNull(new GraphQLList(this.buildOutputTypeParam(type73.type)));
    }
    if (type73.nullable) {
      return this.getOutputType(type73.ref);
    }
    return new GraphQLNonNull(this.getOutputType(type73.ref));
  }
  buildInputTypeParam(type73) {
    if (type73.kind === "List") {
      if (type73.required) {
        return new GraphQLNonNull(new GraphQLList(this.buildInputTypeParam(type73.type)));
      }
      return new GraphQLList(this.buildInputTypeParam(type73.type));
    }
    if (type73.required) {
      return new GraphQLNonNull(this.getInputType(type73.ref));
    }
    return this.getInputType(type73.ref);
  }
  buildFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config = {
        ...updatedConfig
      };
      const argMap = new Map;
      Object.keys(config.args).forEach((argName) => {
        argMap.set(argName, config.args[argName]);
      });
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      Object.keys(config.args).forEach((argName) => {
        argConfigs[argName] = this.inputFieldConfigs.get(config.args[argName]);
      });
      config.args = argConfigs;
      var _config_resolve;
      const resolve = this.plugin.wrapResolve((_config_resolve = config.resolve) !== null && _config_resolve !== undefined ? _config_resolve : defaultFieldResolver, config);
      const subscribe3 = this.plugin.wrapSubscribe(config.subscribe, config);
      var _config_resolve1;
      built[fieldName] = {
        ...config,
        type: this.buildOutputTypeParam(config.type),
        args,
        extensions: {
          ...config.extensions,
          pothosResolveWrapped: resolve !== ((_config_resolve1 = config.resolve) !== null && _config_resolve1 !== undefined ? _config_resolve1 : defaultFieldResolver),
          pothosSubscribeWrapped: subscribe3 !== config.subscribe,
          pothosOptions: config.pothosOptions,
          pothosConfig: config
        },
        resolve: resolve === defaultFieldResolver ? undefined : resolve,
        subscribe: subscribe3
      };
    }
    return built;
  }
  buildInputFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config = this.inputFieldConfigs.get(originalConfig);
      if (config) {
        built[fieldName] = {
          ...config,
          type: this.buildInputTypeParam(config.type),
          extensions: {
            ...config.extensions,
            pothosOptions: config.pothosOptions,
            pothosConfig: config
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type73) {
    const interfaceFields = type73.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const configs2 = this.configStore.getFields(type73.name, "Interface");
    const fields = this.buildFields(configs2);
    return {
      ...interfaceFields,
      ...fields
    };
  }
  getObjectFields(type73) {
    const interfaceFields = type73.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const objectFields = this.buildFields(this.configStore.getFields(type73.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type73) {
    return this.buildFields(this.configStore.getFields(type73.name, "Object"));
  }
  getFields(type73) {
    if (type73 instanceof GraphQLObjectType) {
      if (type73.name === "Query" || type73.name === "Mutation" || type73.name === "Subscription") {
        return this.getRootFields(type73);
      }
      return this.getObjectFields(type73);
    }
    if (type73 instanceof GraphQLInterfaceType) {
      return this.getInterfaceFields(type73);
    }
    throw new PothosSchemaError(`Type ${type73.name} does not have fields to resolve`);
  }
  getInputFields(type73) {
    return this.buildInputFields(this.configStore.getFields(type73.name, "InputObject"));
  }
  getType(ref3) {
    if (ref3 instanceof BuiltinScalarRef) {
      return ref3.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref3);
    const type73 = this.types.get(typeConfig.name);
    if (!type73) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type73;
  }
  getOutputType(ref3) {
    const type73 = this.getType(ref3);
    if (type73 instanceof GraphQLInputObjectType) {
      throw new PothosSchemaError(`Expected ${String(ref3)} to be an output type but it was defined as an InputObject`);
    }
    return type73;
  }
  getInputType(ref3) {
    const type73 = this.getType(ref3);
    if (!type73) {
      throw new PothosSchemaError(`Missing implementation of for type ${String(ref3)}`);
    }
    if (type73 instanceof GraphQLObjectType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type73 instanceof GraphQLInterfaceType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type73 instanceof GraphQLUnionType) {
      throw new PothosSchemaError(`Expected ${String(ref3)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type73;
  }
  getTypeOfKind(ref3, kind) {
    const type73 = this.getType(ref3);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type73 instanceof GraphQLObjectType) {
          return type73;
        }
        break;
      case "Interface":
        if (type73 instanceof GraphQLInterfaceType) {
          return type73;
        }
        break;
      case "Union":
        if (type73 instanceof GraphQLUnionType) {
          return type73;
        }
        break;
      case "Enum":
        if (type73 instanceof GraphQLEnumType) {
          return type73;
        }
        break;
      case "Scalar":
        if (type73 instanceof GraphQLScalarType) {
          return type73;
        }
        break;
      case "InputObject":
        if (type73 instanceof GraphQLScalarType) {
          return type73;
        }
        break;
      default:
        break;
    }
    throw new PothosSchemaError(`Expected ${String(ref3)} to be of type ${kind}`);
  }
  buildObject(config) {
    var _config_isTypeOf;
    const type73 = new GraphQLObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getFields(type73),
      isTypeOf: config.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config.isTypeOf) !== null && _config_isTypeOf !== undefined ? _config_isTypeOf : undefined, config) : undefined,
      interfaces: config.kind === "Object" ? () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : undefined
    });
    return type73;
  }
  buildInterface(config) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _config_resolveType;
      const resolver = (_config_resolveType = config.resolveType) !== null && _config_resolveType !== undefined ? _config_resolveType : defaultTypeResolver;
      return resolver(parent, context, info, type73);
    };
    const type73 = new GraphQLInterfaceType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      interfaces: () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type73),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
    return type73;
  }
  buildUnion(config) {
    const resolveType = (parent, context, info, type73) => {
      if (typeof parent === "object" && parent !== null && (typeBrandKey in parent)) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config.resolveType) {
        return defaultTypeResolver(parent, context, info, type73);
      }
      const resultOrPromise = config.resolveType(parent, context, info, type73);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new GraphQLUnionType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      types: () => config.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
  }
  buildInputObject(config) {
    const type73 = new GraphQLInputObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getInputFields(type73)
    });
    return type73;
  }
  buildScalar(config) {
    if (config.name === "ID") {
      return GraphQLID;
    }
    if (config.name === "Int") {
      return GraphQLInt;
    }
    if (config.name === "Float") {
      return GraphQLFloat;
    }
    if (config.name === "Boolean") {
      return GraphQLBoolean;
    }
    if (config.name === "String") {
      return GraphQLString;
    }
    return new GraphQLScalarType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  buildEnum(config) {
    const values3 = {};
    for (const key of Object.keys(config.values)) {
      const original = config.values[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values3[key] = this.enumValueConfigs.get(original);
      }
    }
    return new GraphQLEnumType({
      ...config,
      values: values3,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  constructor(builder, options) {
    _defineProperty9(this, "types", new Map);
    _defineProperty9(this, "builder", undefined);
    _defineProperty9(this, "plugin", undefined);
    _defineProperty9(this, "options", undefined);
    _defineProperty9(this, "configStore", undefined);
    _defineProperty9(this, "pluginMap", undefined);
    _defineProperty9(this, "pluginList", undefined);
    _defineProperty9(this, "implementers", new Map);
    _defineProperty9(this, "typeConfigs", new Map);
    _defineProperty9(this, "enumValueConfigs", new Map);
    _defineProperty9(this, "outputFieldConfigs", new Map);
    _defineProperty9(this, "inputFieldConfigs", new Map);
    this.builder = builder;
    this.configStore = builder.configStore;
    this.options = options;
    const plugins3 = {};
    var _builder_options_plugins;
    this.pluginList = ((_builder_options_plugins = builder.options.plugins) !== null && _builder_options_plugins !== undefined ? _builder_options_plugins : []).map((pluginName) => {
      const Plugin = this.builder.constructor.plugins[pluginName];
      if (!Plugin) {
        throw new PothosError(`No plugin named ${pluginName} was registered`);
      }
      plugins3[pluginName] = new Plugin(this, pluginName);
      return plugins3[pluginName];
    });
    this.pluginMap = plugins3;
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/config-store.js
var _defineProperty12 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input.js
var _defineProperty10 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _inputShapeKey4 = inputShapeKey;

class InputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty10(this, "kind", undefined);
    _defineProperty10(this, _inputShapeKey4, undefined);
    this.kind = kind;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/output.js
var _defineProperty11 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputShapeKey3 = outputShapeKey;
var _parentShapeKey3 = parentShapeKey;

class OutputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty11(this, "kind", undefined);
    _defineProperty11(this, _outputShapeKey3, undefined);
    _defineProperty11(this, _parentShapeKey3, undefined);
    this.kind = kind;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/config-store.js
class ConfigStore {
  hasConfig(typeParam) {
    if (typeof typeParam === "string") {
      return this.typeConfigs.has(typeParam);
    }
    return this.refsToName.has(typeParam);
  }
  addUnionTypes(typeName, unionTypes) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Union") {
        throw new PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.types = [
        ...typeConfig.types,
        ...typeof unionTypes === "function" ? unionTypes() : unionTypes
      ];
    });
  }
  addInterfaces(typeName, interfaces) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
        throw new PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.interfaces = [
        ...typeConfig.interfaces,
        ...typeof interfaces === "function" ? interfaces() : interfaces
      ];
    });
  }
  addFieldRef(ref3, typeParam, args, getConfig) {
    if (this.fieldRefs.has(ref3)) {
      throw new PothosSchemaError(`FieldRef ${String(ref3)} has already been added to config store`);
    }
    const typeRefOrName = unwrapListParam(typeParam);
    const argRefs = Object.keys(args).map((argName) => {
      const argRef = args[argName];
      argRef.fieldName = argName;
      argRef.argFor = ref3;
      return argRef;
    });
    const checkArgs = () => {
      for (const arg of argRefs) {
        if (this.pendingFields.has(arg)) {
          const unresolvedArgType = this.pendingFields.get(arg);
          this.pendingFields.set(ref3, unresolvedArgType);
          this.onTypeConfig(unresolvedArgType, checkArgs);
          return;
        }
      }
      this.pendingFields.delete(ref3);
      this.fieldRefs.set(ref3, getConfig);
    };
    if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
      checkArgs();
    } else {
      this.pendingFields.set(ref3, typeRefOrName);
      this.onTypeConfig(typeRefOrName, () => {
        checkArgs();
      });
    }
  }
  createFieldConfig(ref3, name, typeConfig, parentField, kind) {
    if (!this.fieldRefs.has(ref3)) {
      if (this.pendingFields.has(ref3)) {
        throw new PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref3))}`);
      }
      throw new PothosSchemaError(`Missing definition for ${String(ref3)}`);
    }
    const config = this.fieldRefs.get(ref3)(name, parentField, typeConfig);
    if (kind && config.graphqlKind !== kind) {
      throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
    }
    return config;
  }
  associateRefWithName(ref3, name) {
    if (!this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`${name} has not been implemented yet`);
    }
    this.refsToName.set(ref3, name);
    if (this.pendingRefResolutions.has(ref3)) {
      const cbs = this.pendingRefResolutions.get(ref3);
      this.pendingRefResolutions.delete(ref3);
      cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
    }
  }
  addTypeConfig(config, ref3) {
    const { name } = config;
    if (this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
    }
    this.typeConfigs.set(config.name, config);
    if (ref3) {
      this.associateRefWithName(ref3, name);
    }
    if (this.pendingRefResolutions.has(name)) {
      const cbs = this.pendingRefResolutions.get(name);
      this.pendingRefResolutions.delete(name);
      cbs.forEach((cb) => void cb(config));
    }
  }
  getTypeConfig(ref3, kind) {
    let config;
    if (typeof ref3 === "string") {
      if (!this.typeConfigs.has(ref3)) {
        throw new PothosSchemaError(`Type ${String(ref3)} has not been implemented`);
      }
      config = this.typeConfigs.get(ref3);
    } else if (this.refsToName.has(ref3)) {
      config = this.typeConfigs.get(this.refsToName.get(ref3));
    } else if (ref3 instanceof ListRef || ref3 instanceof InputObjectRef2) {
      throw new PothosSchemaError(`Expected a base type but got a ${ref3.kind} of ${String(ref3.listType)}`);
    } else {
      throw new PothosSchemaError(`Ref ${String(ref3)} has not been implemented`);
    }
    if (kind && config.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
    }
    return config;
  }
  getInputTypeRef(ref3) {
    if (ref3 instanceof BaseTypeRef) {
      if (ref3.kind !== "InputObject" && ref3.kind !== "Enum" && ref3.kind !== "Scalar") {
        throw new PothosSchemaError(`Expected ${ref3.name} to be an input type but got ${ref3.kind}`);
      }
      return ref3;
    }
    if (typeof ref3 === "string") {
      if (this.scalarsToRefs.has(ref3)) {
        return this.scalarsToRefs.get(ref3);
      }
      if (this.typeConfigs.has(ref3)) {
        const config = this.typeConfigs.get(ref3);
        if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
          throw new PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
        }
        const newRef = new InputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref3;
  }
  getOutputTypeRef(ref3) {
    if (ref3 instanceof BaseTypeRef) {
      if (ref3.kind === "InputObject" || ref3.kind === "InputList") {
        throw new PothosSchemaError(`Expected ${ref3.name} to be an output type but got ${ref3.kind}`);
      }
      if (ref3.kind === "List") {
        throw new PothosSchemaError(`Expected ${ref3.name} to be a base type but got a ${ref3.kind}`);
      }
      return ref3;
    }
    if (typeof ref3 === "string") {
      if (this.scalarsToRefs.has(ref3)) {
        return this.scalarsToRefs.get(ref3);
      }
      if (this.typeConfigs.has(ref3)) {
        const config = this.typeConfigs.get(ref3);
        if (config.graphqlKind === "InputObject") {
          throw new PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
        }
        const newRef = new OutputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref3;
  }
  onTypeConfig(ref3, cb) {
    if (!ref3) {
      throw new PothosSchemaError(`${String(ref3)} is not a valid type ref`);
    }
    if (this.refsToName.has(ref3)) {
      cb(this.getTypeConfig(ref3));
    } else if (typeof ref3 === "string" && this.typeConfigs.has(ref3)) {
      cb(this.typeConfigs.get(ref3));
    } else if (!this.pending) {
      throw new PothosSchemaError(`Ref ${String(ref3)} has not been implemented`);
    } else if (this.pendingRefResolutions.has(ref3)) {
      this.pendingRefResolutions.get(ref3).push(cb);
    } else {
      this.pendingRefResolutions.set(ref3, [
        cb
      ]);
    }
  }
  onFieldUse(ref3, cb) {
    if (!this.fieldRefCallbacks.has(ref3)) {
      this.fieldRefCallbacks.set(ref3, []);
    }
    this.fieldRefCallbacks.get(ref3).push(cb);
    if (this.fieldRefsToConfigs.has(ref3)) {
      this.fieldRefsToConfigs.get(ref3).forEach((config) => void cb(config));
    }
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, new Map);
    }
    const fields = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields;
  }
  prepareForBuild() {
    this.pending = false;
    const { pendingActions } = this;
    this.pendingActions = [];
    pendingActions.forEach((fn) => void fn());
    if (this.pendingRefResolutions.size > 0) {
      throw new PothosSchemaError(`Missing implementations for some references (${[
        ...this.pendingRefResolutions.keys()
      ].map((ref3) => this.describeRef(ref3)).join(", ")}).`);
    }
  }
  onPrepare(cb) {
    if (this.pending) {
      this.pendingActions.push(cb);
    } else {
      cb();
    }
  }
  addFields(typeRef, fields) {
    this.onPrepare(() => void this.onTypeConfig(typeRef, (config) => {
      this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
    }));
  }
  getImplementers(ref3) {
    const typeConfig = this.getTypeConfig(ref3, "Interface");
    const implementers = [
      ...this.typeConfigs.values()
    ].filter((type73) => type73.kind === "Object" && type73.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
    return implementers;
  }
  describeRef(ref3) {
    var _find;
    if (typeof ref3 === "string") {
      return ref3;
    }
    if (ref3.toString !== {}.toString) {
      return String(ref3);
    }
    const usedBy = (_find = [
      ...this.pendingFields.entries()
    ].find(([fieldRef, typeRef]) => typeRef === ref3)) === null || _find === undefined ? undefined : _find[0];
    if (usedBy) {
      return `<unnamed ref or enum: used by ${usedBy}>`;
    }
    return `<unnamed ref or enum>`;
  }
  buildFields(typeRef, fields) {
    Object.keys(fields).forEach((fieldName) => {
      const fieldRef = fields[fieldName];
      fieldRef.fieldName = fieldName;
      if (this.pendingFields.has(fieldRef)) {
        this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
          this.buildField(typeRef, fieldRef, fieldName);
        });
      } else {
        this.buildField(typeRef, fieldRef, fieldName);
      }
    });
  }
  buildField(typeRef, field, fieldName) {
    const typeConfig = this.getTypeConfig(typeRef);
    const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
    const existingFields = this.getFields(typeConfig.name);
    if (existingFields.has(fieldName)) {
      throw new PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
    }
    if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
      throw new PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
    }
    existingFields.set(fieldName, fieldConfig);
    if (!this.fieldRefsToConfigs.has(field)) {
      this.fieldRefsToConfigs.set(field, []);
    }
    this.fieldRefsToConfigs.get(field).push(fieldConfig);
    if (this.fieldRefCallbacks.has(field)) {
      this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
    }
  }
  constructor() {
    _defineProperty12(this, "typeConfigs", new Map);
    _defineProperty12(this, "fieldRefs", new WeakMap);
    _defineProperty12(this, "fields", new Map);
    _defineProperty12(this, "pendingActions", []);
    _defineProperty12(this, "refsToName", new Map);
    _defineProperty12(this, "scalarsToRefs", new Map);
    _defineProperty12(this, "fieldRefsToConfigs", new Map);
    _defineProperty12(this, "pendingFields", new Map);
    _defineProperty12(this, "pendingRefResolutions", new Map);
    _defineProperty12(this, "fieldRefCallbacks", new Map);
    _defineProperty12(this, "pending", true);
    const scalars6 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars6.forEach((scalar2) => {
      const ref3 = new BuiltinScalarRef(scalar2);
      this.scalarsToRefs.set(scalar2.name, ref3);
      this.refsToName.set(ref3, scalar2.name);
    });
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/input.js
var _defineProperty14 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input-field.js
var _defineProperty13 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _inputFieldShapeKey = inputFieldShapeKey;

class InputFieldRef {
  toString() {
    var _this_argFor;
    if (this.kind !== "Arg") {
      if (this.fieldName) {
        return `${this.parentTypename}.${this.fieldName}`;
      }
      return this.parentTypename;
    }
    var _this_argFor_fieldName;
    const fieldName = (_this_argFor_fieldName = (_this_argFor = this.argFor) === null || _this_argFor === undefined ? undefined : _this_argFor.fieldName) !== null && _this_argFor_fieldName !== undefined ? _this_argFor_fieldName : "[unnamed field]";
    var _this_fieldName;
    const argName = (_this_fieldName = this.fieldName) !== null && _this_fieldName !== undefined ? _this_fieldName : "[unnamed argument]";
    return `${this.parentTypename}.${fieldName}(${argName})`;
  }
  constructor(kind, parentTypename) {
    _defineProperty13(this, "kind", undefined);
    _defineProperty13(this, "parentTypename", undefined);
    _defineProperty13(this, "fieldName", undefined);
    _defineProperty13(this, "argFor", undefined);
    _defineProperty13(this, _inputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/input.js
class InputFieldBuilder {
  argBuilder() {
    const builder = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === undefined);
    [
      ...Object.keys(this),
      ...protoKeys
    ].forEach((key) => {
      builder[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    });
    return builder;
  }
  field(options) {
    const ref3 = new InputFieldRef(this.kind, this.typename);
    var _options_required;
    this.builder.configStore.addFieldRef(ref3, options.type, {}, (name, parentField, typeConfig) => ({
      name,
      parentField,
      kind: this.kind,
      graphqlKind: this.kind,
      parentType: typeConfig.name,
      type: inputTypeFromParam(options.type, this.builder.configStore, (_options_required = options.required) !== null && _options_required !== undefined ? _options_required : this.builder.defaultInputFieldRequiredness),
      pothosOptions: options,
      description: options.description,
      deprecationReason: options.deprecationReason,
      defaultValue: options.defaultValue,
      extensions: options.extensions
    }));
    return ref3;
  }
  helper(type73) {
    return (...args) => {
      const [options = {}] = args;
      return this.field({
        ...options,
        type: type73
      });
    };
  }
  constructor(builder, kind, typename) {
    _defineProperty14(this, "builder", undefined);
    _defineProperty14(this, "kind", undefined);
    _defineProperty14(this, "typename", undefined);
    _defineProperty14(this, "boolean", this.helper("Boolean"));
    _defineProperty14(this, "float", this.helper("Float"));
    _defineProperty14(this, "id", this.helper("ID"));
    _defineProperty14(this, "int", this.helper("Int"));
    _defineProperty14(this, "string", this.helper("String"));
    _defineProperty14(this, "booleanList", this.helper([
      "Boolean"
    ]));
    _defineProperty14(this, "floatList", this.helper([
      "Float"
    ]));
    _defineProperty14(this, "idList", this.helper([
      "ID"
    ]));
    _defineProperty14(this, "intList", this.helper([
      "Int"
    ]));
    _defineProperty14(this, "stringList", this.helper([
      "String"
    ]));
    var _options_required;
    _defineProperty14(this, "listRef", (type73, options) => {
      return new InputObjectRef2(type73, (_options_required = options === null || options === undefined ? undefined : options.required) !== null && _options_required !== undefined ? _options_required : true);
    });
    this.builder = builder;
    this.kind = kind;
    this.typename = typename;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/root.js
var _defineProperty17 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/base.js
var _defineProperty16 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/field.js
var _defineProperty15 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputFieldShapeKey = outputFieldShapeKey;

class FieldRef {
  toString() {
    if (this.fieldName) {
      return `${this.parentTypename}.${this.fieldName}`;
    }
    return this.parentTypename;
  }
  constructor(kind, parentTypename) {
    _defineProperty15(this, "kind", undefined);
    _defineProperty15(this, "parentTypename", undefined);
    _defineProperty15(this, "fieldName", undefined);
    _defineProperty15(this, _outputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/base.js
class BaseFieldUtil {
  createField(options) {
    const ref3 = new FieldRef(this.kind, this.typename);
    var _options_args;
    this.builder.configStore.addFieldRef(ref3, options.type, (_options_args = options.args) !== null && _options_args !== undefined ? _options_args : {}, (name, parentField, typeConfig) => {
      var _options_extensions;
      const args = {};
      if (options.args) {
        Object.keys(options.args).forEach((argName) => {
          const argRef = options.args[argName];
          args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
        });
      }
      var _options_resolve;
      let resolve = (_options_resolve = options.resolve) !== null && _options_resolve !== undefined ? _options_resolve : () => {
        throw new PothosSchemaError(`Not implemented: No resolver found for ${this.typename}.${name}`);
      };
      if (((_options_extensions = options.extensions) === null || _options_extensions === undefined ? undefined : _options_extensions.pothosExposedField) === name) {
        resolve = defaultFieldResolver;
      }
      const { subscribe: subscribe3 } = options;
      var _options_nullable;
      return {
        kind: this.kind,
        graphqlKind: this.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : this.builder.defaultFieldNullability),
        pothosOptions: options,
        extensions: {
          pothosOriginalResolve: resolve,
          pothosOriginalSubscribe: subscribe3,
          ...options.extensions
        },
        description: options.description,
        deprecationReason: options.deprecationReason,
        resolve,
        subscribe: subscribe3
      };
    });
    return ref3;
  }
  exposeField(name, { extensions, ...options }) {
    return this.createField({
      ...options,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(name, builder, kind, graphqlKind) {
    _defineProperty16(this, "typename", undefined);
    _defineProperty16(this, "builder", undefined);
    _defineProperty16(this, "kind", undefined);
    _defineProperty16(this, "graphqlKind", undefined);
    this.typename = name;
    this.builder = builder;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/root.js
class RootFieldBuilder extends BaseFieldUtil {
  boolean(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Boolean"
    });
  }
  float(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Float"
    });
  }
  id(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "ID"
    });
  }
  int(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Int"
    });
  }
  string(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "String"
    });
  }
  booleanList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  floatList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Float"
      ]
    });
  }
  idList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "ID"
      ]
    });
  }
  intList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Int"
      ]
    });
  }
  stringList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "String"
      ]
    });
  }
  field(options) {
    return this.createField(options);
  }
  listRef(type73, options) {
    var _options_nullable;
    return new ListRef(type73, (_options_nullable = options === null || options === undefined ? undefined : options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : false);
  }
  constructor(...args) {
    super(...args);
    _defineProperty17(this, "arg", new InputFieldBuilder(this.builder, "Arg", this.typename).argBuilder());
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/builder.js
class FieldBuilder extends RootFieldBuilder {
  exposeBoolean(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Boolean"
    });
  }
  exposeFloat(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Float"
    });
  }
  exposeID(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "ID"
    });
  }
  exposeInt(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Int"
    });
  }
  exposeString(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "String"
    });
  }
  exposeBooleanList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  exposeFloatList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Float"
      ]
    });
  }
  exposeIDList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "ID"
      ]
    });
  }
  exposeIntList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Int"
      ]
    });
  }
  exposeStringList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "String"
      ]
    });
  }
  expose(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, options);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/interface.js
class InterfaceFieldBuilder extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Interface", "Interface");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/mutation.js
class MutationFieldBuilder extends RootFieldBuilder {
  constructor(builder2) {
    super("Mutation", builder2, "Mutation", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/object.js
class ObjectFieldBuilder extends FieldBuilder {
  constructor(name, builder3) {
    super(name, builder3, "Object", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/query.js
class QueryFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Query", builder3, "Query", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/subscription.js
class SubscriptionFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Subscription", builder3, "Subscription", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/enum.js
var _defineProperty18 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputShapeKey4 = outputShapeKey;
var _inputShapeKey5 = inputShapeKey;

class EnumRef extends BaseTypeRef {
  constructor(name) {
    super("Enum", name);
    _defineProperty18(this, "kind", "Enum");
    _defineProperty18(this, _outputShapeKey4, undefined);
    _defineProperty18(this, _inputShapeKey5, undefined);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/interface.js
var _defineProperty19 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputShapeKey5 = outputShapeKey;
var _parentShapeKey4 = parentShapeKey;

class InterfaceRef extends BaseTypeRef {
  constructor(name) {
    super("Interface", name);
    _defineProperty19(this, "kind", "Interface");
    _defineProperty19(this, _outputShapeKey5, undefined);
    _defineProperty19(this, _parentShapeKey4, undefined);
  }
}
class ImplementableInterfaceRef extends InterfaceRef {
  implement(options) {
    return this.builder.interfaceType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty19(this, "builder", undefined);
    this.builder = builder3;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/object.js
var _defineProperty20 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputShapeKey6 = outputShapeKey;
var _parentShapeKey5 = parentShapeKey;

class ObjectRef extends BaseTypeRef {
  constructor(name) {
    super("Object", name);
    _defineProperty20(this, "kind", "Object");
    _defineProperty20(this, _outputShapeKey6, undefined);
    _defineProperty20(this, _parentShapeKey5, undefined);
  }
}
class ImplementableObjectRef extends ObjectRef {
  implement(options) {
    return this.builder.objectType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty20(this, "builder", undefined);
    this.builder = builder3;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/union.js
var _defineProperty21 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _outputShapeKey7 = outputShapeKey;
var _parentShapeKey6 = parentShapeKey;

class UnionRef extends BaseTypeRef {
  constructor(name) {
    super("Union", name);
    _defineProperty21(this, "kind", "Union");
    _defineProperty21(this, _outputShapeKey7, undefined);
    _defineProperty21(this, _parentShapeKey6, undefined);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/builder.js
class SchemaBuilder {
  static registerPlugin(name, plugin3) {
    if (!this.allowPluginReRegistration && this.plugins[name]) {
      throw new PothosError(`Received multiple implementations for plugin ${name}`);
    }
    this.plugins[name] = plugin3;
  }
  objectType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    if (name === "Query" || name === "Mutation" || name === "Subscription") {
      throw new PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
    }
    const ref3 = param instanceof BaseTypeRef ? param : new ObjectRef(name);
    const config = {
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options.description,
      extensions: options.extensions,
      isTypeOf: options.isTypeOf,
      pothosOptions: options
    };
    this.configStore.addTypeConfig(config, ref3);
    if (options.interfaces) {
      this.configStore.addInterfaces(name, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref3, () => fields(new ObjectFieldBuilder(name, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref3, () => {
        const t2 = new ObjectFieldBuilder(name, this);
        return options.fields(t2);
      });
    }
    return ref3;
  }
  objectFields(ref3, fields) {
    verifyRef(ref3);
    this.configStore.onTypeConfig(ref3, ({ name }) => {
      this.configStore.addFields(ref3, () => fields(new ObjectFieldBuilder(name, this)));
    });
  }
  objectField(ref3, fieldName, field2) {
    verifyRef(ref3);
    this.configStore.onTypeConfig(ref3, ({ name }) => {
      this.configStore.addFields(ref3, () => ({
        [fieldName]: field2(new ObjectFieldBuilder(name, this))
      }));
    });
  }
  queryType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Query",
      graphqlKind: "Object",
      name: "Query",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    const ref3 = new ObjectRef("Query");
    this.configStore.addTypeConfig(config, ref3);
    if (fields) {
      this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
    }
    return ref3;
  }
  queryFields(fields) {
    this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
  }
  queryField(name, field2) {
    this.configStore.addFields("Query", () => ({
      [name]: field2(new QueryFieldBuilder(this))
    }));
  }
  mutationType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Mutation",
      graphqlKind: "Object",
      name: "Mutation",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields) {
      this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
    }
  }
  mutationFields(fields) {
    this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
  }
  mutationField(name, field2) {
    this.configStore.addFields("Mutation", () => ({
      [name]: field2(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Subscription",
      graphqlKind: "Object",
      name: "Subscription",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields) {
      this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
    }
  }
  subscriptionFields(fields) {
    this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field2) {
    this.configStore.addFields("Subscription", () => ({
      [name]: field2(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields) {
    return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
  }
  interfaceType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    const ref3 = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
    const typename = ref3.name;
    const config = {
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions,
      resolveType: options.resolveType
    };
    this.configStore.addTypeConfig(config, ref3);
    if (options.interfaces) {
      this.configStore.addInterfaces(typename, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref3, () => fields(new InterfaceFieldBuilder(typename, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref3, () => options.fields(new InterfaceFieldBuilder(typename, this)));
    }
    return ref3;
  }
  interfaceFields(ref3, fields) {
    verifyRef(ref3);
    this.configStore.onTypeConfig(ref3, ({ name }) => {
      this.configStore.addFields(ref3, () => fields(new InterfaceFieldBuilder(name, this)));
    });
  }
  interfaceField(ref3, fieldName, field2) {
    verifyRef(ref3);
    this.configStore.onTypeConfig(ref3, ({ name }) => {
      this.configStore.addFields(ref3, () => ({
        [fieldName]: field2(new InterfaceFieldBuilder(name, this))
      }));
    });
  }
  unionType(name, options) {
    const ref3 = new UnionRef(name);
    if (Array.isArray(options.types)) {
      options.types.forEach((type73) => {
        verifyRef(type73);
      });
    }
    const config = {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: [],
      description: options.description,
      resolveType: options.resolveType,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref3);
    this.configStore.addUnionTypes(name, options.types);
    return ref3;
  }
  enumType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options.name;
    const ref3 = new EnumRef(name);
    const values3 = typeof param === "object" ? valuesFromEnum(param, options === null || options === undefined ? undefined : options.values) : normalizeEnumValues(options.values);
    const config = {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values: values3,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref3);
    if (typeof param !== "string") {
      this.configStore.associateRefWithName(param, name);
    }
    return ref3;
  }
  scalarType(name, options) {
    const ref3 = new ScalarRef(name);
    const config = {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options.description,
      parseLiteral: options.parseLiteral,
      parseValue: options.parseValue,
      serialize: options.serialize,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref3);
    return ref3;
  }
  addScalarType(name, scalar3, options) {
    const config = scalar3.toConfig();
    return this.scalarType(name, {
      ...config,
      ...options,
      extensions: {
        ...config.extensions,
        ...options.extensions
      }
    });
  }
  inputType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref3 = typeof param === "string" ? new InputObjectRef(name) : param;
    const config = {
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref3);
    this.configStore.addFields(ref3, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
    return ref3;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(...args) {
    const [options = {}] = args;
    const { directives: directives11, extensions } = options;
    const scalars6 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars6.forEach((scalar3) => {
      if (!this.configStore.hasConfig(scalar3.name)) {
        this.addScalarType(scalar3.name, scalar3, {});
      }
    });
    const buildCache = new BuildCache(this, options);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const schema3 = new GraphQLSchema({
      query: buildCache.types.get("Query"),
      mutation: buildCache.types.get("Mutation"),
      subscription: buildCache.types.get("Subscription"),
      extensions: extensions !== null && extensions !== undefined ? extensions : {},
      directives: directives11,
      types: builtTypes
    });
    const processedSchema = buildCache.plugin.afterBuild(schema3);
    return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
  }
  constructor(options) {
    _defineProperty22(this, "configStore", undefined);
    _defineProperty22(this, "options", undefined);
    _defineProperty22(this, "defaultFieldNullability", undefined);
    _defineProperty22(this, "defaultInputFieldRequiredness", undefined);
    this.options = options;
    this.configStore = new ConfigStore;
    var _options_defaultFieldNullability;
    this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== undefined ? _options_defaultFieldNullability : false;
    var _options_defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== undefined ? _options_defaultInputFieldRequiredness : false;
  }
}
_defineProperty22(SchemaBuilder, "plugins", {});
_defineProperty22(SchemaBuilder, "allowPluginReRegistration", false);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;
var RootFieldBuilder2 = RootFieldBuilder;
var QueryFieldBuilder2 = QueryFieldBuilder;
var MutationFieldBuilder2 = MutationFieldBuilder;
var SubscriptionFieldBuilder2 = SubscriptionFieldBuilder;
var ObjectFieldBuilder2 = ObjectFieldBuilder;
var InterfaceFieldBuilder2 = InterfaceFieldBuilder;
var InputFieldBuilder2 = InputFieldBuilder;
var BaseTypeRef2 = BaseTypeRef;
var InputObjectRef3 = InputObjectRef;
var InterfaceRef2 = InterfaceRef;
var ObjectRef2 = ObjectRef;

// src/utils/prisma.ts
var client = __toESM(require_client2(), 1);

// src/env.ts
var envsToCheck = {
  NODE_ENV: [false, false],
  PORT: [false, false],
  DATABASE_URL: [true, true],
  ORIGIN: [true, false],
  PATH_TO_PLUGINS: [false, true]
};
var env = {};
console.log("\x1B[2mEnvironment variables:\x1B[0m");
for (const [envKey, [required4, sensitive]] of Object.entries(envsToCheck)) {
  const envValue = process.env[envKey];
  if (required4 && !envValue) {
    throw `\x1B[31mEnvironment variable ${envKey} is required but not set.\x1B[0m`;
  }
  if (sensitive) {
    console.log(`\x1B[2m  ${envKey}: ${envValue ? `***${envValue.slice(-15)}` : undefined}\x1B[0m`);
  } else {
    console.log(`\x1B[2m  ${envKey}: ${envValue}\x1B[0m`);
  }
  env[envKey] = envValue;
  delete process.env[envKey];
}

// src/pubsub.ts
var pubsub = createPubSub();

// src/utils/dayjs.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var customParseFormat = __toESM(require_customParseFormat(), 1);
var utc = __toESM(require_utc(), 1);
var timezone = __toESM(require_timezone(), 1);
import_dayjs.default.extend(customParseFormat.default);
import_dayjs.default.extend(utc.default);
import_dayjs.default.extend(timezone.default);
var dayjs = import_dayjs.default;

// src/utils/prisma.ts
var $prisma = new client.PrismaClient({
  datasources: {
    db: {
      url: env.DATABASE_URL
    }
  }
});
var withPubsub = (delegate, pub) => ({
  ...delegate,
  async create(args) {
    const res = await delegate.create(args);
    pub("Created", [res]);
    return res;
  },
  async createMany(args) {
    const now = dayjs().subtract(1, "second").toDate();
    const res = await delegate.createMany(args);
    const created = await delegate.findMany({ where: { createdAt: { gte: now } } });
    pub("Created", created);
    return res;
  },
  async update(args) {
    const res = await delegate.update(args);
    pub("Updated", [res]);
    return res;
  },
  async updateMany(args) {
    const now = dayjs().subtract(1, "second").toDate();
    const res = await delegate.updateMany(args);
    const updated = await delegate.findMany({ where: { updatedAt: { gte: now } } });
    pub("Updated", updated);
    return res;
  },
  async upsert(args) {
    const res = await delegate.upsert(args);
    if (dayjs(res.updatedAt).isSame(dayjs(res.createdAt))) {
      pub("Created", [res]);
    } else {
      pub("Updated", [res]);
    }
    return res;
  },
  async delete(args) {
    const res = await delegate.delete(args);
    pub("Deleted", [res]);
    return res;
  },
  async deleteMany(args) {
    const toBeDeleted = await delegate.findMany(args);
    const res = await delegate.deleteMany(args);
    pub("Deleted", toBeDeleted);
    return res;
  }
});
var prisma = {
  ...$prisma,
  task: withPubsub($prisma.task, (action, rows) => pubsub.publish(`tasks${action}`, rows)),
  item: withPubsub($prisma.item, (action, rows) => pubsub.publish(`items${action}`, rows)),
  async $transaction(fn, options) {
    const tasksCreated = [];
    const tasksUpdated = [];
    const tasksDeleted = [];
    const itemsCreated = [];
    const itemsUpdated = [];
    const itemsDeleted = [];
    if (typeof fn !== "function") {
      return $prisma.$transaction(fn, options);
    }
    const res = await $prisma.$transaction((tx) => {
      return fn({
        ...tx,
        task: withPubsub(tx.task, (action, rowsRaw) => {
          const rows = rowsRaw;
          switch (action) {
            case "Created":
              tasksCreated.push(...rows);
              break;
            case "Updated":
              tasksUpdated.push(...rows);
              break;
            case "Deleted":
              tasksDeleted.push(...rows);
              break;
          }
        }),
        item: withPubsub(tx.item, (action, rowsRaw) => {
          const rows = rowsRaw;
          switch (action) {
            case "Created":
              itemsCreated.push(...rows);
              break;
            case "Updated":
              itemsUpdated.push(...rows);
              break;
            case "Deleted":
              itemsDeleted.push(...rows);
              break;
          }
        })
      });
    }, options);
    if (tasksCreated.length)
      pubsub.publish("tasksCreated", tasksCreated);
    if (tasksUpdated.length)
      pubsub.publish("tasksUpdated", tasksUpdated);
    if (tasksDeleted.length)
      pubsub.publish("tasksDeleted", tasksDeleted);
    if (itemsCreated.length)
      pubsub.publish("itemsCreated", itemsCreated);
    if (itemsUpdated.length)
      pubsub.publish("itemsUpdated", itemsUpdated);
    if (itemsDeleted.length)
      pubsub.publish("itemsDeleted", itemsDeleted);
    return res;
  },
  $executeRaw: $prisma.$executeRaw,
  $executeRawUnsafe: (...args) => $prisma.$executeRawUnsafe(...args),
  $on: $prisma.$on,
  $use: $prisma.$use,
  $connect: $prisma.$connect,
  $disconnect: $prisma.$disconnect,
  $queryRaw: $prisma.$queryRaw,
  $queryRawUnsafe: $prisma.$queryRawUnsafe
};
// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/global-ids.js
function encodeGlobalID(typename, id) {
  return encodeBase64(`${typename}:${id}`);
}
function decodeGlobalID(globalID) {
  const [typename, id] = decodeBase64(globalID).split(":");
  if (!typename || !id) {
    throw new TypeError(`Invalid global ID: ${globalID}`);
  }
  return {
    typename,
    id
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/internal.js
function internalEncodeGlobalID(builder5, typename, id, ctx) {
  if (builder5.options.relayOptions.encodeGlobalID) {
    return builder5.options.relayOptions.encodeGlobalID(typename, id, ctx);
  }
  return encodeGlobalID(typename, id);
}
function internalDecodeGlobalID(builder5, globalID, ctx) {
  if (builder5.options.relayOptions.decodeGlobalID) {
    return builder5.options.relayOptions.decodeGlobalID(globalID, ctx);
  }
  return decodeGlobalID(globalID);
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/resolve-nodes.js
async function resolveNodes(builder5, context, info, globalIDs) {
  const requestCache = getRequestCache(context);
  const idsByType = {};
  const results = {};
  globalIDs.forEach((globalID, i) => {
    if (globalID == null) {
      return;
    }
    if (requestCache.has(globalID)) {
      results[globalID] = requestCache.get(globalID);
      return;
    }
    const { id, typename } = internalDecodeGlobalID(builder5, globalID, context);
    idsByType[typename] = idsByType[typename] || new Map;
    idsByType[typename].set(id, globalID);
  });
  await Promise.all(Object.keys(idsByType).map(async (typename) => {
    const ids = [
      ...idsByType[typename].keys()
    ];
    const globalIds = [
      ...idsByType[typename].values()
    ];
    const config = builder5.configStore.getTypeConfig(typename, "Object");
    const options = config.pothosOptions;
    var _brandLoadedObjects, ref3;
    const shouldBrandObjects = (ref3 = (_brandLoadedObjects = options.brandLoadedObjects) !== null && _brandLoadedObjects !== undefined ? _brandLoadedObjects : builder5.options.relayOptions.brandLoadedObjects) !== null && ref3 !== undefined ? ref3 : false;
    const resultsForType = await resolveUncachedNodesForType(builder5, context, info, ids, typename);
    resultsForType.forEach((val, i) => {
      if (shouldBrandObjects) {
        brandWithType(val, typename);
      }
      results[globalIds[i]] = val;
    });
  }));
  var _globalID;
  return globalIDs.map((globalID) => globalID == null ? null : (_globalID = results[globalID]) !== null && _globalID !== undefined ? _globalID : null);
}
async function resolveUncachedNodesForType(builder5, context, info, ids, type73) {
  const requestCache = getRequestCache(context);
  const config = builder5.configStore.getTypeConfig(type73, "Object");
  const options = config.pothosOptions;
  if (options.loadMany) {
    const loadManyPromise = Promise.resolve(options.loadMany(ids, context));
    return Promise.all(ids.map((id, i) => {
      const globalID = internalEncodeGlobalID(builder5, config.name, id, context);
      const entryPromise = loadManyPromise.then((results) => results[i]).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadOne) {
    return Promise.all(ids.map((id) => {
      const globalID = internalEncodeGlobalID(builder5, config.name, id, context);
      const entryPromise = Promise.resolve(options.loadOne(id, context)).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadManyWithoutCache) {
    return options.loadManyWithoutCache(ids, context);
  }
  if (options.loadWithoutCache) {
    return Promise.all(ids.map((id) => Promise.resolve(options.loadWithoutCache(id, context, info))));
  }
  throw new Error(`${config.name} does not support loading by id`);
}
var getRequestCache = createContextCache(() => new Map);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/index.js
function capitalize2(s2) {
  return `${s2.slice(0, 1).toUpperCase()}${s2.slice(1)}`;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/field-builder.js
var fieldBuilderProto = RootFieldBuilder2.prototype;
fieldBuilderProto.globalIDList = function globalIDList({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result) {
      return result;
    }
    assertArray(result);
    if (Array.isArray(result)) {
      return (await Promise.all(result)).map((item) => item == null || typeof item === "string" ? item : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context));
    }
    return null;
  };
  return this.field({
    ...options,
    type: [
      "ID"
    ],
    resolve: wrappedResolve
  });
};
fieldBuilderProto.globalID = function globalID({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result || typeof result === "string") {
      return result;
    }
    const item = result;
    return internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context);
  };
  return this.field({
    ...options,
    type: "ID",
    resolve: wrappedResolve
  });
};
fieldBuilderProto.node = function node({ id, ...options }) {
  return this.field({
    ...options,
    type: this.builder.nodeInterfaceRef(),
    nullable: true,
    resolve: async (parent, args, context, info) => {
      const rawID = await id(parent, args, context, info);
      if (rawID == null) {
        return null;
      }
      const globalID2 = typeof rawID === "string" ? rawID : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(rawID.type).name, String(rawID.id), context);
      return (await resolveNodes(this.builder, context, info, [
        globalID2
      ]))[0];
    }
  });
};
fieldBuilderProto.nodeList = function nodeList({ ids, ...options }) {
  return this.field({
    ...options,
    nullable: {
      list: false,
      items: true
    },
    type: [
      this.builder.nodeInterfaceRef()
    ],
    resolve: async (parent, args, context, info) => {
      const rawIDList = await ids(parent, args, context, info);
      assertArray(rawIDList);
      if (!Array.isArray(rawIDList)) {
        return [];
      }
      const rawIds = await Promise.all(rawIDList);
      const globalIds = rawIds.map((id) => !id || typeof id === "string" ? id : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(id.type).name, String(id.id), context));
      return resolveNodes(this.builder, context, info, globalIds);
    }
  });
};
fieldBuilderProto.connection = function connection({ type: type73, edgesNullable, nodeNullable, ...fieldOptions }, connectionOptionsOrRef = {}, edgeOptionsOrRef = {}) {
  var ref3;
  const connectionRef = connectionOptionsOrRef instanceof ObjectRef2 ? connectionOptionsOrRef : this.builder.objectRef("Unnamed connection");
  const fieldRef = this.field({
    ...(ref3 = this.builder.options.relayOptions) === null || ref3 === undefined ? undefined : ref3.defaultConnectionFieldOptions,
    ...fieldOptions,
    type: connectionRef,
    args: {
      ...fieldOptions.args,
      ...this.arg.connectionArgs()
    },
    resolve: fieldOptions.resolve
  });
  if (!(connectionOptionsOrRef instanceof ObjectRef2)) {
    this.builder.configStore.onFieldUse(fieldRef, (fieldConfig) => {
      var _name;
      const connectionName = (_name = connectionOptionsOrRef.name) !== null && _name !== undefined ? _name : `${this.typename}${capitalize2(fieldConfig.name)}${fieldConfig.name.toLowerCase().endsWith("connection") ? "" : "Connection"}`;
      this.builder.connectionObject({
        type: type73,
        edgesNullable,
        nodeNullable,
        ...connectionOptionsOrRef,
        name: connectionName
      }, edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : {
        name: `${connectionName}Edge`,
        ...edgeOptionsOrRef
      });
      this.builder.configStore.associateRefWithName(connectionRef, connectionName);
    });
  }
  return fieldRef;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/input-field-builder.js
var inputFieldBuilder = InputFieldBuilder2.prototype;
inputFieldBuilder.globalIDList = function globalIDList2(options = {}) {
  return this.idList({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.globalID = function globalID2(options = {}) {
  return this.id({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.connectionArgs = function connectionArgs() {
  const {
    cursorType = "ID",
    beforeArgOptions = {},
    afterArgOptions = {},
    firstArgOptions = {},
    lastArgOptions = {}
  } = this.builder.options.relayOptions;
  return {
    before: this.field({
      ...beforeArgOptions,
      type: cursorType,
      required: false
    }),
    after: this.field({
      ...afterArgOptions,
      type: cursorType,
      required: false
    }),
    first: this.int({
      ...firstArgOptions,
      required: false
    }),
    last: this.int({
      ...lastArgOptions,
      required: false
    })
  };
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/schema-builder.js
var schemaBuilderProto = esm_default.prototype;
var pageInfoRefMap = new WeakMap;
var nodeInterfaceRefMap = new WeakMap;
var connectionRefs = new WeakMap;
var globalConnectionFieldsMap = new WeakMap;
schemaBuilderProto.pageInfoRef = function pageInfoRef() {
  if (pageInfoRefMap.has(this)) {
    return pageInfoRefMap.get(this);
  }
  const ref3 = this.objectRef("PageInfo");
  pageInfoRefMap.set(this, ref3);
  const { cursorType = "String", hasNextPageFieldOptions = {}, hasPreviousPageFieldOptions = {}, startCursorFieldOptions = {}, endCursorFieldOptions = {} } = this.options.relayOptions;
  ref3.implement({
    ...this.options.relayOptions.pageInfoTypeOptions,
    fields: (t2) => ({
      hasNextPage: t2.exposeBoolean("hasNextPage", {
        nullable: false,
        ...hasNextPageFieldOptions
      }),
      hasPreviousPage: t2.exposeBoolean("hasPreviousPage", {
        nullable: false,
        ...hasPreviousPageFieldOptions
      }),
      startCursor: t2.expose("startCursor", {
        nullable: true,
        ...startCursorFieldOptions,
        type: cursorType
      }),
      endCursor: t2.expose("endCursor", {
        nullable: true,
        ...endCursorFieldOptions,
        type: cursorType
      })
    })
  });
  return ref3;
};
schemaBuilderProto.nodeInterfaceRef = function nodeInterfaceRef() {
  if (nodeInterfaceRefMap.has(this)) {
    return nodeInterfaceRefMap.get(this);
  }
  const ref3 = this.interfaceRef("Node");
  nodeInterfaceRefMap.set(this, ref3);
  var ref1;
  ref3.implement({
    resolveType: (value14, context, info, graphQLType) => {
      if (!value14) {
        return defaultTypeResolver(value14, context, info, graphQLType);
      }
      const typeBrand = getTypeBrand(value14);
      if (typeBrand) {
        const type73 = this.configStore.getTypeConfig(typeBrand);
        return type73.name;
      }
      try {
        if (typeof value14 === "object") {
          const typename = value14.__typename;
          if (typename) {
            return typename;
          }
          const nodeRef = value14.__type;
          if (nodeRef) {
            const config = this.configStore.getTypeConfig(nodeRef);
            if (config) {
              return config.name;
            }
          }
        }
      } catch {
      }
      return defaultTypeResolver(value14, context, info, graphQLType);
    },
    ...this.options.relayOptions.nodeTypeOptions,
    fields: (t2) => {
      var ref4;
      return {
        [(ref1 = (ref4 = this.options.relayOptions) === null || ref4 === undefined ? undefined : ref4.idFieldName) !== null && ref1 !== undefined ? ref1 : "id"]: t2.globalID({
          nullable: false,
          resolve: (parent) => {
            throw new Error("id field not implemented");
          }
        })
      };
    }
  });
  this.queryField("node", (t2) => t2.field({
    nullable: true,
    ...this.options.relayOptions.nodeQueryOptions,
    type: ref3,
    args: {
      id: t2.arg.id({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => (await resolveNodes(this, context, info, [
      String(args.id)
    ]))[0]
  }));
  this.queryField("nodes", (t2) => t2.field({
    nullable: {
      list: false,
      items: true
    },
    ...this.options.relayOptions.nodesQueryOptions,
    type: [
      ref3
    ],
    args: {
      ids: t2.arg.idList({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => await resolveNodes(this, context, info, args.ids)
  }));
  return ref3;
};
schemaBuilderProto.node = function node2(param, { interfaces, ...options }, fields) {
  verifyRef(param);
  const interfacesWithNode = [
    this.nodeInterfaceRef(),
    ...interfaces !== null && interfaces !== undefined ? interfaces : []
  ];
  let nodeName;
  var _isTypeOf;
  const ref3 = this.objectType(param, {
    ...options,
    isTypeOf: (_isTypeOf = options.isTypeOf) !== null && _isTypeOf !== undefined ? _isTypeOf : typeof param === "function" ? (maybeNode, context, info) => {
      if (!maybeNode) {
        return false;
      }
      if (maybeNode instanceof param) {
        return true;
      }
      const proto = Object.getPrototypeOf(maybeNode);
      try {
        if (proto === null || proto === undefined ? undefined : proto.constructor) {
          const config = this.configStore.getTypeConfig(proto.constructor);
          return config.name === nodeName;
        }
      } catch {
      }
      return false;
    } : undefined,
    interfaces: interfacesWithNode
  }, fields);
  this.configStore.onTypeConfig(ref3, (nodeConfig) => {
    nodeName = nodeConfig.name;
    var _idFieldName;
    this.objectField(ref3, (_idFieldName = this.options.relayOptions.idFieldName) !== null && _idFieldName !== undefined ? _idFieldName : "id", (t2) => t2.globalID({
      nullable: false,
      ...this.options.relayOptions.idFieldOptions,
      ...options.id,
      args: {},
      resolve: async (parent, args, context, info) => ({
        type: nodeConfig.name,
        id: await options.id.resolve(parent, args, context, info)
      })
    }));
  });
  return ref3;
};
schemaBuilderProto.globalConnectionField = function globalConnectionField(name, field2) {
  var ref3;
  const onRef = (ref4) => {
    this.objectField(ref4, name, field2);
  };
  (ref3 = connectionRefs.get(this)) === null || ref3 === undefined || ref3.forEach((ref4) => void onRef(ref4));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
schemaBuilderProto.globalConnectionFields = function globalConnectionFields(fields) {
  var ref3;
  const onRef = (ref4) => {
    this.objectFields(ref4, fields);
  };
  (ref3 = connectionRefs.get(this)) === null || ref3 === undefined || ref3.forEach((ref4) => void onRef(ref4));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
var mutationIdCache = createContextCache(() => new Map);
schemaBuilderProto.relayMutationField = function relayMutationField(fieldName, inputOptionsOrRef, { resolve, ...fieldOptions }, { name: payloadName = `${capitalize2(fieldName)}Payload`, outputFields, interfaces, ...paylaodOptions }) {
  var ref3;
  const { relayOptions: { clientMutationIdInputOptions = {}, clientMutationIdFieldOptions = {}, mutationInputArgOptions = {} } } = this.options;
  const includeClientMutationId = this.options.relayOptions.clientMutationId !== "omit";
  let inputRef;
  let argName = "input";
  if (inputOptionsOrRef instanceof InputObjectRef3) {
    inputRef = inputOptionsOrRef;
  } else {
    var ref1;
    const { name: inputName = `${capitalize2(fieldName)}Input`, argName: argNameFromOptions = "input", inputFields, ...inputOptions } = inputOptionsOrRef;
    argName = argNameFromOptions;
    inputRef = this.inputType(inputName, {
      ...(ref1 = this.options.relayOptions) === null || ref1 === undefined ? undefined : ref1.defaultMutationInputTypeOptions,
      ...inputOptions,
      fields: (t2) => ({
        ...inputFields(t2),
        ...includeClientMutationId ? {
          clientMutationId: t2.id({
            ...clientMutationIdInputOptions,
            required: this.options.relayOptions.clientMutationId !== "optional"
          })
        } : {}
      })
    });
  }
  const payloadRef = this.objectRef(payloadName).implement({
    ...(ref3 = this.options.relayOptions) === null || ref3 === undefined ? undefined : ref3.defaultPayloadTypeOptions,
    ...paylaodOptions,
    interfaces,
    fields: (t2) => ({
      ...outputFields(t2),
      ...includeClientMutationId ? {
        clientMutationId: t2.id({
          nullable: this.options.relayOptions.clientMutationId === "optional",
          ...clientMutationIdFieldOptions,
          resolve: (parent, args, context, info) => mutationIdCache(context).get(String(info.path.prev.key))
        })
      } : {}
    })
  });
  this.mutationField(fieldName, (t2) => t2.field({
    ...fieldOptions,
    type: payloadRef,
    args: {
      [argName]: t2.arg({
        ...mutationInputArgOptions,
        type: inputRef,
        required: true
      })
    },
    resolve: (root6, args, context, info) => {
      mutationIdCache(context).set(String(info.path.key), args[argName].clientMutationId);
      return resolve(root6, args, context, info);
    }
  }));
  return {
    inputType: inputRef,
    payloadType: payloadRef
  };
};
schemaBuilderProto.connectionObject = function connectionObject({ type: type73, name: connectionName, edgesNullable: edgesNullableField, nodeNullable, ...connectionOptions }, edgeOptionsOrRef) {
  var ref3, ref1;
  verifyRef(type73);
  const { edgesFieldOptions: { nullable: edgesNullable = {
    items: true,
    list: false
  }, ...edgesFieldOptions } = {}, pageInfoFieldOptions = {} } = this.options.relayOptions;
  const connectionRef = this.objectRef(connectionName);
  const edgeRef = edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : this.edgeObject({
    name: `${connectionName.replace(/Connection$/, "")}Edge`,
    ...edgeOptionsOrRef,
    nodeNullable,
    type: type73
  });
  const connectionFields = connectionOptions.fields;
  const { nodesOnConnection } = this.options.relayOptions;
  const edgesNullableOption = edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable;
  const edgeListNullable = typeof edgesNullableOption === "object" ? edgesNullableOption.list : !!edgesNullableOption;
  const edgeItemsNullable = typeof edgesNullableOption === "object" && ("items" in edgesNullableOption) ? edgesNullableOption.items : false;
  var ref22, ref32, ref4;
  this.objectType(connectionRef, {
    ...(ref3 = this.options.relayOptions) === null || ref3 === undefined ? undefined : ref3.defaultConnectionTypeOptions,
    ...connectionOptions,
    fields: (t2) => {
      var ref5, ref12;
      return {
        pageInfo: t2.field({
          nullable: false,
          ...pageInfoFieldOptions,
          type: this.pageInfoRef(),
          resolve: (parent) => parent.pageInfo
        }),
        edges: t2.field({
          nullable: edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable,
          ...edgesFieldOptions,
          type: [
            edgeRef
          ],
          resolve: (parent) => parent.edges
        }),
        ...nodesOnConnection ? {
          nodes: t2.field({
            ...typeof nodesOnConnection === "object" ? nodesOnConnection : {},
            type: [
              type73
            ],
            nullable: {
              list: edgeListNullable,
              items: (ref32 = (ref22 = edgeItemsNullable !== null && edgeItemsNullable !== undefined ? edgeItemsNullable : nodeNullable) !== null && ref22 !== undefined ? ref22 : (ref5 = this.options.relayOptions) === null || ref5 === undefined ? undefined : (ref12 = ref5.nodeFieldOptions) === null || ref12 === undefined ? undefined : ref12.nullable) !== null && ref32 !== undefined ? ref32 : false
            },
            resolve: (con) => {
              var ref6;
              return (ref4 = (ref6 = con.edges) === null || ref6 === undefined ? undefined : ref6.map((edge) => {
                return edge === null || edge === undefined ? undefined : edge.node;
              })) !== null && ref4 !== undefined ? ref4 : [];
            }
          })
        } : {},
        ...connectionFields === null || connectionFields === undefined ? undefined : connectionFields(t2)
      };
    }
  });
  if (!connectionRefs.has(this)) {
    connectionRefs.set(this, []);
  }
  connectionRefs.get(this).push(connectionRef);
  (ref1 = globalConnectionFieldsMap.get(this)) === null || ref1 === undefined || ref1.forEach((fieldFn) => void fieldFn(connectionRef));
  return connectionRef;
};
schemaBuilderProto.edgeObject = function edgeObject({ type: type73, name: edgeName, nodeNullable: nodeFieldNullable, ...edgeOptions }) {
  var ref3;
  verifyRef(type73);
  const { cursorType = "String", cursorFieldOptions = {}, nodeFieldOptions: { nullable: nodeNullable = false, ...nodeFieldOptions } = {} } = this.options.relayOptions;
  const edgeRef = this.objectRef(edgeName);
  const edgeFields = edgeOptions.fields;
  this.objectType(edgeRef, {
    ...(ref3 = this.options.relayOptions) === null || ref3 === undefined ? undefined : ref3.defaultEdgeTypeOptions,
    ...edgeOptions,
    fields: (t2) => {
      return {
        node: t2.field({
          nullable: nodeFieldNullable !== null && nodeFieldNullable !== undefined ? nodeFieldNullable : nodeNullable,
          ...nodeFieldOptions,
          type: type73,
          resolve: (parent) => parent.node
        }),
        cursor: t2.expose("cursor", {
          nullable: false,
          type: cursorType,
          ...cursorFieldOptions
        }),
        ...edgeFields === null || edgeFields === undefined ? undefined : edgeFields(t2)
      };
    }
  });
  return edgeRef;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/index.js
var pluginName = "relay";
var esm_default2 = pluginName;

class PothosRelayPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref3;
      if ((ref3 = inputField.extensions) === null || ref3 === undefined ? undefined : ref3.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => resolver(parent, argMapper(args, undefined, context), context, info);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref3;
      if ((ref3 = inputField.extensions) === null || ref3 === undefined ? undefined : ref3.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings || !subscribe3) {
      return subscribe3;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => subscribe3(parent, argMapper(args, undefined, context), context, info);
  }
}
esm_default.registerPlugin(pluginName, PothosRelayPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/interface-ref.js
var _define_property2 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/object-ref.js
var _define_property = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var prismaModelKey = Symbol.for("Pothos.prismaModelKey");
var _prismaModelKey = prismaModelKey;
var _abstractReturnShapeKey = abstractReturnShapeKey;

class PrismaObjectRef extends ObjectRef2 {
  addBrand(value14) {
    if (Array.isArray(value14)) {
      value14.forEach((val) => void brandWithType(val, this.name));
      return value14;
    }
    brandWithType(value14, this.name);
    return value14;
  }
  hasBrand(value14) {
    return typeof value14 === "object" && value14 !== null && (typeBrandKey in value14) && value14[typeBrandKey] === this.name;
  }
  constructor(name, modelName) {
    super(name);
    _define_property(this, _prismaModelKey, undefined);
    _define_property(this, _abstractReturnShapeKey, undefined);
    _define_property(this, "modelName", undefined);
    this.modelName = modelName;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/interface-ref.js
var _prismaModelKey2 = prismaModelKey;

class PrismaInterfaceRef extends InterfaceRef2 {
  constructor(name, modelName) {
    super(name);
    _define_property2(this, _prismaModelKey2, undefined);
    _define_property2(this, "modelName", undefined);
    this.modelName = modelName;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/model-loader.js
var _define_property3 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/get-client.js
function getClient(builder5, context) {
  if (typeof builder5.options.prisma.client === "function") {
    return prismaClientCache(builder5)(context);
  }
  return builder5.options.prisma.client;
}
function getDMMF(builder5) {
  var _client__baseDmmf;
  if (("dmmf" in builder5.options.prisma) && builder5.options.prisma.dmmf) {
    return builder5.options.prisma.dmmf.datamodel;
  }
  const client2 = builder5.options.prisma.client;
  var _client__runtimeDataModel, _ref;
  return (_ref = (_client__runtimeDataModel = client2._runtimeDataModel) !== null && _client__runtimeDataModel !== undefined ? _client__runtimeDataModel : (_client__baseDmmf = client2._baseDmmf) === null || _client__baseDmmf === undefined ? undefined : _client__baseDmmf.datamodel) !== null && _ref !== undefined ? _ref : client2._dmmf.datamodel;
}
var prismaClientCache = createContextCache((builder5) => createContextCache((context) => typeof builder5.options.prisma.client === "function" ? builder5.options.prisma.client(context) : builder5.options.prisma.client));

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/datamodel.js
function getRefFromModel(name, builder5, type73 = "object") {
  if (!refMap.has(builder5)) {
    refMap.set(builder5, new Map);
  }
  const cache = refMap.get(builder5);
  if (!cache.has(name)) {
    cache.set(name, type73 === "object" ? new PrismaObjectRef(name, name) : new PrismaInterfaceRef(name, name));
  }
  return cache.get(name);
}
function getRelation(name, builder5, relation) {
  const fieldData = getFieldData(name, builder5, relation);
  if (fieldData.kind !== "object") {
    throw new PothosSchemaError(`Field ${relation} of model '${name}' is not a relation (${fieldData.kind})`);
  }
  return fieldData;
}
function getFieldData(name, builder5, fieldName) {
  const modelData = getModel(name, builder5);
  const fieldData = modelData.fields.find((field2) => field2.name === fieldName);
  if (!fieldData) {
    throw new PothosSchemaError(`Field '${fieldName}' not found in model '${name}'`);
  }
  return fieldData;
}
function getModel(name, builder5) {
  const dmmf = getDMMF(builder5);
  const modelData = Array.isArray(dmmf.models) ? dmmf.models.find((model) => model.name === name) : dmmf.models[name];
  if (!modelData) {
    throw new PothosSchemaError(`Model '${name}' not found in DMMF`);
  }
  return modelData;
}
function getDelegateFromModel(client2, model) {
  const lowerCase = `${model.slice(0, 1).toLowerCase()}${model.slice(1)}`;
  const delegate = lowerCase in client2 ? client2[lowerCase] : null;
  if (!delegate) {
    throw new PothosSchemaError(`Unable to find delegate for model ${model}`);
  }
  return delegate;
}
var refMap = new WeakMap;
var findUniqueMap = new WeakMap;
var includeForRefMap = new WeakMap;

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/loader-map.js
function cacheKey(type73, path, subPath = []) {
  let key = "";
  let current = path;
  while (current) {
    if (typeof current.key === "string") {
      key = key ? `${current.key}.${key}` : current.key;
    }
    current = current.prev;
  }
  for (const entry of subPath) {
    key = `${key}.${entry}`;
  }
  return `${type73}@${key}`;
}
function setLoaderMappings(ctx, info, value14) {
  Object.keys(value14).forEach((field2) => {
    const map4 = cache(ctx);
    const mapping = value14[field2];
    const subPath = [
      ...mapping.indirectPath,
      field2
    ];
    const key = cacheKey(mapping.type, info.path, subPath);
    map4.set(key, mapping.mappings);
  });
}
function getLoaderMapping(ctx, path, type73) {
  const map4 = cache(ctx);
  const key = cacheKey(type73, path, []);
  var _map_get;
  return (_map_get = map4.get(key)) !== null && _map_get !== undefined ? _map_get : null;
}
var cache = createContextCache((ctx) => new Map);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/deep-equal.js
function deepEqual(left, right, ignore) {
  if (left === right) {
    return true;
  }
  if (left && right && typeof left === "object" && typeof right === "object") {
    var _left_valueOf, _right_valueOf;
    if (Array.isArray(left)) {
      if (!Array.isArray(right)) {
        return false;
      }
      const { length } = left;
      if (right.length !== length) {
        return false;
      }
      for (let i = 0;i < length; i += 1) {
        if (!deepEqual(left[i], right[i])) {
          return false;
        }
      }
      return true;
    }
    const lValue = (_left_valueOf = left.valueOf) === null || _left_valueOf === undefined ? undefined : _left_valueOf.call(left);
    const rValue = (_right_valueOf = right.valueOf) === null || _right_valueOf === undefined ? undefined : _right_valueOf.call(right);
    if ((lValue != null || rValue != null) && typeof lValue !== "object") {
      return lValue === rValue;
    }
    const keys = Object.keys(left);
    const keyLength = keys.length;
    if (keyLength !== Object.keys(right).length) {
      return false;
    }
    for (const key of keys) {
      if (ignore === null || ignore === undefined ? undefined : ignore.has(key)) {
        continue;
      }
      if (!deepEqual(left[key], right[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/selections.js
function selectionCompatible(state, selectionMap, ignoreQuery = false) {
  if (typeof selectionMap === "boolean") {
    return ignoreQuery || !selectionMap || Object.keys(state.query).length === 0;
  }
  const { select, include, ...query3 } = selectionMap;
  if (select && Object.keys(select).some((key) => compare(key, select[key]))) {
    return false;
  }
  if (include && Object.keys(include).some((key) => compare(key, include[key]))) {
    return false;
  }
  return ignoreQuery || deepEqual(state.query, query3);
  function compare(key, value14) {
    if (key === "_count") {
      const selections = value14 && value14.select;
      const keys = selections && Object.keys(selections);
      if (!keys || keys.length === 0) {
        return false;
      }
      return keys.some((k2) => state.counts.has(k2) && !deepEqual(state.counts.get(k2), selections[k2]));
    }
    return value14 && state.fieldMap.relations.has(key) && state.relations.has(key) && !selectionCompatible(state.relations.get(key), value14);
  }
}
function createState(fieldMap, mode, parent) {
  return {
    parent,
    mode,
    fieldMap,
    query: {},
    fields: new Set,
    counts: new Map,
    relations: new Map,
    mappings: {}
  };
}
function mergeSelection(state, { select, include, ...query3 }) {
  if (state.mode === "select" && !select) {
    state.mode = "include";
  }
  if (include) {
    Object.keys(include).forEach((key) => {
      merge2(key, include[key]);
    });
  }
  if (select) {
    Object.keys(select).forEach((key) => {
      merge2(key, select[key]);
    });
  }
  if (Object.keys(query3).length > 0) {
    state.query = query3;
  }
  function merge2(key, value14) {
    if (!value14) {
      return;
    }
    if (key === "_count") {
      var _value_select;
      const counts = (_value_select = value14.select) !== null && _value_select !== undefined ? _value_select : {};
      Object.keys(counts).forEach((count) => {
        state.counts.set(count, counts[count]);
      });
      return;
    }
    const selection = value14 === true ? {
      include: {}
    } : value14;
    const childMap = state.fieldMap.relations.get(key);
    if (childMap) {
      if (state.relations.has(key)) {
        mergeSelection(state.relations.get(key), selection);
      } else {
        const relatedState = createState(childMap, "select");
        mergeSelection(relatedState, selection);
        state.relations.set(key, relatedState);
      }
    } else {
      state.fields.add(key);
    }
  }
}
function selectionToQuery(state) {
  const nestedIncludes = {};
  const counts = {};
  let hasSelection = false;
  state.relations.forEach((sel, relation) => {
    hasSelection = true;
    const nested = selectionToQuery(sel);
    nestedIncludes[relation] = Object.keys(nested).length > 0 ? nested : true;
  });
  if (state.counts.size > 0) {
    hasSelection = true;
    for (const [count, selection] of state.counts) {
      counts[count] = selection;
    }
    nestedIncludes._count = {
      select: counts
    };
  }
  if (state.mode === "select") {
    state.fields.forEach((field2) => {
      hasSelection = true;
      nestedIncludes[field2] = true;
    });
    return {
      ...state.query,
      select: nestedIncludes
    };
  }
  return hasSelection ? {
    ...state.query,
    include: nestedIncludes
  } : state.query;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/usage.js
function wrapWithUsageCheck(obj) {
  const result = {};
  let used = true;
  Object.defineProperty(result, usageSymbol, {
    get() {
      return used;
    },
    set(value14) {
      used = value14;
    },
    enumerable: false
  });
  for (const key of Object.keys(obj)) {
    used = false;
    Object.defineProperty(result, key, {
      enumerable: true,
      configurable: true,
      get() {
        used = true;
        return obj[key];
      }
    });
  }
  return result;
}
function isUsed(obj) {
  return !(usageSymbol in obj) || obj[usageSymbol];
}
function extendWithUsage(original, extension) {
  if (!(usageSymbol in original)) {
    return {
      ...original,
      ...extension
    };
  }
  const result = {
    ...extension
  };
  for (const key of [
    usageSymbol,
    ...Object.keys(original)
  ]) {
    if (key in result) {
      continue;
    }
    Object.defineProperty(result, key, {
      enumerable: key !== usageSymbol,
      configurable: key !== usageSymbol,
      get() {
        return original[key];
      }
    });
  }
  return result;
}
var usageSymbol = Symbol.for("Pothos.isUsed");

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/map-query.js
var addTypeSelectionsForField = function(type73, context, info, state, selection, indirectPath) {
  if (selection.name.value.startsWith("__")) {
    return;
  }
  var _type_extensions;
  const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_type_extensions = type73.extensions) !== null && _type_extensions !== undefined ? _type_extensions : {};
  if (!!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.path) && pothosPrismaIndirectInclude.path.length > 0 || !!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.paths) && pothosPrismaIndirectInclude.paths.length === 0) {
    var _pothosPrismaIndirectInclude_paths;
    resolveIndirectIncludePaths(type73, info, selection, [], (_pothosPrismaIndirectInclude_paths = pothosPrismaIndirectInclude.paths) !== null && _pothosPrismaIndirectInclude_paths !== undefined ? _pothosPrismaIndirectInclude_paths : [
      pothosPrismaIndirectInclude.path
    ], indirectPath, (resolvedType, field2, path) => {
      addTypeSelectionsForField(resolvedType, context, info, state, field2, path);
    });
  } else if (pothosPrismaIndirectInclude) {
    addTypeSelectionsForField(info.schema.getType(pothosPrismaIndirectInclude.getType()), context, info, state, selection, indirectPath);
    return;
  }
  if (!(isObjectType(type73) || isInterfaceType(type73))) {
    return;
  }
  if (pothosPrismaModel && !pothosPrismaSelect) {
    state.mode = "include";
  }
  if (pothosPrismaInclude !== null && pothosPrismaInclude !== undefined ? pothosPrismaInclude : pothosPrismaSelect) {
    mergeSelection(state, {
      select: pothosPrismaSelect ? {
        ...pothosPrismaSelect
      } : undefined,
      include: pothosPrismaInclude ? {
        ...pothosPrismaInclude
      } : undefined
    });
  }
  if (selection.selectionSet) {
    addNestedSelections(type73, context, info, state, selection.selectionSet, indirectPath);
  }
};
var resolveIndirectIncludePaths = function(type73, info, selection, pathPrefix, includePaths, path, resolve) {
  for (const includePath of includePaths) {
    if (pathPrefix.length > 0) {
      resolveIndirectInclude(type73, info, selection, [
        ...pathPrefix,
        ...includePath
      ], path, resolve);
    } else {
      resolveIndirectInclude(type73, info, selection, includePath, path, resolve);
    }
  }
};
var resolveIndirectInclude = function(type73, info, selection, includePath, path, resolve, expectedType = type73) {
  if (includePath.length === 0) {
    resolve(type73, selection, path);
    return;
  }
  const [include, ...rest3] = includePath;
  if (!selection.selectionSet || !include) {
    return;
  }
  for (const sel of selection.selectionSet.selections) {
    switch (sel.kind) {
      case Kind2.FIELD:
        if (expectedType.name === type73.name && !fieldSkipped(info, sel) && sel.name.value === include.name && (isObjectType(type73) || isInterfaceType(type73))) {
          var _sel_alias;
          const returnType = getNamedType(type73.getFields()[sel.name.value].type);
          var _sel_alias_value;
          resolveIndirectInclude(returnType, info, sel, rest3, [
            ...path,
            (_sel_alias_value = (_sel_alias = sel.alias) === null || _sel_alias === undefined ? undefined : _sel_alias.value) !== null && _sel_alias_value !== undefined ? _sel_alias_value : sel.name.value
          ], resolve);
        }
        continue;
      case Kind2.FRAGMENT_SPREAD:
        resolveIndirectInclude(info.schema.getType(info.fragments[sel.name.value].typeCondition.name.value), info, info.fragments[sel.name.value], includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
        continue;
      case Kind2.INLINE_FRAGMENT:
        if (!sel.typeCondition || !include.type || sel.typeCondition.name.value === include.type) {
          resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type73, info, sel, includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
        }
        continue;
      default:
        throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
    }
  }
};
var addNestedSelections = function(type73, context, info, state, selections2, indirectPath, expectedType = type73) {
  let parentType = type73;
  for (const selection of selections2.selections) {
    switch (selection.kind) {
      case Kind2.FIELD:
        if (expectedType.name !== type73.name) {
          continue;
        }
        addFieldSelection(type73, context, info, state, selection, indirectPath);
        continue;
      case Kind2.FRAGMENT_SPREAD:
        var _parentType_extensions;
        parentType = info.schema.getType(info.fragments[selection.name.value].typeCondition.name.value);
        addNestedSelections(parentType, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath, ((_parentType_extensions = parentType.extensions) === null || _parentType_extensions === undefined ? undefined : _parentType_extensions.pothosPrismaModel) === type73.extensions.pothosPrismaModel ? parentType : expectedType);
        continue;
      case Kind2.INLINE_FRAGMENT:
        var _parentType_extensions1;
        parentType = selection.typeCondition ? info.schema.getType(selection.typeCondition.name.value) : type73;
        addNestedSelections(parentType, context, info, state, selection.selectionSet, indirectPath, ((_parentType_extensions1 = parentType.extensions) === null || _parentType_extensions1 === undefined ? undefined : _parentType_extensions1.pothosPrismaModel) === type73.extensions.pothosPrismaModel ? parentType : expectedType);
        continue;
      default:
        throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
    }
  }
};
var addFieldSelection = function(type73, context, info, state, selection, indirectPath) {
  var _field_extensions;
  if (selection.name.value.startsWith("__") || fieldSkipped(info, selection)) {
    return;
  }
  const field2 = type73.getFields()[selection.name.value];
  if (!field2) {
    throw new PothosValidationError(`Unknown field ${selection.name.value} on ${type73.name}`);
  }
  const fieldSelect = (_field_extensions = field2.extensions) === null || _field_extensions === undefined ? undefined : _field_extensions.pothosPrismaSelect;
  let fieldSelectionMap;
  let mappings = {};
  if (typeof fieldSelect === "function") {
    const args = getArgumentValues(field2, selection, info.variableValues);
    fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude) => {
      const returnType = getNamedType(field2.type);
      const query3 = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
      const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info)) : indirectInclude;
      const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
      if (typeof query3 === "object" && Object.keys(query3).length > 0) {
        mergeSelection(fieldState, {
          select: {},
          ...query3
        });
      }
      if (!!(normalizedIndirectInclude === null || normalizedIndirectInclude === undefined ? undefined : normalizedIndirectInclude.path) && normalizedIndirectInclude.path.length > 0 || !!(normalizedIndirectInclude === null || normalizedIndirectInclude === undefined ? undefined : normalizedIndirectInclude.paths) && normalizedIndirectInclude.paths.length > 0) {
        var _this, _returnType_extensions;
        var _path, _normalizedIndirectInclude_paths;
        resolveIndirectIncludePaths(returnType, info, selection, (_path = (_this = (_returnType_extensions = returnType.extensions) === null || _returnType_extensions === undefined ? undefined : _returnType_extensions.pothosPrismaIndirectInclude) === null || _this === undefined ? undefined : _this.path) !== null && _path !== undefined ? _path : [], (_normalizedIndirectInclude_paths = normalizedIndirectInclude.paths) !== null && _normalizedIndirectInclude_paths !== undefined ? _normalizedIndirectInclude_paths : [
          normalizedIndirectInclude.path
        ], [], (resolvedType, resolvedField, path) => {
          addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
        });
      }
      addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
      mappings = fieldState.mappings;
      return selectionToQuery(fieldState);
    }, (path) => {
      if (path.length === 0) {
        return selection;
      }
      const returnType = getNamedType(field2.type);
      let node3 = null;
      resolveIndirectInclude(returnType, info, selection, path.map((name) => ({
        name
      })), [], (_, resolvedField) => {
        node3 = resolvedField;
      });
      return node3;
    });
  } else {
    fieldSelectionMap = {
      select: fieldSelect
    };
  }
  if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
    var _selection_alias;
    mergeSelection(state, fieldSelectionMap);
    var _selection_alias_value;
    state.mappings[(_selection_alias_value = (_selection_alias = selection.alias) === null || _selection_alias === undefined ? undefined : _selection_alias.value) !== null && _selection_alias_value !== undefined ? _selection_alias_value : selection.name.value] = {
      field: selection.name.value,
      type: type73.name,
      mappings,
      indirectPath
    };
  }
};
function queryFromInfo({ context, info, typeName, select, path = [], paths = [], withUsageCheck = false }) {
  const returnType = getNamedType(info.returnType);
  const type73 = typeName ? info.schema.getTypeMap()[typeName] : returnType;
  let state;
  const initialSelection = select ? {
    select
  } : undefined;
  if (path.length > 0 || paths.length > 0) {
    var _returnType_extensions;
    const { pothosPrismaIndirectInclude } = (_returnType_extensions = returnType.extensions) !== null && _returnType_extensions !== undefined ? _returnType_extensions : {};
    var _pothosPrismaIndirectInclude_path;
    resolveIndirectInclude(returnType, info, info.fieldNodes[0], (_pothosPrismaIndirectInclude_path = pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.path) !== null && _pothosPrismaIndirectInclude_path !== undefined ? _pothosPrismaIndirectInclude_path : [], [], (indirectType, indirectField, subPath) => {
      resolveIndirectIncludePaths(indirectType, info, indirectField, [], paths.length > 0 ? paths.map((p2) => p2.map((n2) => typeof n2 === "string" ? {
        name: n2
      } : n2)) : [
        path.map((n2) => typeof n2 === "string" ? {
          name: n2
        } : n2)
      ], subPath, (resolvedType, resolvedField, nested) => {
        state = createStateForType(typeName ? type73 : resolvedType, info, undefined, initialSelection);
        addTypeSelectionsForField(typeName ? type73 : resolvedType, context, info, state, resolvedField, nested);
      });
    });
  } else {
    state = createStateForType(type73, info, undefined, initialSelection);
    addTypeSelectionsForField(type73, context, info, state, info.fieldNodes[0], []);
  }
  if (!state) {
    state = createStateForType(type73, info, undefined, initialSelection);
  }
  setLoaderMappings(context, info, state.mappings);
  const query3 = selectionToQuery(state);
  return withUsageCheck ? wrapWithUsageCheck(query3) : query3;
}
function selectionStateFromInfo(context, info, typeName) {
  const type73 = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
  const state = createStateForType(type73, info);
  if (!(isObjectType(type73) || isInterfaceType(type73))) {
    throw new PothosValidationError("Prisma plugin can only resolve includes for object and interface types");
  }
  addFieldSelection(type73, context, info, state, info.fieldNodes[0], []);
  return state;
}
var createStateForType = function(type73, info, parent, initialSelections) {
  var _targetType_extensions, _targetType_extensions1;
  const targetType = getIndirectType(type73, info);
  const fieldMap = (_targetType_extensions = targetType.extensions) === null || _targetType_extensions === undefined ? undefined : _targetType_extensions.pothosPrismaFieldMap;
  const state = createState(fieldMap, ((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === undefined ? undefined : _targetType_extensions1.pothosPrismaSelect) ? "select" : "include", parent);
  if (initialSelections) {
    mergeSelection(state, initialSelections);
  }
  return state;
};
function getIndirectType(type73, info) {
  var _targetType_extensions;
  let targetType = type73;
  while ((_targetType_extensions = targetType.extensions) === null || _targetType_extensions === undefined ? undefined : _targetType_extensions.pothosPrismaIndirectInclude) {
    var _targetType_extensions1;
    targetType = info.schema.getType(((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === undefined ? undefined : _targetType_extensions1.pothosPrismaIndirectInclude).getType());
  }
  return targetType;
}
var normalizeInclude = function(path, type73) {
  let currentType = type73;
  const normalized = [];
  if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
    throw new PothosValidationError(`Expected ${currentType} to be an Object type`);
  }
  for (const fieldName of path) {
    const field2 = currentType.getFields()[fieldName];
    if (!field2) {
      throw new PothosValidationError(`Expected ${currentType} to have a field ${fieldName}`);
    }
    currentType = getNamedType(field2.type);
    if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
      throw new PothosValidationError(`Expected ${currentType} to be an Object or Interface type`);
    }
    normalized.push({
      name: fieldName,
      type: currentType.name
    });
  }
  return {
    getType: () => normalized.length > 0 ? normalized[normalized.length - 1].type : type73.name,
    path: normalized
  };
};
var fieldSkipped = function(info, selection) {
  const skip = getDirectiveValues(GraphQLSkipDirective, selection, info.variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return true;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, selection, info.variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return true;
  }
  return false;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/model-loader.js
var createResolvablePromise = function() {
  let resolveFn;
  let rejectFn;
  const promise4 = new Promise((resolve, reject2) => {
    resolveFn = resolve;
    rejectFn = reject2;
  });
  return {
    promise: promise4,
    resolve: resolveFn,
    reject: rejectFn
  };
};

class ModelLoader {
  static forRef(ref3, modelName, findUnique, builder5) {
    return createContextCache((model) => new ModelLoader(model, builder5, modelName, findUnique === null ? () => {
      throw new PothosSchemaError(`Missing findUnique for ${ref3.name}`);
    } : findUnique !== null && findUnique !== undefined ? findUnique : this.getDefaultFindUnique(ref3, modelName, builder5)));
  }
  static getFindUnique(findBy) {
    if (typeof findBy === "string") {
      return (parent) => ({
        [findBy]: parent[findBy]
      });
    }
    const { fields, name: primaryKeyName } = findBy;
    return (parent) => {
      const primaryKey = {};
      for (const key of fields) {
        primaryKey[key] = parent[key];
      }
      return {
        [primaryKeyName !== null && primaryKeyName !== undefined ? primaryKeyName : fields.join("_")]: primaryKey
      };
    };
  }
  static getDefaultFindBy(ref3, modelName, builder5) {
    const model = getModel(modelName, builder5);
    const idField = model.fields.find((field2) => field2.isId);
    const uniqueField = model.fields.find((field2) => field2.isRequired && field2.isUnique);
    const uniqueIndex = model.uniqueIndexes.find((idx) => idx.fields.every((field2) => {
      var _model_fields_find;
      return (_model_fields_find = model.fields.find((f) => f.name === field2)) === null || _model_fields_find === undefined ? undefined : _model_fields_find.isRequired;
    }));
    let findBy;
    if (model.primaryKey) {
      findBy = model.primaryKey;
    } else if (idField) {
      findBy = idField.name;
    } else if (uniqueField) {
      findBy = uniqueField.name;
    } else if (uniqueIndex) {
      findBy = uniqueIndex;
    }
    if (!findBy) {
      throw new PothosSchemaError(`Missing findUnique for ${ref3.name}`);
    }
    return findBy;
  }
  static getDefaultFindUnique(ref3, modelName, builder5) {
    const findBy = this.getDefaultFindBy(ref3, modelName, builder5);
    return this.getFindUnique(findBy);
  }
  static getDefaultIDSelection(ref3, modelName, builder5) {
    const findBy = this.getDefaultFindBy(ref3, modelName, builder5);
    if (typeof findBy === "string") {
      return {
        [findBy]: true
      };
    }
    const result = {};
    for (const field2 of findBy.fields) {
      result[field2] = true;
    }
    return result;
  }
  static getCursorSelection(ref3, modelName, cursor, builder5) {
    const model = getModel(modelName, builder5);
    const field2 = model.fields.find((field3) => field3.name === cursor);
    if (field2) {
      return {
        [field2.name]: true
      };
    }
    const index = [
      model.primaryKey,
      ...model.uniqueIndexes
    ].filter(Boolean).find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
    });
    if (!index) {
      throw new PothosSchemaError(`Can't find "${cursor}" field or index for ${ref3.name}`);
    }
    const selection = {};
    for (const column of index.fields) {
      selection[column] = true;
    }
    return selection;
  }
  static getFindUniqueForField(ref3, modelName, fieldName, builder5) {
    var _model_primaryKey, _model_primaryKey1;
    const model = getModel(modelName, builder5);
    const uniqueIndex = model.uniqueIndexes.find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
    });
    let findBy;
    var _model_primaryKey_name;
    if (model.fields.some((field2) => field2.name === fieldName)) {
      findBy = fieldName;
    } else if (model.primaryKey && ((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
      findBy = model.primaryKey;
    } else if (uniqueIndex) {
      findBy = uniqueIndex;
    }
    if (!findBy) {
      throw new PothosSchemaError(`Unable to find field or index for ${fieldName} of ${ref3.name}`);
    }
    return this.getFindUnique(findBy);
  }
  getSelection(info) {
    const key = cacheKey(info.parentType.name, info.path);
    if (!this.queryCache.has(key)) {
      const selection = selectionStateFromInfo(this.context, info);
      this.queryCache.set(key, {
        selection,
        query: selectionToQuery(selection)
      });
    }
    return this.queryCache.get(key);
  }
  async loadSelection(info, model) {
    const { selection, query: query3 } = this.getSelection(info);
    const result = await this.stageQuery(selection, query3, model);
    if (result) {
      const mappings = selection.mappings[info.path.key];
      if (mappings) {
        setLoaderMappings(this.context, info, mappings.mappings);
      }
    }
    return result;
  }
  async stageQuery(selection, query3, model) {
    for (const entry of this.staged) {
      if (selectionCompatible(entry.state, query3)) {
        mergeSelection(entry.state, query3);
        if (!entry.models.has(model)) {
          entry.models.set(model, createResolvablePromise());
        }
        return entry.models.get(model).promise;
      }
    }
    return this.initLoad(selection, model);
  }
  async initLoad(state, initialModel) {
    const models = new Map;
    const promise4 = createResolvablePromise();
    models.set(initialModel, promise4);
    const entry = {
      models,
      state
    };
    this.staged.add(entry);
    const nextTick = createResolvablePromise();
    this.tick.then(() => {
      this.staged.delete(entry);
      for (const [model, { resolve, reject: reject2 }] of entry.models) {
        if (this.delegate.findUniqueOrThrow) {
          this.delegate.findUniqueOrThrow({
            ...selectionToQuery(state),
            where: {
              ...this.findUnique(model, this.context)
            }
          }).then(resolve, reject2);
        } else {
          this.delegate.findUnique({
            rejectOnNotFound: true,
            ...selectionToQuery(state),
            where: {
              ...this.findUnique(model, this.context)
            }
          }).then(resolve, reject2);
        }
      }
    });
    setTimeout(() => void nextTick.resolve(), 0);
    this.tick = nextTick.promise;
    return promise4.promise;
  }
  constructor(context, builder5, modelName, findUnique) {
    _define_property3(this, "context", undefined);
    _define_property3(this, "builder", undefined);
    _define_property3(this, "findUnique", undefined);
    _define_property3(this, "modelName", undefined);
    _define_property3(this, "queryCache", new Map);
    _define_property3(this, "staged", new Set);
    _define_property3(this, "delegate", undefined);
    _define_property3(this, "tick", Promise.resolve());
    this.context = context;
    this.builder = builder5;
    this.findUnique = findUnique;
    this.modelName = modelName;
    this.delegate = getDelegateFromModel(getClient(this.builder, this.context), this.modelName);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/node-ref.js
class PrismaNodeRef extends PrismaObjectRef {
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var _define_property4 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/cursors.js
function formatCursorChunk(value14) {
  if (value14 instanceof Date) {
    return `D:${String(Number(value14))}`;
  }
  switch (typeof value14) {
    case "number":
      return `N:${value14}`;
    case "string":
      return `S:${value14}`;
    case "bigint":
      return `I:${value14}`;
    default:
      throw new PothosValidationError(`Unsupported cursor type ${typeof value14}`);
  }
}
function cursorFormatter(fields) {
  return (value14) => {
    if (typeof fields === "string") {
      return encodeBase64(`GPC:${formatCursorChunk(value14[fields])}`);
    }
    return encodeBase64(`GPC:J:${JSON.stringify(fields.map((name) => value14[name]))}`);
  };
}
function parsePrismaCursor(cursor) {
  if (typeof cursor !== "string") {
    throw new PothosValidationError("Cursor must be a string");
  }
  try {
    const decoded = decodeBase64(cursor);
    const [, type73, value14] = decoded.match(/^GPC:(\w):(.*)/);
    switch (type73) {
      case "S":
        return value14;
      case "N":
        return Number.parseInt(value14, 10);
      case "D":
        return new Date(Number.parseInt(value14, 10));
      case "J":
        return JSON.parse(value14);
      case "I":
        return BigInt(value14);
      default:
        throw new PothosValidationError(`Invalid cursor type ${type73}`);
    }
  } catch {
    throw new PothosValidationError(`Invalid cursor: ${cursor}`);
  }
}
function parseID(id, dataType) {
  if (!id) {
    return id;
  }
  switch (dataType) {
    case "String":
      return id;
    case "Int":
      return Number.parseInt(id, 10);
    case "BigInt":
      return BigInt(id);
    case "Boolean":
      return id !== "false";
    case "Float":
    case "Decimal":
      return Number.parseFloat(id);
    case "DateTime":
      return new Date(id);
    case "Json":
      return JSON.parse(id);
    case "Byte":
      return Buffer.from(id, "base64");
    default:
      return id;
  }
}
function getDefaultIDSerializer(modelName, fieldName, builder5) {
  var _model_primaryKey, _model_primaryKey1;
  const model = getModel(modelName, builder5);
  const field2 = model.fields.find((f) => f.name === fieldName);
  if (field2) {
    return (parent) => serializeID(parent[fieldName], field2.type);
  }
  var _model_primaryKey_name;
  if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
    const fields = model.primaryKey.fields.map((n2) => model.fields.find((f) => f.name === n2));
    return (parent) => JSON.stringify(fields.map((f) => serializeID(parent[f.name], f.kind)));
  }
  const index = model.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
  });
  if (index) {
    const fields = index.fields.map((n2) => model.fields.find((f) => f.name === n2));
    return (parent) => JSON.stringify(fields.map((f) => serializeID(parent[f.name], f.kind)));
  }
  throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
}
function getDefaultIDParser(modelName, fieldName, builder5) {
  var _model_primaryKey, _model_primaryKey1;
  if (!fieldName) {
    throw new PothosValidationError("Missing field name");
  }
  const model = getModel(modelName, builder5);
  const field2 = model.fields.find((f) => f.name === fieldName);
  if (field2) {
    return (id) => parseID(id, field2.type);
  }
  const index = model.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
  });
  let fields;
  var _model_primaryKey_name;
  if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
    fields = model.primaryKey.fields.map((n2) => model.fields.find((f) => f.name === n2));
  } else if (index) {
    fields = index.fields.map((n2) => model.fields.find((f) => f.name === n2));
  }
  if (!fields) {
    throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
  }
  return (id) => {
    const parts = JSON.parse(id);
    if (!Array.isArray(parts)) {
      throw new PothosValidationError(`Invalid id received for ${fieldName} of ${modelName}`);
    }
    const result = {};
    for (let i = 0;i < fields.length; i += 1) {
      result[fields[i].name] = parseID(parts[i], fields[i].type);
    }
    return result;
  };
}
function serializeID(id, dataType) {
  switch (dataType) {
    case "Json":
      return JSON.stringify(id);
    case "Byte":
      return id.toString("base64");
    default:
      return String(id);
  }
}
function parseCompositeCursor(fields) {
  return (cursor) => {
    const parsed = parsePrismaCursor(cursor);
    if (!Array.isArray(parsed)) {
      throw new PothosValidationError(`Expected compound cursor to contain an array, but got ${parsed}`);
    }
    const record3 = {};
    fields.forEach((field2, i) => {
      record3[field2] = parsed[i];
    });
    return record3;
  };
}
function prismaCursorConnectionQuery({ args, ctx, maxSize = DEFAULT_MAX_SIZE, defaultSize = DEFAULT_SIZE, parseCursor }) {
  const { before, after, first, last } = args;
  if (first != null && first < 0) {
    throw new PothosValidationError("Argument \"first\" must be a non-negative integer");
  }
  if (last != null && last < 0) {
    throw new PothosValidationError("Argument \"last\" must be a non-negative integer");
  }
  if (before && after) {
    throw new PothosValidationError("Arguments \"before\" and \"after\" are not supported at the same time");
  }
  if (before != null && first != null) {
    throw new PothosValidationError("Arguments \"before\" and \"first\" are not supported at the same time");
  }
  if (after != null && last != null) {
    throw new PothosValidationError("Arguments \"after\" and \"last\" are not supported at the same time");
  }
  const cursor = before !== null && before !== undefined ? before : after;
  const maxSizeForConnection = typeof maxSize === "function" ? maxSize(args, ctx) : maxSize;
  const defaultSizeForConnection = typeof defaultSize === "function" ? defaultSize(args, ctx) : defaultSize;
  var _ref;
  let take = Math.min((_ref = first !== null && first !== undefined ? first : last) !== null && _ref !== undefined ? _ref : defaultSizeForConnection, maxSizeForConnection) + 1;
  if (before || last) {
    take = -take;
  }
  return cursor == null ? {
    take,
    skip: 0
  } : {
    cursor: parseCursor(cursor),
    take,
    skip: 1
  };
}
function wrapConnectionResult(parent, results, args, take, cursor, totalCount, resolveNode) {
  var _edges_, _edges_1;
  const gotFullResults = results.length === Math.abs(take);
  const hasNextPage = args.before ? true : args.last ? false : gotFullResults;
  const hasPreviousPage = args.after ? true : args.before || args.last ? gotFullResults : false;
  const nodes = gotFullResults ? results.slice(take < 0 ? 1 : 0, take < 0 ? results.length : -1) : results;
  const connection2 = {
    parent,
    args,
    totalCount,
    edges: [],
    pageInfo: {
      startCursor: null,
      endCursor: null,
      hasPreviousPage,
      hasNextPage
    }
  };
  const edges = nodes.map((value14, index) => value14 == null ? null : resolveNode ? {
    connection: connection2,
    ...value14,
    cursor: cursor(value14),
    node: resolveNode(value14)
  } : {
    connection: connection2,
    cursor: cursor(value14),
    node: value14
  });
  connection2.edges = edges;
  var _edges__cursor;
  connection2.pageInfo.startCursor = (_edges__cursor = (_edges_ = edges[0]) === null || _edges_ === undefined ? undefined : _edges_.cursor) !== null && _edges__cursor !== undefined ? _edges__cursor : null;
  var _edges__cursor1;
  connection2.pageInfo.endCursor = (_edges__cursor1 = (_edges_1 = edges[edges.length - 1]) === null || _edges_1 === undefined ? undefined : _edges_1.cursor) !== null && _edges__cursor1 !== undefined ? _edges__cursor1 : null;
  return connection2;
}
async function resolvePrismaCursorConnection(options, cursor, resolve) {
  const query3 = prismaCursorConnectionQuery(options);
  const results = await resolve(extendWithUsage(options.query, query3));
  if (!results) {
    return results;
  }
  return wrapConnectionResult(options.parent, results, options.args, query3.take, cursor, options.totalCount);
}
function getCursorFormatter(name, builder5, cursor) {
  var _modelData_primaryKey, _modelData_primaryKey1;
  const modelData = getModel(name, builder5);
  var _modelData_primaryKey_name;
  const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === undefined ? undefined : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== undefined ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === undefined ? undefined : _modelData_primaryKey1.fields.join("_");
  if (primaryKey === cursor) {
    return cursorFormatter(modelData.primaryKey.fields);
  }
  const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
  });
  var _uniqueIndex_fields;
  return cursorFormatter((_uniqueIndex_fields = uniqueIndex === null || uniqueIndex === undefined ? undefined : uniqueIndex.fields) !== null && _uniqueIndex_fields !== undefined ? _uniqueIndex_fields : cursor);
}
function getCursorParser(name, builder5, cursor) {
  var _modelData_primaryKey, _modelData_primaryKey1;
  const modelData = getModel(name, builder5);
  var _modelData_primaryKey_name;
  const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === undefined ? undefined : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== undefined ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === undefined ? undefined : _modelData_primaryKey1.fields.join("_");
  let parser = parsePrismaCursor;
  if (primaryKey === cursor) {
    parser = parseCompositeCursor(modelData.primaryKey.fields);
  } else {
    const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
    });
    if (uniqueIndex) {
      parser = parseCompositeCursor(uniqueIndex.fields);
    }
  }
  return (rawCursor) => ({
    [cursor]: parser(rawCursor)
  });
}
var DEFAULT_MAX_SIZE = 100;
var DEFAULT_SIZE = 20;

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/description.js
function getFieldDescription(model, builder5, fieldName, description) {
  const { exposeDescriptions } = builder5.options.prisma;
  const usePrismaDescription = exposeDescriptions === true || typeof exposeDescriptions === "object" && (exposeDescriptions === null || exposeDescriptions === undefined ? undefined : exposeDescriptions.fields) === true;
  return (usePrismaDescription ? description !== null && description !== undefined ? description : getFieldData(model, builder5, fieldName).documentation : description) || undefined;
}
function getModelDescription(model, builder5, description) {
  const { exposeDescriptions } = builder5.options.prisma;
  const usePrismaDescription = exposeDescriptions === true || typeof exposeDescriptions === "object" && (exposeDescriptions === null || exposeDescriptions === undefined ? undefined : exposeDescriptions.models) === true;
  return (usePrismaDescription ? description !== null && description !== undefined ? description : getModel(model, builder5).documentation : description) || undefined;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var addScopes = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var withAuth = function(scopes) {
  return addScopes(scopes, new PrismaObjectFieldBuilder(this.typename, this.builder, this.model, this.prismaFieldMap));
};
var RootBuilder = RootFieldBuilder2;

class PrismaObjectFieldBuilder extends RootBuilder {
  relation(name, ...allArgs) {
    const [{ description: description2, ...options } = {}] = allArgs;
    const relationField = getRelation(this.model, this.builder, name);
    var _options_type;
    const ref3 = (_options_type = options.type) !== null && _options_type !== undefined ? _options_type : getRefFromModel(relationField.type, this.builder);
    const { query: query3 = {}, resolve, extensions, ...rest3 } = options;
    const relationSelect = (args, context, nestedQuery) => ({
      select: {
        [name]: nestedQuery(query3)
      }
    });
    return this.field({
      ...rest3,
      type: relationField.isList ? [
        ref3
      ] : ref3,
      description: getFieldDescription(this.model, this.builder, name, description2),
      extensions: {
        ...extensions,
        pothosPrismaSelect: relationSelect,
        pothosPrismaLoaded: (value14) => value14[name] !== undefined,
        pothosPrismaFallback: resolve && ((q, parent, args, context, info) => resolve({
          ...q,
          ...typeof query3 === "function" ? query3(args, context) : query3
        }, parent, args, context, info))
      },
      resolve: (parent) => parent[name]
    });
  }
  relationCount(name, ...allArgs) {
    const [{ where, ...options } = {}] = allArgs;
    const { resolve, ...rest3 } = options;
    const countSelect = typeof where === "function" ? (args, context) => ({
      _count: {
        select: {
          [name]: {
            where: where(args, context)
          }
        }
      }
    }) : {
      _count: {
        select: {
          [name]: where ? {
            where
          } : true
        }
      }
    };
    return this.field({
      ...rest3,
      type: "Int",
      nullable: false,
      select: countSelect,
      resolve: (parent, args, context, info) => {
        var _parent__count;
        return (_parent__count = parent._count) === null || _parent__count === undefined ? undefined : _parent__count[name];
      }
    });
  }
  variant(variant, ...allArgs) {
    const [{ isNull, nullable, ...options } = {}] = allArgs;
    const ref3 = typeof variant === "string" ? getRefFromModel(variant, this.builder) : variant;
    const selfSelect = (args, context, nestedQuery) => nestedQuery({});
    return this.field({
      ...options,
      type: ref3,
      extensions: {
        ...options === null || options === undefined ? undefined : options.extensions,
        pothosPrismaSelect: selfSelect
      },
      nullable: nullable !== null && nullable !== undefined ? nullable : !!isNull,
      resolve: isNull ? (parent, args, context, info) => {
        const parentIsNull = isNull(parent, args, context, info);
        if (parentIsNull) {
          if (isThenable(parentIsNull)) {
            return parentIsNull.then((resolved) => resolved ? null : parent);
          }
          return null;
        }
        return parent;
      } : (parent) => parent
    });
  }
  expose(name, ...args) {
    var _typeConfig_extensions;
    const [options = {}] = args;
    const typeConfig = this.builder.configStore.getTypeConfig(this.typename);
    const usingSelect = !!((_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === undefined ? undefined : _typeConfig_extensions.pothosPrismaSelect);
    return this.exposeField(name, {
      ...options,
      description: getFieldDescription(this.model, this.builder, name, options.description),
      extensions: {
        ...options.extensions,
        pothosPrismaVariant: name,
        pothosPrismaSelect: usingSelect && {
          [name]: true
        }
      }
    });
  }
  createExpose(type73) {
    return (name, ...args) => {
      const [options = {}] = args;
      return this.expose(name, {
        ...options,
        type: type73
      });
    };
  }
  constructor(name, builder5, model, fieldMap, graphqlKind = "Object") {
    super(name, builder5, "PrismaObject", graphqlKind);
    _define_property4(this, "model", undefined);
    _define_property4(this, "prismaFieldMap", undefined);
    _define_property4(this, "exposeBoolean", this.createExpose("Boolean"));
    _define_property4(this, "exposeFloat", this.createExpose("Float"));
    _define_property4(this, "exposeInt", this.createExpose("Int"));
    _define_property4(this, "exposeID", this.createExpose("ID"));
    _define_property4(this, "exposeString", this.createExpose("String"));
    _define_property4(this, "exposeBooleanList", this.createExpose([
      "Boolean"
    ]));
    _define_property4(this, "exposeFloatList", this.createExpose([
      "Float"
    ]));
    _define_property4(this, "exposeIntList", this.createExpose([
      "Int"
    ]));
    _define_property4(this, "exposeIDList", this.createExpose([
      "ID"
    ]));
    _define_property4(this, "exposeStringList", this.createExpose([
      "String"
    ]));
    _define_property4(this, "withAuth", withAuth);
    _define_property4(this, "relatedConnection", function relatedConnection(name2, { maxSize, defaultSize, cursor: cursorValue, query: query3, resolve, extensions, totalCount, description: description2, ...options }, connectionOptions = {}, edgeOptions = {}) {
      const relationField = getRelation(this.model, this.builder, name2);
      var _options_type;
      const ref3 = (_options_type = options.type) !== null && _options_type !== undefined ? _options_type : getRefFromModel(relationField.type, this.builder);
      let typeName;
      const formatCursor = getCursorFormatter(relationField.type, this.builder, cursorValue);
      const parseCursor = getCursorParser(relationField.type, this.builder, cursorValue);
      const getQuery = (args, ctx) => {
        const connectionQuery = prismaCursorConnectionQuery({
          parseCursor,
          ctx,
          maxSize,
          defaultSize,
          args
        });
        var _ref;
        const { take = connectionQuery.take, skip = connectionQuery.skip, cursor = connectionQuery.cursor, ...fieldQuery } = (_ref = typeof query3 === "function" ? query3(args, ctx) : query3) !== null && _ref !== undefined ? _ref : {};
        return {
          ...fieldQuery,
          ...connectionQuery,
          take,
          skip,
          ...cursor ? {
            cursor
          } : {}
        };
      };
      const cursorSelection = ModelLoader.getCursorSelection(ref3, relationField.type, cursorValue, this.builder);
      const relationSelect = (args, context, nestedQuery, getSelection) => {
        var _selection_selectionSet;
        typeName !== null && typeName !== undefined || (typeName = this.builder.configStore.getTypeConfig(ref3).name);
        const nested = nestedQuery(getQuery(args, context), {
          getType: () => typeName,
          paths: [
            [
              {
                name: "nodes"
              }
            ],
            [
              {
                name: "edges"
              },
              {
                name: "node"
              }
            ]
          ]
        });
        const selection = getSelection([]);
        const hasTotalCount = totalCount && !!getSelection([
          "totalCount"
        ]);
        const totalCountOnly = ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && hasTotalCount;
        const countSelect = this.builder.options.prisma.filterConnectionTotalCount ? nested.where ? {
          where: nested.where
        } : true : true;
        return {
          select: {
            ...hasTotalCount ? {
              _count: {
                select: {
                  [name2]: countSelect
                }
              }
            } : {},
            [name2]: totalCountOnly ? undefined : (nested === null || nested === undefined ? undefined : nested.select) ? {
              ...nested,
              select: {
                ...cursorSelection,
                ...nested.select
              }
            } : nested
          }
        };
      };
      const fieldRef = this.connection({
        ...options,
        description: getFieldDescription(this.model, this.builder, name2, description2),
        extensions: {
          ...extensions,
          pothosPrismaSelect: relationSelect,
          pothosPrismaLoaded: (value14, info) => {
            const returnType = getNamedType(info.returnType);
            const fields = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
            const selections3 = info.fieldNodes;
            const totalCountOnly = selections3.every((selection) => {
              var _selection_selectionSet;
              return ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && selection.selectionSet.selections.every((s2) => {
                var _fields_s_name_value_extensions, _fields_s_name_value;
                return s2.kind === Kind2.FIELD && ((_fields_s_name_value = fields[s2.name.value]) === null || _fields_s_name_value === undefined ? undefined : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === undefined ? undefined : _fields_s_name_value_extensions.pothosPrismaTotalCount);
              });
            });
            return totalCountOnly || value14[name2] !== undefined;
          },
          pothosPrismaFallback: resolve && ((q, parent, args, context, info) => Promise.resolve(resolve({
            ...q,
            ...getQuery(args, context)
          }, parent, args, context, info)).then((result) => wrapConnectionResult(parent, result, args, q.take, formatCursor)))
        },
        type: ref3,
        resolve: (parent, args, context) => {
          var _parent__count;
          const connectionQuery = getQuery(args, context);
          var _parent_name;
          return wrapConnectionResult(parent, (_parent_name = parent[name2]) !== null && _parent_name !== undefined ? _parent_name : [], args, connectionQuery.take, formatCursor, (_parent__count = parent._count) === null || _parent__count === undefined ? undefined : _parent__count[name2]);
        }
      }, connectionOptions instanceof ObjectRef2 ? connectionOptions : {
        ...connectionOptions,
        fields: totalCount ? (t2) => {
          var _connectionOptions_fields;
          return {
            totalCount: t2.int({
              nullable: false,
              extensions: {
                pothosPrismaTotalCount: true
              },
              resolve: (parent, args, context) => parent.totalCount
            }),
            ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === undefined ? undefined : _connectionOptions_fields.call(connectionOptions, t2)
          };
        } : connectionOptions.fields
      }, edgeOptions);
      return fieldRef;
    });
    this.model = model;
    this.prismaFieldMap = fieldMap;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/relation-map.js
function createRelationMap({ models }) {
  const relationMap = new Map;
  if (Array.isArray(models)) {
    models.forEach((model) => {
      relationMap.set(model.name, {
        model: model.name,
        relations: new Map
      });
    });
    models.forEach((model) => {
      const map4 = relationMap.get(model.name).relations;
      model.fields.forEach((field2) => {
        if (field2.kind === "object" && relationMap.has(field2.type)) {
          map4.set(field2.name, relationMap.get(field2.type));
        }
      });
    });
  } else {
    Object.keys(models).forEach((name) => {
      relationMap.set(name, {
        model: name,
        relations: new Map
      });
    });
    Object.entries(models).forEach(([name, model]) => {
      const map4 = relationMap.get(name).relations;
      model.fields.forEach((field2) => {
        if (field2.kind === "object" && relationMap.has(field2.type)) {
          map4.set(field2.name, relationMap.get(field2.type));
        }
      });
    });
  }
  return relationMap;
}
var getRelationMap = createContextCache((datamodel5) => createRelationMap(datamodel5));

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/schema-builder.js
var schemaBuilderProto2 = esm_default.prototype;
schemaBuilderProto2.prismaObject = function prismaObject(type73, { fields, findUnique, select, include, description: description3, ...options }) {
  const ref3 = options.variant ? new PrismaObjectRef(options.variant, type73) : getRefFromModel(type73, this);
  var _options_variant, _ref;
  const name = (_ref = (_options_variant = options.variant) !== null && _options_variant !== undefined ? _options_variant : options.name) !== null && _ref !== undefined ? _ref : type73;
  const fieldMap = getRelationMap(getDMMF(this)).get(type73);
  const idSelection = ModelLoader.getDefaultIDSelection(ref3, type73, this);
  ref3.name = name;
  this.objectType(ref3, {
    ...options,
    description: getModelDescription(type73, this, description3),
    extensions: {
      ...options.extensions,
      pothosPrismaInclude: include,
      pothosPrismaModel: type73,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: select && {
        ...idSelection,
        ...select
      },
      pothosPrismaLoader: ModelLoader.forRef(ref3, type73, findUnique, this)
    },
    name,
    fields: fields ? () => fields(new PrismaObjectFieldBuilder(name, this, type73, getRelationMap(getDMMF(this)).get(type73))) : undefined
  });
  return ref3;
};
schemaBuilderProto2.prismaInterface = function prismaInterface(type73, { fields, findUnique, select, include, description: description3, ...options }) {
  const ref3 = options.variant ? new PrismaInterfaceRef(options.variant, type73) : getRefFromModel(type73, this, "interface");
  var _options_variant, _ref;
  const name = (_ref = (_options_variant = options.variant) !== null && _options_variant !== undefined ? _options_variant : options.name) !== null && _ref !== undefined ? _ref : type73;
  const fieldMap = getRelationMap(getDMMF(this)).get(type73);
  const idSelection = ModelLoader.getDefaultIDSelection(ref3, type73, this);
  ref3.name = name;
  this.interfaceType(ref3, {
    ...options,
    description: getModelDescription(type73, this, description3),
    extensions: {
      ...options.extensions,
      pothosPrismaInclude: include,
      pothosPrismaModel: type73,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: select && {
        ...idSelection,
        ...select
      },
      pothosPrismaLoader: ModelLoader.forRef(ref3, type73, findUnique, this)
    },
    name,
    fields: fields ? () => fields(new PrismaObjectFieldBuilder(name, this, type73, getRelationMap(getDMMF(this)).get(type73), "Interface")) : undefined
  });
  return ref3;
};
schemaBuilderProto2.prismaNode = function prismaNode(type73, { id: { field: field2, resolve: rawResolve, ...idOptions }, findUnique: rawFindUnique, name, variant, nullable, ...options }) {
  var _this_nodeInterfaceRef, _this;
  const fieldName = field2;
  const interfaceRef = (_this_nodeInterfaceRef = (_this = this).nodeInterfaceRef) === null || _this_nodeInterfaceRef === undefined ? undefined : _this_nodeInterfaceRef.call(_this);
  const resolve = rawResolve !== null && rawResolve !== undefined ? rawResolve : getDefaultIDSerializer(type73, fieldName, this);
  const idParser = fieldName ? getDefaultIDParser(type73, fieldName, this) : undefined;
  var _ref;
  const typeName = (_ref = variant !== null && variant !== undefined ? variant : name) !== null && _ref !== undefined ? _ref : type73;
  const nodeRef = new PrismaNodeRef(typeName, type73);
  const findUnique = rawFindUnique ? (parent, context) => rawFindUnique(resolve(parent, context), context) : ModelLoader.getFindUniqueForField(nodeRef, type73, fieldName, this);
  if (!interfaceRef) {
    throw new PothosError("builder.prismaNode requires @pothos/plugin-relay to be installed");
  }
  const extendedOptions = {
    ...options,
    name,
    variant,
    interfaces: [
      interfaceRef
    ],
    findUnique,
    loadWithoutCache: async (id, context, info) => {
      const query3 = queryFromInfo({
        context,
        info,
        typeName
      });
      const delegate = getDelegateFromModel(getClient(this, context), type73);
      const record3 = await (delegate.findUniqueOrThrow && !nullable ? delegate.findUniqueOrThrow({
        ...query3,
        where: rawFindUnique ? rawFindUnique(id, context) : {
          [fieldName]: idParser(id)
        }
      }) : delegate.findUnique({
        ...query3,
        ...nullable ? {} : {
          rejectOnNotFound: true
        },
        where: rawFindUnique ? rawFindUnique(id, context) : {
          [fieldName]: idParser(id)
        }
      }));
      brandWithType(record3, typeName);
      return record3;
    }
  };
  const ref3 = this.prismaObject(type73, extendedOptions);
  if (options.interfaces) {
    this.configStore.addInterfaces(typeName, options.interfaces);
  }
  this.configStore.onTypeConfig(ref3, (nodeConfig) => {
    var _this_options_relayOptions;
    var _this_options_relayOptions_idFieldName;
    this.objectField(ref3, (_this_options_relayOptions_idFieldName = (_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === undefined ? undefined : _this_options_relayOptions.idFieldName) !== null && _this_options_relayOptions_idFieldName !== undefined ? _this_options_relayOptions_idFieldName : "id", (t2) => {
      var _this_options_relayOptions2;
      return t2.globalID({
        ...(_this_options_relayOptions2 = this.options.relayOptions) === null || _this_options_relayOptions2 === undefined ? undefined : _this_options_relayOptions2.idFieldOptions,
        ...idOptions,
        nullable: false,
        args: {},
        resolve: (parent, args, context, info) => completeValue2(resolve(parent, context), (id) => ({
          type: nodeConfig.name,
          id
        }))
      });
    });
  });
  this.configStore.associateRefWithName(nodeRef, typeName);
  return nodeRef;
};
schemaBuilderProto2.prismaObjectField = function prismaObjectField(type73, fieldName, field2) {
  const ref3 = typeof type73 === "string" ? getRefFromModel(type73, this) : type73;
  this.configStore.onTypeConfig(ref3, ({ name }) => {
    this.configStore.addFields(ref3, () => ({
      [fieldName]: field2(new PrismaObjectFieldBuilder(name, this, ref3.modelName, getRelationMap(getDMMF(this)).get(ref3.modelName)))
    }));
  });
};
schemaBuilderProto2.prismaInterfaceField = function prismaInterfaceField(type73, fieldName, field2) {
  const ref3 = typeof type73 === "string" ? getRefFromModel(type73, this) : type73;
  this.configStore.onTypeConfig(ref3, ({ name }) => {
    this.configStore.addFields(ref3, () => ({
      [fieldName]: field2(new PrismaObjectFieldBuilder(name, this, ref3.modelName, getRelationMap(getDMMF(this)).get(ref3.modelName), "Interface"))
    }));
  });
};
schemaBuilderProto2.prismaObjectFields = function prismaObjectFields(type73, fields) {
  const ref3 = typeof type73 === "string" ? getRefFromModel(type73, this) : type73;
  this.configStore.onTypeConfig(ref3, ({ name }) => {
    this.configStore.addFields(ref3, () => fields(new PrismaObjectFieldBuilder(name, this, ref3.modelName, getRelationMap(getDMMF(this)).get(ref3.modelName))));
  });
};
schemaBuilderProto2.prismaInterfaceFields = function prismaInterfaceFields(type73, fields) {
  const ref3 = typeof type73 === "string" ? getRefFromModel(type73, this) : type73;
  this.configStore.onTypeConfig(ref3, ({ name }) => {
    this.configStore.addFields(ref3, () => fields(new PrismaObjectFieldBuilder(name, this, ref3.modelName, getRelationMap(getDMMF(this)).get(ref3.modelName), "Interface")));
  });
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/field-builder.js
var checkIfQueryIsUsed = function(builder5, query3, info, result) {
  const { onUnusedQuery } = builder5.options.prisma || {};
  if (!onUnusedQuery) {
    return result;
  }
  if (isThenable(result)) {
    return result.then((resolved) => {
      if (!isUsed(query3)) {
        onUnused();
      }
      return resolved;
    });
  }
  if (!isUsed(query3)) {
    onUnused();
  }
  return result;
  function onUnused() {
    if (typeof onUnusedQuery === "function") {
      onUnusedQuery(info);
      return;
    }
    const message = `Prisma query was unused in resolver for ${info.parentType.name}.${info.fieldName}`;
    if (onUnusedQuery === "error") {
      throw new PothosError(message);
    } else if (onUnusedQuery === "warn") {
      console.warn(message);
    }
  }
};
var fieldBuilderProto2 = RootFieldBuilder2.prototype;
fieldBuilderProto2.prismaField = function prismaField({ type: type73, resolve, ...options }) {
  const modelOrRef = Array.isArray(type73) ? type73[0] : type73;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type73) ? [
    typeRef
  ] : typeRef;
  return this.field({
    ...options,
    type: typeParam,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      return checkIfQueryIsUsed(this.builder, query3, info, resolve(query3, parent, args, context, info));
    }
  });
};
fieldBuilderProto2.prismaFieldWithInput = function prismaFieldWithInput({ type: type73, resolve, ...options }) {
  const modelOrRef = Array.isArray(type73) ? type73[0] : type73;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type73) ? [
    typeRef
  ] : typeRef;
  return this.fieldWithInput({
    ...options,
    type: typeParam,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      return checkIfQueryIsUsed(this.builder, query3, info, resolve(query3, parent, args, context, info));
    }
  });
};
fieldBuilderProto2.prismaConnection = function prismaConnection({ type: type73, cursor, maxSize, defaultSize, resolve, totalCount, ...options }, connectionOptions = {}, edgeOptions = {}) {
  var _this_builder_configStore_getTypeConfig_extensions;
  const ref3 = typeof type73 === "string" ? getRefFromModel(type73, this.builder) : type73;
  const typeName = this.builder.configStore.getTypeConfig(ref3).name;
  const model = (_this_builder_configStore_getTypeConfig_extensions = this.builder.configStore.getTypeConfig(ref3).extensions) === null || _this_builder_configStore_getTypeConfig_extensions === undefined ? undefined : _this_builder_configStore_getTypeConfig_extensions.pothosPrismaModel;
  const formatCursor = getCursorFormatter(model, this.builder, cursor);
  const parseCursor = getCursorParser(model, this.builder, cursor);
  const cursorSelection = ModelLoader.getCursorSelection(ref3, model, cursor, this.builder);
  const fieldRef = this.connection({
    ...options,
    type: ref3,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        select: cursorSelection,
        paths: [
          [
            "nodes"
          ],
          [
            "edges",
            "node"
          ]
        ],
        typeName,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      const returnType = getNamedType(info.returnType);
      const fields = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
      const selections3 = info.fieldNodes;
      const totalCountOnly = selections3.every((selection) => {
        var _selection_selectionSet;
        return ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && selection.selectionSet.selections.every((s2) => {
          var _fields_s_name_value_extensions, _fields_s_name_value;
          return s2.kind === Kind2.FIELD && ((_fields_s_name_value = fields[s2.name.value]) === null || _fields_s_name_value === undefined ? undefined : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === undefined ? undefined : _fields_s_name_value_extensions.pothosPrismaTotalCount);
        });
      });
      return resolvePrismaCursorConnection({
        parent,
        query: query3,
        ctx: context,
        parseCursor,
        maxSize,
        defaultSize,
        args,
        totalCount: totalCount && (() => totalCount(parent, args, context, info))
      }, formatCursor, (q) => {
        if (totalCountOnly)
          return [];
        return checkIfQueryIsUsed(this.builder, query3, info, resolve(q, parent, args, context, info));
      });
    }
  }, connectionOptions instanceof ObjectRef2 ? connectionOptions : {
    ...connectionOptions,
    fields: totalCount ? (t2) => {
      var _connectionOptions_fields;
      return {
        totalCount: t2.int({
          nullable: false,
          extensions: {
            pothosPrismaTotalCount: true
          },
          resolve: (parent, args, context) => {
            var _parent_totalCount;
            return (_parent_totalCount = parent.totalCount) === null || _parent_totalCount === undefined ? undefined : _parent_totalCount.call(parent);
          }
        }),
        ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === undefined ? undefined : _connectionOptions_fields.call(connectionOptions, t2)
      };
    } : connectionOptions.fields,
    extensions: {
      ...connectionOptions === null || connectionOptions === undefined ? undefined : connectionOptions.extensions
    }
  }, edgeOptions);
  return fieldRef;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/connection-helpers.js
var prismaModelKey2 = Symbol.for("Pothos.prismaModelKey");
// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/types.js
var prismaModelName = Symbol.for("Pothos.prismaModelName");

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/index.js
var pluginName2 = "prisma";
var esm_default3 = pluginName2;
class PrismaPlugin extends BasePlugin {
  onTypeConfig(typeConfig) {
    var _typeConfig_extensions;
    if (typeConfig.kind !== "Object" && typeConfig.kind !== "Interface") {
      return typeConfig;
    }
    let model = (_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === undefined ? undefined : _typeConfig_extensions.pothosPrismaModel;
    typeConfig.interfaces.forEach((iface) => {
      var _this_buildCache_getTypeConfig_extensions;
      const interfaceModel = (_this_buildCache_getTypeConfig_extensions = this.buildCache.getTypeConfig(iface, "Interface").extensions) === null || _this_buildCache_getTypeConfig_extensions === undefined ? undefined : _this_buildCache_getTypeConfig_extensions.pothosPrismaModel;
      if (interfaceModel) {
        if (model && model !== interfaceModel) {
          throw new PothosSchemaError(`PrismaObjects must be based on the same prisma model as any PrismaInterfaces they extend. ${typeConfig.name} uses ${model} and ${iface.name} uses ${interfaceModel}`);
        }
        model = interfaceModel;
      }
    });
    return {
      ...typeConfig,
      extensions: {
        ...typeConfig.extensions,
        pothosPrismaModel: model
      }
    };
  }
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "PrismaObject" && fieldConfig.pothosOptions.select) {
      const { select } = fieldConfig.pothosOptions;
      return {
        ...fieldConfig,
        extensions: {
          ...fieldConfig.extensions,
          pothosPrismaSelect: typeof select === "function" ? (args, ctx, nestedQuery) => ({
            select: select(args, ctx, nestedQuery)
          }) : select
        }
      };
    }
    return fieldConfig;
  }
  wrapResolve(resolver, fieldConfig) {
    var _fieldConfig_extensions, _fieldConfig_extensions1, _parentConfig_extensions, _fieldConfig_extensions2;
    if (fieldConfig.kind !== "PrismaObject" || !((_fieldConfig_extensions = fieldConfig.extensions) === null || _fieldConfig_extensions === undefined ? undefined : _fieldConfig_extensions.pothosPrismaSelect)) {
      return resolver;
    }
    const parentConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    const loadedCheck = (_fieldConfig_extensions1 = fieldConfig.extensions) === null || _fieldConfig_extensions1 === undefined ? undefined : _fieldConfig_extensions1.pothosPrismaLoaded;
    const loaderCache = (_parentConfig_extensions = parentConfig.extensions) === null || _parentConfig_extensions === undefined ? undefined : _parentConfig_extensions.pothosPrismaLoader;
    const fallback = (_fieldConfig_extensions2 = fieldConfig.extensions) === null || _fieldConfig_extensions2 === undefined ? undefined : _fieldConfig_extensions2.pothosPrismaFallback;
    const parentTypes = new Set([
      fieldConfig.parentType
    ]);
    if (parentConfig.kind === "Interface" || parentConfig.kind === "Object") {
      parentConfig.interfaces.forEach((iface) => {
        var _interfaceConfig_extensions;
        const interfaceConfig = this.buildCache.getTypeConfig(iface, "Interface");
        if ((_interfaceConfig_extensions = interfaceConfig.extensions) === null || _interfaceConfig_extensions === undefined ? undefined : _interfaceConfig_extensions.pothosPrismaModel) {
          parentTypes.add(interfaceConfig.name);
        }
      });
    }
    return (parent, args, context, info) => {
      let mapping = getLoaderMapping(context, info.path, info.parentType.name);
      if (!mapping) {
        for (const parentType of parentTypes) {
          mapping = getLoaderMapping(context, info.path, parentType);
          if (mapping) {
            break;
          }
        }
      }
      if ((!loadedCheck || loadedCheck(parent, info)) && mapping) {
        setLoaderMappings(context, info, mapping);
        return resolver(parent, args, context, info);
      }
      if (fallback) {
        return fallback(queryFromInfo({
          context,
          info
        }), parent, args, context, info);
      }
      return loaderCache(context).loadSelection(info, parent).then((result) => resolver(result, args, context, info));
    };
  }
  constructor(cache2) {
    super(cache2, pluginName2);
  }
}
esm_default.registerPlugin(pluginName2, PrismaPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma-utils/esm/schema-builder.js
var nameFromType = function(type73, builder5) {
  if (typeof type73 === "string") {
    return type73;
  }
  if (builder5.configStore.hasConfig(type73)) {
    return builder5.configStore.getTypeConfig(type73).name;
  }
  if (typeof type73 === "function" && ("name" in type73)) {
    return type73.name;
  }
  if (type73 instanceof BaseTypeRef2) {
    return type73.name;
  }
  throw new PothosSchemaError(`Unable to determine name for type ${String(type73)}`);
};
var capitalize3 = function(str) {
  return str[0].toUpperCase() + str.slice(1);
};
var schemaBuilder = esm_default.prototype;
var OrderByRefMap = new WeakMap;
var PrismaStringFilterModeRefMap = new WeakMap;
schemaBuilder.prismaFilter = function prismaFilter(type73, { ops, name, ...options }) {
  const filterName = name !== null && name !== undefined ? name : `${nameFromType(type73, this)}Filter`;
  const ref3 = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map4, op) => {
    map4[op] = {};
    return map4;
  }, {}) : ops;
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fields = {};
      for (const op of Object.keys(opsOptions)) {
        const isList = op === "in" || op === "notIn";
        let fieldType;
        switch (op) {
          case "not":
            fieldType = ref3;
            break;
          case "in":
          case "notIn":
            fieldType = [
              type73
            ];
            break;
          case "mode":
            fieldType = this.prismaStringFilterModeEnum();
            break;
          default:
            fieldType = type73;
        }
        fields[op] = t2.field({
          required: isList ? {
            list: false,
            items: true
          } : false,
          type: fieldType,
          ...opsOptions[op]
        });
      }
      return fields;
    }
  });
  return ref3;
};
schemaBuilder.prismaStringFilterModeEnum = function prismaStringFilterModeEnum() {
  if (PrismaStringFilterModeRefMap.has(this)) {
    return PrismaStringFilterModeRefMap.get(this);
  }
  const ref3 = this.enumType("StringFilterMode", {
    values: {
      Default: {
        value: "default"
      },
      Insensitive: {
        value: "insensitive"
      }
    }
  });
  PrismaStringFilterModeRefMap.set(this, ref3);
  return ref3;
};
schemaBuilder.prismaListFilter = function prismaListFilter(type73, { name, ops, ...options }) {
  let filterName = name;
  if (!filterName) {
    const typeName = nameFromType(type73, this);
    filterName = typeName.endsWith("Filter") ? typeName.replace(/Filter$/, "ListFilter") : `List${typeName}`;
  }
  const ref3 = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map4, op) => {
    map4[op] = {};
    return map4;
  }, {}) : ops;
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fields = {};
      for (const op of Object.keys(opsOptions)) {
        fields[op] = t2.field({
          required: false,
          type: type73,
          ...opsOptions[op]
        });
      }
      return fields;
    }
  });
  return ref3;
};
schemaBuilder.prismaScalarListFilter = function prismaScalarListFilter(type73, { name, ops, ...options }) {
  let filterName = name;
  if (!filterName) {
    const typeName = nameFromType(type73, this);
    filterName = `${typeName}ListFilter`;
  }
  const ref3 = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map4, op) => {
    map4[op] = {};
    return map4;
  }, {}) : ops;
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fields = {};
      for (const op of Object.keys(opsOptions)) {
        let fieldType = type73;
        switch (op) {
          case "has":
            fieldType = type73;
            break;
          case "equals":
          case "hasSome":
          case "hasEvery":
            fieldType = [
              type73
            ];
            break;
          case "isEmpty":
            fieldType = "Boolean";
            break;
          default:
            throw new Error(`Invalid op ${op} for scalar list filter`);
        }
        fields[op] = t2.field({
          required: false,
          type: fieldType,
          ...opsOptions[op]
        });
      }
      return fields;
    }
  });
  return ref3;
};
schemaBuilder.orderByEnum = function orderByEnum() {
  if (OrderByRefMap.has(this)) {
    return OrderByRefMap.get(this);
  }
  const ref3 = this.enumType("OrderBy", {
    values: {
      Asc: {
        value: "asc"
      },
      Desc: {
        value: "desc"
      }
    }
  });
  OrderByRefMap.set(this, ref3);
  return ref3;
};
schemaBuilder.prismaOrderBy = function prismaOrderBy(type73, { name, fields, ...options }) {
  const filterName = name !== null && name !== undefined ? name : `${nameFromType(type73, this)}OrderBy`;
  const ref3 = this.inputRef(filterName);
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields() : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (typeof fieldOption === "function") {
          const { type: fieldType, ...fieldOptions } = fieldOption();
          fieldDefs[field2] = t2.field({
            required: false,
            ...fieldOptions,
            type: fieldType
          });
        } else if (typeof fieldOption === "boolean") {
          fieldDefs[field2] = t2.field({
            required: false,
            type: this.orderByEnum()
          });
        } else {
          fieldDefs[field2] = t2.field({
            required: false,
            type: fieldOption
          });
        }
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaWhere = function prismaWhere(type73, { name, fields, ...options }) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type73, this)}Filter`);
  const model = getModel(type73, this);
  const nullableFields = new Set(model.fields.filter((field2) => !field2.isRequired).map((field2) => field2.name));
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: {
        nullableFields
      }
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t2) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        if (field2 === "AND" || field2 === "OR" || field2 === "NOT") {
          fieldDefs[field2] = t2.field({
            required: false,
            type: field2 === "NOT" ? ref3 : [
              ref3
            ],
            ...typeof fieldOption === "object" ? fieldOption : {}
          });
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t2.field({
          required: false,
          type: fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaWhereUnique = function prismaWhereUnique(type73, { name, fields, ...options }) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type73, this)}UniqueFilter`);
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t2) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t2.field({
          required: false,
          type: fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaCreate = function prismaCreate(type73, { name, fields, ...options }) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type73, this)}CreateInput`);
  const model = getModel(type73, this);
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t2) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldModel = model.fields.find(({ name: fieldName }) => fieldName === field2);
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t2.field({
          required: fieldModel.isRequired && !fieldModel.isList && !fieldModel.hasDefaultValue && !fieldModel.isUpdatedAt,
          type: fieldModel.isList && fieldModel.kind !== "object" ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaUpdate = function prismaUpdate(type73, { name, fields, ...options }) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type73, this)}UpdateInput`);
  const model = getModel(type73, this);
  const nullableFields = new Set(model.fields.filter((field2) => !field2.isRequired).map((field2) => field2.name));
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: {
        nullableFields
      }
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t2) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldModel = model.fields.find(({ name: fieldName }) => fieldName === field2);
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t2.field({
          required: false,
          type: fieldModel.isList && fieldModel.kind !== "object" ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaCreateRelation = function prismaCreateRelation(type73, relation, { name, fields, ...options }) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type73, this)}Create${capitalize3(relation)}RelationInput`);
  const model = getModel(type73, this);
  const fieldModel = model.fields.find((field2) => field2.name === relation);
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t2) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t2.field({
          required: false,
          type: fieldModel.isList ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaUpdateRelation = function prismaUpdateRelation(type73, relation, { name, fields, ...options }) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type73, this)}Update${capitalize3(relation)}RelationInput`);
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t2) : fields;
      const model = getModel(type73, this);
      const fieldModel = model.fields.find((field2) => field2.name === relation);
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        if (fieldOption instanceof InputFieldRef) {
          fieldDefs[field2] = fieldOption;
        } else if (fieldModel.isList && (field2 === "update" || field2 === "updateMany")) {
          const { name: nestedName = `${ref3.name}U${field2.slice(1)}`, where: whereType, data: dataType } = fieldOption;
          const nestedRef = this.inputType(nestedName, {
            fields: (t22) => ({
              where: whereType instanceof InputFieldRef ? whereType : t22.field({
                type: whereType
              }),
              data: dataType instanceof InputFieldRef ? dataType : t22.field({
                type: dataType
              })
            })
          });
          fieldDefs[field2] = t2.field({
            required: false,
            type: [
              nestedRef
            ]
          });
        } else {
          fieldDefs[field2] = t2.field({
            required: false,
            type: fieldModel.isList ? [
              fieldOption
            ] : fieldOption
          });
        }
      });
      return fieldDefs;
    }
  });
  return ref3;
};
schemaBuilder.prismaIntAtomicUpdate = function prismaIntUpdateOperations({ name, ops = [
  "set",
  "increment",
  "decrement",
  "multiply",
  "divide"
], ...options } = {}) {
  const ref3 = this.inputRef(name !== null && name !== undefined ? name : "IntAtomicUpdate");
  ref3.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t2) => {
      const fieldDefs = {};
      ops.forEach((op) => {
        fieldDefs[op] = t2.field({
          required: false,
          type: "Int"
        });
      });
      return fieldDefs;
    }
  });
  return ref3;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma-utils/esm/index.js
var normalizeInputObject = function(object16, nullableFields) {
  if (!object16) {
    return object16;
  }
  if (typeof object16 !== "object") {
    return object16;
  }
  if (Array.isArray(object16)) {
    return object16.map((o2) => normalizeInputObject(o2, nullableFields));
  }
  const mapped19 = {};
  Object.keys(object16).forEach((key) => {
    mapped19[key] = !nullableFields.has(key) && object16[key] === null ? undefined : object16[key];
  });
  return mapped19;
};
var pluginName3 = "prismaUtils";
var esm_default4 = pluginName3;

class PrismaUtilsPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var _inputType_extensions;
      const inputType = this.buildCache.getTypeConfig(unwrapInputFieldType(inputField.type));
      if ((_inputType_extensions = inputType.extensions) === null || _inputType_extensions === undefined ? undefined : _inputType_extensions.pothosPrismaInput) {
        var _inputType_extensions1, _inputType_extensions2;
        return typeof ((_inputType_extensions1 = inputType.extensions) === null || _inputType_extensions1 === undefined ? undefined : _inputType_extensions1.pothosPrismaInput) === "object" ? (_inputType_extensions2 = inputType.extensions) === null || _inputType_extensions2 === undefined ? undefined : _inputType_extensions2.pothosPrismaInput : {
          nullableFields: new Set
        };
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    var _mapping_value_nullableFields;
    const argMapper = createInputValueMapper(argMappings, (inputObject, mapping) => {
      var _mapping_value;
      return normalizeInputObject(inputObject, (_mapping_value_nullableFields = (_mapping_value = mapping.value) === null || _mapping_value === undefined ? undefined : _mapping_value.nullableFields) !== null && _mapping_value_nullableFields !== undefined ? _mapping_value_nullableFields : new Set);
    });
    return (parent, args, context, info) => resolver(parent, argMapper(args), context, info);
  }
  constructor(cache2) {
    super(cache2, pluginName3);
  }
}
esm_default.registerPlugin(pluginName3, PrismaUtilsPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-with-input/esm/schema-builder.js
var capitalize4 = function(s2) {
  return `${s2.slice(0, 1).toUpperCase()}${s2.slice(1)}`;
};
var rootBuilderProto = RootFieldBuilder2.prototype;
rootBuilderProto.fieldWithInput = function fieldWithInput({ typeOptions: { name: typeName, ...typeOptions } = {}, argOptions: { name: argName = "input", ...argOptions } = {}, args, input: input6, ...fieldOptions }) {
  var ref3;
  const inputRef = this.builder.inputRef(typeName !== null && typeName !== undefined ? typeName : `UnnamedWithInputOn${this.typename}`);
  const fieldRef = this.field({
    args: {
      ...args,
      [argName]: this.arg({
        required: true,
        ...(ref3 = this.builder.options.withInput) === null || ref3 === undefined ? undefined : ref3.argOptions,
        ...argOptions,
        type: inputRef
      })
    },
    ...fieldOptions
  });
  this.builder.configStore.onFieldUse(fieldRef, (config) => {
    var ref4;
    const name = typeName !== null && typeName !== undefined ? typeName : `${this.typename}${capitalize4(config.name)}Input`;
    this.builder.inputType(name, {
      fields: () => input6,
      ...(ref4 = this.builder.options.withInput) === null || ref4 === undefined ? undefined : ref4.typeOptions,
      ...typeOptions
    });
    this.builder.configStore.associateRefWithName(inputRef, name);
  });
  return fieldRef;
};
Object.defineProperty(rootBuilderProto, "input", {
  get: function getInputBuilder() {
    return new InputFieldBuilder2(this.builder, "InputObject", `UnnamedWithInputOn${this.typename}`);
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-with-input/esm/index.js
var pluginName4 = "withInput";
var esm_default5 = pluginName4;

class PothosWithInputPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName4, PothosWithInputPlugin);

// /Users/richardguerre/Projects/flow/node_modules/graphql-scalars/index.mjs
var _validateInt = function(value14) {
  if (!Number.isFinite(value14)) {
    throw new TypeError(`Value is not a finite number: ${value14}`);
  }
  if (!Number.isInteger(value14)) {
    throw new TypeError(`Value is not an integer: ${value14}`);
  }
  if (!Number.isSafeInteger(value14)) {
    throw new TypeError(`Value is not a safe integer: ${value14}`);
  }
};
var _validateFloat = function(value14) {
  if (!Number.isFinite(value14)) {
    throw new TypeError(`Value is not a finite number: ${value14}`);
  }
};
var processValue = function(value14, scalarName) {
  const VALIDATIONS = {
    NonPositiveInt: {
      range: VALUE_RANGES.NON_POSITIVE,
      type: VALUE_TYPES.INT
    },
    PositiveInt: {
      range: VALUE_RANGES.POSITIVE,
      type: VALUE_TYPES.INT
    },
    NonNegativeInt: {
      range: VALUE_RANGES.NON_NEGATIVE,
      type: VALUE_TYPES.INT
    },
    NegativeInt: {
      range: VALUE_RANGES.NEGATIVE,
      type: VALUE_TYPES.INT
    },
    NonPositiveFloat: {
      range: VALUE_RANGES.NON_POSITIVE,
      type: VALUE_TYPES.FLOAT
    },
    PositiveFloat: {
      range: VALUE_RANGES.POSITIVE,
      type: VALUE_TYPES.FLOAT
    },
    NonNegativeFloat: {
      range: VALUE_RANGES.NON_NEGATIVE,
      type: VALUE_TYPES.FLOAT
    },
    NegativeFloat: {
      range: VALUE_RANGES.NEGATIVE,
      type: VALUE_TYPES.FLOAT
    }
  };
  const { range, type: type73 } = VALIDATIONS[scalarName];
  if (value14 === null || typeof value14 === "undefined" || isNaN(value14) || Number.isNaN(value14) || value14 === Number.NaN) {
    throw new TypeError(`Value is not a number: ${value14}`);
  }
  let parsedValue;
  switch (type73) {
    case VALUE_TYPES.FLOAT:
      parsedValue = parseFloat(value14);
      _validateFloat(parsedValue);
      break;
    case VALUE_TYPES.INT:
      parsedValue = parseInt(value14, 10);
      _validateInt(parsedValue);
      break;
  }
  if (range === VALUE_RANGES.NEGATIVE && !(parsedValue < 0) || range === VALUE_RANGES.NON_NEGATIVE && !(parsedValue >= 0) || range === VALUE_RANGES.POSITIVE && !(parsedValue > 0) || range === VALUE_RANGES.NON_POSITIVE && !(parsedValue <= 0)) {
    throw new TypeError(`Value is not a ${VALUE_RANGES[range].toLowerCase().replace("_", "-")} number: ${value14}`);
  }
  return parsedValue;
};
var identity = function(value14) {
  return value14;
};
var parseObject$1 = function(ast8, variables) {
  const value14 = Object.create(null);
  ast8.fields.forEach((field2) => {
    value14[field2.name.value] = parseLiteral(field2.value, variables);
  });
  return value14;
};
var parseLiteral = function(ast8, variables) {
  switch (ast8.kind) {
    case Kind2.STRING:
    case Kind2.BOOLEAN:
      return ast8.value;
    case Kind2.INT:
    case Kind2.FLOAT:
      return parseFloat(ast8.value);
    case Kind2.OBJECT:
      return parseObject$1(ast8, variables);
    case Kind2.LIST:
      return ast8.values.map((n2) => parseLiteral(n2, variables));
    case Kind2.NULL:
      return null;
    case Kind2.VARIABLE: {
      const name = ast8.name.value;
      return variables ? variables[name] : undefined;
    }
  }
};
var leapYear = (year) => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var validateTime = (time) => {
  time = time === null || time === undefined ? undefined : time.toUpperCase();
  const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  return TIME_REGEX.test(time);
};
var validateDate = (datestring) => {
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;
  if (!RFC_3339_REGEX.test(datestring)) {
    return false;
  }
  const year = Number(datestring.substr(0, 4));
  const month = Number(datestring.substr(5, 2));
  const day2 = Number(datestring.substr(8, 2));
  switch (month) {
    case 2:
      if (leapYear(year) && day2 > 29) {
        return false;
      } else if (!leapYear(year) && day2 > 28) {
        return false;
      }
      return true;
    case 4:
    case 6:
    case 9:
    case 11:
      if (day2 > 30) {
        return false;
      }
      break;
  }
  return true;
};
var validateDateTime = (dateTimeString) => {
  dateTimeString = dateTimeString === null || dateTimeString === undefined ? undefined : dateTimeString.toUpperCase();
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  if (!RFC_3339_REGEX.test(dateTimeString)) {
    return false;
  }
  const time = Date.parse(dateTimeString);
  if (time !== time) {
    return false;
  }
  const index = dateTimeString.indexOf("T");
  const dateString = dateTimeString.substr(0, index);
  const timeString = dateTimeString.substr(index + 1);
  return validateDate(dateString) && validateTime(timeString);
};
var validateJSDate = (date4) => {
  const time = date4.getTime();
  return time === time;
};
var parseDate = (date4) => {
  return new Date(date4);
};
var serializeDate = (date4) => {
  return date4.toISOString().split("T")[0];
};
var parseDateTime = (dateTime) => {
  return new Date(dateTime);
};
var GraphQLDateConfig = {
  name: "Date",
  description: "A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value14) {
    if (value14 instanceof Date) {
      if (validateJSDate(value14)) {
        return serializeDate(value14);
      }
      throw new TypeError("Date cannot represent an invalid Date instance");
    } else if (typeof value14 === "string") {
      if (validateDate(value14)) {
        return value14;
      }
      throw new TypeError(`Date cannot represent an invalid date-string ${value14}.`);
    } else {
      throw new TypeError("Date cannot represent a non string, or non Date type " + JSON.stringify(value14));
    }
  },
  parseValue(value14) {
    if (!(typeof value14 === "string")) {
      throw new TypeError(`Date cannot represent non string type ${JSON.stringify(value14)}`);
    }
    if (validateDate(value14)) {
      return parseDate(value14);
    }
    throw new TypeError(`Date cannot represent an invalid date-string ${value14}.`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind2.STRING) {
      throw new TypeError(`Date cannot represent non string type ${("value" in ast8) && ast8.value}`);
    }
    const { value: value14 } = ast8;
    if (validateDate(value14)) {
      return parseDate(value14);
    }
    throw new TypeError(`Date cannot represent an invalid date-string ${String(value14)}.`);
  },
  extensions: {
    codegenScalarType: "Date | string"
  }
};
var GraphQLDate = new GraphQLScalarType(GraphQLDateConfig);
var GraphQLDateTimeConfig = {
  name: "DateTime",
  description: "A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value14) {
    if (value14 instanceof Date) {
      if (validateJSDate(value14)) {
        return value14;
      }
      throw new TypeError("DateTime cannot represent an invalid Date instance");
    } else if (typeof value14 === "string") {
      if (validateDateTime(value14)) {
        return parseDateTime(value14);
      }
      throw new TypeError(`DateTime cannot represent an invalid date-time-string ${value14}.`);
    } else if (typeof value14 === "number") {
      try {
        return new Date(value14);
      } catch (e2) {
        throw new TypeError("DateTime cannot represent an invalid Unix timestamp " + value14);
      }
    } else {
      throw new TypeError("DateTime cannot be serialized from a non string, non numeric or non Date type " + JSON.stringify(value14));
    }
  },
  parseValue(value14) {
    if (value14 instanceof Date) {
      if (validateJSDate(value14)) {
        return value14;
      }
      throw new TypeError("DateTime cannot represent an invalid Date instance");
    }
    if (typeof value14 === "string") {
      if (validateDateTime(value14)) {
        return parseDateTime(value14);
      }
      throw new TypeError(`DateTime cannot represent an invalid date-time-string ${value14}.`);
    }
    throw new TypeError(`DateTime cannot represent non string or Date type ${JSON.stringify(value14)}`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind2.STRING) {
      throw new TypeError(`DateTime cannot represent non string or Date type ${("value" in ast8) && ast8.value}`);
    }
    const { value: value14 } = ast8;
    if (validateDateTime(value14)) {
      return parseDateTime(value14);
    }
    throw new TypeError(`DateTime cannot represent an invalid date-time-string ${String(value14)}.`);
  },
  extensions: {
    codegenScalarType: "Date | string"
  }
};
var GraphQLDateTime = new GraphQLScalarType(GraphQLDateTimeConfig);
var ISO_DURATION = /^(-|\+)?P(?!$)((-|\+)?\d+(?:(\.|,)\d+)?Y)?((-|\+)?\d+(?:(\.|,)\d+)?M)?((-|\+)?\d+(?:(\.|,)\d+)?W)?((-|\+)?\d+(?:(\.|,)\d+)?D)?(T(?=(-|\+)?\d)((-|\+)?\d+(?:(\.|,)\d+)?H)?((-|\+)?\d+(?:(\.|,)\d+)?M)?((-|\+)?\d+(?:(\.|,)\d+)?S)?)?$/;
var GraphQLDurationConfig = {
  name: "Duration",
  description: `
    A string representing a duration conforming to the ISO8601 standard,
    such as: P1W1DT13H23M34S
    P is the duration designator (for period) placed at the start of the duration representation.
    Y is the year designator that follows the value for the number of years.
    M is the month designator that follows the value for the number of months.
    W is the week designator that follows the value for the number of weeks.
    D is the day designator that follows the value for the number of days.
    T is the time designator that precedes the time components of the representation.
    H is the hour designator that follows the value for the number of hours.
    M is the minute designator that follows the value for the number of minutes.
    S is the second designator that follows the value for the number of seconds.

    Note the time designator, T, that precedes the time value.

    Matches moment.js, Luxon and DateFns implementations
    ,/. is valid for decimal places and +/- is a valid prefix
  `,
  serialize(value14) {
    if (typeof value14 !== "string") {
      throw new TypeError(`Value is not string: ${value14}`);
    }
    if (!ISO_DURATION.test(value14)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${value14}`);
    }
    return value14;
  },
  parseValue(value14) {
    if (typeof value14 !== "string") {
      throw new TypeError(`Value is not string: ${value14}`);
    }
    if (!ISO_DURATION.test(value14)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${value14}`);
    }
    return value14;
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind2.STRING) {
      throw new GraphQLError(`Can only validate strings as ISO Durations but got a: ${ast8.kind}`);
    }
    if (!ISO_DURATION.test(ast8.value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${ast8.value}`);
    }
    return ast8.value;
  },
  extensions: {
    codegenScalarType: "string"
  }
};
var GraphQLISO8601Duration = new GraphQLScalarType({
  ...GraphQLDurationConfig,
  name: "ISO8601Duration"
});
var GraphQLDuration = new GraphQLScalarType({
  ...GraphQLDurationConfig,
  name: "Duration"
});
var VALUE_RANGES;
(function(VALUE_RANGES2) {
  VALUE_RANGES2[VALUE_RANGES2["NEGATIVE"] = 0] = "NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_NEGATIVE"] = 1] = "NON_NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["POSITIVE"] = 2] = "POSITIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_POSITIVE"] = 3] = "NON_POSITIVE";
})(VALUE_RANGES || (VALUE_RANGES = {}));
var VALUE_TYPES;
(function(VALUE_TYPES2) {
  VALUE_TYPES2[VALUE_TYPES2["INT"] = 0] = "INT";
  VALUE_TYPES2[VALUE_TYPES2["FLOAT"] = 1] = "FLOAT";
})(VALUE_TYPES || (VALUE_TYPES = {}));
var GraphQLPositiveInt = new GraphQLScalarType({
  name: "PositiveInt",
  description: "Integers that will have a value greater than 0.",
  serialize(value14) {
    return processValue(value14, "PositiveInt");
  },
  parseValue(value14) {
    return processValue(value14, "PositiveInt");
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind2.INT) {
      throw new GraphQLError(`Can only validate integers as positive integers but got a: ${ast8.kind}`);
    }
    return processValue(ast8.value, "PositiveInt");
  },
  extensions: {
    codegenScalarType: "number"
  }
});
var specifiedByURL$5 = "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf";
var GraphQLJSONConfig = {
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: identity,
  parseValue: identity,
  parseLiteral,
  specifiedByURL: specifiedByURL$5,
  specifiedByUrl: specifiedByURL$5,
  extensions: {
    codegenScalarType: "any"
  }
};
var GraphQLJSON = new GraphQLScalarType(GraphQLJSONConfig);
var A = "A".charCodeAt(0);
var Z = "Z".charCodeAt(0);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/errors.js
var _define_property5 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/types.js
var AuthScopeFailureType;
(function(AuthScopeFailureType2) {
  AuthScopeFailureType2["AuthScope"] = "AuthScope";
  AuthScopeFailureType2["AuthScopeFunction"] = "AuthScopeFunction";
  AuthScopeFailureType2["GrantedScope"] = "GrantedScope";
  AuthScopeFailureType2["AnyAuthScopes"] = "AnyAuthScopes";
  AuthScopeFailureType2["AllAuthScopes"] = "AllAuthScopes";
  AuthScopeFailureType2["Unknown"] = "Unknown";
})(AuthScopeFailureType || (AuthScopeFailureType = {}));

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/errors.js
class ForbiddenError extends PothosValidationError {
  constructor(message, result) {
    super(message);
    _define_property5(this, "code", "FORBIDDEN");
    _define_property5(this, "result", undefined);
    this.name = "ForbiddenError";
    this.result = result !== null && result !== undefined ? result : {
      kind: AuthScopeFailureType.Unknown
    };
    Object.defineProperty(this, "name", {
      value: "ForbiddenError"
    });
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var _define_property6 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/util.js
function canCache(map4) {
  if (map4.$granted) {
    return false;
  }
  return (map4.$all ? canCache(map4.$all) : true) && (map4.$any ? canCache(map4.$any) : true);
}
function cacheKey2(path) {
  if (!path) {
    return "*";
  }
  let key = String(path.key);
  let current = path.prev;
  while (current) {
    key = `${current.key}.${key}`;
    current = current.prev;
  }
  return key;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var requestCache = new WeakMap;

class RequestCache {
  static fromContext(context, builder5) {
    if (!requestCache.has(context)) {
      requestCache.set(context, new RequestCache(builder5, context));
    }
    return requestCache.get(context);
  }
  getScopes() {
    if (!this.scopes) {
      const scopes = this.builder.options.authScopes(this.context);
      this.scopes = isThenable(scopes) ? scopes.then((resolved) => {
        this.scopes = resolved;
        return resolved;
      }) : scopes;
    }
    return this.scopes;
  }
  withScopes(cb) {
    const scopes = this.getScopes();
    if (isThenable(scopes)) {
      return scopes.then((resolvedScopes) => cb(resolvedScopes));
    }
    return cb(scopes);
  }
  saveGrantedScopes(scopes, path) {
    const key = cacheKey2(path);
    if (this.grantCache.has(key)) {
      const set2 = this.grantCache.get(key);
      scopes.forEach((scope) => set2.add(scope));
    } else {
      this.grantCache.set(key, new Set(scopes));
    }
    return null;
  }
  testGrantedScopes(scope, path) {
    var _this_grantCache_get, _path_prev, _this_grantCache_get1;
    if ((_this_grantCache_get = this.grantCache.get(cacheKey2(path.prev))) === null || _this_grantCache_get === undefined ? undefined : _this_grantCache_get.has(scope)) {
      return true;
    }
    if (typeof ((_path_prev = path.prev) === null || _path_prev === undefined ? undefined : _path_prev.key) === "number" && ((_this_grantCache_get1 = this.grantCache.get(cacheKey2(path.prev.prev))) === null || _this_grantCache_get1 === undefined ? undefined : _this_grantCache_get1.has(scope))) {
      return true;
    }
    return false;
  }
  grantTypeScopes(type73, parent, path, cb) {
    if (!this.typeGrants.has(type73)) {
      this.typeGrants.set(type73, new Map);
    }
    const cache2 = this.typeGrants.get(type73);
    if (!cache2.has(parent)) {
      const result = cb();
      if (isThenable(result)) {
        cache2.set(parent, result.then((resolved) => this.saveGrantedScopes(resolved, path)));
      } else {
        cache2.set(parent, this.saveGrantedScopes(result, path));
      }
    }
    return cache2.get(parent);
  }
  evaluateScopeLoader(scopes, name, arg) {
    if (!this.scopeCache.has(name)) {
      this.scopeCache.set(name, new Map);
    }
    const cache2 = this.scopeCache.get(name);
    const key = this.cacheKey ? this.cacheKey(arg) : arg;
    if (!cache2.has(key)) {
      const loader = scopes[name];
      if (typeof loader !== "function") {
        throw new PothosValidationError(`Attempted to evaluate scope ${String(name)} as scope loader, but it is not a function`);
      }
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = loader(arg);
        } catch (error28) {
          cache2.set(key, {
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error28
          });
          return cache2.get(key);
        }
      } else {
        result = loader(arg);
      }
      if (isThenable(result)) {
        let promise4 = result.then((r) => r ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
        if (this.treatErrorsAsUnauthorized) {
          promise4 = promise4.catch((error28) => ({
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error28
          }));
        }
        cache2.set(key, promise4);
      } else {
        cache2.set(key, result ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
      }
    }
    return cache2.get(key);
  }
  evaluateScopeMapWithScopes({ $all, $any, $granted, ...map4 }, scopes, info, forAll) {
    const scopeNames = Object.keys(map4);
    const problems = [];
    const failure = {
      kind: forAll ? AuthScopeFailureType.AllAuthScopes : AuthScopeFailureType.AnyAuthScopes,
      failures: problems
    };
    const loaderList = [];
    for (const scopeName of scopeNames) {
      if (scopes[scopeName] == null || scopes[scopeName] === false) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map4[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
        continue;
      }
      const scope = scopes[scopeName];
      if (typeof scope === "function") {
        loaderList.push([
          scopeName,
          map4[scopeName]
        ]);
      } else if (scope && !forAll) {
        return null;
      } else if (!scope) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map4[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
      }
    }
    const promises = [];
    if ($granted) {
      const result = !!info && this.testGrantedScopes($granted, info.path);
      if (result && !forAll) {
        return null;
      }
      if (!result) {
        problems.push({
          kind: AuthScopeFailureType.GrantedScope,
          scope: $granted
        });
        if (forAll) {
          return failure;
        }
      }
    }
    if ($any) {
      const anyResult = this.evaluateScopeMap($any, info, false);
      if (isThenable(anyResult)) {
        promises.push(anyResult);
      } else if (anyResult === null && !forAll) {
        return null;
      } else if (anyResult) {
        problems.push(anyResult);
        if (forAll) {
          return failure;
        }
      }
    }
    if ($all) {
      const allResult = this.evaluateScopeMap($all, info, true);
      if (isThenable(allResult)) {
        promises.push(allResult);
      } else if (allResult === null && !forAll) {
        return resolveAndReturn(null);
      } else if (allResult) {
        problems.push(allResult);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    for (const [loaderName, arg] of loaderList) {
      const result = this.evaluateScopeLoader(scopes, loaderName, arg);
      if (isThenable(result)) {
        promises.push(result);
      } else if (result === null && !forAll) {
        return resolveAndReturn(null);
      } else if (result) {
        problems.push(result);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    if (promises.length === 0) {
      return forAll && problems.length === 0 ? null : failure;
    }
    return Promise.all(promises).then((results) => {
      let hasSuccess = false;
      results.forEach((result) => {
        if (result) {
          problems.push(result);
        } else {
          hasSuccess = true;
        }
      });
      if (forAll) {
        return problems.length > 0 ? failure : null;
      }
      return hasSuccess ? null : failure;
    });
    function resolveAndReturn(val) {
      if (promises.length > 0) {
        return Promise.all(promises).then(() => val);
      }
      return val;
    }
  }
  evaluateScopeMap(map4, info, forAll = this.defaultStrategy === "all") {
    if (typeof map4 === "boolean") {
      return map4 ? null : {
        kind: AuthScopeFailureType.AuthScopeFunction,
        error: null
      };
    }
    if (!this.mapCache.has(map4)) {
      const result = this.withScopes((scopes) => this.evaluateScopeMapWithScopes(map4, scopes, info, forAll));
      if (canCache(map4)) {
        this.mapCache.set(map4, result);
      }
      return result;
    }
    return this.mapCache.get(map4);
  }
  evaluateTypeScopeFunction(authScopes, type73, parent, info) {
    const { typeCache } = this;
    if (!typeCache.has(type73)) {
      typeCache.set(type73, new Map);
    }
    const cache2 = typeCache.get(type73);
    if (!cache2.has(parent)) {
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = authScopes(parent, this.context);
        } catch (error28) {
          cache2.set(parent, {
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error28
          });
          return cache2.get(parent);
        }
      } else {
        result = authScopes(parent, this.context);
      }
      if (isThenable(result)) {
        let promise4 = result.then((resolved) => this.evaluateScopeMap(resolved, info));
        if (this.treatErrorsAsUnauthorized) {
          promise4 = promise4.catch((error28) => ({
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error28
          }));
        }
        cache2.set(parent, promise4);
      } else {
        cache2.set(parent, this.evaluateScopeMap(result, info));
      }
    }
    return cache2.get(parent);
  }
  constructor(builder5, context) {
    var _builder_options_scopeAuthOptions, _builder_options_scopeAuthOptions1, _builder_options_scopeAuthOptions2;
    _define_property6(this, "builder", undefined);
    _define_property6(this, "context", undefined);
    _define_property6(this, "mapCache", new Map);
    _define_property6(this, "scopeCache", new Map);
    _define_property6(this, "typeCache", new Map);
    _define_property6(this, "typeGrants", new Map);
    _define_property6(this, "grantCache", new Map);
    _define_property6(this, "scopes", undefined);
    _define_property6(this, "cacheKey", undefined);
    _define_property6(this, "treatErrorsAsUnauthorized", undefined);
    _define_property6(this, "defaultStrategy", undefined);
    this.builder = builder5;
    this.context = context;
    this.cacheKey = (_builder_options_scopeAuthOptions = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions === undefined ? undefined : _builder_options_scopeAuthOptions.cacheKey;
    var _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized;
    this.treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions_treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions1 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions1 === undefined ? undefined : _builder_options_scopeAuthOptions1.treatErrorsAsUnauthorized) !== null && _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized !== undefined ? _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized : false;
    var _builder_options_scopeAuthOptions_defaultStrategy;
    this.defaultStrategy = (_builder_options_scopeAuthOptions_defaultStrategy = (_builder_options_scopeAuthOptions2 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions2 === undefined ? undefined : _builder_options_scopeAuthOptions2.defaultStrategy) !== null && _builder_options_scopeAuthOptions_defaultStrategy !== undefined ? _builder_options_scopeAuthOptions_defaultStrategy : "any";
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/schema-builder.js
var schemaBuilderProto3 = esm_default.prototype;
schemaBuilderProto3.runAuthScopes = function runAuthScopes(context, scopes, unauthorizedError = (result) => new ForbiddenError(result.message, result.failure)) {
  const cache2 = RequestCache.fromContext(context, this);
  const resultOrPromise = cache2.evaluateScopeMap(scopes);
  if (isThenable(resultOrPromise)) {
    return resultOrPromise.then(handleScopeResult);
  }
  handleScopeResult(resultOrPromise);
  function handleScopeResult(result) {
    if (result) {
      const error28 = unauthorizedError({
        message: "Unauthorized",
        failure: result
      });
      if (typeof error28 === "string") {
        throw new ForbiddenError(error28, result);
      }
      throw error28;
    }
  }
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/field-builders.js
var addScopes2 = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var objectFieldBuilder = ObjectFieldBuilder2.prototype;
objectFieldBuilder.withAuth = function withAuth2(scopes) {
  return addScopes2(scopes, new ObjectFieldBuilder2(this.typename, this.builder));
};
var interfaceFieldBuilder = InterfaceFieldBuilder2.prototype;
interfaceFieldBuilder.withAuth = function withAuth3(scopes) {
  return addScopes2(scopes, new InterfaceFieldBuilder2(this.typename, this.builder));
};
var queryFieldBuilder = QueryFieldBuilder2.prototype;
queryFieldBuilder.withAuth = function withAuth4(scopes) {
  return addScopes2(scopes, new QueryFieldBuilder2(this.builder));
};
var mutationFieldBuilder = MutationFieldBuilder2.prototype;
mutationFieldBuilder.withAuth = function withAuth5(scopes) {
  return addScopes2(scopes, new MutationFieldBuilder2(this.builder));
};
var subscriptionFieldBuilder = SubscriptionFieldBuilder2.prototype;
subscriptionFieldBuilder.withAuth = function withAuth6(scopes) {
  return addScopes2(scopes, new SubscriptionFieldBuilder2(this.builder));
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/is-type-of-helper.js
function isTypeOfHelper(steps, plugin3, isTypeOf) {
  var _plugin_builder_options_scopeAuthOptions;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin3.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const createError = (parent, context, info, result) => globalUnauthorizedError ? globalUnauthorizedError(parent, context, info, result) : result.message;
  return (parent, context, info) => {
    const cache2 = RequestCache.fromContext(context, plugin3.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache2, parent, {}, context, info, () => {
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error28 = createError(parent, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
                failure: result
              });
              throw typeof error28 === "string" ? new ForbiddenError(error28, result) : error28;
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error28 = createError(parent, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
            failure: stepResult
          });
          throw typeof error28 === "string" ? new ForbiddenError(error28, stepResult) : error28;
        }
      }
      return isTypeOf ? isTypeOf(parent, context, info) : true;
    }
    return runSteps(0);
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/resolve-helper.js
function resolveHelper(steps, plugin3, fieldConfig) {
  var _plugin_builder_options_scopeAuthOptions;
  var _fieldConfig_pothosOptions_unauthorizedResolver;
  const unauthorizedResolver = (_fieldConfig_pothosOptions_unauthorizedResolver = fieldConfig.pothosOptions.unauthorizedResolver) !== null && _fieldConfig_pothosOptions_unauthorizedResolver !== undefined ? _fieldConfig_pothosOptions_unauthorizedResolver : defaultUnauthorizedResolver;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin3.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const defaultUnauthorizedError = (parent, args, context, info, result) => {
    if (globalUnauthorizedError) {
      return globalUnauthorizedError(parent, context, info, result);
    }
    if ((result.failure.kind === AuthScopeFailureType.AuthScope || result.failure.kind === AuthScopeFailureType.AuthScopeFunction) && result.failure.error) {
      return result.failure.error;
    }
    return result.message;
  };
  var _fieldConfig_pothosOptions_unauthorizedError;
  const createError = (_fieldConfig_pothosOptions_unauthorizedError = fieldConfig.pothosOptions.unauthorizedError) !== null && _fieldConfig_pothosOptions_unauthorizedError !== undefined ? _fieldConfig_pothosOptions_unauthorizedError : defaultUnauthorizedError;
  return (parent, args, context, info) => {
    let resolvedValue;
    const cache2 = RequestCache.fromContext(context, plugin3.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache2, parent, args, context, info, (val) => {
          resolvedValue = val;
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error28 = createError(parent, args, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
                failure: result
              });
              return unauthorizedResolver(parent, args, context, info, typeof error28 === "string" ? new ForbiddenError(error28, result) : error28);
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error28 = createError(parent, args, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
            failure: stepResult
          });
          return unauthorizedResolver(parent, args, context, info, typeof error28 === "string" ? new ForbiddenError(error28, stepResult) : error28);
        }
      }
      return resolvedValue;
    }
    return runSteps(0);
  };
}
var defaultUnauthorizedResolver = (_root, _args, _context, _info, error28) => {
  throw error28;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/steps.js
function createTypeAuthScopesStep(authScopes, type73) {
  if (typeof authScopes === "function") {
    return {
      run: (state, parent, args, context, info) => state.evaluateTypeScopeFunction(authScopes, type73, parent, info),
      errorMessage: `Not authorized to read fields for ${type73}`
    };
  }
  return {
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info),
    errorMessage: `Not authorized to read fields for ${type73}`
  };
}
function createTypeGrantScopesStep(grantScopes, type73, forField) {
  return {
    run: (state, parent, args, context, info) => state.grantTypeScopes(type73, parent, forField ? info.path.prev : info.path, () => grantScopes(parent, context)),
    errorMessage: `Unknown error creating grants for ${type73}`
  };
}
function createFieldAuthScopesStep(authScopes) {
  if (typeof authScopes === "function") {
    return {
      errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
      run: (state, parent, args, context, info) => {
        const scopeMap = authScopes(parent, args, context, info);
        if (isThenable(scopeMap)) {
          return scopeMap.then((resolved) => state.evaluateScopeMap(resolved, info));
        }
        return state.evaluateScopeMap(scopeMap, info);
      }
    };
  }
  return {
    errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info)
  };
}
function createFieldGrantScopesStep(grantScopes) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue generating grants for ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => {
      if (typeof grantScopes !== "function") {
        state.saveGrantedScopes(grantScopes, info.path);
        return null;
      }
      const result = grantScopes(parent, args, context, info);
      if (isThenable(result)) {
        return result.then((resolved) => {
          state.saveGrantedScopes(resolved, info.path);
          return null;
        });
      }
      state.saveGrantedScopes(result, info.path);
      return null;
    }
  };
}
function createResolveStep(resolver) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue resolving ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info, setResolved) => {
      const result = resolver(parent, args, context, info);
      if (isThenable(result)) {
        return Promise.resolve(result).then((resolved) => {
          setResolved(resolved);
          return null;
        });
      }
      setResolved(result);
      return null;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/index.js
var pluginName5 = "scopeAuth";
var esm_default6 = pluginName5;
var inResolveType = false;

class PothosScopeAuthPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    var _this_builder_options_scopeAuthOptions, _this_builder_options_scopeAuthOptions1;
    if (this.options.disableScopeAuth) {
      return resolver;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    const authorizedOnSubscribe = !!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) && typeConfig.kind === "Subscription";
    const nonRoot = (typeConfig.graphqlKind === "Interface" || typeConfig.graphqlKind === "Object") && typeConfig.kind !== "Query" && typeConfig.kind !== "Mutation" && typeConfig.kind !== "Subscription";
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const runTypeScopesOnField = !nonRoot || !((_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions1 = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions1 === undefined ? undefined : _this_builder_options_scopeAuthOptions1.runScopesOnType) !== null && _ref !== undefined ? _ref : false);
    const steps2 = this.createResolveSteps(fieldConfig, typeConfig, resolver, runTypeScopesOnField, authorizedOnSubscribe);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return resolver;
  }
  wrapSubscribe(subscriber, fieldConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return subscriber;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    if (!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) || typeConfig.kind !== "Subscription") {
      return subscriber;
    }
    const steps2 = this.createSubscribeSteps(fieldConfig, typeConfig, subscriber);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return subscriber;
  }
  wrapResolveType(resolveType, typeConfig) {
    return (...args) => {
      inResolveType = true;
      try {
        return resolveType(...args);
      } finally {
        inResolveType = false;
      }
    };
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return isTypeOf;
    }
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const shouldRunTypeScopes = (_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.runScopesOnType) !== null && _ref !== undefined ? _ref : false;
    if (!shouldRunTypeScopes) {
      return isTypeOf;
    }
    const steps2 = this.createStepsForType(typeConfig, {
      forField: false
    });
    if (steps2.length === 0) {
      return isTypeOf;
    }
    const runSteps = isTypeOfHelper(steps2, this, isTypeOf);
    return (source2, context, info) => {
      if (inResolveType) {
        var _isTypeOf;
        var _isTypeOf1;
        return (_isTypeOf1 = (_isTypeOf = isTypeOf) === null || _isTypeOf === undefined ? undefined : _isTypeOf(source2, context, info)) !== null && _isTypeOf1 !== undefined ? _isTypeOf1 : false;
      }
      return runSteps(source2, context, info);
    };
  }
  createStepsForType(typeConfig, { skipTypeScopes, skipInterfaceScopes, forField }) {
    const parentAuthScope = typeConfig.pothosOptions.authScopes;
    const parentGrantScopes = typeConfig.pothosOptions.grantScopes;
    const interfaceConfigs = typeConfig.kind === "Object" || typeConfig.kind === "Interface" ? typeConfig.interfaces.map((iface) => this.buildCache.getTypeConfig(iface, "Interface")) : [];
    const steps2 = [];
    if (parentAuthScope && !skipTypeScopes) {
      steps2.push(createTypeAuthScopesStep(parentAuthScope, typeConfig.name));
    }
    if (!skipInterfaceScopes && !(typeConfig.kind === "Object" && typeConfig.pothosOptions.skipInterfaceScopes)) {
      interfaceConfigs.forEach((interfaceConfig) => {
        if (interfaceConfig.pothosOptions.authScopes) {
          steps2.push(createTypeAuthScopesStep(interfaceConfig.pothosOptions.authScopes, interfaceConfig.name));
        }
      });
    }
    if (parentGrantScopes) {
      steps2.push(createTypeGrantScopesStep(parentGrantScopes, typeConfig.name, forField));
    }
    return steps2;
  }
  createResolveSteps(fieldConfig, typeConfig, resolver, shouldRunTypeScopes, authorizedOnSubscribe) {
    var _ref, _ref1;
    const stepsForType = shouldRunTypeScopes && !authorizedOnSubscribe ? this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    }) : [];
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const fieldGrantScopes = fieldConfig.pothosOptions.grantScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes && !authorizedOnSubscribe) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(resolver));
    if (fieldGrantScopes) {
      steps2.push(createFieldGrantScopesStep(fieldGrantScopes));
    }
    return steps2;
  }
  createSubscribeSteps(fieldConfig, typeConfig, subscriber) {
    var _ref, _ref1;
    const stepsForType = this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    });
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(subscriber));
    return steps2;
  }
}
var fieldBuilderProto3 = RootFieldBuilder2.prototype;
fieldBuilderProto3.authField = function authField(options) {
  return this.field(options);
};
esm_default.registerPlugin(pluginName5, PothosScopeAuthPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/index.js
var _defineProperty29 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache.js
var _defineProperty27 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache-node.js
var _defineProperty26 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/field.js
var _defineProperty24 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/base.js
var _defineProperty23 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};

class BaseSubscriptionManager {
  addRegistration(options) {
    this.registrations.push(options);
    this.manager.register(options);
  }
  reRegister() {
    this.registrations.forEach((options) => void this.manager.register(options));
  }
  constructor(manager) {
    _defineProperty23(this, "manager", undefined);
    _defineProperty23(this, "registrations", []);
    this.manager = manager;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/field.js
class FieldSubscriptionManager extends BaseSubscriptionManager {
  register(name, { filter: filter2, invalidateCache } = {}) {
    this.addRegistration({
      name,
      filter: filter2,
      onValue: (value14) => {
        if (invalidateCache) {
          invalidateCache(value14);
        }
        return this.cacheNode.refetch();
      }
    });
  }
  constructor(manager, cacheNode) {
    super(manager);
    _defineProperty24(this, "cacheNode", undefined);
    this.cacheNode = cacheNode;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/type.js
var _defineProperty25 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
class TypeSubscriptionManager extends BaseSubscriptionManager {
  register(name, { filter: filter2, invalidateCache, refetch } = {}) {
    this.addRegistration({
      name,
      filter: filter2,
      onValue: (value14) => {
        if (invalidateCache) {
          invalidateCache(value14);
        }
        if (refetch) {
          let resultOrPromise;
          try {
            resultOrPromise = refetch(value14);
          } catch (error28) {
            this.manager.handleError(error28);
          }
          this.replace(resultOrPromise);
          return resultOrPromise;
        }
        return this.refetchParent();
      }
    });
  }
  constructor(manager, replace, refetchParent) {
    super(manager);
    _defineProperty25(this, "replace", undefined);
    _defineProperty25(this, "refetchParent", undefined);
    this.replace = replace;
    this.refetchParent = refetchParent;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache-node.js
class CacheNode {
  reRegister() {
    if (this.fieldManager) {
      this.fieldManager.reRegister();
    }
    this.typeManagers.forEach((manager) => void manager.reRegister());
  }
  managerForField() {
    this.fieldManager = new FieldSubscriptionManager(this.cache.manager, this);
    return this.fieldManager;
  }
  managerForType(key) {
    if (this.typeManagers.has(key)) {
      return null;
    }
    const typeManager = new TypeSubscriptionManager(this.cache.manager, (value14) => {
      this.replaceValue(value14, key);
    }, this.refetch);
    this.typeManagers.set(key, typeManager);
    return typeManager;
  }
  replaceValue(value14, key) {
    if (typeof key === "number") {
      if (!Array.isArray(this.value)) {
        throw new PothosValidationError("Expected value of CacheNode for list path to be an array");
      }
      this.cache.invalidPaths.push(`${this.path}.${key}`);
      this.value[key] = value14;
    } else {
      this.cache.invalidPaths.push(`${this.path}.`);
      this.value = value14;
    }
    this.typeManagers.delete(key);
  }
  constructor(cache2, path, value14, refetch) {
    _defineProperty26(this, "path", undefined);
    _defineProperty26(this, "value", undefined);
    _defineProperty26(this, "fieldManager", null);
    _defineProperty26(this, "typeManagers", new Map);
    _defineProperty26(this, "cache", undefined);
    _defineProperty26(this, "refetch", undefined);
    this.cache = cache2;
    this.path = path;
    this.value = value14;
    this.refetch = refetch;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache.js
class SubscriptionCache {
  get(path, reRegister) {
    const node3 = this.currentCache.get(path);
    if (!node3) {
      return null;
    }
    for (const invalid of this.prevInvalidPaths) {
      if (path.startsWith(invalid)) {
        return null;
      }
    }
    if (reRegister) {
      this.nextCache.set(path, node3);
      node3.reRegister();
    }
    return node3;
  }
  getTypeSubscriber(type74) {
    const config = this.buildCache.getTypeConfig(type74, "Object");
    if (config.graphqlKind === "Object") {
      var _config_pothosOptions_subscribe;
      return (_config_pothosOptions_subscribe = config.pothosOptions.subscribe) !== null && _config_pothosOptions_subscribe !== undefined ? _config_pothosOptions_subscribe : null;
    }
    return null;
  }
  getParent(info) {
    let parentPath = info.path.prev;
    if (!parentPath) {
      return null;
    }
    if (typeof parentPath.key === "number") {
      parentPath = parentPath.prev;
    }
    const parentKey = this.cacheKey(parentPath);
    if (this.nextCache.has(parentKey)) {
      return this.nextCache.get(parentKey);
    }
    return null;
  }
  managerForParentType(info) {
    const parentPath = info.path.prev;
    if (!parentPath) {
      return null;
    }
    const isListItem = typeof parentPath.key === "number";
    const parentKey = this.cacheKey(isListItem ? parentPath.prev : parentPath);
    const parentCacheNode = this.nextCache.get(parentKey);
    var _parentCacheNode_managerForType;
    return (_parentCacheNode_managerForType = parentCacheNode === null || parentCacheNode === undefined ? undefined : parentCacheNode.managerForType(parentPath.key)) !== null && _parentCacheNode_managerForType !== undefined ? _parentCacheNode_managerForType : null;
  }
  add(info, path, canRefetch, value14) {
    const parent = this.getParent(info);
    const node3 = new CacheNode(this, path, value14, canRefetch || !parent ? () => void this.invalidPaths.push(path) : parent.refetch);
    this.nextCache.set(path, node3);
    return node3;
  }
  next() {
    this.prevInvalidPaths = this.invalidPaths;
    this.invalidPaths = [];
    this.currentCache = this.nextCache;
    this.nextCache = new Map;
  }
  cacheKey(path) {
    let { key, prev } = path;
    while (prev) {
      key = `${prev.key}.${key}`;
      prev = prev.prev;
    }
    return key.toString();
  }
  constructor(manager, buildCache) {
    _defineProperty27(this, "manager", undefined);
    _defineProperty27(this, "buildCache", undefined);
    _defineProperty27(this, "currentCache", new Map);
    _defineProperty27(this, "nextCache", new Map);
    _defineProperty27(this, "invalidPaths", []);
    _defineProperty27(this, "prevInvalidPaths", []);
    this.manager = manager;
    this.buildCache = buildCache;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/create-field-data.js
function getFieldSubscribe(field3, plugin3) {
  if (field3.graphqlKind === "Object" && field3.kind !== "Mutation" && field3.kind !== "Subscription") {
    return field3.pothosOptions.subscribe;
  }
  if (field3.kind === "Subscription" && plugin3.smartSubscriptionsToQueryField.has(field3.name)) {
    return plugin3.smartSubscriptionsToQueryField.get(field3.name).subscribe;
  }
  return null;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/index.js
var _defineProperty28 = function(obj, key, value14) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value14,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value14;
  }
  return obj;
};
var _Symbol_asyncIterator = Symbol.asyncIterator;

class SubscriptionManager {
  register({ name, ...options }) {
    if (this.stopped) {
      return;
    }
    this.addOptions(name, options);
    if (this.nextSubscriptions.has(name)) {
      return;
    }
    this.nextSubscriptions.add(name);
    if (this.activeSubscriptions.has(name)) {
      return;
    }
    const maybePromise = this.subscribeToName(name, (err, value14) => {
      if (err) {
        this.handleError(err);
      } else {
        this.handleValue(name, value14);
      }
    });
    if (maybePromise) {
      maybePromise.catch((error28) => void this.handleError(error28));
    }
  }
  [_Symbol_asyncIterator]() {
    return this;
  }
  async return() {
    if (this.pendingError) {
      throw this.pendingError;
    }
    await this.stop();
    return {
      done: true,
      value: this.value
    };
  }
  async throw(error28) {
    this.handleError(error28);
    return Promise.reject(error28);
  }
  async next() {
    if (this.pendingError) {
      throw this.pendingError;
    }
    if (this.stopped) {
      return {
        done: true,
        value: this.value
      };
    }
    for (const name of this.activeSubscriptions) {
      if (!this.nextSubscriptions.has(name)) {
        await this.unsubscribeFromName(name);
      }
    }
    this.activeSubscriptions = this.nextSubscriptions;
    this.nextSubscriptions = new Set;
    this.activeOptions = this.nextOptions;
    this.nextOptions = new Map;
    if (this.pendingEvent) {
      this.pendingEvent = false;
      return {
        done: false,
        value: this.value
      };
    }
    return new Promise((resolve, reject2) => {
      this.resolveNext = (done = false) => {
        this.resolveNext = null;
        this.rejectNext = null;
        resolve({
          done,
          value: this.value
        });
      };
      this.rejectNext = (err) => {
        this.resolveNext = null;
        this.rejectNext = null;
        reject2(err);
      };
      const pending = this.pendingEvents;
      if (pending.length > 0) {
        this.pendingEvents = [];
        for (const [name, value14] of pending) {
          this.handleValue(name, value14);
        }
      }
    });
  }
  handleError(err) {
    this.pendingError = err;
    if (this.rejectNext) {
      this.rejectNext(err);
    }
    this.stop().catch((error28) => void this.handleError(error28));
  }
  async stop() {
    if (this.stopped) {
      return;
    }
    if (this.debounceRef) {
      clearTimeout(this.debounceRef);
      this.debounceRef = null;
    }
    this.stopped = true;
    const names = new Set([
      ...this.activeSubscriptions,
      ...this.nextSubscriptions
    ]);
    this.activeSubscriptions = new Set;
    this.nextSubscriptions = new Set;
    this.activeOptions = new Map;
    this.nextOptions = new Map;
    if (this.pendingError && this.rejectNext) {
      this.rejectNext(this.pendingError);
    } else if (this.resolveNext) {
      this.resolveNext(true);
    }
    for (const name of names) {
      await this.unsubscribeFromName(name);
    }
  }
  addOptions(name, options) {
    if (!this.nextOptions.has(name)) {
      this.nextOptions.set(name, []);
    }
    this.nextOptions.get(name).push(options);
  }
  filterValue(name, value14) {
    const optionsList = this.activeOptions.get(name);
    if (!optionsList) {
      return {
        allowed: true
      };
    }
    let allowed = false;
    const promises = [];
    for (const options of optionsList) {
      const currentAllowed = !options.filter || options.filter(value14);
      allowed = allowed || currentAllowed;
      if (currentAllowed && options.onValue) {
        const promise4 = options.onValue(value14);
        if (promise4) {
          promises.push(promise4);
        }
      }
    }
    return {
      allowed,
      promises: Promise.all(promises)
    };
  }
  handleValue(name, value14) {
    if (this.stopped) {
      return;
    }
    if (!this.resolveNext) {
      this.pendingEvents.push([
        name,
        value14
      ]);
      return;
    }
    const { allowed, promises } = this.filterValue(name, value14);
    if (promises) {
      promises.catch((error28) => void this.handleError(error28));
    }
    if (!allowed) {
      return;
    }
    if (this.debounceRef) {
      return;
    }
    if (this.debounceDelay === null) {
      this.pushValue();
    } else {
      this.debounceRef = setTimeout(() => {
        this.debounceRef = null;
        this.pushValue();
      }, this.debounceDelay);
      if (typeof this.debounceRef === "object" && ("unref" in this.debounceRef)) {
        this.debounceRef.unref();
      }
    }
  }
  pushValue() {
    if (this.stopped) {
      return;
    }
    if (this.resolveNext) {
      this.resolveNext();
    } else {
      this.pendingEvent = true;
    }
  }
  constructor({ value: value14, debounceDelay, subscribe: subscribe3, unsubscribe }) {
    _defineProperty28(this, "activeSubscriptions", new Set);
    _defineProperty28(this, "nextSubscriptions", new Set);
    _defineProperty28(this, "activeOptions", new Map);
    _defineProperty28(this, "nextOptions", new Map);
    _defineProperty28(this, "subscribeToName", undefined);
    _defineProperty28(this, "unsubscribeFromName", undefined);
    _defineProperty28(this, "pendingEvent", true);
    _defineProperty28(this, "pendingError", undefined);
    _defineProperty28(this, "pendingEvents", []);
    _defineProperty28(this, "value", undefined);
    _defineProperty28(this, "resolveNext", null);
    _defineProperty28(this, "rejectNext", null);
    _defineProperty28(this, "stopped", false);
    _defineProperty28(this, "debounceDelay", null);
    _defineProperty28(this, "debounceRef", null);
    this.subscribeToName = subscribe3;
    this.unsubscribeFromName = unsubscribe;
    this.value = value14;
    this.debounceDelay = debounceDelay !== null && debounceDelay !== undefined ? debounceDelay : null;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/resolve-with-cache.js
function resolveWithCache(cache2, subscribe3, resolve, canRefetch, parent, args, context, info) {
  const key = cache2.cacheKey(info.path);
  const existingCacheNode = cache2.get(key, true);
  if (existingCacheNode) {
    return existingCacheNode.value;
  }
  const parentSubscriber = cache2.getTypeSubscriber(info.parentType.name);
  if (parentSubscriber) {
    const parentManager = cache2.managerForParentType(info);
    if (parentManager) {
      parentSubscriber(parentManager, parent, context, info);
    }
  }
  const resultOrPromise = resolve(parent, args, context, info);
  function cacheResult(result) {
    const cacheNode = cache2.add(info, key, canRefetch, result);
    subscribe3 === null || subscribe3 === undefined || subscribe3(cacheNode.managerForField(), parent, args, context, info);
    return result;
  }
  return isThenable(resultOrPromise) ? resultOrPromise.then(cacheResult) : cacheResult(resultOrPromise);
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/index.js
var DEFAULT_DEBOUNCE_DELAY = 10;
var pluginName6 = "smartSubscriptions";
var esm_default7 = pluginName6;

class PothosSmartSubscriptionsPlugin extends BasePlugin {
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "Query" && fieldConfig.pothosOptions.smartSubscription) {
      this.smartSubscriptionsToQueryField.set(fieldConfig.name, fieldConfig);
      var _fieldConfig_resolve;
      this.builder.subscriptionField(fieldConfig.name, (t2) => t2.field({
        ...fieldConfig.pothosOptions,
        resolve: (parent, args, context, info) => ((_fieldConfig_resolve = fieldConfig.resolve) !== null && _fieldConfig_resolve !== undefined ? _fieldConfig_resolve : defaultFieldResolver)(parent, args, context, info),
        subscribe: (parent, args, context, info) => {
          const manager2 = new SubscriptionManager({
            value: parent,
            debounceDelay: this.debounceDelay,
            subscribe: (subName, cb) => this.subscribe(subName, context, cb),
            unsubscribe: (subName) => this.unsubscribe(subName, context)
          });
          const cache3 = new SubscriptionCache(manager2, this.buildCache);
          this.requestData(context).cache = cache3;
          return {
            [Symbol.asyncIterator]() {
              return {
                async next() {
                  return manager2.next().then((next) => {
                    cache3.next();
                    return next;
                  });
                },
                async return() {
                  return manager2.return();
                },
                async throw(error28) {
                  return manager2.throw(error28);
                }
              };
            }
          };
        }
      }));
    }
    return fieldConfig;
  }
  createRequestData(context) {
    return {};
  }
  wrapResolve(resolve, field3) {
    let canRefetch = false;
    if (field3.graphqlKind === "Object" && field3.kind !== "Query" && field3.kind !== "Subscription" && field3.kind !== "Mutation") {
      var _field_pothosOptions_canRefetch;
      canRefetch = (_field_pothosOptions_canRefetch = field3.pothosOptions.canRefetch) !== null && _field_pothosOptions_canRefetch !== undefined ? _field_pothosOptions_canRefetch : false;
    }
    const subscribe3 = getFieldSubscribe(field3, this);
    return (parent, args, context, info) => {
      const { cache: cache3 } = this.requestData(context);
      if (!cache3) {
        return resolve(parent, args, context, info);
      }
      return resolveWithCache(cache3, subscribe3, resolve, canRefetch, parent, args, context, info);
    };
  }
  wrapResolveType(resolveType) {
    return resolveType;
  }
  constructor(buildCache) {
    super(buildCache, pluginName6);
    _defineProperty29(this, "debounceDelay", undefined);
    _defineProperty29(this, "smartSubscriptionsToQueryField", new Map);
    _defineProperty29(this, "subscribe", undefined);
    _defineProperty29(this, "unsubscribe", undefined);
    this.subscribe = this.builder.options.smartSubscriptions.subscribe;
    this.unsubscribe = this.builder.options.smartSubscriptions.unsubscribe;
    var _this_builder_options_smartSubscriptions_debounceDelay;
    this.debounceDelay = (_this_builder_options_smartSubscriptions_debounceDelay = this.builder.options.smartSubscriptions.debounceDelay) !== null && _this_builder_options_smartSubscriptions_debounceDelay !== undefined ? _this_builder_options_smartSubscriptions_debounceDelay : DEFAULT_DEBOUNCE_DELAY;
  }
}
esm_default.registerPlugin(pluginName6, PothosSmartSubscriptionsPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-simple-objects/esm/index.js
var pluginName7 = "simpleObjects";
var esm_default8 = pluginName7;

class PothosSimpleObjectsPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName7, PothosSimpleObjectsPlugin);
var proto = esm_default.prototype;
proto.simpleObject = function simpleObject(name, options, extraFields) {
  const ref3 = new ObjectRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t2) => {
      const fields = originalFields(t2);
      Object.keys(fields).forEach((key) => {
        this.configStore.onFieldUse(fields[key], (config) => {
          if (config.kind === "Object") {
            config.resolve = (parent) => parent[key];
          }
        });
      });
      return fields;
    };
  }
  this.objectType(ref3, options);
  if (extraFields) {
    this.objectFields(ref3, extraFields);
  }
  return ref3;
};
proto.simpleInterface = function simpleInterface(name, options, extraFields) {
  const ref3 = new InterfaceRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t2) => {
      const fields = originalFields(t2);
      Object.keys(fields).forEach((key) => {
        this.configStore.onFieldUse(fields[key], (config) => {
          if (config.kind === "Interface") {
            config.resolve = (parent) => parent[key];
          }
        });
      });
      return fields;
    };
  }
  this.interfaceType(ref3, options);
  if (extraFields) {
    this.interfaceFields(ref3, extraFields);
  }
  return ref3;
};

// src/graphql/builder.ts
function u2(input6) {
  return input6 ?? undefined;
}
function uParseInt(input6) {
  return input6 ? parseInt(input6) : undefined;
}
var encodeGlobalID2 = (typename, id) => {
  return `${typename}_${id}`;
};
var decodeGlobalID2 = (globalId) => {
  const [typename, ...idElements] = globalId.split("_");
  const id = idElements.join("_");
  if (!typename || !id)
    throw new Error("Invalid Relay ID");
  return { typename, id };
};
var builder5 = new esm_default({
  plugins: [
    esm_default2,
    esm_default6,
    esm_default3,
    esm_default4,
    esm_default5,
    esm_default7,
    esm_default8
  ],
  relayOptions: {
    clientMutationId: "omit",
    cursorType: "ID",
    edgesFieldOptions: {
      nullable: false
    },
    nodeFieldOptions: {
      nullable: false
    },
    encodeGlobalID: encodeGlobalID2,
    decodeGlobalID: decodeGlobalID2
  },
  prisma: {
    client: prisma,
    exposeDescriptions: true,
    filterConnectionTotalCount: true
  },
  authScopes: async (context) => {
    return {
      public: true,
      authenticated: () => context.isSessionValid()
    };
  },
  scopeAuthOptions: {
    unauthorizedError: (_, __, info) => {
      const errors19 = {
        query: "You need to be logged in to see this.",
        mutation: "You need to be logged in to do this.",
        subscription: "You need to be logged in to see this.",
        _default: "You need to be logged in to do this."
      };
      return new GraphQLError(errors19[info.operation.operation] ?? errors19._default, {
        extensions: {
          code: "UNAUTHENTICATED",
          userFriendlyMessage: errors19[info.operation.operation] ?? errors19._default
        }
      });
    }
  },
  smartSubscriptions: {
    subscribe: async ($name, context, callback) => {
      const name = $name;
      if (!context.subscriptions[name])
        context.subscriptions[name] = pubsub.subscribe(name);
      for await (const data of context.subscriptions[name]) {
        callback(undefined, data);
      }
    },
    unsubscribe: ($name, context) => {
      const name = $name;
      context.subscriptions[name]?.return?.();
      delete context.subscriptions[name];
    }
  }
});
builder5.queryType({ authScopes: { authenticated: true } });
builder5.mutationType({ authScopes: { authenticated: true } });
builder5.subscriptionType({ authScopes: { authenticated: true } });
builder5.addScalarType("Date", GraphQLDate, {});
builder5.addScalarType("DateTime", GraphQLDateTime, {});
builder5.addScalarType("PositiveInt", GraphQLPositiveInt, {});
builder5.addScalarType("JSON", GraphQLJSON, {});
builder5.scalarType("Time", {
  description: "A time of day, represented as a string in the format `HH:mm`. For example, `16:20`.",
  serialize: (value14) => dayjs(value14).utc(false).format("HH:mm"),
  parseValue: (value14) => {
    const dayjsObj = dayjs(`1970-01-01 ${value14}`, "YYYY-MM-DD HH:mm", true).utc(true);
    if (!dayjsObj.isValid()) {
      throw new GraphQLError(`Invalid time "${value14}". Should be in the format \`HH:mm\`. For example, \`16:20\`.`);
    }
    return dayjsObj.toDate();
  }
});

// src/graphql/Color.ts
var values3 = {
  slate: { value: "slate" },
  gray: { value: "gray" },
  zinc: { value: "zinc" },
  neutral: { value: "neutral" },
  stone: { value: "stone" },
  red: { value: "red" },
  orange: { value: "orange" },
  amber: { value: "amber" },
  yellow: { value: "yellow" },
  lime: { value: "lime" },
  green: { value: "green" },
  emerald: { value: "emerald" },
  teal: { value: "teal" },
  cyan: { value: "cyan" },
  sky: { value: "sky" },
  blue: { value: "blue" },
  indigo: { value: "indigo" },
  violet: { value: "violet" },
  purple: { value: "purple" },
  fuchsia: { value: "fuchsia" },
  pink: { value: "pink" },
  rose: { value: "rose" }
};
var ColorEnum = builder5.enumType("Color", { values: values3 });

// src/utils/getDays.ts
var getStartFromConnectionArgs = ({ after, before, last }) => {
  let start = new Date;
  if (after) {
    const afterDate = new Date(after);
    start = addDays(afterDate, 1);
  } else if (last) {
    const beforeDate = new Date(before ?? start);
    start = addDays(beforeDate, (before ? 0 : 1) - last);
  }
  return startOfDay(start);
};
var startOfDay = (day2 = new Date) => {
  return new Date(day2.setUTCHours(0, 0, 0, 0));
};
var endOfDay = (day2 = new Date) => {
  return new Date(day2.setUTCHours(23, 59, 59, 999));
};
var addDays = (day2 = new Date, days) => {
  return new Date(day2.setDate(day2.getDate() + days));
};
var getDayOfWeek = (date4) => {
  return dayOfWeekArr[date4.getDay()];
};
var dayOfWeekArr = [
  "SUNDAY",
  "MONDAY",
  "TUESDAY",
  "WEDNESDAY",
  "THURSDAY",
  "FRIDAY",
  "SATURDAY"
];
var toDateOnly = (date4) => {
  const dateString = date4.toJSON();
  return dateString.split("T")[0] ?? dateString;
};

// src/graphql/Day.ts
var DayType = builder5.prismaNode("Day", {
  id: { resolve: (day2) => toDateOnly(day2.date) },
  findUnique: (date4) => ({ date: new Date(date4) }),
  nullable: true,
  extensions: {
    resolveWhenNull: (findUniqueRes) => createEmptyNode(findUniqueRes)
  },
  fields: (t2) => ({
    date: t2.expose("date", { type: "Date", description: "The date of the day." }),
    notes: t2.relation("notes"),
    tasks: t2.prismaField({
      type: ["Task"],
      resolve: async (query3, day2) => {
        const dayInfo = await prisma.day.findUnique({
          where: { date: day2.date },
          select: { tasksOrder: true }
        });
        const order = dayInfo?.tasksOrder ?? day2.tasksOrder;
        const tasks = await prisma.task.findMany({
          ...query3,
          where: { date: day2.date }
        });
        const tasksOrdered = tasks.sort((a2, b2) => {
          return order.indexOf(a2.id) - order.indexOf(b2.id);
        });
        return tasksOrdered;
      }
    }),
    routines: t2.prismaField({
      type: ["Routine"],
      description: "The routines for the day in chronological order.",
      select: { date: true, routinesCompleted: { select: { id: true } } },
      resolve: async (query3, day2) => {
        const completedRoutineIds = new Set(day2.routinesCompleted.map((routine) => routine.id));
        const routines = await prisma.routine.findMany({
          ...query3,
          orderBy: { time: "asc" },
          where: {
            isActive: true,
            repeats: { has: getDayOfWeek(day2.date) },
            firstDay: { lte: day2.date },
            OR: [{ lastDay: null }, { lastDay: { gte: day2.date } }]
          }
        });
        return routines.map((routine) => ({
          ...routine,
          _done: completedRoutineIds.has(routine.id)
        }));
      }
    })
  })
});
builder5.queryField("days", (t2) => t2.connection({
  type: DayType,
  extensions: {
    pothosPrismaFallback: () => console.log("fallback")
  },
  description: `Get days using a Relay connection.

If no arguments are provided, it will return the current day.

If \`first\` (Int) is provided, it will return the current day and the following days.

If \`after\` (Date*) is provided, it will return the days after the given date.

If \`last\` (Int) is provided, it will return the current day and the previous days.

If \`before\` (Date*) is provided, it will return the days before the given date.

*Ignore that the GraphQL type is ID as Pothos doesn't support overriding the type of the connection fields.
Please input a Date in the format: YYYY-MM-DD`,
  resolve: async (_, args, context, info) => {
    const start = getStartFromConnectionArgs(args);
    const totalDays = args.first ?? args.last ?? 1;
    const end = endOfDay(new Date(start));
    end.setDate(end.getDate() + totalDays - 1);
    const days = await prisma.day.findMany({
      ...queryFromInfo({ context, info, typeName: "Day", path: ["edges", "node"] }),
      where: { date: { gte: start, lte: end } }
    });
    const dayMap = new Map(days.map((day2) => [toDateOnly(day2.date), day2]));
    const dayEdges = [];
    const dateCursor = new Date(start);
    for (const _2 of Array.from({ length: totalDays })) {
      const day2 = toDateOnly(dateCursor);
      dayEdges.push({
        cursor: day2,
        node: dayMap.get(day2) ?? createEmptyNode({ date: new Date(dateCursor) })
      });
      dateCursor.setDate(dateCursor.getDate() + 1);
    }
    return {
      edges: dayEdges,
      pageInfo: {
        hasNextPage: true,
        hasPreviousPage: true,
        startCursor: toDateOnly(start),
        endCursor: toDateOnly(end)
      }
    };
  }
}));
var createEmptyNode = ({ date: date4 }) => ({
  __typename: "Day",
  id: `Day_${toDateOnly(date4)}`,
  date: date4,
  tasksOrder: [],
  notes: [],
  routines: [],
  routinesCompleted: [],
  tasks: []
});

// src/graphql/ItemPluginData.ts
var ItemPluginDataType = builder5.prismaNode("ItemPluginData", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    updatedAt: t2.expose("updatedAt", { type: "DateTime" }),
    min: t2.expose("min", { type: "JSON" }),
    full: t2.expose("full", { type: "JSON" }),
    pluginSlug: t2.exposeString("pluginSlug")
  })
});
var ItemPluginDataInput = builder5.inputType(builder5.inputRef("ItemPluginDataInput"), {
  fields: (t2) => ({
    pluginSlug: t2.string({ required: true }),
    originalId: t2.string({ required: false }),
    min: t2.field({ type: "JSON", required: true }),
    full: t2.field({ type: "JSON", required: true })
  })
});

// src/graphql/PrismaFilters.ts
var DateFilter = builder5.prismaFilter("Date", {
  name: "PrismaDateFilter",
  description: "Filter input of Date",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var DateTimeFilter = builder5.prismaFilter("DateTime", {
  name: "PrismaDateTimeFilter",
  description: "Filter input of DateTime",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var IntFilter = builder5.prismaFilter("Int", {
  name: "PrismaIntFilter",
  description: "Filter input of Int",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});

// src/utils/getPlugins.ts
import fs from "fs/promises";
import path from "path";

// src/utils/pgBoss.ts
var import_pg_boss = __toESM(require_src(), 1);
var pgBoss = new import_pg_boss.default(env.DATABASE_URL ?? "postgresql://postgres@localhost:5432/flow");
pgBoss.on("error", (error28) => {
  console.log("pg-boss error:", error28);
});

// /Users/richardguerre/Projects/flow/node_modules/@flowdev/nearest-color/src/index.ts
var hexToRgb = function(hex) {
  if (hex.length === 4) {
    hex = hex.replace(/#([a-f0-9])/i, "$1$1");
  }
  const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return {
    r: parseInt(res[1], 16),
    g: parseInt(res[2], 16),
    b: parseInt(res[3], 16)
  };
};
var nearestColor = (colorPallette, color) => {
  if (typeof color === "string") {
    color = hexToRgb(color);
  }
  const rgbColor = color;
  const colorKeys = Object.keys(colorPallette);
  const colorValues = colorKeys.map((key) => hexToRgb(colorPallette[key]));
  const colorDistances = colorValues.map((value14) => {
    return Math.sqrt(Math.pow(value14.r - rgbColor.r, 2) + Math.pow(value14.g - rgbColor.g, 2) + Math.pow(value14.b - rgbColor.b, 2));
  });
  const minDistance = Math.min(...colorDistances);
  const minDistanceIndex = colorDistances.indexOf(minDistance);
  return colorKeys[minDistanceIndex];
};

// src/utils/nearestTailwindColor.ts
var colorPalette = {
  slate: "#cbd5e1",
  gray: "#d1d5db",
  zinc: "#d4d4d8",
  neutral: "#d4d4d4",
  stone: "#d6d3d1",
  red: "#fca5a5",
  orange: "#fdba74",
  amber: "#fcd34d",
  yellow: "#fde047",
  lime: "#bef264",
  green: "#86efac",
  emerald: "#6ee7b7",
  teal: "#5eead4",
  cyan: "#67e8f9",
  sky: "#7dd3fc",
  blue: "#93c5fd",
  indigo: "#a5b4fc",
  violet: "#c4b5fd",
  purple: "#d8b4fe",
  fuchsia: "#f0abfc",
  pink: "#f9a8d4",
  rose: "#fda4af"
};
var nearestTailwindColor = (color) => nearestColor(colorPalette, color);

// src/utils/index.ts
var ROLLOVER_TASKS_JOB_NAME = "rollover-tasks-to-today";
var ROLLOVER_TASKS_CRON = "0 4 * * *";
var syncTasks = async () => {
  console.log("-- Syncing tasks...");
  const usersTimezone = await getTimezone();
  const usersToday = dayjs().tz(usersTimezone).utc(true).startOf("day").toDate();
  await prisma.day.upsert({
    where: { date: usersToday },
    create: { date: usersToday },
    update: {}
  });
  const res = await prisma.task.updateMany({
    where: {
      status: { notIn: ["DONE", "CANCELED"] },
      date: { lt: usersToday },
      OR: [{ item: null }, { item: { scheduledAt: null } }]
    },
    data: { date: usersToday }
  });
  console.log(`\u2705 Synced ${res.count} tasks.`);
};
var scheduleRolloverTasks = async (timezone3 = "Etc/GMT-11") => {
  await pgBoss.schedule(ROLLOVER_TASKS_JOB_NAME, ROLLOVER_TASKS_CRON, undefined, {
    tz: timezone3,
    singletonKey: ROLLOVER_TASKS_JOB_NAME
  });
  console.log(`\u2705 Scheduled "${ROLLOVER_TASKS_JOB_NAME}" job.`);
};
var isSessionTokenValid = async (sessionToken) => {
  if (!sessionToken) {
    return false;
  } else {
    const sessionItem = await prisma.store.findFirst({
      where: {
        pluginSlug: FlowPluginSlug,
        key: { startsWith: StoreKeys.AUTH_SESSION_PREFIX },
        AND: [
          { value: { path: ["token"], equals: sessionToken } },
          { value: { path: ["expiresAt"], gt: new Date().toISOString() } }
        ]
      }
    });
    if (!sessionItem) {
      return false;
    }
  }
  return true;
};
var getTimezone = async () => {
  const timezoneItem = await prisma.store.findFirst({
    where: {
      pluginSlug: FlowPluginSlug,
      key: StoreKeys.TIMEZONE
    }
  });
  const timezone3 = timezoneItem?.value;
  try {
    dayjs().tz(timezone3);
    return timezone3;
  } catch {
    return;
  }
};

// src/graphql/Store.ts
var FlowPluginSlug = "flow";
var StoreKeys = {
  INSTALLED_PLUGINS: "installed-plugins",
  PASSWORD_HASH: "password-hash",
  AUTH_SESSION_PREFIX: "session-",
  TIMEZONE: "timezone"
};
var StoreType = builder5.prismaNode("Store", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    updatedAt: t2.expose("updatedAt", { type: "DateTime" }),
    key: t2.exposeString("key"),
    pluginSlug: t2.exposeString("pluginSlug"),
    isSecret: t2.exposeBoolean("isSecret"),
    isServerOnly: t2.exposeBoolean("isServerOnly"),
    value: t2.field({
      type: "JSON",
      nullable: true,
      description: "The value of the store item.",
      resolve: (store) => store.isSecret || store.isServerOnly ? null : store.value
    })
  })
});
builder5.queryField("storeItems", (t2) => t2.prismaFieldWithInput({
  type: ["Store"],
  description: `Get store items.

Pass the \`pluginSlug\` if you want to get items created by a specific plugin. Not passing the \`pluginSlug\` will return items created by flow.`,
  input: {
    pluginSlug: t2.input.string({ required: false }),
    keys: t2.input.stringList({ required: false })
  },
  argOptions: {
    required: false,
    name: "where"
  },
  resolve: (query3, _, args) => {
    return prisma.store.findMany({
      ...query3,
      where: {
        ...args.where?.pluginSlug ? { pluginSlug: args.where?.pluginSlug } : {},
        ...args.where?.keys?.length ? { key: { in: args.where.keys } } : {}
      }
    });
  }
}));
builder5.queryField("isPasswordSet", (t2) => t2.field({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "Boolean",
  description: "Whether the password is set.",
  resolve: async () => {
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    }).catch(() => null);
    return !!passwordSetting;
  }
}));
builder5.queryField("timezoneSet", (t2) => t2.field({
  type: "String",
  description: "The timezone set for the Flow instance. `null` if no timezone is set.",
  nullable: true,
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: async () => {
    const timezoneSetting = await prisma.store.findUnique({
      where: { pluginSlug_key_unique: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug } }
    }).catch(() => null);
    return timezoneSetting?.value ?? null;
  }
}));
builder5.queryField("isFullySetup", (t2) => t2.field({
  type: "Boolean",
  description: "Whether the Flow instance is fully setup.",
  nullable: false,
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: async () => {
    const storeItems = await prisma.store.findMany({
      where: {
        key: { in: [StoreKeys.PASSWORD_HASH, StoreKeys.TIMEZONE] },
        pluginSlug: FlowPluginSlug
      }
    });
    return storeItems.length === 2;
  }
}));
builder5.queryField("isSessionValid", (t2) => t2.field({
  type: "Boolean",
  description: "Whether the session is valid.",
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: (_, __, context) => context.isSessionValid()
}));
builder5.queryField("installedPlugins", (t2) => t2.field({
  type: [PluginInstallationType],
  description: "Get all installed plugins.",
  resolve: getPluginsInStore
}));
var PluginInstallationType = builder5.objectType(builder5.objectRef("PluginInstallation"), {
  fields: (t2) => ({
    slug: t2.exposeString("slug"),
    url: t2.exposeString("url"),
    hasWebRuntime: t2.exposeBoolean("web"),
    hasServerRuntime: t2.exposeBoolean("server")
  })
});
builder5.mutationField("upsertStoreItem", (t2) => t2.prismaFieldWithInput({
  type: "Store",
  description: `Creates a store item. If a store item with the same key exists, only its value will be updated (\`isSecret\` and \`isServerOnly\` will not be updated).

If the \`pluginSlug\` is passed, it will create/update a store item for that plugin. Otherwise, it will create/update a store item for flow.

If \`isSecret\` is set to true, \`isServerOnly\` will also be set to true and will not be returned in the \`storeItems\` query (it will be \`null\`). The item will only be accessible by plugin with the same \`pluginSlug\` in the server.

If \`isServerOnly\` is set to true, the store item will not be returned in the \`storeItems\` query (it will be \`null\`). The item will be accessible by all plugins in the server.`,
  input: {
    key: t2.input.string({ required: true }),
    value: t2.input.field({ type: "JSON", required: true }),
    pluginSlug: t2.input.string({ required: true }),
    isSecret: t2.input.boolean({ required: false }),
    isServerOnly: t2.input.boolean({ required: false })
  },
  resolve: async (query3, _, args) => {
    if (args.input.pluginSlug === "flow") {
      throw new GraphQLError("The slug 'flow' is reserved for internal use. Please use your plugin's slug.", {
        extensions: {
          code: "KEY_RESERVED",
          userFriendlyMessage: "The item couldn't be saved. Please ask the plugin author for more information."
        }
      });
    }
    const res = await prisma.store.upsert({
      ...query3,
      where: {
        pluginSlug_key_unique: { key: args.input.key, pluginSlug: args.input.pluginSlug }
      },
      update: { value: args.input.value },
      create: {
        key: args.input.key,
        value: args.input.value,
        pluginSlug: args.input.pluginSlug,
        isSecret: args.input.isSecret ?? false,
        isServerOnly: args.input.isServerOnly ?? args.input.isSecret ?? false
      }
    });
    const plugins4 = await getPlugins2();
    const plugin3 = plugins4[args.input.pluginSlug];
    await plugin3?.onStoreItemUpsert?.(args.input.key).catch((e2) => console.log(`Error plugin.onStoreItemUpsert for ${args.input.pluginSlug}`, e2));
    return res;
  }
}));
builder5.mutationField("installPlugin", (t2) => t2.fieldWithInput({
  type: [PluginInstallationType],
  description: "Install a plugin. If a plugin with the same slug exists, it will throw an error, unless `override` is set to true.",
  input: {
    url: t2.input.string({ required: true }),
    override: t2.input.boolean({ required: false })
  },
  resolve: async (_, args) => {
    let installedPlugins = await getPluginsInStore();
    const newPluginJson = await getPluginJson({ url: args.input.url });
    if (!args.input.override && installedPlugins.find((p2) => p2.slug === newPluginJson.slug)) {
      throw new GraphQLError(`A plugin with the slug "${newPluginJson.slug}" is already installed. Use the \`override\` option to override the existing plugin.`, {
        extensions: {
          code: "PLUGIN_WITH_SAME_SLUG",
          userFriendlyMessage: "There is a problem with the plugin you are trying to install (Error: PLUGIN_WITH_SAME_SLUG). Please contact the plugin author for more information."
        }
      });
    }
    if (newPluginJson.slug.includes("_")) {
      throw new GraphQLError(`The plugin slug "${newPluginJson.slug}" is invalid. Plugin slugs cannot contain underscores.`, {
        extensions: {
          code: "PLUGIN_SLUG_INVALID",
          userFriendlyMessage: "There is a problem with the plugin you are trying to install (Err: PLUGIN_SLUG_INVALID). Please contact the plugin author for more information."
        }
      });
    }
    if (newPluginJson.server) {
      await installServerPlugin({
        url: args.input.url,
        slug: newPluginJson.slug,
        override: args.input.override ?? false
      });
    }
    installedPlugins = installedPlugins.filter((p2) => p2.slug !== newPluginJson.slug);
    installedPlugins.push({
      url: args.input.url,
      slug: newPluginJson.slug,
      web: newPluginJson.web ?? false,
      server: newPluginJson.server ?? false
    });
    const newSetting = await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.INSTALLED_PLUGINS, pluginSlug: FlowPluginSlug }
      },
      update: { value: installedPlugins },
      create: {
        key: StoreKeys.INSTALLED_PLUGINS,
        pluginSlug: FlowPluginSlug,
        value: installedPlugins,
        isSecret: false,
        isServerOnly: false
      }
    });
    return newSetting.value;
  }
}));
builder5.mutationField("uninstallPlugin", (t2) => t2.fieldWithInput({
  type: [PluginInstallationType],
  description: "Uninstall a plugin.",
  input: {
    slug: t2.input.string({ required: true })
  },
  resolve: async (_, args) => {
    let installedPlugins = await getPluginsInStore();
    await uninstallServerPlugin(args.input.slug);
    installedPlugins = installedPlugins.filter((p2) => p2.slug !== args.input.slug);
    const newSetting = await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.INSTALLED_PLUGINS, pluginSlug: FlowPluginSlug }
      },
      update: { value: installedPlugins },
      create: {
        key: StoreKeys.INSTALLED_PLUGINS,
        pluginSlug: FlowPluginSlug,
        value: installedPlugins,
        isSecret: false,
        isServerOnly: false
      }
    });
    return newSetting.value;
  }
}));
var generatePasswordHash = async (password) => {
  return Bun.password.hash(password, "bcrypt");
};
var generateSessionToken = () => {
  return new Bun.CryptoHasher("sha256").digest("base64");
};
builder5.mutationField("setPassword", (t2) => t2.fieldWithInput({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "String",
  description: "Set password for the Flow instance and get a session token to make authenticated requests.",
  input: {
    password: t2.input.string({ required: true, description: "The password to set (unhashed)." })
  },
  resolve: async (_, args, context) => {
    if (args.input.password.length < 8) {
      throw new GraphQLError("The password must be at least 8 characters long.", {
        extensions: { code: "PASSWORD_TOO_SHORT" }
      });
    }
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (passwordSetting) {
      throw new GraphQLError("The password can only be set once. Use the `changePassword` mutation to change the password.", { extensions: { code: "PASSWORD_ALREADY_SET" } });
    }
    const passwordHash = await generatePasswordHash(args.input.password);
    await prisma.store.create({
      data: {
        key: StoreKeys.PASSWORD_HASH,
        pluginSlug: FlowPluginSlug,
        value: passwordHash,
        isSecret: true,
        isServerOnly: true
      }
    }).catch((e2) => {
      console.error(e2);
      throw new GraphQLError(e2.message ?? "Something went wrong while setting the password.", {
        extensions: {
          code: "PASSWORD_SET_ERROR",
          userFriendlyMessage: "Something went wrong while setting the password."
        }
      });
    });
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    return sessionToken;
  }
}));
builder5.mutationField("changePassword", (t2) => t2.fieldWithInput({
  type: "String",
  description: "Change password for the Flow instance and get a new session token to make authenticated requests.",
  input: {
    oldPassword: t2.input.string({ required: true, description: "The old password (unhashed)." }),
    newPassword: t2.input.string({ required: true, description: "The new password (unhashed)." })
  },
  resolve: async (_, args, context) => {
    if (args.input.newPassword.length < 8) {
      throw new GraphQLError("The new password must be at least 8 characters.", {
        extensions: { code: "PASSWORD_TOO_SHORT" }
      });
    }
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (!passwordSetting) {
      throw new GraphQLError("The password is not set. Use the `setPassword` mutation to set the password.", {
        extensions: {
          code: "PASSWORD_NOT_SET",
          userFriendlyMessage: "No password was set for your Flow yet. Please refresh the page to set the password."
        }
      });
    }
    const isOldPasswordCorrect = await Bun.password.verify(args.input.oldPassword, passwordSetting.value);
    if (!isOldPasswordCorrect) {
      throw new GraphQLError("The old password is incorrect.", {
        extensions: { code: "PASSWORD_INCORRECT" }
      });
    }
    const newPasswordHash = await generatePasswordHash(args.input.newPassword);
    await prisma.store.update({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      },
      data: { value: newPasswordHash }
    }).catch((e2) => {
      console.error(e2);
      throw new GraphQLError(e2.message ?? "Something went wrong while changing the password.", {
        extensions: {
          code: "PASSWORD_CHANGE_ERROR",
          userFriendlyMessage: "Something went wrong while changing the password."
        }
      });
    });
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    await prisma.store.deleteMany({
      where: { pluginSlug: FlowPluginSlug, key: { not: authSessionKey } }
    });
    return sessionToken;
  }
}));
builder5.mutationField("login", (t2) => t2.fieldWithInput({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "String",
  description: "Login to the Flow instance and get a session token to make authenticated requests.",
  input: {
    password: t2.input.string({ required: true, description: "The password (unhashed)." })
  },
  resolve: async (_, args, context) => {
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (!passwordSetting) {
      throw new GraphQLError("The password is not set. Use the `setPassword` mutation to set the password.", {
        extensions: {
          code: "PASSWORD_NOT_SET",
          userFriendlyMessage: "No password was set for your Flow yet. Please refresh the page to set the password."
        }
      });
    }
    const isPasswordCorrect = await Bun.password.verify(args.input.password, passwordSetting.value);
    if (!isPasswordCorrect) {
      throw new GraphQLError("The password is incorrect.", {
        extensions: { code: "PASSWORD_INCORRECT" }
      });
    }
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    return sessionToken;
  }
}));
builder5.mutationField("logout", (t2) => t2.field({
  authScopes: { authenticated: true },
  skipTypeScopes: true,
  type: "Boolean",
  description: "Logout from the Flow instance using the session token set in the Authorization header.",
  resolve: async (_, __, { sessionToken }) => {
    await prisma.store.deleteMany({
      where: {
        pluginSlug: FlowPluginSlug,
        key: { startsWith: StoreKeys.AUTH_SESSION_PREFIX },
        value: { path: ["token"], equals: sessionToken }
      }
    });
    return true;
  }
}));
builder5.mutationField("setTimezone", (t2) => t2.fieldWithInput({
  type: "String",
  description: 'Set the timezone using a [dayjs timezone string](https://day.js.org/docs/en/plugin/timezone) (e.g. "America/New_York") for the Flow instance. This will affect the time the tasks are synced (default is 04:00 in the timezone set)',
  input: {
    timezone: t2.input.string({
      required: true,
      description: 'The timezone to set as a [dayjs timezone string](https://day.js.org/docs/en/plugin/timezone) (e.g. "America/New_York").'
    })
  },
  resolve: async (_, args) => {
    try {
      dayjs().tz(args.input.timezone);
    } catch {
      throw new GraphQLError('The timezone is invalid. Please use a correct timezone identifier (e.g. "America/New_York") from this list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.', { extensions: { code: "TIMEZONE_INVALID" } });
    }
    await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug }
      },
      update: { value: args.input.timezone },
      create: {
        key: StoreKeys.TIMEZONE,
        pluginSlug: FlowPluginSlug,
        value: args.input.timezone,
        isSecret: false,
        isServerOnly: false
      }
    });
    await scheduleRolloverTasks(args.input.timezone);
    return args.input.timezone;
  }
}));

// src/utils/getPluginOptions.ts
var getPluginOptions = (pluginSlug) => ({
  pluginSlug,
  serverOrigin: env.ORIGIN,
  dayjs,
  pgBoss: {
    send: pgBoss.send,
    sendAfter: pgBoss.sendAfter,
    sendOnce: pgBoss.sendOnce,
    sendSingleton: pgBoss.sendSingleton,
    sendThrottled: pgBoss.sendThrottled,
    sendDebounced: pgBoss.sendDebounced,
    schedule: pgBoss.schedule
  },
  prisma: {
    day: {
      findUnique: prisma.day.findUnique,
      findUniqueOrThrow: prisma.day.findUniqueOrThrow,
      findFirst: prisma.day.findFirst,
      findFirstOrThrow: prisma.day.findFirstOrThrow,
      findMany: prisma.day.findMany,
      count: prisma.day.count,
      aggregate: prisma.day.aggregate,
      groupBy: prisma.day.groupBy
    },
    note: prisma.note,
    noteTag: prisma.noteTag,
    task: prisma.task,
    taskPluginData: prisma.taskPluginData,
    taskTag: prisma.taskTag,
    item: prisma.item,
    itemPluginData: prisma.itemPluginData,
    list: prisma.list,
    routine: prisma.routine
  },
  store: {
    setItem: async (key, value14) => {
      if (typeof value14 === "symbol" || typeof value14 === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value: value14 },
        create: { pluginSlug, key, value: value14 }
      });
      return result;
    },
    setSecretItem: async (key, value14) => {
      if (typeof value14 === "symbol" || typeof value14 === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value: value14 },
        create: { pluginSlug, key, value: value14, isSecret: true, isServerOnly: true }
      });
      return result;
    },
    setServerOnlyItem: async (key, value14) => {
      if (typeof value14 === "symbol" || typeof value14 === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value: value14 },
        create: { pluginSlug, key, value: value14, isServerOnly: true }
      });
      return result;
    },
    deleteItem: async (key) => {
      const result = await prisma.store.delete({
        where: { pluginSlug_key_unique: { pluginSlug, key } }
      });
      return result;
    },
    getPluginItem: async (key) => {
      const result = await prisma.store.findFirst({
        where: { key, pluginSlug }
      });
      return result;
    },
    getItem: async (key, opts) => {
      const result = await prisma.store.findFirst({
        where: { key, pluginSlug: opts?.pluginSlug, isSecret: false }
      });
      return result;
    }
  },
  getUsersTimezone: async () => {
    const timezoneItem = await prisma.store.findFirst({
      where: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug }
    });
    return timezoneItem?.value ?? null;
  },
  getNearestItemColor: (hex) => nearestTailwindColor(hex),
  GraphQLError
});

// src/utils/getPlugins.ts
async function installServerPlugin(opts) {
  const res = await fetch(`${opts.url}/server.js`).catch((err) => {
    if (err.message === "fetch failed") {
      throw new GraphQLError(`Got no response. Make sure the URL is correct: "${opts.url}/server.js"`);
    }
    throw new GraphQLError(err.message);
  });
  if (!res.ok) {
    throw new GraphQLError(`Got status code ${res.status} from "${opts.url}/server.js"`);
  }
  const text = await res.text();
  if (text.startsWith("Couldn't find the requested file")) {
    throw new GraphQLError(`Couldn't find the plugin at "${opts.url}/server.js"`);
  }
  try {
    await fs.readdir(pathToPlugins);
  } catch (err) {
    if (err.code !== "ENOENT") {
      throw err;
    }
    await fs.mkdir(pathToPlugins, { recursive: true });
  }
  if (/Bun|require(?=\(|\/\*)|eval|setTimeout|setInterval|setImmidiate|process\.|__dirname|__filename|spawn|spawnSync|write|import\.meta| ffi|transpile|transform| \$`/.test(text)) {
    throw new GraphQLError(`The plugin is unsafe to install as it can gain access to sensitive data. Contact the plugin author or install a different plugin.`);
  }
  await Bun.write(pathToTemp, text);
  delete import.meta.require.cache[pathToTemp];
  let exported;
  try {
    exported = import.meta.require(pathToTemp);
  } catch (e2) {
    console.log(e2);
    throw new GraphQLError(`Couldn't install the server part of the plugin. Contact the plugin author to fix this.`);
  }
  if (typeof exported !== "object") {
    throw new GraphQLError(`Couldn't find any exports at "${opts.url}/server.js"`);
  }
  if ("default" in exported) {
    exported = exported.default;
  }
  if (typeof exported.plugin !== "function") {
    throw new GraphQLError(`The exports of "${opts.url}/server.js" must have a \`plugin\` property which is a function. Please use \`definePlugin\` from \`@flowdev/plugin/server\`.`);
  }
  if (!opts.override && cache3.has(opts.slug)) {
    throw new GraphQLError(`PLUGIN_WITH_SAME_SLUG: A plugin with the slug "${opts.slug}" is already installed. Use the \`override\` option to override the existing plugin.`);
  }
  await fs.rename(pathToTemp, path.join(pathToPlugins, `${opts.slug}.js`));
  const plugin3 = exported.plugin(getPluginOptions(opts.slug));
  cache3.set(opts.slug, plugin3);
  await plugin3.onInstall?.();
}
async function uninstallServerPlugin(slug) {
  await cache3.get(slug)?.onUninstall?.();
  await fs.unlink(path.join(pathToPlugins, `${slug}.js`));
  cache3.delete(slug);
}
var cache3 = new Map;
var pathToPlugins = path.join(import.meta.dir, env.PATH_TO_PLUGINS ?? "../../plugins");
var pathToTemp = path.join(pathToPlugins, "__temp.js");
var getPlugins2 = async () => {
  const plugins4 = (await fs.readdir(pathToPlugins).catch(() => [])).filter((p2) => p2.endsWith(".js") && p2 !== "__temp.js").map((p2) => p2.replace(".js", ""));
  const unCachedPlugins = plugins4.filter((plugin3) => !cache3.has(plugin3));
  if (unCachedPlugins.length === 0) {
    return Object.fromEntries(cache3);
  }
  for (const pluginSlug of unCachedPlugins) {
    let exported = import.meta.require(path.join(pathToPlugins, pluginSlug));
    if ("default" in exported) {
      exported = exported.default;
    }
    cache3.set(pluginSlug, exported.plugin(getPluginOptions(pluginSlug)));
  }
  return Object.fromEntries(cache3);
};
var getPluginsInStore = async () => {
  const storeItem = await prisma.store.findFirst({
    where: {
      key: StoreKeys.INSTALLED_PLUGINS,
      isSecret: false,
      isServerOnly: false,
      pluginSlug: FlowPluginSlug
    }
  });
  return storeItem?.value ?? [];
};
var getPluginJson = async (opts) => {
  const res = await fetch(`${opts.url}/plugin.json`).catch((err) => {
    if (err.message === "fetch failed") {
      throw new GraphQLError(`Got no response. Make sure the URL is correct: "${opts.url}/plugin.json"`);
    }
    throw new GraphQLError(err.message);
  });
  if (!res.ok) {
    throw new GraphQLError(`Got status code ${res.status} from "${opts.url}/plugin.json"`);
  }
  const text = await res.text();
  if (text.startsWith("Couldn't find the requested file")) {
    throw new GraphQLError(`Couldn't find the plugin at "${opts.url}/server.js"`);
  }
  try {
    return JSON.parse(text);
  } catch (err) {
    throw new GraphQLError(`Couldn't parse JSON of "${opts.url}/plugin.json"`);
  }
};

// src/graphql/Task.ts
var TaskType = builder5.prismaNode("Task", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    title: t2.exposeString("title"),
    status: t2.expose("status", { type: TaskStatusEnum }),
    completedAt: t2.expose("completedAt", { type: "DateTime", nullable: true }),
    date: t2.expose("date", { type: "Date" }),
    item: t2.relation("item", { nullable: true }),
    durationInMinutes: t2.int({
      nullable: true,
      description: "The length of time the task is expected to take.",
      select: { item: { select: { durationInMinutes: true } } },
      resolve: (task) => {
        return task.durationInMinutes ?? task.item?.durationInMinutes;
      }
    }),
    tags: t2.relation("tags"),
    pluginDatas: t2.relation("pluginDatas")
  })
});
var TaskStatusEnum = builder5.enumType("TaskStatus", {
  values: {
    TODO: {
      description: "When the task is planned or in progress.",
      value: "TODO"
    },
    CANCELED: {
      description: "When the task was decided not to be done anymore.",
      value: "CANCELED"
    },
    DONE: {
      description: "When the task is done.",
      value: "DONE"
    }
  }
});
var TaskStatusFilter = builder5.prismaFilter(TaskStatusEnum, {
  ops: ["equals", "not", "in", "notIn"]
});
var TaskWhereInputType = builder5.prismaWhere("Task", {
  fields: {
    status: TaskStatusFilter,
    date: DateFilter,
    completedAt: DateTimeFilter
  }
});
var TaskListWhereInputType = builder5.prismaListFilter(TaskWhereInputType, {
  ops: ["every", "some", "none"]
});
builder5.mutationField("createTask", (t2) => t2.prismaFieldWithInput({
  type: "Task",
  description: `Create a new task.`,
  input: {
    title: t2.input.string({ required: true, description: "The title of the task." }),
    status: t2.input.field({
      type: TaskStatusEnum,
      defaultValue: "TODO",
      description: "The initial status of the task. Defaults to `TODO`."
    }),
    durationInMinutes: t2.input.field({
      type: "PositiveInt",
      description: "The length of time (in minutes) the task is expected to take."
    }),
    date: t2.input.field({
      type: "Date",
      description: "The day (no time required) the task is planned for."
    }),
    itemId: t2.input.globalID({
      description: "The Relay ID of the Item that should be linked to the task."
    }),
    atIndex: t2.input.int({
      description: "The position in the day the task should be placed at. If not specified, it will be placed at the beginning."
    }),
    pluginDatas: t2.input.field({
      description: "The plugin data to be linked to the task.",
      type: [TaskPluginDataInput]
    }),
    actionDatas: t2.input.field({
      description: "The actions to be executed after the task is created.",
      type: [TaskActionDataInput]
    })
  },
  resolve: async (query3, _, args) => {
    const date4 = args.input.date ?? startOfDay(new Date);
    const index = args.input.atIndex ?? 0;
    const plugins4 = await getPlugins2();
    const pluginDatas = [];
    let item;
    if (args.input.itemId) {
      item = await prisma.item.findUnique({
        where: { id: parseInt(args.input.itemId?.id) },
        include: { pluginDatas: true }
      });
    }
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      const actionData = args.input.actionDatas?.find((actionData2) => actionData2.pluginSlug === pluginSlug)?.data;
      const webPluginData = args.input.pluginDatas?.find((pluginData) => pluginData.pluginSlug === pluginSlug);
      const result = await plugin3.onCreateTask?.({
        actionData,
        task: {
          title: args.input.title,
          status: args.input.status,
          durationInMinutes: args.input.durationInMinutes,
          date: date4,
          item,
          pluginData: {
            originalId: webPluginData?.originalId,
            min: webPluginData?.min,
            full: webPluginData?.full
          }
        }
      }).catch((e2) => {
        console.log(`Error plugin.onCreateTask for ${pluginSlug}`, e2);
        return null;
      });
      if (result?.pluginData) {
        pluginDatas.push({
          pluginSlug,
          originalId: result.pluginData.originalId,
          min: result.pluginData.min,
          full: result.pluginData.full
        });
      }
    }
    return prisma.$transaction(async (tx) => {
      const task = await tx.task.create({
        ...query3,
        data: {
          title: args.input.title,
          status: u2(args.input.status),
          durationInMinutes: args.input.durationInMinutes,
          day: { connectOrCreate: { where: { date: date4 }, create: { date: date4 } } },
          ...args.input.itemId ? { item: { connect: { id: parseInt(args.input.itemId.id) } } } : {},
          pluginDatas: { createMany: { data: pluginDatas } }
        }
      });
      const day2 = await tx.day.findUnique({ where: { date: date4 }, select: { tasksOrder: true } });
      const newTasksOrder = [
        ...day2.tasksOrder.slice(0, index),
        task.id,
        ...day2.tasksOrder.slice(index)
      ];
      await tx.day.update({ where: { date: date4 }, data: { tasksOrder: { set: newTasksOrder } } });
      return task;
    });
  }
}));
var TaskPluginDataInput = builder5.inputType("TaskPluginDataInput", {
  fields: (t2) => ({
    pluginSlug: t2.string({ required: true }),
    originalId: t2.string({ required: false }),
    min: t2.field({ type: "JSON" }),
    full: t2.field({ type: "JSON" })
  })
});
var TaskActionDataInput = builder5.inputType("TaskActionDataInput", {
  fields: (t2) => ({
    pluginSlug: t2.string({ required: true }),
    data: t2.field({ type: "JSON" })
  })
});
builder5.mutationField("updateTask", (t2) => t2.prismaFieldWithInput({
  type: "Task",
  description: `Update a task.`,
  input: {
    id: t2.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    title: t2.input.string({ description: "The title of the task." }),
    durationInMinutes: t2.input.field({
      type: "PositiveInt",
      description: "The length of time (in minutes) the task is expected to take."
    })
  },
  resolve: (query3, _, args) => {
    return prisma.task.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: {
        title: u2(args.input.title),
        durationInMinutes: args.input.durationInMinutes
      }
    });
  }
}));
builder5.mutationField("deleteTask", (t2) => t2.prismaField({
  type: "Task",
  description: `Delete a task.`,
  args: {
    id: t2.arg.globalID({ required: true, description: "The Relay ID of the task to delete." })
  },
  resolve: (query3, _, args) => {
    return prisma.task.delete({ ...query3, where: { id: parseInt(args.id.id) } });
  }
}));
builder5.mutationField("updateTaskStatus", (t2) => t2.prismaFieldWithInput({
  type: ["Day"],
  description: `Update the status of a task and get the updated days (as a list in chronological order).

When the task is:
- already in the desired status, it does nothing and returns an empty list.
- for today, it updates the status and returns the day.
- for a previous day and changing to \`TODO\`, it updates the status and
  returns the original day and today.
- for a future day and changing to \`DONE\` or \`CANCELED\`, it updates the status and
  returns the original day and today.

Any other scenario is not possible by nature of the app, where tasks:
- in the past can only be \`DONE\` or \`CANCELED\` 
- in the future can only be in \`TODO\`
    `,
  input: {
    id: t2.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    status: t2.input.field({
      type: TaskStatusEnum,
      required: true,
      description: "The new status of the task."
    }),
    actionData: t2.input.field({
      type: [TaskActionDataInput],
      description: "The action data to be passed to the plugin."
    })
  },
  resolve: async (query3, _, args) => {
    const days = [];
    const plugins4 = await getPlugins2();
    await prisma.$transaction(async (tx) => {
      const newStatus = args.input.status;
      const task = await tx.task.findUniqueOrThrow({
        where: { id: parseInt(args.input.id.id) },
        include: { day: { select: { date: true, tasksOrder: true } }, pluginDatas: true }
      });
      for (const pluginSlug in plugins4) {
        const plugin3 = plugins4[pluginSlug];
        await plugin3.onUpdateTaskStatus?.({
          actionData: args.input.actionData,
          newStatus,
          task
        });
      }
      const originalDay = task.day;
      const startOfToday = startOfDay();
      const endOfToday = endOfDay();
      if (task.status === newStatus) {
      } else if (task.date >= startOfToday && task.date <= endOfToday) {
        await tx.task.update({
          where: { id: task.id },
          data: { status: newStatus, completedAt: newStatus === "DONE" ? new Date : null }
        });
        const newTasksOrder = originalDay.tasksOrder.filter((id) => id !== task.id);
        if (newStatus === "TODO") {
          newTasksOrder.splice(0, 0, task.id);
        } else {
          newTasksOrder.push(task.id);
        }
        await tx.day.update({
          where: { date: startOfToday },
          data: {
            tasksOrder: { set: newTasksOrder }
          }
        });
        days.push(task.date);
      } else if (task.date > endOfToday && (newStatus === "DONE" || newStatus === "CANCELED")) {
        await tx.task.update({
          where: { id: task.id },
          data: {
            status: newStatus,
            completedAt: newStatus === "DONE" ? new Date : null,
            day: {
              connectOrCreate: {
                where: { date: startOfToday },
                create: { date: startOfToday }
              }
            }
          }
        });
        await tx.day.update({
          where: { date: startOfToday },
          data: { tasksOrder: { push: task.id } }
        });
        days.push(startOfToday);
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
        });
        days.push(originalDay.date);
      } else if (task.date < startOfToday) {
        if (newStatus === "TODO") {
          const updatedTask = await tx.task.update({
            where: { id: task.id },
            data: {
              status: newStatus,
              completedAt: null,
              day: {
                connectOrCreate: {
                  where: { date: startOfToday },
                  create: { date: startOfToday }
                }
              }
            },
            select: {
              day: {
                select: { tasks: { select: { id: true, status: true } }, tasksOrder: true }
              }
            }
          });
          await tx.day.update({
            where: { date: originalDay.date },
            data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
          });
          days.push(task.date);
          const tasksOrdered = updatedTask.day.tasks.sort((a2, b2) => updatedTask.day.tasksOrder.indexOf(a2.id) - updatedTask.day.tasksOrder.indexOf(b2.id));
          const lastTodoIndex = tasksOrdered.findIndex((t3) => t3.status === "TODO");
          const newTasksOrder = updatedTask.day.tasksOrder.splice(lastTodoIndex + 1, 0, task.id);
          await tx.day.update({
            where: { date: startOfToday },
            data: { tasksOrder: { set: newTasksOrder } }
          });
          days.push(startOfToday);
        } else {
          await tx.task.update({
            where: { id: task.id },
            data: {
              status: newStatus,
              completedAt: newStatus === "DONE" ? dayjs(task.date).endOf("day").toDate() : null
            }
          });
          days.push(task.date);
        }
      }
    });
    return prisma.day.findMany({
      ...query3,
      where: { date: { in: days } },
      orderBy: { date: "asc" }
    });
  }
}));
builder5.mutationField("updateTaskDate", (t2) => t2.fieldWithInput({
  type: [DayType],
  description: `Update the date of a task and/or position of the task in the day, and get the updated days (as a list in chronological order).

Input:
- \`id\`: The ID of the task to update.
- \`date\`: The new date of the task.
- \`after\`: The ID of the task to place the task after. If \`null\`, the task will be placed at the beginning of the day.

When the task is:
- already in the desired date, it updates the order and returns the day.
- moved to today, it updates the date and order but not the status, and returns the original day and today.
- moved into the past, it updates the date and order, updates the status to \`DONE\` (if not already),
  and returns the original day and the new day.
- moved into the future, it updates the date and order, updates the status to \`TODO\` (if not already),
  and returns the original day and the new day.`,
  input: {
    id: t2.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    date: t2.input.field({
      type: "Date",
      required: true,
      description: "The new date of the task."
    }),
    newTasksOrder: t2.input.globalIDList({
      required: true,
      description: "The new order of the tasks in the day the task is moved into."
    })
  },
  resolve: async (_, args) => {
    const plugins4 = await getPlugins2();
    return prisma.$transaction(async (tx) => {
      const days = [];
      const newDate = args.input.date;
      const task = await tx.task.findUniqueOrThrow({
        where: { id: parseInt(args.input.id.id) },
        include: { day: { select: { date: true, tasksOrder: true } }, pluginDatas: true }
      });
      const originalDay = task.day;
      const isSameDay = dayjs(task.date).isSame(newDate, "day");
      const newDayTasksOrder = args.input.newTasksOrder.filter((id) => id.typename === "Task").map((id) => parseInt(id.id));
      const startOfToday = startOfDay();
      const endOfToday = endOfDay();
      let newStatus = null;
      if (isSameDay) {
        newStatus = null;
        days.push(task.date);
      } else if (newDate >= startOfToday && newDate <= endOfToday) {
        newStatus = null;
        days.push(task.date, newDate);
      } else if (newDate < startOfToday) {
        if (task.status !== "CANCELED") {
          newStatus = "DONE";
        }
        days.push(task.date, newDate);
      } else if (newDate > endOfToday) {
        newStatus = "TODO";
        days.push(task.date, newDate);
      }
      if (newStatus === task.status) {
        newStatus = null;
      }
      if (newStatus) {
        for (const pluginSlug in plugins4) {
          const plugin3 = plugins4[pluginSlug];
          await plugin3.onUpdateTaskStatus?.({ newStatus, task });
        }
      }
      await tx.task.update({
        where: { id: task.id },
        data: {
          day: { connectOrCreate: { where: { date: newDate }, create: { date: newDate } } },
          ...newStatus ? {
            status: newStatus,
            completedAt: newStatus === "DONE" ? dayjs(newDate).endOf("day").toDate() : null
          } : {}
        }
      });
      if (isSameDay) {
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: newDayTasksOrder } }
        });
      } else {
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
        });
        await tx.day.update({
          where: { date: newDate },
          data: { tasksOrder: { set: newDayTasksOrder } }
        });
      }
      return prisma.day.findMany({
        where: { date: { in: days } },
        orderBy: { date: "asc" }
      });
    });
  }
}));

// src/graphql/Item.ts
var ItemType = builder5.prismaNode("Item", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    title: t2.exposeString("title"),
    isRelevant: t2.exposeBoolean("isRelevant"),
    inboxPoints: t2.exposeInt("inboxPoints", { nullable: true }),
    scheduledAt: t2.expose("scheduledAt", { type: "DateTime", nullable: true }),
    durationInMinutes: t2.exposeInt("durationInMinutes", { nullable: true }),
    isAllDay: t2.exposeBoolean("isAllDay", { nullable: true }),
    color: t2.expose("color", { type: ColorEnum, nullable: true }),
    pluginDatas: t2.relation("pluginDatas"),
    tasks: t2.relation("tasks"),
    list: t2.relation("list", { nullable: true })
  })
});
var ItemWhereInputType = builder5.prismaWhere("Item", {
  fields: {
    isRelevant: "Boolean",
    scheduledAt: DateTimeFilter,
    inboxPoints: IntFilter,
    tasks: TaskListWhereInputType
  }
});
var ItemOrderByType = builder5.prismaOrderBy("Item", {
  fields: {
    inboxPoints: true,
    scheduledAt: true,
    createdAt: true,
    updatedAt: true
  }
});
builder5.queryField("items", (t2) => t2.prismaConnection({
  type: "Item",
  cursor: "id",
  description: `Get all external items. Useuful to get list of items for a specific day to show in a calendar, or get items with inboxPoints to show in the inbox.
By default, only items where \`isRelevant\` is true.
Pass the \`where\` argument to override these defaults.`,
  args: {
    where: t2.arg({ type: ItemWhereInputType, required: false }),
    orderBy: t2.arg({ type: ItemOrderByType, required: false })
  },
  smartSubscription: true,
  subscribe: (subs) => {
    subs.register("itemsCreated");
    subs.register("itemsUpdated");
    subs.register("itemsDeleted");
  },
  resolve: (query3, _, args) => {
    return prisma.item.findMany({
      ...query3,
      take: undefined,
      where: args.where ?? undefined,
      orderBy: args.orderBy ?? undefined
    });
  }
}));
builder5.mutationField("createItem", (t2) => t2.prismaFieldWithInput({
  type: "Item",
  description: `Create an item.`,
  input: {
    title: t2.input.string({ required: true, description: `The title of the item.` }),
    isRelevant: t2.input.boolean({
      required: false,
      description: `If set to true, it will return items where \`isRelevant\` is true. 

\`isRelevant\` is used in the List component to only show relevant items. If the item becomes irrelevant (e.g. because the trello task was already completed), you can update the item to make this \`isRelevant = false\``
    }),
    scheduledAt: t2.input.field({ type: "DateTime", required: false }),
    durationInMinutes: t2.input.int({ required: false }),
    isAllDay: t2.input.boolean({ required: false }),
    color: t2.input.field({ type: ColorEnum, required: false }),
    inboxPoints: t2.input.int({ required: false }),
    listId: t2.input.globalID({ required: false }),
    pluginDatas: t2.input.field({ type: [ItemPluginDataInput], required: false })
  },
  resolve: (query3, _, { input: input6 }) => {
    return prisma.item.create({
      ...query3,
      data: {
        title: input6.title,
        isRelevant: u2(input6.isRelevant),
        scheduledAt: u2(input6.scheduledAt),
        durationInMinutes: u2(input6.durationInMinutes),
        isAllDay: u2(input6.isAllDay),
        color: u2(input6.color),
        inboxPoints: u2(input6.inboxPoints),
        list: input6.listId && input6.listId.typename === "List" ? { connect: { id: parseInt(input6.listId.id) } } : undefined,
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {}
      }
    });
  }
}));
builder5.mutationField("updateItem", (t2) => t2.prismaFieldWithInput({
  type: "Item",
  description: `Update an item.`,
  input: {
    id: t2.input.globalID({ required: true }),
    title: t2.input.string({ required: false }),
    isRelevant: t2.input.boolean({
      required: false,
      description: `If set to true, it will return items where \`isRelevant\` is true.

\`isRelevant\` is used in the List component to only show relevant items. If the item becomes irrelevant (e.g. because the trello task was already completed), you can update the item to make this \`isRelevant = false\``
    }),
    scheduledAt: t2.input.field({ type: "DateTime", required: false }),
    durationInMinutes: t2.input.int({ required: false }),
    isAllDay: t2.input.boolean({ required: false }),
    color: t2.input.field({ type: ColorEnum, required: false }),
    inboxPoints: t2.input.int({ required: false }),
    listId: t2.input.globalID({ required: false }),
    pluginDatas: t2.input.field({ type: [ItemPluginDataInput], required: false })
  },
  resolve: (query3, _, { input: input6 }) => {
    return prisma.item.update({
      ...query3,
      where: { id: parseInt(input6.id.id) },
      data: {
        title: u2(input6.title),
        isRelevant: u2(input6.isRelevant),
        scheduledAt: u2(input6.scheduledAt),
        durationInMinutes: u2(input6.durationInMinutes),
        isAllDay: u2(input6.isAllDay),
        color: u2(input6.color),
        inboxPoints: u2(input6.inboxPoints),
        list: input6.listId && input6.listId.typename === "List" ? { connect: { id: parseInt(input6.listId.id) } } : undefined,
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {}
      }
    });
  }
}));
builder5.mutationField("updateItemStatus", (t2) => t2.prismaFieldWithInput({
  type: "Item",
  description: `Mark an item as done or not done. Plugins can use this to mark the item as done or not done in the external system. For example, if the item is a trello task and is marked as done in Flow, it will be marked as done in trello (by the Trello plugin).`,
  input: {
    id: t2.input.globalID({ required: true, description: "The ID of the item." }),
    done: t2.input.boolean({ required: true, description: "Whether the item is done or not." })
  },
  resolve: async (query3, _, args) => {
    const plugins4 = await getPlugins2();
    const item = await prisma.item.findUnique({
      where: { id: parseInt(args.input.id.id) },
      include: { pluginDatas: true }
    });
    if (!item)
      throw new Error(`Item with id ${args.input.id} not found.`);
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      if (plugin3.onUpdateItemStatus) {
        await plugin3.onUpdateItemStatus({
          settingToDone: args.input.done,
          item
        });
      }
    }
    return await prisma.item.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: { isRelevant: !args.input.done }
    });
  }
}));
builder5.mutationField("deleteItem", (t2) => t2.prismaField({
  type: "Item",
  description: `Delete an item.`,
  args: {
    id: t2.arg.globalID({ required: true })
  },
  resolve: (query3, _, args) => {
    return prisma.item.delete({ ...query3, where: { id: parseInt(args.id.id) } });
  }
}));
builder5.mutationField("dismissItemFromInbox", (t2) => t2.prismaFieldWithInput({
  type: "Item",
  description: `Dismiss an item from the inbox. This effectively sets \`inboxPoints = null\` for the item.`,
  input: {
    id: t2.input.globalID({ required: true })
  },
  resolve: (query3, _, args) => {
    return prisma.item.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: { inboxPoints: null }
    });
  }
}));

// src/graphql/List.ts
var ListType = builder5.prismaNode("List", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    name: t2.exposeString("name"),
    slug: t2.exposeString("slug"),
    description: t2.exposeString("description", { nullable: true }),
    items: t2.relatedConnection("items", {
      cursor: "id",
      args: { where: t2.arg({ type: ItemWhereInputType, required: false }) },
      query: (args) => ({
        where: args.where ?? undefined,
        orderBy: { updatedAt: "desc" }
      })
    })
  })
});
builder5.queryField("lists", (t2) => t2.prismaField({
  type: ["List"],
  description: "Get all lists.",
  args: {
    first: t2.arg({
      type: "PositiveInt",
      required: false,
      description: "The number of lists to return. If not provided, all lists will be returned."
    })
  },
  resolve: (query3, _, args) => {
    return prisma.list.findMany({
      ...query3,
      take: u2(args.first),
      orderBy: { createdAt: "asc" }
    });
  }
}));
builder5.queryField("list", (t2) => t2.prismaField({
  type: "List",
  description: "Get a list by its id or slug.",
  nullable: true,
  smartSubscription: true,
  subscribe: (subs) => {
    subs.register("itemsCreated");
    subs.register("itemsUpdated");
    subs.register("itemsDeleted");
  },
  args: {
    id: t2.arg.globalID({ required: false }),
    slug: t2.arg.string({ required: false })
  },
  resolve: (query3, _, args) => {
    return prisma.list.findFirst({
      ...query3,
      where: { id: uParseInt(args.id?.id), slug: args.slug ?? undefined }
    });
  }
}));

// src/graphql/NoteTag.ts
var NoteTagType = builder5.prismaNode("NoteTag", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    name: t2.exposeString("name"),
    slug: t2.exposeString("slug"),
    color: t2.expose("color", { type: ColorEnum }),
    notes: t2.relatedConnection("notes", { cursor: "id" }),
    isPrivate: t2.exposeBoolean("isPrivate")
  })
});
builder5.queryField("noteTags", (t2) => t2.prismaConnection({
  type: "NoteTag",
  cursor: "id",
  description: "Get all note tags ordered by usage in descending order. `before` and `after` cursors are ignored, and `first` and `last` act the same and are limited to 100.",
  args: {
    where: t2.arg({
      type: NoteTagWhereInput,
      required: false,
      description: "Filters to use when querying note tags."
    })
  },
  resolve: (query3, _, args) => {
    const where = args.where;
    return prisma.noteTag.findMany({
      ...query3,
      where: {
        ...where?.nameIsLike ? { name: { contains: where.nameIsLike, mode: "insensitive" } } : {},
        ...where?.isPrivate ? { isPrivate: { equals: where.isPrivate } } : {}
      },
      orderBy: { notes: { _count: "desc" } },
      take: Math.min(args.first ?? args.last ?? 100, 100)
    });
  }
}));
var NoteTagWhereInput = builder5.inputType("NoteTagWhereInput", {
  fields: (t2) => ({
    nameIsLike: t2.string({
      required: false,
      description: "Filter by name. Case insensitive."
    }),
    isPrivate: t2.boolean({
      required: false,
      description: "Filter by whether the tag is for private use."
    })
  })
});
var CreateNoteTagInputType = builder5.inputType("CreateNoteTagInput", {
  fields: (t2) => ({
    name: t2.string({ required: true, description: "The name of the tag." }),
    slug: t2.string({
      required: false,
      description: "The slug of the tag. Defaults to dashcase version of the name."
    }),
    color: t2.string({ required: true, description: "The color of the tag." })
  })
});

// src/graphql/Note.ts
var NoteType = builder5.prismaNode("Note", {
  id: { field: "slug" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    updatedAt: t2.expose("updatedAt", { type: "DateTime" }),
    date: t2.expose("date", { type: "Date" }),
    slug: t2.exposeString("slug"),
    title: t2.exposeString("title"),
    content: t2.exposeString("content"),
    tags: t2.relation("tags")
  })
});
builder5.queryField("note", (t2) => t2.prismaField({
  type: "Note",
  description: "Get a note by its `slug`.",
  nullable: true,
  args: {
    slug: t2.arg.string({ required: true, description: "The slug of the note." })
  },
  resolve: (query3, _, { slug }) => {
    return prisma.note.findUnique({ ...query3, where: { slug } });
  }
}));
builder5.mutationField("createOrUpdateNote", (t2) => t2.prismaFieldWithInput({
  type: "Note",
  description: "Updates a note if one exists with the passed in `slug`, otherwise creates a new note.",
  input: {
    date: t2.input.field({ type: "Date", required: true, description: "The date of the note." }),
    slug: t2.input.string({
      required: true,
      description: "The slug of the note. Used for retrieving the note back."
    }),
    title: t2.input.string({ required: true, description: "The title of the note." }),
    content: t2.input.string({ required: true, description: "The content of the note." }),
    tags: t2.input.globalIDList({
      required: false,
      description: "The IDs of exsiting tags to be linked to the note. If you want to create a new tag, use the `newTags` input."
    }),
    newTags: t2.input.field({
      type: [CreateNoteTagInputType],
      required: false,
      description: "Create new tags and link them to the note."
    }),
    removedTags: t2.input.globalIDList({
      required: false,
      description: "The IDs of tags to be unlinked from the note."
    })
  },
  resolve: (query3, _, args) => {
    const date4 = args.input.date;
    const tags = {
      connect: args.input.tags?.map((globalId) => ({ id: parseInt(globalId.id) })) ?? [],
      create: args.input.newTags?.map((tag) => ({
        name: tag.name,
        slug: tag.slug ?? tag.name.toLowerCase().replace(/ /g, "-"),
        color: tag.color
      })) ?? []
    };
    return prisma.note.upsert({
      ...query3,
      where: { slug: args.input.slug },
      update: {
        day: { connectOrCreate: { where: { date: date4 }, create: { date: date4 } } },
        title: args.input.title,
        content: args.input.content,
        tags: {
          ...tags,
          disconnect: args.input.removedTags?.map((globalId) => ({
            id: parseInt(globalId.id)
          })) ?? []
        }
      },
      create: {
        day: { connectOrCreate: { where: { date: date4 }, create: { date: date4 } } },
        slug: args.input.slug,
        title: args.input.title,
        content: args.input.content,
        tags
      }
    });
  }
}));

// src/graphql/Notifications.ts
var NotificationsType = builder5.simpleObject("Notifications", {
  fields: (t2) => ({
    itemsCreated: t2.field({ type: [ItemType] }),
    itemsUpdated: t2.field({ type: [ItemType] }),
    itemsDeleted: t2.field({ type: [ItemType] }),
    tasksCreated: t2.field({ type: [TaskType] }),
    tasksUpdated: t2.field({ type: [TaskType] }),
    tasksDeleted: t2.field({ type: [TaskType] })
  })
});
var getArrayInObj = (payload, type74) => {
  if (!payload)
    return [];
  if (type74 in payload) {
    return payload[type74];
  }
  return [];
};
builder5.subscriptionField("notifications", (t2) => t2.field({
  type: NotificationsType,
  subscribe(_parent, _args, _context, _info) {
    return Repeater.merge([
      undefined,
      pipe(pubsub.subscribe("itemsCreated"), map3((items) => ({ itemsCreated: items }))),
      pipe(pubsub.subscribe("itemsUpdated"), map3((items) => ({ itemsUpdated: items }))),
      pipe(pubsub.subscribe("itemsDeleted"), map3((items) => ({ itemsDeleted: items }))),
      pipe(pubsub.subscribe("tasksCreated"), map3((tasks) => ({ tasksCreated: tasks }))),
      pipe(pubsub.subscribe("tasksUpdated"), map3((tasks) => ({ tasksUpdated: tasks }))),
      pipe(pubsub.subscribe("tasksDeleted"), map3((tasks) => ({ tasksDeleted: tasks })))
    ]);
  },
  resolve: (payload) => {
    return {
      itemsCreated: getArrayInObj(payload, "itemsCreated"),
      itemsUpdated: getArrayInObj(payload, "itemsUpdated"),
      itemsDeleted: getArrayInObj(payload, "itemsDeleted"),
      tasksCreated: getArrayInObj(payload, "tasksCreated"),
      tasksUpdated: getArrayInObj(payload, "tasksUpdated"),
      tasksDeleted: getArrayInObj(payload, "tasksDeleted")
    };
  }
}));

// src/graphql/PluginOperation.ts
var PluginOperationType = builder5.node(builder5.objectRef("PluginOperation"), {
  id: { resolve: (op) => op.id },
  loadOne: async (id) => {
    const [pluginSlug, operationName] = id.split("_");
    if (!pluginSlug || !operationName) {
      throw new GraphQLError(`Invalid plugin operation id: PluginOperation_${id}. It should be in the format of PluginOperation_pluginSlug_operationName.`);
    }
    return await loadOneWithInput(pluginSlug, operationName, {});
  },
  fields: (t2) => ({
    data: t2.field({ type: "JSON", resolve: (op) => op.data, nullable: true })
  }),
  description: `A plugin operation similar to making a request to /api/plugin/:pluginSlug/:operation, but it can be cached by Relay.

This is the recommended way to interact with the plugin's from the web app.

If you want to do a GET-like request, you can do it through \`node\` field if there are no parameters to pass. For example:
\`\`\`graphql
query {
  node(id: "PluginOperation_pluginSlug_operationName") {
    ... on PluginOperation {
      id
      data
    }
  }
}
\`\`\`
Or you can do it through \`pluginOperation\` field if there are parameters to pass. For example:
\`\`\`graphql
query {
  pluginOperation(
    input: {
      pluginSlug: "pluginSlug",
      operationName: "operationName",
      data: { param1: "value1"}
    }
  ) {
    id
    data
  }
}
\`\`\`

If you want to do a POST-like request, you can do it through \`pluginOperation\` field in the Mutation type. For example:
\`\`\`graphql
mutation {
  pluginOperation(
    input: {
      pluginSlug: "pluginSlug",
      operationName: "operationName",
      data: { param1: "value1"}
    }
  ) {
    id
    data
  }
}

What's the difference between \`pluginOperation\` field in the Query type and the Mutation type?
- \`pluginOperation\` field in the Query type is used for GET-like requests and will get cached by Relay in the web app.
- \`pluginOperation\` field in the Mutation type is used for POST-like requests and will invalidate any cached data from the \`pluginOperation\` field in the Query type and Relay will automatically update it's store.
`
});
var loadOneWithInput = async (pluginSlug, operationName, input6) => {
  const plugins4 = await getPlugins2();
  const plugin3 = plugins4[pluginSlug];
  if (!plugin3) {
    throw new GraphQLError(`Plugin ${pluginSlug} not found.`);
  }
  const operation = plugin3.operations?.[operationName];
  if (!operation) {
    throw new GraphQLError(`Operation ${operationName} not found in plugin ${pluginSlug}.`);
  }
  try {
    const result = await operation(input6);
    if (!result)
      return null;
    return {
      id: `${pluginSlug}_${result.operationName ?? operationName}`,
      data: result.data ?? null
    };
  } catch (e2) {
    if (e2 instanceof GraphQLError)
      throw e2;
    if (e2 instanceof Error) {
      throw new GraphQLError(e2.message);
    }
    throw new GraphQLError(JSON.stringify(e2));
  }
};
builder5.queryField("pluginOperation", (t2) => t2.fieldWithInput({
  type: PluginOperationType,
  nullable: true,
  input: {
    pluginSlug: t2.input.string({ required: true }),
    operationName: t2.input.string({ required: true }),
    data: t2.input.field({ type: "JSON", required: false })
  },
  resolve: async (_, args) => {
    return await loadOneWithInput(args.input.pluginSlug, args.input.operationName, args.input.data ?? {});
  }
}));
builder5.mutationField("pluginOperation", (t2) => t2.fieldWithInput({
  type: PluginOperationType,
  nullable: true,
  input: {
    pluginSlug: t2.input.string({ required: true }),
    operationName: t2.input.string({ required: true }),
    data: t2.input.field({ type: "JSON", required: false })
  },
  resolve: async (_, args) => {
    return await loadOneWithInput(args.input.pluginSlug, args.input.operationName, args.input.data ?? {});
  }
}));

// src/graphql/RepetitionPattern.ts
var values4 = {
  MONDAY: { value: "MONDAY" },
  TUESDAY: { value: "TUESDAY" },
  WEDNESDAY: { value: "WEDNESDAY" },
  THURSDAY: { value: "THURSDAY" },
  FRIDAY: { value: "FRIDAY" },
  SATURDAY: { value: "SATURDAY" },
  SUNDAY: { value: "SUNDAY" }
};
var RepetitionPatternEnum = builder5.enumType("RepetitionPattern", { values: values4 });

// src/graphql/Routine.ts
var RoutineType = builder5.prismaNode("Routine", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    name: t2.exposeString("name"),
    actionName: t2.exposeString("actionName"),
    time: t2.expose("time", { type: "Time" }),
    repeats: t2.expose("repeats", { type: [RepetitionPatternEnum] }),
    steps: t2.field({
      type: [RoutineStepType],
      resolve: (routine) => routine.steps.map((step) => {
        const [pluginSlug, stepSlug, shouldSkip] = step.split("_");
        return {
          pluginSlug,
          stepSlug,
          shouldSkip: shouldSkip === "true"
        };
      })
    }),
    isActive: t2.exposeBoolean("isActive"),
    firstStep: t2.string({
      resolve: (routine) => routine.steps[0] ?? null,
      nullable: true,
      description: "Returns the first step in the routine. If there are no steps in the routine, it returns `null`."
    }),
    done: t2.boolean({
      description: "Whether the routine was done for the day. This can be null if the routine is queried outside of a day.",
      nullable: true,
      resolve: async (routine) => {
        if (!("_done" in routine) || typeof routine._done !== "boolean")
          return null;
        return routine._done;
      }
    })
  })
});
var RoutineStepType = builder5.simpleObject("RoutineStep", {
  description: "A step in a routine. To know which plugin the step belongs to, see `pluginSlug`.",
  fields: (t2) => ({
    pluginSlug: t2.string({ description: "The slug of the plugin that the step belongs to." }),
    stepSlug: t2.string({ description: "The slug of the step." }),
    shouldSkip: t2.boolean({
      description: "Whether the step should be skipped if the previous routine was done (i.e. routine.done = true)."
    })
  })
});
var RoutineStepInput = builder5.inputType(builder5.inputRef("RoutineStepInput"), {
  fields: (t2) => ({
    pluginSlug: t2.string({ required: true }),
    stepSlug: t2.string({ required: true }),
    shouldSkip: t2.boolean({ required: true })
  })
});
builder5.queryField("routines", (t2) => t2.prismaField({
  type: ["Routine"],
  description: "Get all routines.",
  resolve: prisma.routine.findMany
}));
builder5.mutationField("createRoutine", (t2) => t2.prismaFieldWithInput({
  type: "Routine",
  input: {
    name: t2.input.string({ required: true }),
    actionName: t2.input.string({ required: true }),
    time: t2.input.field({ type: "Time", required: true }),
    repeats: t2.input.field({ type: [RepetitionPatternEnum], required: true }),
    steps: t2.input.field({ type: [RoutineStepInput], required: true })
  },
  resolve: async (query3, _, args) => {
    return prisma.routine.create({
      ...query3,
      data: {
        name: args.input.name,
        actionName: args.input.actionName,
        time: args.input.time,
        repeats: args.input.repeats,
        firstDay: new Date,
        isActive: true,
        steps: args.input.steps.map((step) => `${step.pluginSlug}_${step.stepSlug}_${step.shouldSkip}`)
      }
    });
  }
}));
builder5.mutationField("updateRoutine", (t2) => t2.prismaFieldWithInput({
  type: "Routine",
  input: {
    routineId: t2.input.globalID({
      description: "The ID of the routine to update.",
      required: true
    }),
    isActive: t2.input.boolean({
      description: "Whether the routine is active.",
      required: false
    }),
    name: t2.input.string({
      description: "The name to update the routine with.",
      required: false
    }),
    actionName: t2.input.string({
      description: "The action name to update the routine with.",
      required: false
    }),
    time: t2.input.field({
      type: "Time",
      description: "The time to update the routine with.",
      required: false
    }),
    steps: t2.input.field({
      type: [RoutineStepInput],
      description: "The steps to update the routine with.",
      required: false
    }),
    repeats: t2.input.field({
      type: [RepetitionPatternEnum],
      description: "The repetition patterns to update the routine with.",
      required: false
    })
  },
  resolve: async (query3, _, args) => {
    return prisma.routine.update({
      ...query3,
      where: { id: parseInt(args.input.routineId.id) },
      data: {
        isActive: u2(args.input.isActive),
        name: u2(args.input.name),
        actionName: u2(args.input.actionName),
        time: u2(args.input.time),
        repeats: u2(args.input.repeats),
        steps: args.input.steps?.map((step) => `${step.pluginSlug}_${step.stepSlug}_${step.shouldSkip}`) ?? undefined
      }
    });
  }
}));
builder5.mutationField("completeRoutine", (t2) => t2.fieldWithInput({
  type: "Boolean",
  input: {
    routineId: t2.input.globalID({
      description: "The ID of the routine that was completed.",
      required: true
    }),
    date: t2.input.field({
      type: "Date",
      description: "The date the routine was completed.",
      required: true
    })
  },
  resolve: async (_, args) => {
    try {
      await prisma.day.update({
        where: { date: args.input.date },
        data: { routinesCompleted: { connect: { id: parseInt(args.input.routineId.id) } } }
      });
    } catch (e2) {
      new GraphQLError(e2.message);
    }
    return true;
  }
}));

// src/graphql/TaskPluginData.ts
var TaskPluginDataType = builder5.prismaNode("TaskPluginData", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    updatedAt: t2.expose("updatedAt", { type: "DateTime" }),
    min: t2.expose("min", { type: "JSON" }),
    full: t2.expose("full", { type: "JSON" }),
    pluginSlug: t2.exposeString("pluginSlug")
  })
});

// src/graphql/TaskTag.ts
var TaskTagType = builder5.prismaNode("TaskTag", {
  id: { field: "id" },
  fields: (t2) => ({
    createdAt: t2.expose("createdAt", { type: "DateTime" }),
    name: t2.exposeString("name"),
    slug: t2.exposeString("slug"),
    color: t2.expose("color", { type: ColorEnum }),
    tasks: t2.relatedConnection("tasks", { cursor: "id" }),
    isPrivate: t2.exposeBoolean("isPrivate")
  })
});
builder5.queryField("taskTags", (t2) => t2.prismaConnection({
  type: "TaskTag",
  cursor: "id",
  description: "Get all task tags ordered by usage in descending order. `before` and `after` cursors are ignored, and `first` and `last` act the same and are limited to 100.",
  args: {
    where: t2.arg({
      type: TaskTagWhereInput,
      required: false,
      description: "Filters to use when querying task tags."
    })
  },
  resolve: (query3, _, args) => {
    const where = args.where;
    return prisma.taskTag.findMany({
      ...query3,
      where: {
        ...where?.nameIsLike ? { name: { contains: where.nameIsLike, mode: "insensitive" } } : {},
        ...where?.isPrivate ? { isPrivate: { equals: where.isPrivate } } : {}
      },
      orderBy: { tasks: { _count: "desc" } },
      take: Math.min(args.first ?? args.last ?? 100, 100)
    });
  }
}));
var TaskTagWhereInput = builder5.inputType("TaskTagWhereInput", {
  fields: (t2) => ({
    nameIsLike: t2.string({
      required: false,
      description: "Filter by name. Case insensitive."
    }),
    isPrivate: t2.boolean({
      required: false,
      description: "Filter by whether the tag is for private use."
    })
  })
});

// src/graphql/index.ts
var schema3 = builder5.toSchema();
if (env.NODE_ENV === "development") {
  const schemaAsString = printSchema(schema3);
  const path2 = await Bun.resolve("../../../web/src/relay/schema.graphql", import.meta.dir);
  await Bun.write(path2, "# @generated\n" + schemaAsString);
  console.log(`
\u2705 GraphQL schema generated into apps/web/src/relay/schema.graphql`);
}

// src/index.ts
var PORT = env.PORT ?? 4000;
var yogaHandler = async (request) => {
  const res = await createYoga({
    schema: schema3,
    cors: {
      origin: undefined
    },
    context: async (req) => {
      const sessionToken = req.request.headers.get("authorization")?.replace("Bearer ", "");
      return {
        userAgent: req.request.headers.get("user-agent") ?? undefined,
        sessionToken,
        isSessionValid: () => isSessionTokenValid(sessionToken),
        subscriptions: {}
      };
    },
    graphiql: {
      title: "Flow GraphQL API",
      headers: JSON.stringify({
        Authorization: `Bearer COPY_TOKEN_FROM_BROWSER_CONSOLE_OR_LOGIN_MUTATION`
      })
    }
  }).handle(request);
  res.headers.delete("Access-Control-Allow-Origin");
  return res;
};
var app = new c$().use(cors()).get("/graphql", async ({ request }) => yogaHandler(request)).post("/graphql", async ({ request }) => yogaHandler(request), {
  type: "none"
}).all("/api/plugin/:pluginSlug/*", async (req) => {
  const pluginSlug = req.params.pluginSlug;
  const installedPlugins = await getPlugins2();
  const plugin3 = installedPlugins[pluginSlug];
  if (!plugin3) {
    return new Response(`Plugin ${pluginSlug} not found. It may be in the process of being installed. Please try again later.`, { status: 404 });
  }
  if (!plugin3.onRequest) {
    return new Response(`Plugin ${pluginSlug} has no \`onRequest\` function to handle the request.`, { status: 404 });
  }
  req.path = req.path.replace(`/api/plugin/${pluginSlug}`, "");
  const maybePromise = plugin3.onRequest(req);
  if (maybePromise instanceof Response)
    return maybePromise;
  const res = await maybePromise?.catch(() => null);
  if (res)
    return res;
  return new Response(`Plugin ${pluginSlug} has no endpoint for ${req.path}.`, { status: 404 });
});
app.all("*", async (req) => {
  if (env.NODE_ENV === "development") {
    const developmentPath = `http://localhost:3000${req.path}`;
    try {
      const result = await fetch(developmentPath);
      if (result.ok) {
        return Response.redirect(developmentPath);
      }
    } catch {
      return new Response("Local frontend is not running on port 3000.", { status: 404 });
    }
  }
  const webDir = "./web";
  try {
    const path2 = await Bun.resolve(`${webDir}${req.path}`, import.meta.dir);
    return new Response(Bun.file(path2));
  } catch {
    try {
      const path2 = await Bun.resolve(`${webDir}/index.html`, import.meta.dir);
      return new Response(Bun.file(path2));
    } catch {
      return new Response("Not sure how you got here. Contact Richard Guerre (through Slack or @richardguerre_ on Twitter) with a screenshot of this screen with the URL.", { status: 404 });
    }
  }
});
if (env.NODE_ENV !== "test") {
  const plugins4 = await getPlugins2();
  if (env.NODE_ENV !== "development") {
    try {
      const installedPlugins = await getPluginsInStore().catch(() => {
        console.log("Failed to get plugins from DB.");
        return [];
      });
      for (const pluginInfo of installedPlugins) {
        const pluginJson = await getPluginJson(pluginInfo).catch(() => null);
        if (!pluginJson) {
          console.log(`Invalid plugin.json for "${pluginInfo.slug}".`);
          continue;
        }
        if (Object.keys(plugins4).find((p2) => p2 === pluginJson.slug)) {
          console.log(`Plugin "${pluginJson.slug}" already installed on server.`);
          continue;
        }
        if (!pluginJson.server) {
          console.log(`Plugin "${pluginJson.slug}" has no server entrypoint.`);
          continue;
        }
        await installServerPlugin(pluginInfo).catch((e2) => {
          if (e2.message.includes("PLUGIN_WITH_SAME_SLUG")) {
            console.log(`Plugin "${pluginInfo.slug}" already installed on server.`);
            return;
          }
          console.log(`Failed to install "${pluginInfo.slug}": ${e2}`);
        });
      }
    } catch (e2) {
      console.log("Failed to install plugins from DB.");
      console.error(e2);
    }
  }
  app.listen(PORT, () => {
    console.log(`\u2705 Server started at: http://localhost:${PORT}`);
    console.log(`\uD83D\uDFE3 GraphQL API: http://localhost:${PORT}/graphql`);
  });
  await pgBoss.start();
  console.log("\u2705 PgBoss started.");
  for (const plugin3 of Object.values(plugins4)) {
    const handlers = plugin3.handlePgBossWork?.(pgBoss.work) ?? [];
    await Promise.all(handlers);
  }
  if (env.NODE_ENV !== "development") {
    await pgBoss.work(ROLLOVER_TASKS_JOB_NAME, syncTasks);
    const timezone3 = await getTimezone();
    await scheduleRolloverTasks(timezone3);
    await syncTasks();
  }
} else {
  app.listen(0);
}
process.on("SIGINT", () => {
  Promise.allSettled([
    prisma.$disconnect().then(() => console.log("\u2705 Prisma disconnected.")),
    pgBoss.stop().then(() => console.log("\u2705 PgBoss stopped."))
  ]).then(() => {
    process.exit(0);
  }).catch((e2) => {
    console.error(e2);
    process.exit(1);
  });
});
export {
  app
};
