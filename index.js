// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// /Users/richardguerre/Projects/flow/node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS((exports, module) => {
  var we = function(e, t) {
    return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
  };
  var D = function(e, t = false) {
    let r = [], n = 0;
    for (;n < e.length; ) {
      let a = e[n], c = function(l) {
        if (!t)
          throw new TypeError(l);
        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
      };
      if (a === "*") {
        r.push({ type: "ASTERISK", index: n, value: e[n++] });
        continue;
      }
      if (a === "+" || a === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
        continue;
      }
      if (a === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
        continue;
      }
      if (a === "{") {
        r.push({ type: "OPEN", index: n, value: e[n++] });
        continue;
      }
      if (a === "}") {
        r.push({ type: "CLOSE", index: n, value: e[n++] });
        continue;
      }
      if (a === ":") {
        let l = "", s = n + 1;
        for (;s < e.length; ) {
          let i = e.substr(s, 1);
          if (s === n + 1 && Te.test(i) || s !== n + 1 && Ae.test(i)) {
            l += e[s++];
            continue;
          }
          break;
        }
        if (!l) {
          c(`Missing parameter name at ${n}`);
          continue;
        }
        r.push({ type: "NAME", index: n, value: l }), n = s;
        continue;
      }
      if (a === "(") {
        let l = 1, s = "", i = n + 1, o = false;
        if (e[i] === "?") {
          c(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e.length; ) {
          if (!we(e[i], false)) {
            c(`Invalid character '${e[i]}' at ${i}.`), o = true;
            break;
          }
          if (e[i] === "\\") {
            s += e[i++] + e[i++];
            continue;
          }
          if (e[i] === ")") {
            if (l--, l === 0) {
              i++;
              break;
            }
          } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
            c(`Capturing groups are not allowed at ${i}`), o = true;
            break;
          }
          s += e[i++];
        }
        if (o)
          continue;
        if (l) {
          c(`Unbalanced pattern at ${n}`);
          continue;
        }
        if (!s) {
          c(`Missing pattern at ${n}`);
          continue;
        }
        r.push({ type: "REGEX", index: n, value: s }), n = i;
        continue;
      }
      r.push({ type: "CHAR", index: n, value: e[n++] });
    }
    return r.push({ type: "END", index: n, value: "" }), r;
  };
  var F = function(e, t = {}) {
    let r = D(e);
    t.delimiter ??= "/#?", t.prefixes ??= "./";
    let n = `[^${x(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = new Set, o = (f) => {
      if (l < r.length && r[l].type === f)
        return r[l++].value;
    }, h = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), p = (f) => {
      let u = o(f);
      if (u !== undefined)
        return u;
      let { type: d, index: T } = r[l];
      throw new TypeError(`Unexpected ${d} at ${T}, expected ${f}`);
    }, O = () => {
      let f = "", u;
      for (;u = o("CHAR") ?? o("ESCAPED_CHAR"); )
        f += u;
      return f;
    }, be = (f) => f, L = t.encodePart || be, I = "", H = (f) => {
      I += f;
    }, $ = () => {
      I.length && (a.push(new k(3, "", "", L(I), "", 3)), I = "");
    }, X = (f, u, d, T, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u && !d && g === 3) {
        H(f);
        return;
      }
      if ($(), !u && !d) {
        if (!f)
          return;
        a.push(new k(3, "", "", L(f), "", g));
        return;
      }
      let m;
      d ? d === "*" ? m = v : m = d : m = n;
      let R = 2;
      m === n ? (R = 1, m = "") : m === v && (R = 0, m = "");
      let S;
      if (u ? S = u : d && (S = c++), i.has(S))
        throw new TypeError(`Duplicate name '${S}'.`);
      i.add(S), a.push(new k(R, S, L(f), m, L(T), g));
    };
    for (;l < r.length; ) {
      let f = o("CHAR"), u = o("NAME"), d = o("REGEX");
      if (!u && !d && (d = o("ASTERISK")), u || d) {
        let g = f ?? "";
        t.prefixes.indexOf(g) === -1 && (H(g), g = ""), $();
        let m = h();
        X(g, u, d, "", m);
        continue;
      }
      let T = f ?? o("ESCAPED_CHAR");
      if (T) {
        H(T);
        continue;
      }
      if (o("OPEN")) {
        let g = O(), m = o("NAME"), R = o("REGEX");
        !m && !R && (R = o("ASTERISK"));
        let S = O();
        p("CLOSE");
        let Pe = h();
        X(g, m, R, S, Pe);
        continue;
      }
      $(), p("END");
    }
    return a;
  };
  var x = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e) {
    return e && e.ignoreCase ? "ui" : "u";
  };
  var q = function(e, t, r) {
    return W(F(e, r), t, r);
  };
  var y = function(e) {
    switch (e) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e, t, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n = r.start ? "^" : "";
    for (let s of e) {
      if (s.type === 3) {
        s.modifier === 3 ? n += x(s.value) : n += `(?:${x(s.value)})${y(s.modifier)}`;
        continue;
      }
      t && t.push(s.name);
      let i = `[^${x(r.delimiter)}]+?`, o = s.value;
      if (s.type === 1 ? o = i : s.type === 0 && (o = v), !s.prefix.length && !s.suffix.length) {
        s.modifier === 3 || s.modifier === 1 ? n += `(${o})${y(s.modifier)}` : n += `((?:${o})${y(s.modifier)})`;
        continue;
      }
      if (s.modifier === 3 || s.modifier === 1) {
        n += `(?:${x(s.prefix)}(${o})${x(s.suffix)})`, n += y(s.modifier);
        continue;
      }
      n += `(?:${x(s.prefix)}`, n += `((?:${o})(?:`, n += x(s.suffix), n += x(s.prefix), n += `(?:${o}))*)${x(s.suffix)})`, s.modifier === 0 && (n += "?");
    }
    let a = `[${x(r.endsWith)}]|\$`, c = `[${x(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
    r.strict || (n += `(?:${c}(?=${a}))?`);
    let l = false;
    if (e.length) {
      let s = e[e.length - 1];
      s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
    }
    return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
  };
  var ee = function(e, t) {
    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
  };
  var te = function(e, t) {
    return e.startsWith(t) ? e.substring(t.length, e.length) : e;
  };
  var Ce = function(e, t) {
    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
  };
  var _ = function(e) {
    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
  };
  var N = function(e) {
    if (!e)
      return true;
    for (let t of re)
      if (e.test(t))
        return true;
    return false;
  };
  var ne = function(e, t) {
    if (e = te(e, "#"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e, t) {
    if (e = te(e, "?"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e, t) {
    return t || e === "" ? e : _(e) ? K(e) : j(e);
  };
  var ae = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.password = e, r.password;
  };
  var oe = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.username = e, r.username;
  };
  var ce = function(e, t, r) {
    if (r || e === "")
      return e;
    if (t && !re.includes(t))
      return new URL(`${t}:${e}`).pathname;
    let n = e[0] == "/";
    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
  };
  var le = function(e, t, r) {
    return z(t) === e && (e = ""), r || e === "" ? e : V(e);
  };
  var he = function(e, t) {
    return e = Ce(e, ":"), t || e === "" ? e : A(e);
  };
  var z = function(e) {
    switch (e) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var A = function(e) {
    if (e === "")
      return e;
    if (/^[-+.A-Za-z0-9]*$/.test(e))
      return e.toLowerCase();
    throw new TypeError(`Invalid protocol '${e}'.`);
  };
  var fe = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.username = e, t.username;
  };
  var ue = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.password = e, t.password;
  };
  var j = function(e) {
    if (e === "")
      return e;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
      throw new TypeError(`Invalid hostname '${e}'`);
    let t = new URL("https://example.com");
    return t.hostname = e, t.hostname;
  };
  var K = function(e) {
    if (e === "")
      return e;
    if (/[^0-9a-fA-F[\]:]/g.test(e))
      throw new TypeError(`Invalid IPv6 hostname '${e}'`);
    return e.toLowerCase();
  };
  var V = function(e) {
    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
      return e;
    throw new TypeError(`Invalid port '${e}'.`);
  };
  var pe = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
  };
  var de = function(e) {
    return e === "" ? e : new URL(`data:${e}`).pathname;
  };
  var ge = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.search = e, t.search.substring(1, t.search.length);
  };
  var me = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.hash = e, t.hash.substring(1, t.hash.length);
  };
  var xe = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e, t);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var P = function(e, t) {
    return t ? C(e) : e;
  };
  var w = function(e, t, r) {
    let n;
    if (typeof t.baseURL == "string")
      try {
        n = new URL(t.baseURL), e.protocol = P(n.protocol.substring(0, n.protocol.length - 1), r), e.username = P(n.username, r), e.password = P(n.password, r), e.hostname = P(n.hostname, r), e.port = P(n.port, r), e.pathname = P(n.pathname, r), e.search = P(n.search.substring(1, n.search.length), r), e.hash = P(n.hash.substring(1, n.hash.length), r);
      } catch {
        throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
      }
    if (typeof t.protocol == "string" && (e.protocol = he(t.protocol, r)), typeof t.username == "string" && (e.username = oe(t.username, r)), typeof t.password == "string" && (e.password = ae(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
      if (e.pathname = t.pathname, n && !ee(e.pathname, r)) {
        let a = n.pathname.lastIndexOf("/");
        a >= 0 && (e.pathname = P(n.pathname.substring(0, a + 1), r) + e.pathname);
      }
      e.pathname = ce(e.pathname, e.protocol, r);
    }
    return typeof t.search == "string" && (e.search = se(t.search, r)), typeof t.hash == "string" && (e.hash = ne(t.hash, r)), e;
  };
  var C = function(e) {
    return e.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e, t) {
    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
    let r = ".*", n = `[^${Le(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
    for (let l = 0;l < e.length; ++l) {
      let s = e[l];
      if (s.type === 3) {
        if (s.modifier === 3) {
          c += C(s.value);
          continue;
        }
        c += `{${C(s.value)}}${y(s.modifier)}`;
        continue;
      }
      let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), h = l > 0 ? e[l - 1] : null, p = l < e.length - 1 ? e[l + 1] : null;
      if (!o && i && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)
        if (p.type === 3) {
          let O = p.value.length > 0 ? p.value[0] : "";
          o = a.test(O);
        } else
          o = !p.hasCustomName();
      if (!o && !s.prefix.length && h && h.type === 3) {
        let O = h.value[h.value.length - 1];
        o = t.prefixes.includes(O);
      }
      o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!h || h.type === 3 || h.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += y(s.modifier));
    }
    return c;
  };
  var M = Object.defineProperty;
  var Se = Object.getOwnPropertyDescriptor;
  var ke = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Re = (e, t) => {
    for (var r in t)
      M(e, r, { get: t[r], enumerable: true });
  };
  var ye = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let a of ke(t))
        !Ee.call(e, a) && a !== r && M(e, a, { get: () => t[a], enumerable: !(n = Se(t, a)) || n.enumerable });
    return e;
  };
  var Oe = (e) => ye(M({}, "__esModule", { value: true }), e);
  var Ne = {};
  Re(Ne, { URLPattern: () => Y });
  module.exports = Oe(Ne);
  var k = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t, r, n, a, c, l) {
      this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Te = /[$_\p{ID_Start}]/u;
  var Ae = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var b = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var U = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #u = 0;
    #c = 0;
    #p = 0;
    #d = 0;
    #g = false;
    constructor(t) {
      this.#i = t;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#c === 0) {
            this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = "") : (this.#r(7, 0), this.#t.search = "", this.#t.hash = "");
            continue;
          } else if (this.#c === 2) {
            this.#f(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#p > 0)
          if (this.#T())
            this.#p -= 1;
          else
            continue;
        if (this.#O()) {
          this.#p += 1;
          continue;
        }
        switch (this.#c) {
          case 0:
            this.#S() && (this.#t.username = "", this.#t.password = "", this.#t.hostname = "", this.#t.port = "", this.#t.pathname = "", this.#t.search = "", this.#t.hash = "", this.#f(1));
            break;
          case 1:
            if (this.#S()) {
              this.#C();
              let t = 7, r = 1;
              this.#g && (this.#t.pathname = "/"), this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
            }
            break;
          case 2:
            this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);
            break;
          case 3:
            this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);
            break;
          case 4:
            this.#x() && this.#r(5, 1);
            break;
          case 5:
            this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 6:
            this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
            break;
          case 8:
            this.#l() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
    }
    #r(t, r) {
      switch (this.#c) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#o();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#o();
          break;
        case 4:
          this.#t.password = this.#o();
          break;
        case 5:
          this.#t.hostname = this.#o();
          break;
        case 6:
          this.#t.port = this.#o();
          break;
        case 7:
          this.#t.pathname = this.#o();
          break;
        case 8:
          this.#t.search = this.#o();
          break;
        case 9:
          this.#t.hash = this.#o();
          break;
        case 10:
          break;
      }
      this.#k(t, r);
    }
    #k(t, r) {
      this.#c = t, this.#u = this.#e + r, this.#e += r, this.#s = 0;
    }
    #P() {
      this.#e = this.#u, this.#s = 0;
    }
    #f(t) {
      this.#P(), this.#c = t;
    }
    #m(t) {
      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
    }
    #a(t, r) {
      let n = this.#m(t);
      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
    }
    #S() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #x() {
      return this.#a(this.#e, "@");
    }
    #R() {
      return this.#a(this.#e, ":");
    }
    #y() {
      return this.#a(this.#e, ":");
    }
    #b() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t = this.#m(this.#e - 1);
      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
    }
    #l() {
      return this.#a(this.#e, "#");
    }
    #O() {
      return this.#n[this.#e].type == "OPEN";
    }
    #T() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #A() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #o() {
      let t = this.#n[this.#e], r = this.#m(this.#u).index;
      return this.#i.substring(r, t.index);
    }
    #C() {
      let t = {};
      Object.assign(t, b), t.encodePart = A;
      let r = q(this.#o(), undefined, t);
      this.#g = N(r);
    }
  };
  var G = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    constructor(t = {}, r, n) {
      try {
        let a;
        if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
          let i = new U(t);
          if (i.parse(), t = i.result, a === undefined && typeof t.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t.baseURL = a;
        } else {
          if (!t || typeof t != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n > "u" && (n = { ignoreCase: false });
        let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s;
        for (s of G) {
          if (!(s in this.#i))
            continue;
          let i = {}, o = this.#i[s];
          switch (this.#t[s] = [], s) {
            case "protocol":
              Object.assign(i, b), i.encodePart = A;
              break;
            case "username":
              Object.assign(i, b), i.encodePart = fe;
              break;
            case "password":
              Object.assign(i, b), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, b), i.encodePart = V;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c), i.encodePart = pe) : (Object.assign(i, b, c), i.encodePart = de);
              break;
            case "search":
              Object.assign(i, b, c), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, b, c), i.encodePart = me;
              break;
          }
          try {
            this.#s[s] = F(o, i), this.#n[s] = W(this.#s[s], this.#t[s], i), this.#e[s] = Ie(this.#s[s], i);
          } catch {
            throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
          }
        }
      } catch (a) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
      }
    }
    test(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return false;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, xe(t, r), false);
      } catch {
        return false;
      }
      let a;
      for (a of G)
        if (!this.#n[a].exec(n[a]))
          return false;
      return true;
    }
    exec(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, xe(t, r), false);
      } catch {
        return null;
      }
      let a = {};
      r ? a.inputs = [t, r] : a.inputs = [t];
      let c;
      for (c of G) {
        let l = this.#n[c].exec(n[c]);
        if (!l)
          return null;
        let s = {};
        for (let [i, o] of this.#t[c].entries())
          if (typeof o == "string" || typeof o == "number") {
            let h = l[i + 1];
            s[o] = h;
          }
        a[c] = { input: n[c] ?? "", groups: s };
      }
      return a;
    }
    static compareComponent(t, r, n) {
      let a = (i, o) => {
        for (let h of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[h] < o[h])
            return -1;
          if (i[h] === o[h])
            continue;
          return 1;
        }
        return 0;
      }, c = new k(3, "", "", "", "", 3), l = new k(0, "", "", "", "", 3), s = (i, o) => {
        let h = 0;
        for (;h < Math.min(i.length, o.length); ++h) {
          let p = a(i[h], o[h]);
          if (p)
            return p;
        }
        return i.length === o.length ? 0 : a(i[h] ?? c, o[h] ?? c);
      };
      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillAbortError = undefined;

  class PonyfillAbortError extends Error {
    constructor(reason) {
      let message = "The operation was aborted";
      if (reason) {
        message += ` reason: ${reason}`;
      }
      super(message, {
        cause: reason
      });
      this.name = "AbortError";
    }
    get reason() {
      return this.cause;
    }
  }
  exports.PonyfillAbortError = PonyfillAbortError;
});

// /Users/richardguerre/Projects/flow/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type = str.slice(0, i).toLowerCase();
    return { type, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode = 2;
                else if (encode === 0)
                  encode = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode)
      return decode(data, hint);
  };
  var basename = function(path) {
    if (typeof path !== "string")
      return "";
    for (let i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// /Users/richardguerre/Projects/flow/node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = import.meta.require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = import.meta.require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// /Users/richardguerre/Projects/flow/node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type of TYPES) {
      const matched = type.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = import.meta.require("stream");

  class PonyfillReadableStream {
    constructor(underlyingSource) {
      this.locked = false;
      if (underlyingSource instanceof PonyfillReadableStream) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        let reader;
        let started = false;
        this.readable = new stream_1.Readable({
          read() {
            if (!started) {
              started = true;
              reader = underlyingSource.getReader();
            }
            reader.read().then(({ value, done }) => {
              if (done) {
                this.push(null);
              } else {
                this.push(value);
              }
            }).catch((err) => {
              this.destroy(err);
            });
          },
          destroy(err, callback) {
            reader.cancel(err).then(() => callback(err), callback);
          }
        });
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          async destroy(err, callback) {
            try {
              await underlyingSource?.cancel?.(err);
              callback(null);
            } catch (err2) {
              callback(err2);
            }
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return Promise.resolve();
    }
    getReader(_options) {
      const iterator = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator.next();
        },
        releaseLock: () => {
          iterator.return?.();
          this.locked = false;
        },
        cancel: async (reason) => {
          await iterator.return?.(reason);
          this.locked = false;
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    async pipeTo(destination) {
      const writer = destination.getWriter();
      await writer.ready;
      for await (const chunk of this.readable) {
        await writer.write(chunk);
      }
      await writer.ready;
      return writer.close();
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils2 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value);
      }
      headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
  };
  var isPromise4 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value) {
    if (isPromise4(value)) {
      return value;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value);
          if (isPromise4(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise4(callbackResult)) {
            return callbackResult.then(() => value);
          }
          return fakePromise(value);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadable = exports.isArrayBufferView = exports.fakePromise = exports.defaultHeadersSerializer = exports.getHeadersObj = undefined;
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var isBlob = function(obj) {
    return obj != null && obj.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();

  class PonyfillBlob {
    constructor(blobParts, options) {
      this.blobParts = blobParts;
      this._size = null;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && isBlob(blobParts[0])) {
        return blobParts[0];
      }
    }
    arrayBuffer() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.arrayBuffer();
        }
        return (0, utils_js_1.fakePromise)(getBlobPartAsBuffer(blobPart));
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (isBlob(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    text() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          return (0, utils_js_1.fakePromise)(blobPart);
        }
        if (isBlob(blobPart)) {
          return blobPart.text();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(buf.toString(this.encoding));
      }
      return this.arrayBuffer().then((buf) => buf.toString(this.encoding));
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (isBlob(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (isBlob(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    constructor(fileBits, name, options) {
      super(fileBits, options);
      this.name = name;
      this.webkitRelativePath = "";
      this.lastModified = options?.lastModified || Date.now();
    }
  }
  exports.PonyfillFile = PonyfillFile;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value] = entry;
          if (typeof value === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value));
          } else {
            let filenamePart = "";
            if (value.name) {
              filenamePart = `; filename="${value.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name, blob, fileName) {
    blob.name = fileName || blob.name || name;
    return blob;
  };
  var isBlob = function(value) {
    return value?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamFromFormData = exports.PonyfillFormData = undefined;
  var ReadableStream_js_1 = require_ReadableStream();

  class PonyfillFormData {
    constructor() {
      this.map = new Map;
    }
    append(name, value, fileName) {
      let values3 = this.map.get(name);
      if (!values3) {
        values3 = [];
        this.map.set(name, values3);
      }
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      values3.push(entry);
    }
    delete(name) {
      this.map.delete(name);
    }
    get(name) {
      const values3 = this.map.get(name);
      return values3 ? values3[0] : null;
    }
    getAll(name) {
      return this.map.get(name) || [];
    }
    has(name) {
      return this.map.has(name);
    }
    set(name, value, fileName) {
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      this.map.set(name, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values3] of this.map) {
        for (const value of values3) {
          yield [key, value];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values3 of this.map.values()) {
        for (const value of values3) {
          yield value;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
  exports.getStreamFromFormData = getStreamFromFormData;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value) {
    return value?.forEach != null;
  };
  var isBlob = function(value) {
    return value?.stream != null;
  };
  var isURLSearchParams = function(value) {
    return value?.sort != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = import.meta.require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob();
  var File_js_1 = require_File();
  var FormData_js_1 = require_FormData();
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      this.bodyUsed = false;
      this.contentType = null;
      this.contentLength = null;
      this._bodyFactory = () => null;
      this._generatedBody = null;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    generateBody() {
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _collectChunksFromReadable() {
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      const chunks = [];
      _body.readable.on("data", (chunk) => {
        chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(chunks);
        });
        _body.readable.once("error", (e) => {
          reject(e);
        });
      });
    }
    blob() {
      if (this.bodyType === BodyInitType.Blob) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      if (this._buffer) {
        const blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
      });
    }
    formData(opts) {
      if (this.bodyType === BodyInitType.FormData) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      const formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          formData.set(name, value);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            formData.set(name, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(formData);
        });
        bb.on("error", (err) => {
          reject(err);
        });
        _body?.readable.pipe(bb);
      });
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
          return this.bodyInit.arrayBuffer();
        }
        const bodyInitTyped = this.bodyInit;
        return bodyInitTyped.arrayBuffer().then((arrayBuffer) => Buffer.from(arrayBuffer, undefined, bodyInitTyped.size));
      }
      return this._collectChunksFromReadable().then((chunks) => {
        if (chunks.length === 1) {
          return chunks[0];
        }
        return Buffer.concat(chunks);
      });
    }
    json() {
      return this.text().then((text) => JSON.parse(text));
    }
    text() {
      if (this.bodyType === BodyInitType.String) {
        return (0, utils_js_1.fakePromise)(this.bodyInit);
      }
      return this.arrayBuffer().then((buffer) => buffer.toString("utf-8"));
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  var splitSetCookieHeader = function(setCookieHeader) {
    const setCookieHeaders = [];
    let currentStr = "";
    let ignoreComma = false;
    for (const ch of setCookieHeader) {
      if (currentStr.endsWith("Expires=")) {
        ignoreComma = true;
      }
      if (ignoreComma) {
        if (ch === ";") {
          ignoreComma = false;
        }
        if (ch === "," && currentStr.split("Expires=")[1].length > 3) {
          ignoreComma = false;
        }
      }
      if (ch === "," && !ignoreComma) {
        setCookieHeaders.push(currentStr.trim());
        currentStr = "";
      } else {
        currentStr += ch;
      }
    }
    if (currentStr) {
      setCookieHeaders.push(currentStr.trim());
    }
    return setCookieHeaders;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitSetCookieHeader = exports.PonyfillHeaders = exports.isHeadersLike = undefined;
  var node_util_1 = import.meta.require("util");
  exports.isHeadersLike = isHeadersLike;

  class PonyfillHeaders {
    constructor(headersInit) {
      this.headersInit = headersInit;
      this.objectNormalizedKeysOfHeadersInit = [];
      this.objectOriginalKeysOfHeadersInit = [];
    }
    _get(key) {
      if (this._map) {
        return this._map.get(key.toLowerCase()) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      const normalized = key.toLowerCase();
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k) => {
            this.objectOriginalKeysOfHeadersInit.push(k);
            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map(this.headersInit);
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value, key) => {
              this._map.set(key, value);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name, value) {
      const key = name.toLowerCase();
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value}` : value;
      this.getMap().set(key, finalValue);
    }
    get(name) {
      const value = this._get(name);
      if (value == null) {
        return null;
      }
      return value;
    }
    has(name) {
      return !!this._get(name);
    }
    set(name, value) {
      const key = name.toLowerCase();
      this.getMap().set(key, value);
    }
    delete(name) {
      const key = name.toLowerCase();
      this.getMap().delete(key);
    }
    forEach(callback) {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value]) => {
              callback(value, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value]) => {
            if (value != null) {
              callback(value, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value, key) => {
        callback(value, key, this);
      });
    }
    keys() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit.map(([key]) => key)[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.keys();
          }
          return Object.keys(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().keys();
    }
    values() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit.map(([, value]) => value)[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.values();
          }
          return Object.values(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().values();
    }
    entries() {
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            return this.headersInit[Symbol.iterator]();
          }
          if (isHeadersLike(this.headersInit)) {
            return this.headersInit.entries();
          }
          return Object.entries(this.headersInit)[Symbol.iterator]();
        }
      }
      return this.getMap().entries();
    }
    getSetCookie() {
      const setCookieHeader = this.get("set-cookie");
      if (!setCookieHeader) {
        return [];
      }
      return splitSetCookieHeader(setCookieHeader);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record = {};
      this.forEach((value, key) => {
        if (key === "set-cookie") {
          record["set-cookie"] = this.getSetCookie();
        } else {
          record[key] = value.includes(",") ? value.split(",").map((el) => el.trim()) : value;
        }
      });
      return `Headers ${(0, node_util_1.inspect)(record)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
  exports.splitSetCookieHeader = splitSetCookieHeader;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = import.meta.require("http");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    clone() {
      return new PonyfillResponse(this.body, this);
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 301) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlCode, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    curlHandle.setOpt("SSL_VERIFYPEER", false);
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
      size = Number(value);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    return new Promise(function promiseResolver(resolve, reject) {
      let streamResolved = false;
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          if (streamResolved) {
            curlHandle.pause(CurlPause.Recv);
          } else {
            reject(new AbortError_js_1.PonyfillAbortError);
            curlHandle.close();
          }
        };
      }
      curlHandle.once("end", function endListener() {
        curlHandle.close();
      });
      curlHandle.once("error", function errorListener(error) {
        if (error.isCurlError && error.code === CurlCode.CURLE_ABORTED_BY_CALLBACK) {
        } else {
          reject(error);
        }
        curlHandle.close();
      });
      curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
        const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
          if (headerFilter && !headerFilter.startsWith("HTTP/")) {
            if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
              reject(new Error("redirect is not allowed"));
            }
            return true;
          }
          return false;
        });
        const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
        resolve(new Response_js_1.PonyfillResponse(stream, {
          status,
          headers: headersInit,
          url: fetchRequest.url
        }));
        streamResolved = true;
      });
      curlHandle.perform();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = undefined;
  var node_stream_1 = import.meta.require("stream");
  var AbortError_js_1 = require_AbortError();
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  exports.fetchCurl = fetchCurl;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
    }
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return new PonyfillRequest(this);
    }
  }
  exports.PonyfillRequest = PonyfillRequest;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse2 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse2;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse2,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse2;
  module.exports.stringify = stringify;
});

// /Users/richardguerre/Projects/flow/node_modules/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS((exports, module) => {
  var Url = function() {
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
  };
  var _escapePath = function(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var _escapeSearch = function(search) {
    return search.replace(/#/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var containsCharacter = function(string, char1, fromIndex, stopCharacterTable) {
    var len2 = string.length;
    for (var i2 = fromIndex;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1) {
        return true;
      } else if (stopCharacterTable[ch] === 1) {
        return false;
      }
    }
    return false;
  };
  var containsCharacter2 = function(string, char1, char2) {
    for (var i2 = 0, len2 = string.length;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1 || ch === char2)
        return true;
    }
    return false;
  };
  var makeAsciiTable = function(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item) {
      if (typeof item === "number") {
        ret[item] = 1;
      } else {
        var start = item[0];
        var end = item[1];
        for (var j = start;j <= end; ++j) {
          ret[j] = 1;
        }
      }
    });
    return ret;
  };
  var f = function() {
  };
  var querystring = import.meta.require("querystring");
  Url.queryString = querystring;
  Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    while (str.charCodeAt(start) <= 32)
      start++;
    while (str.charCodeAt(end) <= 32)
      end--;
    start = this._parseProtocol(str, start, end);
    if (this._protocol !== "javascript") {
      start = this._parseHost(str, start, end, hostDenotesSlash);
      var proto = this._protocol;
      if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
        this.hostname = this.host = "";
      }
    }
    if (start <= end) {
      var ch = str.charCodeAt(start);
      if (ch === 47 || ch === 92) {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else if (ch === 63) {
        this._parseQuery(str, start, end, disableAutoEscapeChars);
      } else if (ch === 35) {
        this._parseHash(str, start, end, disableAutoEscapeChars);
      } else if (this._protocol !== "javascript") {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else {
        this.pathname = str.slice(start, end + 1);
      }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
      this.pathname = "/";
    }
    if (parseQueryString) {
      var search = this.search;
      if (search == null) {
        search = this.search = "";
      }
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      this.query = Url.queryString.parse(search);
    }
  };
  Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
  };
  Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    var q = this.query;
    if (q && typeof q === "object") {
      query = Url.queryString.stringify(q);
    }
    if (!search) {
      search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
      protocol += ":";
    if (this.host) {
      host = auth + this.host;
    } else if (hostname) {
      var ip6 = hostname.indexOf(":") > -1;
      if (ip6)
        hostname = "[" + hostname + "]";
      host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol)
      scheme = protocol + (slashes ? "//" : "");
    else if (slashes)
      scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
      pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 63)
      search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 35)
      hash = "#" + hash;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash;
  };
  Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
      relative = Url.parse(relative, false, true);
    var result = this._clone();
    result.hash = relative.hash;
    if (!relative.href) {
      result._href = "";
      return result;
    }
    if (relative.slashes && !relative._protocol) {
      relative._copyPropsTo(result, true);
      if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
      }
      result._href = "";
      return result;
    }
    if (relative._protocol && relative._protocol !== result._protocol) {
      if (!slashProtocols[relative._protocol]) {
        relative._copyPropsTo(result, false);
        result._href = "";
        return result;
      }
      result._protocol = relative._protocol;
      if (!relative.host && relative._protocol !== "javascript") {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result._port = relative._port;
      result.slashes = result.slashes || relative.slashes;
      result._href = "";
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
    var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    if (psychotic) {
      result.hostname = "";
      result._port = -1;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative._protocol) {
        relative.hostname = "";
        relative._port = -1;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = "";
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host ? relative.host : result.host;
      result.hostname = relative.hostname ? relative.hostname : result.hostname;
      result.search = relative.search;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
    } else if (relative.search) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result._href = "";
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      result._href = "";
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--) {
      last = srcPath[i2];
      if (last === ".") {
        srcPath.splice(i2, 1);
      } else if (last === "..") {
        srcPath.splice(i2, 1);
        up++;
      } else if (up) {
        srcPath.splice(i2, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (;up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
  };
  var punycode = import.meta.require("punycode");
  Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    return punycode.toASCII(hostname);
  };
  var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 35, 63)) {
      return pathname;
    }
    return _escapePath(pathname);
  };
  var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 35, -1))
      return search;
    return _escapeSearch(search);
  };
  Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        var protocol = str.slice(start, i2);
        if (doLowerCase)
          protocol = protocol.toLowerCase();
        this._protocol = protocol;
        return i2 + 1;
      } else if (protocolCharacters[ch] === 1) {
        if (ch < 97)
          doLowerCase = true;
      } else {
        return start;
      }
    }
    return start;
  };
  Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
      auth = decodeURIComponent(auth);
    }
    this.auth = auth;
  };
  Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    var port = 0;
    var hadChars = false;
    var validPort = true;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (48 <= ch && ch <= 57) {
        port = 10 * port + (ch - 48);
        hadChars = true;
      } else {
        validPort = false;
        if (ch === 92 || ch === 47) {
          validPort = true;
        }
        break;
      }
    }
    if (port === 0 && !hadChars || !validPort) {
      if (!validPort) {
        this._port = -2;
      }
      return 0;
    }
    this._port = port;
    return i2 - start;
  };
  Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
      this.slashes = true;
      if (start === 0) {
        if (end < 2)
          return start;
        var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
        if (!hasAuth && !slashesDenoteHost) {
          this.slashes = null;
          return start;
        }
      }
      start += 2;
    } else if (!this._protocol || slashProtocols[this._protocol]) {
      return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 64) {
        j = i2;
      } else if (ch === 37) {
        authNeedsDecoding = true;
      } else if (hostEndingCharacters[ch] === 1) {
        break;
      }
    }
    if (j > -1) {
      this._parseAuth(str, start, j - 1, authNeedsDecoding);
      start = hostNameStart = j + 1;
    }
    if (str.charCodeAt(start) === 91) {
      for (var i2 = start + 1;i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 93) {
          if (str.charCodeAt(i2 + 1) === 58) {
            portLength = this._parsePort(str, i2 + 2, end) + 1;
          }
          var hostname = str.slice(start + 1, i2).toLowerCase();
          this.hostname = hostname;
          this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
          this.pathname = "/";
          return i2 + portLength + 1;
        }
      }
      return start;
    }
    for (var i2 = start;i2 <= end; ++i2) {
      if (charsAfterDot > 62) {
        this.hostname = this.host = str.slice(start, i2);
        return i2;
      }
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        portLength = this._parsePort(str, i2 + 1, end) + 1;
        hostNameEnd = i2 - 1;
        break;
      } else if (ch < 97) {
        if (ch === 46) {
          charsAfterDot = -1;
        } else if (65 <= ch && ch <= 90) {
          doLowerCase = true;
        } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
          if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
      } else if (ch >= 123) {
        if (ch <= 126) {
          if (this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
        idna = true;
      }
      lastCh = ch;
      charsAfterDot++;
    }
    if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
      var hostname = str.slice(hostNameStart, hostNameEnd + 1);
      if (doLowerCase)
        hostname = hostname.toLowerCase();
      if (idna)
        hostname = this._hostIdna(hostname);
      this.hostname = hostname;
      this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
  };
  Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
      input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
  };
  Url.prototype._clone = function Url$_clone() {
    var ret = new Url;
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
  };
  Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i2 = start;
    var ret = "";
    var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      var escaped = autoEscapeMap2[ch];
      if (escaped !== "" && escaped !== undefined) {
        if (cur < i2)
          ret += str.slice(cur, i2);
        ret += escaped;
        cur = i2 + 1;
      }
    }
    if (cur < i2 + 1)
      ret += str.slice(cur, i2);
    return ret;
  };
  Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (ch === 63) {
        this._parseQuery(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (pathStart > pathEnd) {
      this.pathname = prePath === "" ? "/" : prePath;
      return;
    }
    var path;
    if (escape2) {
      path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
      path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
  };
  Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        queryEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (queryStart > queryEnd) {
      this.search = "";
      return;
    }
    var query;
    if (escape2) {
      query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
      query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
  };
  Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
      this.hash = "";
      return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
  };
  Object.defineProperty(Url.prototype, "port", {
    get: function() {
      if (this._port >= 0) {
        return "" + this._port;
      }
      return null;
    },
    set: function(v) {
      if (v == null) {
        this._port = -1;
      } else {
        this._port = parseInt(v, 10);
      }
    }
  });
  Object.defineProperty(Url.prototype, "query", {
    get: function() {
      var query = this._query;
      if (query != null) {
        return query;
      }
      var search = this.search;
      if (search) {
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        if (search !== "") {
          this._query = search;
          return search;
        }
      }
      return search;
    },
    set: function(v) {
      this._query = v;
    }
  });
  Object.defineProperty(Url.prototype, "path", {
    get: function() {
      var p = this.pathname || "";
      var s = this.search || "";
      if (p || s) {
        return p + s;
      }
      return p == null && s ? "/" + s : null;
    },
    set: function() {
    }
  });
  Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
      var proto = this._protocol;
      return proto ? proto + ":" : proto;
    },
    set: function(v) {
      if (typeof v === "string") {
        var end = v.length - 1;
        if (v.charCodeAt(end) === 58) {
          this._protocol = v.slice(0, end);
        } else {
          this._protocol = v;
        }
      } else if (v == null) {
        this._protocol = null;
      }
    }
  });
  Object.defineProperty(Url.prototype, "href", {
    get: function() {
      var href = this._href;
      if (!href) {
        href = this._href = this.format();
      }
      return href;
    },
    set: function(v) {
      this._href = v;
    }
  });
  Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url)
      return str;
    var ret = new Url;
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
  };
  Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
      obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  };
  Url.resolve = function Url$Resolve(source2, relative) {
    return Url.parse(source2, false, true).resolve(relative);
  };
  Url.resolveObject = function Url$ResolveObject(source2, relative) {
    if (!source2)
      return relative;
    return Url.parse(source2, false, true).resolveObject(relative);
  };
  var autoEscape = [
    "<",
    ">",
    "\"",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
  ];
  var autoEscapeMap = new Array(128);
  for (i = 0, len = autoEscapeMap.length;i < len; ++i) {
    autoEscapeMap[i] = "";
  }
  var i;
  var len;
  for (i = 0, len = autoEscape.length;i < len; ++i) {
    c = autoEscape[i];
    esc = encodeURIComponent(c);
    if (esc === c) {
      esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
  }
  var c;
  var esc;
  var i;
  var len;
  var afterQueryAutoEscapeMap = autoEscapeMap.slice();
  autoEscapeMap[92] = "/";
  var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
  };
  f.prototype = slashProtocols;
  Url.prototype._protocolCharacters = makeAsciiTable([
    [97, 122],
    [65, 90],
    46,
    43,
    45
  ]);
  Url.prototype._hostEndingCharacters = makeAsciiTable([
    35,
    63,
    47,
    92
  ]);
  Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "^",
    "`",
    "\"",
    "%",
    ";"
  ].map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._autoEscapeMap = autoEscapeMap;
  Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
  module.exports = Url;
  Url.replace = function Url$Replace() {
    require.cache.url = {
      exports: Url
    };
  };
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var isURLSearchParams = function(value) {
    return value?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value] of init) {
            this.params[key] = value;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value] of init.entries()) {
            this.params[key] = value;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name, value) {
      const existingValue = this.params[name];
      const finalValue = existingValue ? `${existingValue},${value}` : value;
      this.params[name] = finalValue;
    }
    delete(name) {
      delete this.params[name];
    }
    get(name) {
      const value = this.params[name];
      if (Array.isArray(value)) {
        return value[0] || null;
      }
      return value || null;
    }
    getAll(name) {
      const value = this.params[name];
      if (!Array.isArray(value)) {
        return value ? [value] : [];
      }
      return value;
    }
    has(name) {
      return name in this.params;
    }
    set(name, value) {
      this.params[name] = value;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value = this.params[key];
        if (Array.isArray(value)) {
          for (const item of value) {
            yield [key, item];
          }
        } else {
          yield [key, value];
        }
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value) {
      this.auth = `${value}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value) {
      this.auth = `${this.username}:${value}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
  }
  exports.PonyfillURL = PonyfillURL;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        fetchRequest["_signal"]?.addEventListener("abort", () => {
          if (!nodeRequest.aborted) {
            nodeRequest.abort();
          }
        });
        nodeRequest.once("abort", (reason) => {
          reject(new AbortError_js_1.PonyfillAbortError(reason));
        });
        nodeRequest.once("response", (nodeResponse) => {
          let responseBody = nodeResponse;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
              break;
            case "x-deflate":
            case "deflate":
              responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
              break;
            case "br":
              responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
              break;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e) {
        reject(e);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = undefined;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var stream_1 = import.meta.require("stream");
  var zlib_1 = import.meta.require("zlib");
  var AbortError_js_1 = require_AbortError();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  exports.fetchNodeHttp = fetchNodeHttp;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = undefined;
  var fs_1 = import.meta.require("fs");
  var url_1 = import.meta.require("url");
  var fetchCurl_js_1 = require_fetchCurl();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
  var BASE64_SUFFIX = ";base64";
  exports.fetchPonyfill = fetchPonyfill;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBtoa = exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  var utils_js_1 = require_utils2();

  class PonyfillTextEncoder {
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source2, destination) {
      const buffer = this.encode(source2);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      this.fatal = false;
      this.ignoreBOM = false;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
  exports.PonyfillBtoa = PonyfillBtoa;
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
});

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS((exports, module) => {
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    if (!ponyfills.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill();
      ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (globalThis.Deno || process.versions.bun) {
      return globalThis;
    }
    const newNodeFetch = require_cjs();
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = globalThis.WritableStream;
    ponyfills.TransformStream = globalThis.TransformStream;
    if (!ponyfills.WritableStream) {
      const streamsWeb = import.meta.require("stream/web");
      ponyfills.WritableStream = streamsWeb.WritableStream;
      ponyfills.TransformStream = streamsWeb.TransformStream;
    }
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Request = class Request2 extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Response = class Response2 extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills.crypto) {
      const cryptoModule = import.meta.require("crypto");
      ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var to = function(e) {
    return typeof e == "function" ? e : (t) => t.$extends(e);
  };
  var ro = function(e) {
    return e;
  };
  var no = function(...e) {
    return (t) => t;
  };
  var lo = function(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  };
  var In = function(e, t) {
    return t ? `${t}.${e}` : e;
  };
  var mu = function(e) {
    let t = (0, vr.default)(e), r = Object.assign((...n) => (t.log = r.log, n.length !== 0 && It.push([e, ...n]), It.length > du && It.shift(), t("", ...n)), t);
    return r;
  };
  var bo = function(e = 7500) {
    let t = It.map((r) => r.map((n) => typeof n == "string" ? n : JSON.stringify(n)).join(" ")).join(`
`);
    return t.length < e ? t : t.slice(-e);
  };
  var Eo = function() {
    It.length = 0;
  };
  var _ = function(e, t) {
    let r = new RegExp(`\\x1b\\[${t}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${t}m`;
    return function(o) {
      return !fu.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(r, i + n) : o) + i;
    };
  };
  var Vn = function() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && Co.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var jn = function(e, t) {
    let r = t === "url";
    return e.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? r ? `${Cr}.dylib.node` : `${Cr}-${e}.dylib.node` : r ? `${Cr}.so.node` : `${Cr}-${e}.so.node`;
  };
  var Je = function(e) {
    var t;
    return (t = {})[Ar] = function() {
      return { match: function(r) {
        return { matched: !!e(r) };
      } };
    }, t;
  };
  var st = function(e) {
    return new yu(e, []);
  };
  var Ot = function(e) {
    return (0, _o.default)(e, e, { fallback: te });
  };
  var Dt = function(e, ...t) {
    Eu.warn() && console.warn(`${bu.warn} ${e}`, ...t);
  };
  async function Vo() {
    let e = Sr.default.platform(), t = process.arch;
    if (e === "freebsd") {
      let s = await Ir("freebsd-version");
      if (s && s.trim().length > 0) {
        let l = /^(\d+)\.?/.exec(s);
        if (l)
          return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: t };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: t };
    let r = await Tu(), n = await Fu(), i = Au({ arch: t, archFromUname: n, familyDistro: r.familyDistro }), { libssl: o } = await Ru(i);
    return { platform: "linux", libssl: o, arch: t, archFromUname: n, ...r };
  }
  var vu = function(e) {
    let t = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n = t.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = r.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = st({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l }));
    return ie(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
  };
  async function Tu() {
    let e = "/etc/os-release";
    try {
      let t = await Gn.default.readFile(e, { encoding: "utf-8" });
      return vu(t);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var Cu = function(e) {
    let t = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (t) {
      let r = `${t[1]}.x`;
      return jo(r);
    }
  };
  var No = function(e) {
    let t = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (t) {
      let r = `${t[1]}${t[2] ?? ".0"}.x`;
      return jo(r);
    }
  };
  var jo = function(e) {
    let t = (() => {
      if (Uo(e))
        return e;
      let r = e.split(".");
      return r[1] = "0", r.join(".");
    })();
    if (Pu.includes(t))
      return t;
  };
  var Au = function(e) {
    return st(e).with({ familyDistro: "musl" }, () => (ie('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t }) => (ie('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t}-linux-gnu`, `/lib/${t}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ie('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t, arch: r, archFromUname: n }) => (ie(`Don't know any platform-specific paths for "${t}" on ${r} (${n})`), []));
  };
  async function Ru(e) {
    let t = 'grep -v "libssl.so.0"', r = await Lo(e);
    if (r) {
      ie(`Found libssl.so file using platform-specific paths: ${r}`);
      let o = No(r);
      if (ie(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "libssl-specific-path" };
    }
    ie('Falling back to "ldconfig" and other generic paths');
    let n = await Ir(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t}`);
    if (n || (n = await Lo(["/lib64", "/usr/lib64", "/lib"])), n) {
      ie(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
      let o = No(n);
      if (ie(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "ldconfig" };
    }
    let i = await Ir("openssl version -v");
    if (i) {
      ie(`Found openssl binary with version: ${i}`);
      let o = Cu(i);
      if (ie(`The parsed openssl version is: ${o}`), o)
        return { libssl: o, strategy: "openssl-binary" };
    }
    return ie("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Lo(e) {
    for (let t of e) {
      let r = await Mu(t);
      if (r)
        return r;
    }
  }
  async function Mu(e) {
    try {
      return (await Gn.default.readdir(e)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
    } catch (t) {
      if (t.code === "ENOENT")
        return;
      throw t;
    }
  }
  async function ut() {
    let { binaryTarget: e } = await Bo();
    return e;
  }
  var Su = function(e) {
    return e.binaryTarget !== undefined;
  };
  async function Jn() {
    let { memoized: e, ...t } = await Bo();
    return t;
  }
  async function Bo() {
    if (Su(Mr))
      return Promise.resolve({ ...Mr, memoized: true });
    let e = await Vo(), t = Iu(e);
    return Mr = { ...e, binaryTarget: t }, { ...Mr, memoized: false };
  }
  var Iu = function(e) {
    let { platform: t, arch: r, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
    t === "linux" && !["x64", "arm64"].includes(r) && Dt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
    let l = "1.1.x";
    if (t === "linux" && i === undefined) {
      let c = st({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Dt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
    }
    let u = "debian";
    if (t === "linux" && o === undefined && Dt(`Prisma doesn't know which engines to download for the Linux distro "${a}". Falling back to Prisma engines built "${u}".
Please report your experience by creating an issue at ${Ot("https://github.com/prisma/prisma/issues")} so we can add your distro to the list of known supported distros.`), t === "darwin" && r === "arm64")
      return "darwin-arm64";
    if (t === "darwin")
      return "darwin";
    if (t === "win32")
      return "windows";
    if (t === "freebsd")
      return o;
    if (t === "openbsd")
      return "openbsd";
    if (t === "netbsd")
      return "netbsd";
    if (t === "linux" && o === "nixos")
      return "linux-nixos";
    if (t === "linux" && r === "arm64")
      return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
    if (t === "linux" && r === "arm")
      return `linux-arm-openssl-${i || l}`;
    if (t === "linux" && o === "musl") {
      let c = "linux-musl";
      return !i || Uo(i) ? c : `${c}-openssl-${i}`;
    }
    return t === "linux" && o && i ? `${o}-openssl-${i}` : (t !== "linux" && Dt(`Prisma detected unknown OS "${t}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
  };
  async function ku(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  var Ir = function(e) {
    return ku(async () => {
      let t = await wu(e);
      return ie(`Command "${e}" successfully returned "${t.stdout}"`), t.stdout;
    });
  };
  async function Fu() {
    return typeof Sr.default.machine == "function" ? Sr.default.machine() : (await Ir("uname -m"))?.trim();
  }
  var Uo = function(e) {
    return e.startsWith("1.");
  };
  var Jo = function(e) {
    let t = e.ignoreProcessEnv ? {} : process.env, r = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
      let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a)
        return o;
      let l = a[1], u, c;
      if (l === "\\")
        c = a[0], u = c.replace("\\$", "$");
      else {
        let p = a[2];
        c = a[0].substring(l.length), u = Object.hasOwnProperty.call(t, p) ? t[p] : e.parsed[p] || "", u = r(u);
      }
      return o.replace(c, u);
    }, n) ?? n;
    for (let n in e.parsed) {
      let i = Object.hasOwnProperty.call(t, n) ? t[n] : e.parsed[n];
      e.parsed[n] = r(i);
    }
    for (let n in e.parsed)
      t[n] = e.parsed[n];
    return e;
  };
  var _t = function({ rootEnvPath: e, schemaEnvPath: t }, r = { conflictCheck: "none" }) {
    let n = Ho(e);
    r.conflictCheck !== "none" && Bu(n, t, r.conflictCheck);
    let i = null;
    return Wo(n?.path, t) || (i = Ho(t)), !n && !i && zn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(me(ne("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var Bu = function(e, t, r) {
    let n = e?.dotenvResult.parsed, i = !Wo(e?.path, t);
    if (n && t && i && Or.default.existsSync(t)) {
      let o = Yn.default.parse(Or.default.readFileSync(t)), s = [];
      for (let a in o)
        n[a] === o[a] && s.push(a);
      if (s.length > 0) {
        let a = ct.default.relative(process.cwd(), e.path), l = ct.default.relative(process.cwd(), t);
        if (r === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${te(a)} and ${te(l)}
Conflicting env vars:
${s.map((c) => `  ${ne(c)}`).join(`
`)}

We suggest to move the contents of ${te(l)} to ${te(a)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (r === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => ne(c)).join(", ")} in ${te(a)} and ${te(l)}
Env vars from ${te(l)} overwrite the ones from ${te(a)}
      `;
          console.warn(`${he("warn(prisma)")} ${u}`);
        }
      }
    }
  };
  var Ho = function(e) {
    return Uu(e) ? (zn(`Environment variables loaded from ${e}`), { dotenvResult: Jo(Yn.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined })), message: Fe(`Environment variables loaded from ${ct.default.relative(process.cwd(), e)}`), path: e }) : (zn(`Environment variables not found at ${e}`), null);
  };
  var Wo = function(e, t) {
    return e && t && ct.default.resolve(e) === ct.default.resolve(t);
  };
  var Uu = function(e) {
    return !!(e && Or.default.existsSync(e));
  };
  var Zn = function(e) {
    let t = Ku();
    return t || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : zo);
  };
  var Ku = function() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : undefined;
  };
  var rs = function() {
    return N.default.join(import.meta.dir, "../");
  };
  var ti = function(e) {
    if (process.platform === "win32")
      return;
    let t = ei.default.statSync(e), r = t.mode | 64 | 8 | 1;
    if (t.mode === r) {
      ns(`Execution permissions of ${e} are fine`);
      return;
    }
    let n = r.toString(8).slice(-3);
    ns(`Have to call chmodPlusX on ${e}`), ei.default.chmodSync(e, n);
  };
  var ri = function(e) {
    let t = e.e, r = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = t.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Ot("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Fe(e.id)}\`).`, s = st({ message: t.message, code: t.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${r("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${r("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
      let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${r("libssl")}. Please install ${a} and try again.`;
    }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o}
${s}

Details: ${t.message}`;
  };
  var ni = function(e) {
    return Nt.default.sep === Nt.default.posix.sep ? e : e.split(Nt.default.sep).join(Nt.default.posix.sep);
  };
  var si = function(e) {
    return String(new oi(e));
  };
  var Wu = function(e) {
    let t;
    if (e.length > 0) {
      let r = e.find((n) => n.fromEnvVar !== null);
      r ? t = `env("${r.fromEnvVar}")` : t = e.map((n) => n.native ? "native" : n.value);
    } else
      t = undefined;
    return t;
  };
  var zu = function(e) {
    let t = Object.keys(e).reduce((r, n) => Math.max(r, n.length), 0);
    return Object.entries(e).map(([r, n]) => `${r.padEnd(t)} = ${Yu(n)}`).join(`
`);
  };
  var Yu = function(e) {
    return JSON.parse(JSON.stringify(e, (t, r) => Array.isArray(r) ? `[${r.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(r)));
  };
  var Zu = function(...e) {
    console.log(...e);
  };
  var ai = function(e, ...t) {
    ss.warn() && console.warn(`${Lt.warn} ${e}`, ...t);
  };
  var Xu = function(e, ...t) {
    console.info(`${Lt.info} ${e}`, ...t);
  };
  var ec = function(e, ...t) {
    console.error(`${Lt.error} ${e}`, ...t);
  };
  var tc = function(e, ...t) {
    console.log(`${Lt.query} ${e}`, ...t);
  };
  var _r = function(e, t) {
    if (!e)
      throw new Error(`${t}. This should never happen. If you see this error, please, open an issue at https://github.com/prisma/prisma/issues/new?assignees=&labels=kind%2Fbug&projects=&template=bug_report.yml`);
  };
  var He = function(e, t) {
    throw new Error(t);
  };
  var ui = function(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  };
  var pt = function(e, t) {
    let r = {};
    for (let n of Object.keys(e))
      r[n] = t(e[n], n);
    return r;
  };
  var pi = function(e, t) {
    if (e.length === 0)
      return;
    let r = e[0];
    for (let n = 1;n < e.length; n++)
      t(r, e[n]) < 0 && (r = e[n]);
    return r;
  };
  var E = function(e, t) {
    Object.defineProperty(e, "name", { value: t, configurable: true });
  };
  var Vt = function(e) {
    let t;
    return { get() {
      return t || (t = { value: e() }), t.value;
    } };
  };
  var ms = function(e, t) {
    let r = Vt(() => nc(t));
    Object.defineProperty(e, "dmmf", { get: () => r.get() });
  };
  var nc = function(e) {
    return { datamodel: { models: di(e.models), enums: di(e.enums), types: di(e.types) } };
  };
  var di = function(e) {
    return Object.entries(e).map(([t, r]) => ({ name: t, ...r }));
  };
  var fi = function(e, t) {
    Object.defineProperty(e, "name", { value: t, configurable: true });
  };
  var qr = function(e) {
    return { ok: false, error: e, map() {
      return qr(e);
    }, flatMap() {
      return qr(e);
    } };
  };
  var De = function(e, t) {
    return async (...r) => {
      try {
        return await t(...r);
      } catch (n) {
        let i = e.registerNewError(n);
        return qr({ kind: "GenericJsError", id: i });
      }
    };
  };
  var ac = function(e, t) {
    return (...r) => {
      try {
        return t(...r);
      } catch (n) {
        let i = e.registerNewError(n);
        return qr({ kind: "GenericJsError", id: i });
      }
    };
  };
  var gs = function(e, t = ",", r = "", n = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([r, ...Array(e.length - 1).fill(t), n], e);
  };
  var gi = function(e) {
    return new oe([e], []);
  };
  var yi = function(e, ...t) {
    return new oe(e, t);
  };
  var Qt = function(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(t) {
      return e[t];
    } };
  };
  var re = function(e, t) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return t();
    } };
  };
  var We = function(e) {
    let t = new be;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(r) {
      return t.getOrCreate(r, () => e.getPropertyValue(r));
    }, getPropertyDescriptor(r) {
      return e.getPropertyDescriptor?.(r);
    } };
  };
  var jr = function(e) {
    let t = new Set(e);
    return { getOwnPropertyDescriptor: () => Vr, has: (r, n) => t.has(n), set: (r, n, i) => t.add(n) && Reflect.set(r, n, i), ownKeys: () => [...t] };
  };
  var Ee = function(e, t) {
    let r = uc(t), n = new Set, i = new Proxy(e, { get(o, s) {
      if (n.has(s))
        return o[s];
      let a = r.get(s);
      return a ? a.getPropertyValue(s) : o[s];
    }, has(o, s) {
      if (n.has(s))
        return true;
      let a = r.get(s);
      return a ? a.has?.(s) ?? true : Reflect.has(o, s);
    }, ownKeys(o) {
      let s = xs(Reflect.ownKeys(o), r), a = xs(Array.from(r.keys()), r);
      return [...new Set([...s, ...a, ...n])];
    }, set(o, s, a) {
      return r.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
    }, getOwnPropertyDescriptor(o, s) {
      let a = Reflect.getOwnPropertyDescriptor(o, s);
      if (a && !a.configurable)
        return a;
      let l = r.get(s);
      return l ? l.getPropertyDescriptor ? { ...Vr, ...l?.getPropertyDescriptor(s) } : Vr : a;
    }, defineProperty(o, s, a) {
      return n.add(s), Reflect.defineProperty(o, s, a);
    } });
    return i[hs] = function(o, s, a = bs.inspect) {
      let l = { ...this };
      return delete l[hs], a(l, s);
    }, i;
  };
  var uc = function(e) {
    let t = new Map;
    for (let r of e) {
      let n = r.getKeys();
      for (let i of n)
        t.set(i, r);
    }
    return t;
  };
  var xs = function(e, t) {
    return e.filter((r) => t.get(r)?.has?.(r) ?? true);
  };
  var Gt = function(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var ft = function(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  };
  var Br = function(e) {
    return e.toString() !== "Invalid Date";
  };
  var W = function(e) {
    var t, r, n, i = e.length - 1, o = "", s = e[0];
    if (i > 0) {
      for (o += s, t = 1;t < i; t++)
        n = e[t] + "", r = b - n.length, r && (o += _e(r)), o += n;
      s = e[t], n = s + "", r = b - n.length, r && (o += _e(r));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o + s;
  };
  var se = function(e, t, r) {
    if (e !== ~~e || e < t || e > r)
      throw Error(Le + e);
  };
  var Jt = function(e, t, r, n) {
    var i, o, s, a;
    for (o = e[0];o >= 10; o /= 10)
      --t;
    return --t < 0 ? (t += b, i = 0) : (i = Math.ceil((t + 1) / b), t %= b), o = j(10, b - t), a = e[i] % o | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), s = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 50000 || a == 0) : s = (r < 4 && a + 1 == o || r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == j(10, t - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1000 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), s = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : s = ((n || r < 4) && a + 1 == o || !n && r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1000 | 0) == j(10, t - 3) - 1, s;
  };
  var Ur = function(e, t, r) {
    for (var n, i = [0], o, s = 0, a = e.length;s < a; ) {
      for (o = i.length;o--; )
        i[o] *= t;
      for (i[0] += hi.indexOf(e.charAt(s++)), n = 0;n < i.length; n++)
        i[n] > r - 1 && (i[n + 1] === undefined && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
    }
    return i.reverse();
  };
  var gc = function(e, t) {
    var r, n, i;
    if (t.isZero())
      return t;
    n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Wr(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = yt(e, 1, t.times(i), new e(1));
    for (var o = r;o--; ) {
      var s = t.times(t);
      t = s.times(s).minus(s).times(8).plus(1);
    }
    return e.precision -= r, t;
  };
  var h = function(e, t, r, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor;
    e:
      if (t != null) {
        if (p = e.d, !p)
          return e;
        for (i = 1, a = p[0];a >= 10; a /= 10)
          i++;
        if (o = t - i, o < 0)
          o += b, s = t, c = p[d = 0], l = c / j(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o + 1) / b), a = p.length, d >= a)
          if (n) {
            for (;a++ <= d; )
              p.push(0);
            c = l = 0, i = 1, o %= b, s = o - b + 1;
          } else
            break e;
        else {
          for (c = a = p[d], i = 1;a >= 10; a /= 10)
            i++;
          o %= b, s = o - b + i, l = s < 0 ? 0 : c / j(10, i - s - 1) % 10 | 0;
        }
        if (n = n || t < 0 || p[d + 1] !== undefined || (s < 0 ? c : c % j(10, i - s - 1)), u = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && (o > 0 ? s > 0 ? c / j(10, i - s) : 0 : p[d - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !p[0])
          return p.length = 0, u ? (t -= e.e + 1, p[0] = j(10, (b - t % b) % b), e.e = -t || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = j(10, b - o), p[d] = s > 0 ? (c / j(10, i - s) % j(10, s) | 0) * a : 0), u)
          for (;; )
            if (d == 0) {
              for (o = 1, s = p[0];s >= 10; s /= 10)
                o++;
              for (s = p[0] += a, a = 1;s >= 10; s /= 10)
                a++;
              o != a && (e.e++, p[0] == ge && (p[0] = 1));
              break;
            } else {
              if (p[d] += a, p[d] != ge)
                break;
              p[d--] = 0, a = 1;
            }
        for (o = p.length;p[--o] === 0; )
          p.pop();
      }
    return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
  };
  var we = function(e, t, r) {
    if (!e.isFinite())
      return ks(e);
    var n, i = e.e, o = W(e.d), s = o.length;
    return t ? (r && (n = r - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + _e(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + _e(-i - 1) + o, r && (n = r - s) > 0 && (o += _e(n))) : i >= s ? (o += _e(i + 1 - s), r && (n = r - i - 1) > 0 && (o = o + "." + _e(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), r && (n = r - s) > 0 && (i + 1 === s && (o += "."), o += _e(n))), o;
  };
  var Hr = function(e, t) {
    var r = e[0];
    for (t *= b;r >= 10; r /= 10)
      t++;
    return t;
  };
  var Gr = function(e, t, r) {
    if (t > fc)
      throw w = true, r && (e.precision = r), Error(Ts);
    return h(new e(Kr), t, 1, true);
  };
  var fe = function(e, t, r) {
    if (t > bi)
      throw Error(Ts);
    return h(new e(Qr), t, r, true);
  };
  var Ms = function(e) {
    var t = e.length - 1, r = t * b + 1;
    if (t = e[t], t) {
      for (;t % 10 == 0; t /= 10)
        r--;
      for (t = e[0];t >= 10; t /= 10)
        r++;
    }
    return r;
  };
  var _e = function(e) {
    for (var t = "";e--; )
      t += "0";
    return t;
  };
  var Ss = function(e, t, r, n) {
    var i, o = new e(1), s = Math.ceil(n / b + 4);
    for (w = false;; ) {
      if (r % 2 && (o = o.times(t), ws(o.d, s) && (i = true)), r = ee(r / 2), r === 0) {
        r = o.d.length - 1, i && o.d[r] === 0 && ++o.d[r];
        break;
      }
      t = t.times(t), ws(t.d, s);
    }
    return w = true, o;
  };
  var Es = function(e) {
    return e.d[e.d.length - 1] & 1;
  };
  var Is = function(e, t, r) {
    for (var n, i = new e(t[0]), o = 0;++o < t.length; )
      if (n = new e(t[o]), n.s)
        i[r](n) && (i = n);
      else {
        i = n;
        break;
      }
    return i;
  };
  var Ei = function(e, t) {
    var r, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, y = d.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
    for (t == null ? (w = false, l = y) : l = t, a = new d(0.03125);e.e > -2; )
      e = e.times(a), p += 5;
    for (n = Math.log(j(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, r = o = s = new d(1), d.precision = l;; ) {
      if (o = h(o.times(e), l, 1), r = r.times(++c), a = s.plus(O(o, r, l, 1)), W(a.d).slice(0, l) === W(s.d).slice(0, l)) {
        for (i = p;i--; )
          s = h(s.times(s), l, 1);
        if (t == null)
          if (u < 3 && Jt(s.d, l - n, f, u))
            d.precision = l += 10, r = o = a = new d(1), c = 0, u++;
          else
            return h(s, d.precision = y, f, w = true);
        else
          return d.precision = y, s;
      }
      s = a;
    }
  };
  var Ne = function(e, t) {
    var r, n, i, o, s, a, l, u, c, p, d, f = 1, y = 10, g = e, P = g.d, T = g.constructor, C = T.rounding, x = T.precision;
    if (g.s < 0 || !P || !P[0] || !g.e && P[0] == 1 && P.length == 1)
      return new T(P && !P[0] ? -1 / 0 : g.s != 1 ? NaN : P ? 0 : g);
    if (t == null ? (w = false, c = x) : c = t, T.precision = c += y, r = W(P), n = r.charAt(0), Math.abs(o = g.e) < 1500000000000000) {
      for (;n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
        g = g.times(e), r = W(g.d), n = r.charAt(0), f++;
      o = g.e, n > 1 ? (g = new T("0." + r), o++) : g = new T(n + "." + r.slice(1));
    } else
      return u = Gr(T, c + 2, x).times(o + ""), g = Ne(new T(n + "." + r.slice(1)), c - y).plus(u), T.precision = x, t == null ? h(g, x, C, w = true) : g;
    for (p = g, l = s = g = O(g.minus(1), g.plus(1), c, 1), d = h(g.times(g), c, 1), i = 3;; ) {
      if (s = h(s.times(d), c, 1), u = l.plus(O(s, new T(i), c, 1)), W(u.d).slice(0, c) === W(l.d).slice(0, c))
        if (l = l.times(2), o !== 0 && (l = l.plus(Gr(T, c + 2, x).times(o + ""))), l = O(l, new T(f), c, 1), t == null)
          if (Jt(l.d, c - y, C, a))
            T.precision = c += y, u = s = g = O(p.minus(1), p.plus(1), c, 1), d = h(g.times(g), c, 1), i = a = 1;
          else
            return h(l, T.precision = x, C, w = true);
        else
          return T.precision = x, l;
      l = u, i += 2;
    }
  };
  var ks = function(e) {
    return String(e.s * e.s / 0);
  };
  var wi = function(e, t) {
    var r, n, i;
    for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0;t.charCodeAt(n) === 48; n++)
      ;
    for (i = t.length;t.charCodeAt(i - 1) === 48; --i)
      ;
    if (t = t.slice(n, i), t) {
      if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % b, r < 0 && (n += b), n < i) {
        for (n && e.d.push(+t.slice(0, n)), i -= b;n < i; )
          e.d.push(+t.slice(n, n += b));
        t = t.slice(n), n = b - t.length;
      } else
        n -= i;
      for (;n--; )
        t += "0";
      e.d.push(+t), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  };
  var yc = function(e, t) {
    var r, n, i, o, s, a, l, u, c;
    if (t.indexOf("_") > -1) {
      if (t = t.replace(/(\d)_(?=\d)/g, "$1"), Rs.test(t))
        return wi(e, t);
    } else if (t === "Infinity" || t === "NaN")
      return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (pc.test(t))
      r = 16, t = t.toLowerCase();
    else if (cc.test(t))
      r = 2;
    else if (dc.test(t))
      r = 8;
    else
      throw Error(Le + t);
    for (o = t.search(/p/i), o > 0 ? (l = +t.slice(o + 1), t = t.substring(2, o)) : t = t.slice(2), o = t.indexOf("."), s = o >= 0, n = e.constructor, s && (t = t.replace(".", ""), a = t.length, o = a - o, i = Ss(n, new n(r), o, o * 2)), u = Ur(t, r, ge), c = u.length - 1, o = c;u[o] === 0; --o)
      u.pop();
    return o < 0 ? new n(e.s * 0) : (e.e = Hr(u, c), e.d = u, w = false, s && (e = O(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? j(2, l) : ze.pow(2, l))), w = true, e);
  };
  var hc = function(e, t) {
    var r, n = t.d.length;
    if (n < 3)
      return t.isZero() ? t : yt(e, 2, t, t);
    r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Wr(5, r)), t = yt(e, 2, t, t);
    for (var i, o = new e(5), s = new e(16), a = new e(20);r--; )
      i = t.times(t), t = t.times(o.plus(i.times(s.times(i).minus(a))));
    return t;
  };
  var yt = function(e, t, r, n, i) {
    var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / b);
    for (w = false, l = r.times(r), a = new e(n);; ) {
      if (s = O(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(s) : n.minus(s), n = O(s.times(l), new e(t++ * t++), c, 1), s = a.plus(n), s.d[p] !== undefined) {
        for (o = p;s.d[o] === a.d[o] && o--; )
          ;
        if (o == -1)
          break;
      }
      o = a, a = n, n = s, s = o, u++;
    }
    return w = true, s.d.length = p + 1, s;
  };
  var Wr = function(e, t) {
    for (var r = e;--t; )
      r *= e;
    return r;
  };
  var Fs = function(e, t) {
    var r, n = t.s < 0, i = fe(e, e.precision, 1), o = i.times(0.5);
    if (t = t.abs(), t.lte(o))
      return Me = n ? 4 : 1, t;
    if (r = t.divToInt(i), r.isZero())
      Me = n ? 3 : 2;
    else {
      if (t = t.minus(r.times(i)), t.lte(o))
        return Me = Es(r) ? n ? 2 : 3 : n ? 4 : 1, t;
      Me = Es(r) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return t.minus(i).abs();
  };
  var Pi = function(e, t, r, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor, y = r !== undefined;
    if (y ? (se(r, 1, $e), n === undefined ? n = f.rounding : se(n, 0, 8)) : (r = f.precision, n = f.rounding), !e.isFinite())
      c = ks(e);
    else {
      for (c = we(e), s = c.indexOf("."), y ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = Ur(we(d), 10, i), d.e = d.d.length), p = Ur(c, 10, i), o = l = p.length;p[--l] == 0; )
        p.pop();
      if (!p[0])
        c = y ? "0p+0" : "0";
      else {
        if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = O(e, d, r, n, 0, i), p = e.d, o = e.e, u = vs), s = p[r], a = i / 2, u = u || p[r + 1] !== undefined, u = n < 4 ? (s !== undefined || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = r, u)
          for (;++p[--r] > i - 1; )
            p[r] = 0, r || (++o, p.unshift(1));
        for (l = p.length;!p[l - 1]; --l)
          ;
        for (s = 0, c = "";s < l; s++)
          c += hi.charAt(p[s]);
        if (y) {
          if (l > 1)
            if (t == 16 || t == 8) {
              for (s = t == 16 ? 4 : 3, --l;l % s; l++)
                c += "0";
              for (p = Ur(c, i, t), l = p.length;!p[l - 1]; --l)
                ;
              for (s = 1, c = "1.";s < l; s++)
                c += hi.charAt(p[s]);
            } else
              c = c.charAt(0) + "." + c.slice(1);
          c = c + (o < 0 ? "p" : "p+") + o;
        } else if (o < 0) {
          for (;++o; )
            c = "0" + c;
          c = "0." + c;
        } else if (++o > l)
          for (o -= l;o--; )
            c += "0";
        else
          o < l && (c = c.slice(0, o) + "." + c.slice(o));
      }
      c = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + c;
    }
    return e.s < 0 ? "-" + c : c;
  };
  var ws = function(e, t) {
    if (e.length > t)
      return e.length = t, true;
  };
  var xc = function(e) {
    return new this(e).abs();
  };
  var bc = function(e) {
    return new this(e).acos();
  };
  var Ec = function(e) {
    return new this(e).acosh();
  };
  var wc = function(e, t) {
    return new this(e).plus(t);
  };
  var Pc = function(e) {
    return new this(e).asin();
  };
  var vc = function(e) {
    return new this(e).asinh();
  };
  var Tc = function(e) {
    return new this(e).atan();
  };
  var Cc = function(e) {
    return new this(e).atanh();
  };
  var Ac = function(e, t) {
    e = new this(e), t = new this(t);
    var r, n = this.precision, i = this.rounding, o = n + 4;
    return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = fe(this, o, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? fe(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = fe(this, o, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = o, this.rounding = 1, r = this.atan(O(e, t, o, 1)), t = fe(this, o, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(O(e, t, o, 1)), r;
  };
  var Rc = function(e) {
    return new this(e).cbrt();
  };
  var Mc = function(e) {
    return h(e = new this(e), e.e + 1, 2);
  };
  var Sc = function(e, t, r) {
    return new this(e).clamp(t, r);
  };
  var Ic = function(e) {
    if (!e || typeof e != "object")
      throw Error(Jr + "Object expected");
    var t, r, n, i = e.defaults === true, o = ["precision", 1, $e, "rounding", 0, 8, "toExpNeg", -gt, 0, "toExpPos", 0, gt, "maxE", 0, gt, "minE", -gt, 0, "modulo", 0, 9];
    for (t = 0;t < o.length; t += 3)
      if (r = o[t], i && (this[r] = xi[r]), (n = e[r]) !== undefined)
        if (ee(n) === n && n >= o[t + 1] && n <= o[t + 2])
          this[r] = n;
        else
          throw Error(Le + r + ": " + n);
    if (r = "crypto", i && (this[r] = xi[r]), (n = e[r]) !== undefined)
      if (n === true || n === false || n === 0 || n === 1)
        if (n)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r] = true;
          else
            throw Error(Cs);
        else
          this[r] = false;
      else
        throw Error(Le + r + ": " + n);
    return this;
  };
  var kc = function(e) {
    return new this(e).cos();
  };
  var Fc = function(e) {
    return new this(e).cosh();
  };
  var Os = function(e) {
    var t, r, n;
    function i(o) {
      var s, a, l, u = this;
      if (!(u instanceof i))
        return new i(o);
      if (u.constructor = i, Ps(o)) {
        u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
        return;
      }
      if (l = typeof o, l === "number") {
        if (o === 0) {
          u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
          for (s = 0, a = o;a >= 10; a /= 10)
            s++;
          w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
          return;
        } else if (o * 0 !== 0) {
          o || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return wi(u, o.toString());
      } else if (l !== "string")
        throw Error(Le + o);
      return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Rs.test(o) ? wi(u, o) : yc(u, o);
    }
    if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Ic, i.clone = Os, i.isDecimal = Ps, i.abs = xc, i.acos = bc, i.acosh = Ec, i.add = wc, i.asin = Pc, i.asinh = vc, i.atan = Tc, i.atanh = Cc, i.atan2 = Ac, i.cbrt = Rc, i.ceil = Mc, i.clamp = Sc, i.cos = kc, i.cosh = Fc, i.div = Oc, i.exp = Dc, i.floor = _c, i.hypot = Nc, i.ln = Lc, i.log = $c, i.log10 = Vc, i.log2 = qc, i.max = jc, i.min = Bc, i.mod = Uc, i.mul = Kc, i.pow = Qc, i.random = Gc, i.round = Jc, i.sign = Hc, i.sin = Wc, i.sinh = zc, i.sqrt = Yc, i.sub = Zc, i.sum = Xc, i.tan = ep, i.tanh = tp, i.trunc = rp, e === undefined && (e = {}), e && e.defaults !== true)
      for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0;t < n.length; )
        e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
    return i.config(e), i;
  };
  var Oc = function(e, t) {
    return new this(e).div(t);
  };
  var Dc = function(e) {
    return new this(e).exp();
  };
  var _c = function(e) {
    return h(e = new this(e), e.e + 1, 3);
  };
  var Nc = function() {
    var e, t, r = new this(0);
    for (w = false, e = 0;e < arguments.length; )
      if (t = new this(arguments[e++]), t.d)
        r.d && (r = r.plus(t.times(t)));
      else {
        if (t.s)
          return w = true, new this(1 / 0);
        r = t;
      }
    return w = true, r.sqrt();
  };
  var Ps = function(e) {
    return e instanceof ze || e && e.toStringTag === As || false;
  };
  var Lc = function(e) {
    return new this(e).ln();
  };
  var $c = function(e, t) {
    return new this(e).log(t);
  };
  var qc = function(e) {
    return new this(e).log(2);
  };
  var Vc = function(e) {
    return new this(e).log(10);
  };
  var jc = function() {
    return Is(this, arguments, "lt");
  };
  var Bc = function() {
    return Is(this, arguments, "gt");
  };
  var Uc = function(e, t) {
    return new this(e).mod(t);
  };
  var Kc = function(e, t) {
    return new this(e).mul(t);
  };
  var Qc = function(e, t) {
    return new this(e).pow(t);
  };
  var Gc = function(e) {
    var t, r, n, i, o = 0, s = new this(1), a = [];
    if (e === undefined ? e = this.precision : se(e, 1, $e), n = Math.ceil(e / b), this.crypto)
      if (crypto.getRandomValues)
        for (t = crypto.getRandomValues(new Uint32Array(n));o < n; )
          i = t[o], i >= 4290000000 ? t[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (t = crypto.randomBytes(n *= 4);o < n; )
          i = t[o] + (t[o + 1] << 8) + (t[o + 2] << 16) + ((t[o + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(t, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else
        throw Error(Cs);
    else
      for (;o < n; )
        a[o++] = Math.random() * 1e7 | 0;
    for (n = a[--o], e %= b, n && e && (i = j(10, b - e), a[o] = (n / i | 0) * i);a[o] === 0; o--)
      a.pop();
    if (o < 0)
      r = 0, a = [0];
    else {
      for (r = -1;a[0] === 0; r -= b)
        a.shift();
      for (n = 1, i = a[0];i >= 10; i /= 10)
        n++;
      n < b && (r -= b - n);
    }
    return s.e = r, s.d = a, s;
  };
  var Jc = function(e) {
    return h(e = new this(e), e.e + 1, this.rounding);
  };
  var Hc = function(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  };
  var Wc = function(e) {
    return new this(e).sin();
  };
  var zc = function(e) {
    return new this(e).sinh();
  };
  var Yc = function(e) {
    return new this(e).sqrt();
  };
  var Zc = function(e, t) {
    return new this(e).sub(t);
  };
  var Xc = function() {
    var e = 0, t = arguments, r = new this(t[e]);
    for (w = false;r.s && ++e < t.length; )
      r = r.plus(t[e]);
    return w = true, h(r, this.precision, this.rounding);
  };
  var ep = function(e) {
    return new this(e).tan();
  };
  var tp = function(e) {
    return new this(e).tanh();
  };
  var rp = function(e) {
    return h(e = new this(e), e.e + 1, 1);
  };
  var ht = function(e) {
    return ze.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  };
  var xt = function(e) {
    return e instanceof Ht;
  };
  var en = function(e) {
    return new vi(Ns(e));
  };
  var Ns = function(e) {
    let t = new Q;
    for (let [r, n] of Object.entries(e)) {
      let i = new Xr(r, Ls(n));
      t.addField(i);
    }
    return t;
  };
  var Ls = function(e) {
    if (typeof e == "string")
      return new G(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new G(String(e));
    if (typeof e == "bigint")
      return new G(`${e}n`);
    if (e === null)
      return new G("null");
    if (e === undefined)
      return new G("undefined");
    if (ht(e))
      return new G(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new G(`Buffer.alloc(${e.byteLength})`) : new G(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let t = Br(e) ? e.toISOString() : "Invalid Date";
      return new G(`new Date("${t}")`);
    }
    return e instanceof xe ? new G(`Prisma.${e._getName()}`) : xt(e) ? new G(`prisma.${lo(e.modelName)}.\$fields.${e.name}`) : Array.isArray(e) ? ip(e) : typeof e == "object" ? Ns(e) : new G(Object.prototype.toString.call(e));
  };
  var ip = function(e) {
    let t = new Et;
    for (let r of e)
      t.addItem(Ls(r));
    return t;
  };
  var $s = function(e) {
    if (e === undefined)
      return "";
    let t = en(e);
    return new mt(0, { colors: Zr }).write(t).toString();
  };
  var qs = function(e) {
    var t = e.split(`
`);
    return t.reduce(function(r, n) {
      var i = ap(n) || up(n) || dp(n) || yp(n) || fp(n);
      return i && r.push(i), r;
    }, []);
  };
  var ap = function(e) {
    var t = op.exec(e);
    if (!t)
      return null;
    var r = t[2] && t[2].indexOf("native") === 0, n = t[2] && t[2].indexOf("eval") === 0, i = sp.exec(t[2]);
    return n && i != null && (t[2] = i[1], t[3] = i[2], t[4] = i[3]), { file: r ? null : t[2], methodName: t[1] || Wt, arguments: r ? [t[2]] : [], lineNumber: t[3] ? +t[3] : null, column: t[4] ? +t[4] : null };
  };
  var up = function(e) {
    var t = lp.exec(e);
    return t ? { file: t[2], methodName: t[1] || Wt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
  };
  var dp = function(e) {
    var t = cp.exec(e);
    if (!t)
      return null;
    var r = t[3] && t[3].indexOf(" > eval") > -1, n = pp.exec(t[3]);
    return r && n != null && (t[3] = n[1], t[4] = n[2], t[5] = null), { file: t[3], methodName: t[1] || Wt, arguments: t[2] ? t[2].split(",") : [], lineNumber: t[4] ? +t[4] : null, column: t[5] ? +t[5] : null };
  };
  var fp = function(e) {
    var t = mp.exec(e);
    return t ? { file: t[3], methodName: t[1] || Wt, arguments: [], lineNumber: +t[4], column: t[5] ? +t[5] : null } : null;
  };
  var yp = function(e) {
    var t = gp.exec(e);
    return t ? { file: t[2], methodName: t[1] || Wt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
  };
  var Ve = function(e) {
    return e === "minimal" ? new Ti : new Ci;
  };
  var wt = function(e = {}) {
    let t = xp(e);
    return Object.entries(t).reduce((n, [i, o]) => (Vs[i] !== undefined ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
  };
  var xp = function(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  };
  var tn = function(e = {}) {
    return (t) => (typeof e._count == "boolean" && (t._count = t._count._all), t);
  };
  var js = function(e, t) {
    let r = tn(e);
    return t({ action: "aggregate", unpacker: r, argsMapper: wt })(e);
  };
  var bp = function(e = {}) {
    let { select: t, ...r } = e;
    return typeof t == "object" ? wt({ ...r, _count: t }) : wt({ ...r, _count: { _all: true } });
  };
  var Ep = function(e = {}) {
    return typeof e.select == "object" ? (t) => tn(e)(t)._count : (t) => tn(e)(t)._count._all;
  };
  var Bs = function(e, t) {
    return t({ action: "count", unpacker: Ep(e), argsMapper: bp })(e);
  };
  var wp = function(e = {}) {
    let t = wt(e);
    if (Array.isArray(t.by))
      for (let r of t.by)
        typeof r == "string" && (t.select[r] = true);
    else
      typeof t.by == "string" && (t.select[t.by] = true);
    return t;
  };
  var Pp = function(e = {}) {
    return (t) => (typeof e?._count == "boolean" && t.forEach((r) => {
      r._count = r._count._all;
    }), t);
  };
  var Us = function(e, t) {
    return t({ action: "groupBy", unpacker: Pp(e), argsMapper: wp })(e);
  };
  var Ks = function(e, t, r) {
    if (t === "aggregate")
      return (n) => js(n, r);
    if (t === "count")
      return (n) => Bs(n, r);
    if (t === "groupBy")
      return (n) => Us(n, r);
  };
  var Qs = function(e, t) {
    let r = t.fields.filter((i) => !i.relationName), n = ci(r, (i) => i.name);
    return new Proxy({}, { get(i, o) {
      if ((o in i) || typeof o == "symbol")
        return i[o];
      let s = n[o];
      if (s)
        return new Ht(e, o, s.type, s.isList, s.kind === "enum");
    }, ...jr(Object.keys(n)) });
  };
  var vp = function(e, t) {
    return e === undefined || t === undefined ? [] : [...t, "select", e];
  };
  var Tp = function(e, t, r) {
    return t === undefined ? e ?? {} : Js(t, r, e || true);
  };
  var Ri = function(e, t, r, n, i, o) {
    let a = e._runtimeDataModel.models[t].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
    return (l) => {
      let u = Ve(e._errorFormat), c = vp(n, i), p = Tp(l, o, c), d = r({ dataPath: c, callsite: u })(p), f = Cp(e, t);
      return new Proxy(d, { get(y, g) {
        if (!f.includes(g))
          return y[g];
        let T = [a[g].type, r, g], C = [c, p];
        return Ri(e, ...T, ...C);
      }, ...jr([...f, ...Object.getOwnPropertyNames(d)]) });
    };
  };
  var Cp = function(e, t) {
    return e._runtimeDataModel.models[t].fields.filter((r) => r.kind === "object").map((r) => r.name);
  };
  var ye = function(e, t, r, n, i) {
    this.type = e, this.content = t, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!i;
  };
  var Mp = function(e) {
    return Hs[e] || Ap;
  };
  var Ws = function(e) {
    return Sp(e, v.languages.javascript);
  };
  var Sp = function(e, t) {
    return v.tokenize(e, t).map((n) => ye.stringify(n)).join("");
  };
  var Ys = function(e) {
    return (0, zs.default)(e);
  };
  var Fp = function({ callsite: e, message: t, originalMethod: r, isPanic: n, callArguments: i }, o) {
    let s = { functionName: `prisma.${r}()`, message: t, isPanic: n ?? false, callArguments: i };
    if (!e || typeof window < "u" || false)
      return s;
    let a = e.getLocation();
    if (!a || !a.lineNumber || !a.columnNumber)
      return s;
    let l = Math.max(1, a.lineNumber - 3), u = nn.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
    if (u && c) {
      let p = Dp(c), d = Op(c);
      if (!d)
        return s;
      s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (y) => y.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((y, g) => o.gray(String(g).padStart(f)) + " " + y).mapLines((y) => o.dim(y)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
        let y = p + f + 1;
        y += 2, s.callArguments = (0, Xs.default)(i, y).slice(y);
      }
    }
    return s;
  };
  var Op = function(e) {
    let t = Object.keys(pe.ModelAction).join("|"), n = new RegExp(String.raw`\.(${t})\(`).exec(e);
    if (n) {
      let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
      return { code: e.slice(o, i), openingBraceIndex: i };
    }
    return null;
  };
  var Dp = function(e) {
    let t = 0;
    for (let r = 0;r < e.length; r++) {
      if (e.charAt(r) !== " ")
        return t;
      t++;
    }
    return t;
  };
  var _p = function({ functionName: e, location: t, message: r, isPanic: n, contextLines: i, callArguments: o }, s) {
    let a = [""], l = t ? " in" : ":";
    if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), t && a.push(s.underline(Np(t))), i) {
      a.push("");
      let u = [i.toString()];
      o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
    } else
      a.push(""), o && a.push(o), a.push("");
    return a.push(r), a.join(`
`);
  };
  var Np = function(e) {
    let t = [e.fileName];
    return e.lineNumber && t.push(String(e.lineNumber)), e.columnNumber && t.push(String(e.columnNumber)), t.join(":");
  };
  var Pt = function(e) {
    let t = e.showColors ? Ip : kp, r = Fp(e, t);
    return _p(r, t);
  };
  var ea = function(e, t, r, n) {
    return e === pe.ModelAction.findFirstOrThrow || e === pe.ModelAction.findUniqueOrThrow ? Lp(t, r, n) : n;
  };
  var Lp = function(e, t, r) {
    return async (n) => {
      if ("rejectOnNotFound" in n.args) {
        let o = Pt({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new X(o, { clientVersion: t });
      }
      return await r(n).catch((o) => {
        throw o instanceof U && o.code === "P2025" ? new Re(`No ${e} found`, t) : o;
      });
    };
  };
  var Te = function(e) {
    return e.replace(/^./, (t) => t.toLowerCase());
  };
  var Mi = function(e, t) {
    let r = e._extensions.getAllModelExtensions(t) ?? {}, n = [Vp(e, t), Bp(e, t), Qt(r), re("name", () => t), re("$name", () => t), re("$parent", () => e._appliedParent)];
    return Ee({}, n);
  };
  var Vp = function(e, t) {
    let r = Te(t), n = Object.keys(pe.ModelAction).concat("count");
    return { getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = i, s = (l) => e._request(l);
      s = ea(o, t, e._clientVersion, s);
      let a = (l) => (u) => {
        let c = Ve(e._errorFormat);
        return e._createPrismaPromise((p) => {
          let d = { args: u, dataPath: [], action: o, model: t, clientMethod: `${r}.${i}`, jsModelName: r, transaction: p, callsite: c };
          return s({ ...d, ...l });
        });
      };
      return $p.includes(o) ? Ri(e, t, a) : jp(i) ? Ks(e, i, a) : a({});
    } };
  };
  var jp = function(e) {
    return qp.includes(e);
  };
  var Bp = function(e, t) {
    return We(re("fields", () => {
      let r = e._runtimeDataModel.models[t];
      return Qs(t, r);
    }));
  };
  var ta = function(e) {
    return e.replace(/^./, (t) => t.toUpperCase());
  };
  var zt = function(e) {
    let t = [Up(e), re(Si, () => e), re("$parent", () => e._appliedParent)], r = e._extensions.getAllClientExtensions();
    return r && t.push(Qt(r)), Ee(e, t);
  };
  var Up = function(e) {
    let t = Object.keys(e._runtimeDataModel.models), r = t.map(Te), n = [...new Set(t.concat(r))];
    return We({ getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = ta(i);
      if (e._runtimeDataModel.models[o] !== undefined)
        return Mi(e, o);
      if (e._runtimeDataModel.models[i] !== undefined)
        return Mi(e, i);
    }, getPropertyDescriptor(i) {
      if (!r.includes(i))
        return { enumerable: false };
    } });
  };
  var on = function(e) {
    return e[Si] ? e[Si] : e;
  };
  var ra = function(e) {
    if (typeof e == "function")
      return e(this);
    let t = on(this), r = Object.create(t, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return zt(r);
  };
  var na = function({ result: e, modelName: t, select: r, extensions: n }) {
    let i = n.getAllComputedFields(t);
    if (!i)
      return e;
    let o = [], s = [];
    for (let a of Object.values(i)) {
      if (r) {
        if (!r[a.name])
          continue;
        let l = a.needs.filter((u) => !r[u]);
        l.length > 0 && s.push(Gt(l));
      }
      Kp(e, a.needs) && o.push(Qp(a, Ee(e, o)));
    }
    return o.length > 0 || s.length > 0 ? Ee(e, [...o, ...s]) : e;
  };
  var Kp = function(e, t) {
    return t.every((r) => ui(e, r));
  };
  var Qp = function(e, t) {
    return We(re(e.name, () => e.compute(t)));
  };
  var sn = function({ visitor: e, result: t, args: r, runtimeDataModel: n, modelName: i }) {
    if (Array.isArray(t)) {
      for (let s = 0;s < t.length; s++)
        t[s] = sn({ result: t[s], args: r, modelName: i, runtimeDataModel: n, visitor: e });
      return t;
    }
    let o = e(t, i, r) ?? t;
    return r.include && ia({ includeOrSelect: r.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), r.select && ia({ includeOrSelect: r.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
  };
  var ia = function({ includeOrSelect: e, result: t, parentModelName: r, runtimeDataModel: n, visitor: i }) {
    for (let [o, s] of Object.entries(e)) {
      if (!s || t[o] == null)
        continue;
      let l = n.models[r].fields.find((c) => c.name === o);
      if (!l || l.kind !== "object" || !l.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      t[o] = sn({ visitor: i, result: t[o], args: u, modelName: l.type, runtimeDataModel: n });
    }
  };
  var oa = function({ result: e, modelName: t, args: r, extensions: n, runtimeDataModel: i }) {
    return n.isEmpty() || e == null || typeof e != "object" || !i.models[t] ? e : sn({ result: e, args: r ?? {}, modelName: t, runtimeDataModel: i, visitor: (s, a, l) => na({ result: s, modelName: Te(a), select: l.select, extensions: n }) });
  };
  var sa = function(e) {
    if (e instanceof oe)
      return Gp(e);
    if (Array.isArray(e)) {
      let r = [e[0]];
      for (let n = 1;n < e.length; n++)
        r[n] = Yt(e[n]);
      return r;
    }
    let t = {};
    for (let r in e)
      t[r] = Yt(e[r]);
    return t;
  };
  var Gp = function(e) {
    return new oe(e.strings, e.values);
  };
  var Yt = function(e) {
    if (typeof e != "object" || e == null || e instanceof xe || xt(e))
      return e;
    if (ht(e))
      return new Pe(e.toFixed());
    if (ft(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let t = e.length, r;
      for (r = Array(t);t--; )
        r[t] = Yt(e[t]);
      return r;
    }
    if (typeof e == "object") {
      let t = {};
      for (let r in e)
        r === "__proto__" ? Object.defineProperty(t, r, { value: Yt(e[r]), configurable: true, enumerable: true, writable: true }) : t[r] = Yt(e[r]);
      return t;
    }
    He(e, "Unknown value");
  };
  var la = function(e, t, r, n = 0) {
    return e._createPrismaPromise((i) => {
      let o = t.customDataProxyFetch;
      return ("transaction" in t) && i !== undefined && (t.transaction?.kind === "batch" && t.transaction.lock.then(), t.transaction = i), n === r.length ? e._executeRequest(t) : r[n]({ model: t.model, operation: t.model ? t.action : t.clientMethod, args: sa(t.args ?? {}), __internalParams: t, query: (s, a = t) => {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = da(o, l), a.args = s, la(e, a, r, n + 1);
      } });
    });
  };
  var ua = function(e, t) {
    let { jsModelName: r, action: n, clientMethod: i } = t, o = r ? n : i;
    if (e._extensions.isEmpty())
      return e._executeRequest(t);
    let s = e._extensions.getAllQueryCallbacks(r ?? "$none", o);
    return la(e, t, s);
  };
  var ca = function(e) {
    return (t) => {
      let r = { requests: t }, n = t[0].extensions.getAllBatchQueryCallbacks();
      return n.length ? pa(r, n, 0, e) : e(r);
    };
  };
  var pa = function(e, t, r, n) {
    if (r === t.length)
      return n(e);
    let i = e.customDataProxyFetch, o = e.requests[0].transaction;
    return t[r]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : undefined } : undefined }, __internalParams: e, query(s, a = e) {
      let l = a.customDataProxyFetch;
      return a.customDataProxyFetch = da(i, l), pa(a, t, r + 1, n);
    } });
  };
  var da = function(e = aa, t = aa) {
    return (r) => e(t(r));
  };
  var fa = function(e, t, r) {
    let n = Te(r);
    return !t.result || !(t.result.$allModels || t.result[n]) ? e : Jp({ ...e, ...ma(t.name, e, t.result.$allModels), ...ma(t.name, e, t.result[n]) });
  };
  var Jp = function(e) {
    let t = new be, r = (n, i) => t.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => r(o, i)) : [n]));
    return pt(e, (n) => ({ ...n, needs: r(n.name, new Set) }));
  };
  var ma = function(e, t, r) {
    return r ? pt(r, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Hp(t, o, i) })) : {};
  };
  var Hp = function(e, t, r) {
    let n = e?.[t]?.compute;
    return n ? (i) => r({ ...i, [t]: n(i) }) : r;
  };
  var ga = function(e, t) {
    if (!t)
      return e;
    let r = { ...e };
    for (let n of Object.values(t))
      if (e[n.name])
        for (let i of n.needs)
          r[i] = true;
    return r;
  };
  var xa = function({ postinstall: e, ciName: t, clientVersion: r }) {
    if (ya("checkPlatformCaching:postinstall", e), ya("checkPlatformCaching:ciName", t), e === true && t && (t in ha)) {
      let n = `Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ha[t]}-build`;
      throw console.error(n), new F(n, r);
    }
  };
  var ba = function(e, t) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t[0]]: { url: e.datasourceUrl } } : {} : {};
  };
  var Zt = function({ error: e, user_facing_error: t }, r) {
    return t.error_code ? new U(t.message, { code: t.error_code, clientVersion: r, meta: t.meta, batchRequestIdx: t.batch_request_idx }) : new K(e, { clientVersion: r, batchRequestIdx: t.batch_request_idx });
  };
  var un = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `Add "${t}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Wp(e)}`;
  };
  var Wp = function(e) {
    let { generator: t, generatorBinaryTargets: r, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...r, i];
    return si({ ...t, binaryTargets: o });
  };
  var je = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${t}".`;
  };
  var Be = function(e) {
    let { searchedLocations: t } = e;
    return `The following locations have been searched:
${[...new Set(t)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var Ea = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `${je(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t}".
${un(e)}

${Be(e)}`;
  };
  var cn = function(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  };
  var wa = function(e) {
    let { queryEngineName: t } = e;
    return `${je(e)}

This is likely caused by a bundler that has not copied "${t}" next to the resulting bundle.
Ensure that "${t}" has been copied next to the bundle or in "${e.expectedLocation}".

${cn("engine-not-found-bundler-investigation")}

${Be(e)}`;
  };
  var Pa = function(e) {
    let { runtimeBinaryTarget: t, generatorBinaryTargets: r } = e, n = r.find((i) => i.native);
    return `${je(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${t}".
${un(e)}

${Be(e)}`;
  };
  var va = function(e) {
    let { queryEngineName: t } = e;
    return `${je(e)}

This is likely caused by tooling that has not copied "${t}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t}" has been copied to "${e.expectedLocation}".

${cn("engine-not-found-tooling-investigation")}

${Be(e)}`;
  };
  async function Ca(e, t) {
    let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? t.prismaPath;
    if (r !== undefined)
      return r;
    let { enginePath: n, searchedLocations: i } = await Zp(e, t);
    if (zp("enginePath", n), n !== undefined && e === "binary" && ti(n), n !== undefined)
      return t.prismaPath = n;
    let o = await ut(), s = t.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = import.meta.file.match(Yp()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: t.generator, runtimeBinaryTarget: o, queryEngineName: Aa(e, o), expectedLocation: Xt.default.relative(process.cwd(), t.dirname) }, p;
    throw a && l ? p = Pa(c) : l ? p = Ea(c) : u ? p = wa(c) : p = va(c), new F(p, t.clientVersion);
  }
  async function Zp(engineType, config) {
    let binaryTarget = await ut(), searchedLocations = [], dirname = import.meta.dir, searchLocations = [config.dirname, Xt.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, Xt.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    import.meta.file.includes("resolveEnginePath") && searchLocations.push(rs());
    for (let e of searchLocations) {
      let t = Aa(engineType, binaryTarget), r = Xt.default.join(e, t);
      if (searchedLocations.push(e), Ta.default.existsSync(r))
        return { enginePath: r, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  var Aa = function(e, t) {
    return e === "library" ? jn(t, "fs") : `query-engine-${t}${t === "windows" ? ".exe" : ""}`;
  };
  var pn = function(e, t) {
    return { batch: e, transaction: t?.kind === "batch" ? { isolationLevel: t.options.isolationLevel } : undefined };
  };
  var Ra = function(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t) => `${t[0]}5`) : "";
  };
  var Ma = function(e) {
    return e.split(`
`).map((t) => t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  };
  var Ia = function({ title: e, user: t = "prisma", repo: r = "prisma", template: n = "bug_report.md", body: i }) {
    return (0, Sa.default)({ user: t, repo: r, template: n, title: e, body: i });
  };
  var ka = function({ version: e, platform: t, title: r, description: n, engineVersion: i, database: o, query: s }) {
    let a = bo(6000 - (s?.length ?? 0)), l = Ma((0, Ii.default)(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, Ii.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? Ra(s) : ""}
\`\`\`
`), p = Ia({ title: r, body: c });
    return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${te(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  };
  var dn = function({ inlineDatasources: e, overrideDatasources: t, env: r, clientVersion: n }) {
    let i, o = Object.keys(e)[0], s = e[o]?.url, a = t[o]?.url;
    if (o === undefined ? i = undefined : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = r[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new F(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
    if (i === undefined)
      throw new F("error: Missing URL environment variable, value, or override.", n);
    return i;
  };
  var M = function(e, t) {
    return { ...e, isRetryable: t };
  };
  async function td(e) {
    let t;
    try {
      t = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r = JSON.parse(t);
      if (typeof r == "string")
        switch (r) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r };
          default:
            return { type: "UnknownTextError", body: r };
        }
      if (typeof r == "object" && r !== null) {
        if (("is_panic" in r) && ("message" in r) && ("error_code" in r))
          return { type: "QueryEngineError", body: r };
        if (("EngineNotStarted" in r) || ("InteractiveTransactionMisrouted" in r) || ("InvalidRequestError" in r)) {
          let n = Object.values(r)[0].reason;
          return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
        }
      }
      return { type: "UnknownJsonError", body: r };
    } catch {
      return t === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t };
    }
  }
  async function cr(e, t) {
    if (e.ok)
      return;
    let r = { clientVersion: t, response: e }, n = await td(e);
    if (n.type === "QueryEngineError")
      throw new U(n.body.message, { code: n.body.error_code, clientVersion: t });
    if (n.type === "DataProxyError") {
      if (n.body === "InternalDataProxyError")
        throw new Ct(r, "Internal Data Proxy error");
      if ("EngineNotStarted" in n.body) {
        if (n.body.EngineNotStarted.reason === "SchemaMissing")
          return new Xe(r);
        if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new nr(r);
        if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
          throw new rr(r, i, o);
        }
        if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new F(i, t, o);
        }
        if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
          let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new tr(r, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new or(r, i[n.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n.body)
        throw new sr(r, n.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new lr(r, At(_i, n));
    if (e.status === 404)
      return new ar(r, At(Oi, n));
    if (e.status === 429)
      throw new ur(r, At(Ni, n));
    if (e.status === 504)
      throw new ir(r, At(Fi, n));
    if (e.status >= 500)
      throw new Ct(r, At(Di, n));
    if (e.status >= 400)
      throw new er(r, At(ki, n));
  }
  var At = function(e, t) {
    return t.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t)}`;
  };
  var Fa = function(e) {
    let t = Math.pow(2, e) * 50, r = Math.ceil(Math.random() * t) - Math.ceil(t / 2), n = t + r;
    return new Promise((i) => setTimeout(() => i(n), n));
  };
  var Oa = function(e) {
    if (!!e.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics")))
      throw new F("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  };
  async function et(e, t, r = (n) => n) {
    let n = t.clientVersion;
    try {
      return typeof fetch == "function" ? await r(fetch)(e, t) : await r(Li)(e, t);
    } catch (i) {
      console.log(e);
      let o = i.message ?? "Unknown error";
      throw new pr(o, { clientVersion: n });
    }
  }
  var nd = function(e) {
    return { ...e.headers, "Content-Type": "application/json" };
  };
  var id = function(e) {
    return { method: e.method, headers: nd(e) };
  };
  var od = function(e, t) {
    return { text: () => Promise.resolve(Buffer.concat(e).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e).toString())), ok: t.statusCode >= 200 && t.statusCode <= 299, status: t.statusCode, url: t.url, headers: new $i(t.headers) };
  };
  async function Li(e, t = {}) {
    let r = sd("https"), n = id(t), i = [], { origin: o } = new URL(e);
    return new Promise((s, a) => {
      let l = r.request(e, n, (u) => {
        let { statusCode: c, headers: { location: p } } = u;
        c >= 301 && c <= 399 && p && (p.startsWith("http") === false ? s(Li(`${o}${p}`, t)) : s(Li(p, t))), u.on("data", (d) => i.push(d)), u.on("end", () => s(od(i, u))), u.on("error", a);
      });
      l.on("error", a), l.end(t.body ?? "");
    });
  }
  async function ld(e, t) {
    let r = Da["@prisma/engines-version"], n = t.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
      return n;
    let [i, o] = n?.split("-") ?? [];
    if (o === undefined && ad.test(i))
      return i;
    if (o !== undefined || n === "0.0.0" || n === "in-memory") {
      if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s] = r.split("-") ?? [], [a, l, u] = s.split("."), c = ud(`<=${a}.${l}.${u}`), p = await et(c, { clientVersion: n });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let d = await p.text();
      _a("length of body fetched from unpkg.com", d.length);
      let f;
      try {
        f = JSON.parse(d);
      } catch (y) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), y;
      }
      return f.version;
    }
    throw new Ze("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
  }
  async function Na(e, t) {
    let r = await ld(e, t);
    return _a("version", r), r;
  }
  var ud = function(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  };
  var $a = function(e) {
    if (e?.kind === "itx")
      return e.options.id;
  };
  var cd = function() {
    let e = globalThis;
    return e[ji] === undefined && (e[ji] = {}), e[ji];
  };
  var pd = function(e) {
    let t = cd();
    if (t[e] !== undefined)
      return t[e];
    let r = qa.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Bi.default.constants.dlopen.RTLD_LAZY | Bi.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, r, i), t[e] = n.exports, n.exports;
  };
  var md = function(e) {
    return e.item_type === "query" && ("query" in e);
  };
  var fd = function(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  };
  var Ua = function(e, t) {
    let r;
    try {
      r = dn({ inlineDatasources: t.inlineDatasources, overrideDatasources: t.overrideDatasources, env: { ...t.env, ...process.env }, clientVersion: t.clientVersion });
    } catch {
    }
    e.noEngine !== true && r?.startsWith("prisma://") && qt("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n = Zn(t.generator);
    if (r?.startsWith("prisma://") || e.noEngine)
      return new dr(t);
    if (n === "library")
      return new mr(t);
    throw "binary", new X("Invalid client engine type, please use `library` or `binary`", { clientVersion: t.clientVersion });
  };
  var gn = function({ generator: e }) {
    return e?.previewFeatures ?? [];
  };
  var Ja = function(e, t) {
    let r = Ha(e), n = gd(r), i = hd(n);
    i ? yn(i, t) : t.addErrorMessage(() => "Unknown error");
  };
  var Ha = function(e) {
    return e.errors.flatMap((t) => t.kind === "Union" ? Ha(t) : [t]);
  };
  var gd = function(e) {
    let t = new Map, r = [];
    for (let n of e) {
      if (n.kind !== "InvalidArgumentType") {
        r.push(n);
        continue;
      }
      let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = t.get(i);
      o ? t.set(i, { ...n, argument: { ...n.argument, typeNames: yd(o.argument.typeNames, n.argument.typeNames) } }) : t.set(i, n);
    }
    return r.push(...t.values()), r;
  };
  var yd = function(e, t) {
    return [...new Set(e.concat(t))];
  };
  var hd = function(e) {
    return pi(e, (t, r) => {
      let n = Qa(t), i = Qa(r);
      return n !== i ? n - i : Ga(t) - Ga(r);
    });
  };
  var Qa = function(e) {
    let t = 0;
    return Array.isArray(e.selectionPath) && (t += e.selectionPath.length), Array.isArray(e.argumentPath) && (t += e.argumentPath.length), t;
  };
  var Ga = function(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  };
  var yn = function(e, t) {
    switch (e.kind) {
      case "IncludeAndSelect":
        xd(e, t);
        break;
      case "IncludeOnScalar":
        bd(e, t);
        break;
      case "EmptySelection":
        Ed(e, t);
        break;
      case "UnknownSelectionField":
        wd(e, t);
        break;
      case "UnknownArgument":
        Pd(e, t);
        break;
      case "UnknownInputField":
        vd(e, t);
        break;
      case "RequiredArgumentMissing":
        Td(e, t);
        break;
      case "InvalidArgumentType":
        Cd(e, t);
        break;
      case "InvalidArgumentValue":
        Ad(e, t);
        break;
      case "ValueTooLarge":
        Rd(e, t);
        break;
      case "SomeFieldsMissing":
        Md(e, t);
        break;
      case "TooManyFieldsGiven":
        Sd(e, t);
        break;
      case "Union":
        Ja(e, t);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  };
  var xd = function(e, t) {
    let r = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    r && r instanceof Q && (r.getField("include")?.markAsError(), r.getField("select")?.markAsError()), t.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green("`include`")} or ${n.green("`select`")}, but ${n.red("not both")} at the same time.`);
  };
  var bd = function(e, t) {
    let [r, n] = xn(e.selectionPath), i = e.outputType, o = t.arguments.getDeepSelectionParent(r)?.value;
    if (o && (o.getField(n)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o.addSuggestion(new Se(s.name, "true"));
    t.addErrorMessage((s) => {
      let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
      return i ? a += ` on model ${s.bold(i.name)}. ${fr(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
    });
  };
  var Ed = function(e, t) {
    let r = e.outputType, n = t.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
    n && (n.removeAllFields(), Za(n, r)), t.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${fr(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`);
  };
  var wd = function(e, t) {
    let [r, n] = xn(e.selectionPath), i = t.arguments.getDeepSelectionParent(r);
    i && (i.value.getField(n)?.markAsError(), Za(i.value, e.outputType)), t.addErrorMessage((o) => {
      let s = [`Unknown field ${o.red(`\`${n}\``)}`];
      return i && s.push(`for ${o.bold(i.kind)} statement`), s.push(`on model ${o.bold(`\`${e.outputType.name}\``)}.`), s.push(fr(o)), s.join(" ");
    });
  };
  var Pd = function(e, t) {
    let r = e.argumentPath[0], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && (n.getField(r)?.markAsError(), Id(n, e.arguments)), t.addErrorMessage((i) => za(i, r, e.arguments.map((o) => o.name)));
  };
  var vd = function(e, t) {
    let [r, n] = xn(e.argumentPath), i = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (i instanceof Q) {
      i.getDeepField(e.argumentPath)?.markAsError();
      let o = i.getDeepFieldValue(r);
      o instanceof Q && Xa(o, e.inputType);
    }
    t.addErrorMessage((o) => za(o, n, e.inputType.fields.map((s) => s.name)));
  };
  var za = function(e, t, r) {
    let n = [`Unknown argument \`${e.red(t)}\`.`], i = Fd(t, r);
    return i && n.push(`Did you mean \`${e.green(i)}\`?`), r.length > 0 && n.push(fr(e)), n.join(" ");
  };
  var Td = function(e, t) {
    let r;
    t.addErrorMessage((l) => r?.value instanceof G && r.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
    let n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (!(n instanceof Q))
      return;
    let [i, o] = xn(e.argumentPath), s = new hn, a = n.getDeepFieldValue(i);
    if (a instanceof Q)
      if (r = a.getField(o), r && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l of e.inputTypes[0].fields)
          s.addField(l.name, l.typeNames.join(" | "));
        a.addSuggestion(new Se(o, s).makeRequired());
      } else {
        let l = e.inputTypes.map(Ya).join(" | ");
        a.addSuggestion(new Se(o, l).makeRequired());
      }
  };
  var Ya = function(e) {
    return e.kind === "list" ? `${Ya(e.elementType)}[]` : e.name;
  };
  var Cd = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
      let o = bn("or", e.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
    });
  };
  var Ad = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
      let o = [`Invalid value for argument \`${i.bold(r)}\``];
      if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
        let s = bn("or", e.argument.typeNames.map((a) => i.green(a)));
        o.push(` Expected ${s}.`);
      }
      return o.join("");
    });
  };
  var Rd = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i;
    if (n instanceof Q) {
      let s = n.getDeepField(e.argumentPath)?.value;
      s?.markAsError(), s instanceof G && (i = s.text);
    }
    t.addErrorMessage((o) => {
      let s = ["Unable to fit value"];
      return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``), s.join(" ");
    });
  };
  var Md = function(e, t) {
    let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (n instanceof Q) {
      let i = n.getDeepFieldValue(e.argumentPath);
      i instanceof Q && Xa(i, e.inputType);
    }
    t.addErrorMessage((i) => {
      let o = [`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${bn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(fr(i)), o.join(" ");
    });
  };
  var Sd = function(e, t) {
    let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i = [];
    if (n instanceof Q) {
      let o = n.getDeepFieldValue(e.argumentPath);
      o instanceof Q && (o.markAsError(), i = Object.keys(o.getFields()));
    }
    t.addErrorMessage((o) => {
      let s = [`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${bn("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
    });
  };
  var Za = function(e, t) {
    for (let r of t.fields)
      e.hasField(r.name) || e.addSuggestion(new Se(r.name, "true"));
  };
  var Id = function(e, t) {
    for (let r of t)
      e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var Xa = function(e, t) {
    if (t.kind === "object")
      for (let r of t.fields)
        e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var xn = function(e) {
    let t = [...e], r = t.pop();
    if (!r)
      throw new Error("unexpected empty path");
    return [t, r];
  };
  var fr = function({ green: e, enabled: t }) {
    return "Available options are " + (t ? `listed in ${e("green")}` : "marked with ?") + ".";
  };
  var bn = function(e, t) {
    if (t.length === 1)
      return t[0];
    let r = [...t], n = r.pop();
    return `${r.join(", ")} ${e} ${n}`;
  };
  var Fd = function(e, t) {
    let r = 1 / 0, n;
    for (let i of t) {
      let o = (0, Wa.default)(e, i);
      o > kd || o < r && (r = o, n = i);
    }
    return n;
  };
  var En = function({ args: e, errors: t, errorFormat: r, callsite: n, originalMethod: i, clientVersion: o }) {
    let s = en(e);
    for (let p of t)
      yn(p, s);
    let a = r === "pretty" ? Ds : Zr, l = s.renderAllMessages(a), u = new mt(0, { colors: a }).write(s).toString(), c = Pt({ message: l, callsite: n, originalMethod: i, showColors: r === "pretty", callArguments: u });
    throw new X(c, { clientVersion: o });
  };
  var el = function({ modelName: e, action: t, args: r, runtimeDataModel: n, extensions: i, callsite: o, clientMethod: s, errorFormat: a, clientVersion: l }) {
    let u = new Ki({ runtimeDataModel: n, modelName: e, action: t, rootArgs: r, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l });
    return { modelName: e, action: Od[t], query: Qi(r, u) };
  };
  var Qi = function({ select: e, include: t, ...r } = {}, n) {
    return { arguments: rl(r, n), selection: Dd(e, t, n) };
  };
  var Dd = function(e, t, r) {
    return e && t && r.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r.getSelectionPath() }), e ? Ld(e, r) : _d(r, t);
  };
  var _d = function(e, t) {
    let r = {};
    return e.model && !e.isRawAction() && (r.$composites = true, r.$scalars = true), t && Nd(r, t, e), r;
  };
  var Nd = function(e, t, r) {
    for (let [n, i] of Object.entries(t)) {
      let o = r.findField(n);
      o && o?.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n), outputType: r.getOutputTypeDescription() }), i === true ? e[n] = true : typeof i == "object" && (e[n] = Qi(i, r.nestSelection(n)));
    }
  };
  var Ld = function(e, t) {
    let r = {}, n = t.getComputedFields(), i = ga(e, n);
    for (let [o, s] of Object.entries(i)) {
      let a = t.findField(o);
      n?.[o] && !a || (s === true ? r[o] = true : typeof s == "object" && (r[o] = Qi(s, t.nestSelection(o))));
    }
    return r;
  };
  var tl = function(e, t) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (ft(e)) {
      if (Br(e))
        return { $type: "DateTime", value: e.toISOString() };
      t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (xt(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return $d(e, t);
    if (ArrayBuffer.isView(e))
      return { $type: "Bytes", value: Buffer.from(e).toString("base64") };
    if (qd(e))
      return e.values;
    if (ht(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof xe) {
      if (e !== $r.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (Vd(e))
      return e.toJSON();
    if (typeof e == "object")
      return rl(e, t);
    t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  };
  var rl = function(e, t) {
    if (e.$type)
      return { $type: "Json", value: JSON.stringify(e) };
    let r = {};
    for (let n in e) {
      let i = e[n];
      i !== undefined && (r[n] = tl(i, t.nestArgument(n)));
    }
    return r;
  };
  var $d = function(e, t) {
    let r = [];
    for (let n = 0;n < e.length; n++) {
      let i = t.nestArgument(String(n)), o = e[n];
      o === undefined && t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r.push(tl(o, i));
    }
    return r;
  };
  var qd = function(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  };
  var Vd = function(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  };
  var gr = function(e) {
    try {
      return ol(e, "fast");
    } catch {
      return ol(e, "slow");
    }
  };
  var ol = function(e, t) {
    return JSON.stringify(e.map((r) => jd(r, t)));
  };
  var jd = function(e, t) {
    return typeof e == "bigint" ? { prisma__type: "bigint", prisma__value: e.toString() } : ft(e) ? { prisma__type: "date", prisma__value: e.toJSON() } : Pe.isDecimal(e) ? { prisma__type: "decimal", prisma__value: e.toJSON() } : Buffer.isBuffer(e) ? { prisma__type: "bytes", prisma__value: e.toString("base64") } : Bd(e) || ArrayBuffer.isView(e) ? { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") } : typeof e == "object" && t === "slow" ? al(e) : e;
  };
  var Bd = function(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  };
  var al = function(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(sl);
    let t = {};
    for (let r of Object.keys(e))
      t[r] = sl(e[r]);
    return t;
  };
  var sl = function(e) {
    return typeof e == "bigint" ? e.toString() : al(e);
  };
  var Gi = function(e, t, r, n) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && r.length > 0 && Ud.exec(t))
      throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  };
  var Hi = function(e) {
    return function(r) {
      let n, i = (o = e) => {
        try {
          return o === undefined || o?.kind === "itx" ? n ?? (n = pl(r(o))) : pl(r(o));
        } catch (s) {
          return Promise.reject(s);
        }
      };
      return { then(o, s) {
        return i().then(o, s);
      }, catch(o) {
        return i().catch(o);
      }, finally(o) {
        return i().finally(o);
      }, requestTransaction(o) {
        let s = i(o);
        return s.requestTransaction ? s.requestTransaction(o) : s;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  };
  var pl = function(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  };
  var ml = function(e) {
    return e.includes("tracing") ? new Wi : dl;
  };
  var fl = function(e, t = () => {
  }) {
    let r, n = new Promise((i) => r = i);
    return { then(i) {
      return --e === 0 && r(t()), i?.(n);
    } };
  };
  var gl = function(e) {
    return typeof e == "string" ? e : e.reduce((t, r) => {
      let n = typeof r == "string" ? r : r.level;
      return n === "query" ? t : t && (r === "info" || t === "info") ? "info" : n;
    }, undefined);
  };
  var Pn = function(e) {
    return typeof e.batchRequestIdx == "number";
  };
  var vn = function(e) {
    return e === null ? e : Array.isArray(e) ? e.map(vn) : typeof e == "object" ? Qd(e) ? Gd(e) : pt(e, vn) : e;
  };
  var Qd = function(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  };
  var Gd = function({ $type: e, value: t }) {
    switch (e) {
      case "BigInt":
        return BigInt(t);
      case "Bytes":
        return Buffer.from(t, "base64");
      case "DateTime":
        return new Date(t);
      case "Decimal":
        return new Pe(t);
      case "Json":
        return JSON.parse(t);
      default:
        He(t, "Unknown tagged value");
    }
  };
  var yl = function(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let t = [];
    return e.modelName && t.push(e.modelName), e.query.arguments && t.push(Yi(e.query.arguments)), t.push(Yi(e.query.selection)), t.join("");
  };
  var Yi = function(e) {
    return `(${Object.keys(e).sort().map((r) => {
      let n = e[r];
      return typeof n == "object" && n !== null ? `(${r} ${Yi(n)})` : r;
    }).join(" ")})`;
  };
  var Zi = function(e) {
    return Jd[e];
  };
  var Wd = function(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: xl(e) };
      He(e, "Unknown transaction kind");
    }
  };
  var xl = function(e) {
    return { id: e.id, payload: e.payload };
  };
  var zd = function(e, t) {
    return Pn(e) && t?.kind === "batch" && e.batchRequestIdx !== t.index;
  };
  var Yd = function(e) {
    return e.code === "P2009" || e.code === "P2012";
  };
  var bl = function(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map(bl) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...t] = e.selectionPath;
      return { ...e, selectionPath: t };
    }
    return e;
  };
  var Pl = function(e) {
    return e.map((t) => {
      let r = {};
      for (let n of Object.keys(t))
        r[n] = vl(t[n]);
      return r;
    });
  };
  var vl = function({ prisma__type: e, prisma__value: t }) {
    switch (e) {
      case "bigint":
        return BigInt(t);
      case "bytes":
        return Buffer.from(t, "base64");
      case "decimal":
        return new Pe(t);
      case "datetime":
      case "date":
        return new Date(t);
      case "time":
        return new Date(`1970-01-01T${t}Z`);
      case "array":
        return t.map(vl);
      default:
        return t;
    }
  };
  var Ml = function(e, t) {
    for (let [r, n] of Object.entries(e)) {
      if (!Tl.includes(r)) {
        let i = Rt(r, Tl);
        throw new q(`Unknown property ${r} provided to PrismaClient constructor.${i}`);
      }
      Xd[r](n, t);
    }
    if (e.datasourceUrl && e.datasources)
      throw new q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  };
  var Rt = function(e, t) {
    if (t.length === 0 || typeof e != "string")
      return "";
    let r = em(e, t);
    return r ? ` Did you mean "${r}"?` : "";
  };
  var em = function(e, t) {
    if (t.length === 0)
      return null;
    let r = t.map((i) => ({ value: i, distance: (0, Rl.default)(e, i) }));
    r.sort((i, o) => i.distance < o.distance ? -1 : 1);
    let n = r[0];
    return n.distance < 3 ? n.value : null;
  };
  var Sl = function(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((t, r) => {
      let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
        o || (s++, s === e.length && (o = true, i ? r(i) : t(n)));
      }, l = (u) => {
        o || (o = true, r(u));
      };
      for (let u = 0;u < e.length; u++)
        e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!Pn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
    });
  };
  var Dl = function(e) {

    class t {
      constructor(n) {
        this._middlewares = new wn;
        this._createPrismaPromise = Hi();
        this.$extends = ra;
        xa(e), n && Ml(n, e);
        let i = n?.adapter ? fs(n.adapter) : undefined, o = new Fl.EventEmitter().on("error", () => {
        });
        this._extensions = ln.empty(), this._previewFeatures = gn(e), this._clientVersion = e.clientVersion ?? wl, this._activeProvider = e.activeProvider, this._tracingHelper = ml(this._previewFeatures);
        let s = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && yr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && yr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, a = !i && _t(s, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
          c && D.enable("prisma:client");
          let p = yr.default.resolve(e.dirname, e.relativePath);
          Ol.default.existsSync(p) || (p = e.dirname), Ue("dirname", e.dirname), Ue("relativePath", e.relativePath), Ue("cwd", p);
          let d = u.engine || {};
          if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c, allowTriggerPanic: d.allowTriggerPanic, datamodelPath: yr.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: d.binaryPath ?? undefined, engineEndpoint: d.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && gl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a?.parsed ?? {}, flags: [], clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: ba(l, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: o, isBundled: e.isBundled, adapter: i }, Ue("clientVersion", e.clientVersion), this._engine = Ua(e, this._engineConfig), this._requestHandler = new Cn(this, o), l.log)
            for (let f of l.log) {
              let y = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              y && this.$on(y, (g) => {
                $t.log(`${$t.tags[y] ?? ""}`, g.message || g.query);
              });
            }
          this._metrics = new dt(this._engine);
        } catch (l) {
          throw l.clientVersion = this._clientVersion, l;
        }
        return this._appliedParent = zt(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n) {
        this._middlewares.use(n);
      }
      $on(n, i) {
        n === "beforeExit" ? this._engine.on("beforeExit", i) : this._engine.on(n, (o) => {
          let s = o.fields;
          return i(n === "query" ? { timestamp: o.timestamp, query: s?.query ?? o.query, params: s?.params ?? o.params, duration: s?.duration_ms ?? o.duration, target: o.target } : { timestamp: o.timestamp, message: s?.message ?? o.message, target: o.target });
        });
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        } finally {
          Eo();
        }
      }
      $executeRawInternal(n, i, o, s) {
        let a = this._activeProvider, l = this._engineConfig.adapter?.flavour;
        return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Ji({ clientMethod: i, activeProvider: a, activeProviderFlavour: l }), callsite: Ve(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined) {
            let [s, a] = Il(n, i);
            return Gi(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
          }
          throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => (Gi(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
      }
      $runCommandRaw(n) {
        if (e.activeProvider !== "mongodb")
          throw new X(`The ${e.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: nl, callsite: Ve(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n, i, o, s) {
        let a = this._activeProvider, l = this._engineConfig.adapter?.flavour;
        return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Ji({ clientMethod: i, activeProvider: a, activeProviderFlavour: l }), callsite: Ve(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(Pl);
      }
      $queryRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined)
            return this.$queryRawInternal(o, "$queryRaw", ...Il(n, i));
          throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
      }
      _transactionWithArray({ promises: n, options: i }) {
        let o = nm.nextId(), s = fl(n.length), a = n.map((l, u) => {
          if (l?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c = i?.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
          return l.requestTransaction?.(p) ?? l;
        });
        return Sl(a);
      }
      async _transactionWithCallback({ callback: n, options: i }) {
        let o = { traceparent: this._tracingHelper.getTraceParent() }, s = await this._engine.transaction("start", o, i), a;
        try {
          let l = { kind: "itx", ...s };
          a = await n(this._createItxClient(l)), await this._engine.transaction("commit", o, s);
        } catch (l) {
          throw await this._engine.transaction("rollback", o, s).catch(() => {
          }), l;
        }
        return a;
      }
      _createItxClient(n) {
        return zt(Ee(on(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Hi(n)), re(rm, () => n.id), Gt(zi)]));
      }
      $transaction(n, i) {
        let o;
        typeof n == "function" ? o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o);
      }
      _request(n) {
        n.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n.middlewareArgsMapper ?? tm, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = -1, l = async (u) => {
          let c = this._middlewares.get(++a);
          if (c)
            return this._tracingHelper.runInChildSpan(s.middleware, (P) => c(u, (T) => (P?.end(), l(T))));
          let { runInTransaction: p, args: d, ...f } = u, y = { ...n, ...f };
          d && (y.args = i.middlewareArgsToRequestArgs(d)), n.transaction !== undefined && p === false && delete y.transaction;
          let g = await ua(this, y);
          return y.model ? oa({ result: g, modelName: y.model, args: y.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : g;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new kl.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
      }
      async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
        try {
          n = u ? u(n) : n;
          let y = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(y, () => el({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return D.enabled("prisma:client") && (Ue("Prisma Client call:"), Ue(`prisma.${i}(${$s(n)})`), Ue("Generated request:"), Ue(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (y) {
          throw y.clientVersion = this._clientVersion, y;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new X("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n) {
        return !!this._engineConfig.previewFeatures?.includes(n);
      }
    }
    return t;
  };
  var Il = function(e, t) {
    return im(e) ? [new oe(e, t), ul] : [e, cl];
  };
  var im = function(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  };
  var _l = function(e) {
    return new Proxy(e, { get(t, r) {
      if (r in t)
        return t[r];
      if (!om.has(r))
        throw new TypeError(`Invalid enum value: ${String(r)}`);
    } });
  };
  var Nl = function(e) {
    _t(e, { conflictCheck: "warn" });
  };
  var Ll = Object.create;
  var Mt = Object.defineProperty;
  var $l = Object.getOwnPropertyDescriptor;
  var ql = Object.getOwnPropertyNames;
  var Vl = Object.getPrototypeOf;
  var jl = Object.prototype.hasOwnProperty;
  var Bl = (e, t, r) => (t in e) ? Mt(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
  var V = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
  var St = (e, t) => {
    for (var r in t)
      Mt(e, r, { get: t[r], enumerable: true });
  };
  var Xi = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of ql(t))
        !jl.call(e, i) && i !== r && Mt(e, i, { get: () => t[i], enumerable: !(n = $l(t, i)) || n.enumerable });
    return e;
  };
  var S = (e, t, r) => (r = e != null ? Ll(Vl(e)) : {}, Xi(t || !e || !e.__esModule ? Mt(r, "default", { value: e, enumerable: true }) : r, e));
  var Ul = (e) => Xi(Mt({}, "__esModule", { value: true }), e);
  var eo = (e, t, r) => (Bl(e, typeof t != "symbol" ? t + "" : t, r), r);
  var co = V((xm, uo) => {
    var rt = 1000, nt = rt * 60, it = nt * 60, Qe = it * 24, Kl = Qe * 7, Ql = Qe * 365.25;
    uo.exports = function(e, t) {
      t = t || {};
      var r = typeof e;
      if (r === "string" && e.length > 0)
        return Gl(e);
      if (r === "number" && isFinite(e))
        return t.long ? Hl(e) : Jl(e);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
    };
    function Gl(e) {
      if (e = String(e), !(e.length > 100)) {
        var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
        if (t) {
          var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
          switch (n) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return r * Ql;
            case "weeks":
            case "week":
            case "w":
              return r * Kl;
            case "days":
            case "day":
            case "d":
              return r * Qe;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return r * it;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return r * nt;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return r * rt;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return r;
            default:
              return;
          }
        }
      }
    }
    function Jl(e) {
      var t = Math.abs(e);
      return t >= Qe ? Math.round(e / Qe) + "d" : t >= it ? Math.round(e / it) + "h" : t >= nt ? Math.round(e / nt) + "m" : t >= rt ? Math.round(e / rt) + "s" : e + "ms";
    }
    function Hl(e) {
      var t = Math.abs(e);
      return t >= Qe ? br(e, t, Qe, "day") : t >= it ? br(e, t, it, "hour") : t >= nt ? br(e, t, nt, "minute") : t >= rt ? br(e, t, rt, "second") : e + " ms";
    }
    function br(e, t, r, n) {
      var i = t >= r * 1.5;
      return Math.round(e / r) + " " + n + (i ? "s" : "");
    }
  });
  var kn = V((bm, po) => {
    function Wl(e) {
      r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = i, r.enabled = s, r.humanize = co(), r.destroy = u, Object.keys(e).forEach((c) => {
        r[c] = e[c];
      }), r.names = [], r.skips = [], r.formatters = {};
      function t(c) {
        let p = 0;
        for (let d = 0;d < c.length; d++)
          p = (p << 5) - p + c.charCodeAt(d), p |= 0;
        return r.colors[Math.abs(p) % r.colors.length];
      }
      r.selectColor = t;
      function r(c) {
        let p, d = null, f, y;
        function g(...P) {
          if (!g.enabled)
            return;
          let T = g, C = Number(new Date), x = C - (p || C);
          T.diff = x, T.prev = p, T.curr = C, p = C, P[0] = r.coerce(P[0]), typeof P[0] != "string" && P.unshift("%O");
          let R = 0;
          P[0] = P[0].replace(/%([a-zA-Z%])/g, (J, Ke) => {
            if (J === "%%")
              return "%";
            R++;
            let $ = r.formatters[Ke];
            if (typeof $ == "function") {
              let z = P[R];
              J = $.call(T, z), P.splice(R, 1), R--;
            }
            return J;
          }), r.formatArgs.call(T, P), (T.log || r.log).apply(T, P);
        }
        return g.namespace = c, g.useColors = r.useColors(), g.color = r.selectColor(c), g.extend = n, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: true, configurable: false, get: () => d !== null ? d : (f !== r.namespaces && (f = r.namespaces, y = r.enabled(c)), y), set: (P) => {
          d = P;
        } }), typeof r.init == "function" && r.init(g), g;
      }
      function n(c, p) {
        let d = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
        return d.log = this.log, d;
      }
      function i(c) {
        r.save(c), r.namespaces = c, r.names = [], r.skips = [];
        let p, d = (typeof c == "string" ? c : "").split(/[\s,]+/), f = d.length;
        for (p = 0;p < f; p++)
          d[p] && (c = d[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
      }
      function o() {
        let c = [...r.names.map(a), ...r.skips.map(a).map((p) => "-" + p)].join(",");
        return r.enable(""), c;
      }
      function s(c) {
        if (c[c.length - 1] === "*")
          return true;
        let p, d;
        for (p = 0, d = r.skips.length;p < d; p++)
          if (r.skips[p].test(c))
            return false;
        for (p = 0, d = r.names.length;p < d; p++)
          if (r.names[p].test(c))
            return true;
        return false;
      }
      function a(c) {
        return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function l(c) {
        return c instanceof Error ? c.stack || c.message : c;
      }
      function u() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return r.enable(r.load()), r;
    }
    po.exports = Wl;
  });
  var mo = V((le, Er) => {
    le.formatArgs = Yl;
    le.save = Zl;
    le.load = Xl;
    le.useColors = zl;
    le.storage = eu();
    le.destroy = (() => {
      let e = false;
      return () => {
        e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    le.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function zl() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function Yl(e) {
      if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Er.exports.humanize(this.diff), !this.useColors)
        return;
      let t = "color: " + this.color;
      e.splice(1, 0, t, "color: inherit");
      let r = 0, n = 0;
      e[0].replace(/%[a-zA-Z%]/g, (i) => {
        i !== "%%" && (r++, i === "%c" && (n = r));
      }), e.splice(n, 0, t);
    }
    le.log = console.debug || console.log || (() => {
    });
    function Zl(e) {
      try {
        e ? le.storage.setItem("debug", e) : le.storage.removeItem("debug");
      } catch {
      }
    }
    function Xl() {
      let e;
      try {
        e = le.storage.getItem("debug");
      } catch {
      }
      return !e && typeof process < "u" && ("env" in process) && (e = process.env.DEBUG), e;
    }
    function eu() {
      try {
        return localStorage;
      } catch {
      }
    }
    Er.exports = kn()(le);
    var { formatters: tu } = Er.exports;
    tu.j = function(e) {
      try {
        return JSON.stringify(e);
      } catch (t) {
        return "[UnexpectedJSONParseError]: " + t.message;
      }
    };
  });
  var Fn = V((Em, fo) => {
    fo.exports = (e, t = process.argv) => {
      let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
      return n !== -1 && (i === -1 || n < i);
    };
  });
  var _n = V((wm, yo) => {
    var ru = import.meta.require("os"), go = import.meta.require("tty"), de = Fn(), { env: B } = process, ke;
    de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? ke = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (ke = 1);
    ("FORCE_COLOR" in B) && (B.FORCE_COLOR === "true" ? ke = 1 : B.FORCE_COLOR === "false" ? ke = 0 : ke = B.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(B.FORCE_COLOR, 10), 3));
    function On(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function Dn(e, t) {
      if (ke === 0)
        return 0;
      if (de("color=16m") || de("color=full") || de("color=truecolor"))
        return 3;
      if (de("color=256"))
        return 2;
      if (e && !t && ke === undefined)
        return 0;
      let r = ke || 0;
      if (B.TERM === "dumb")
        return r;
      if (process.platform === "win32") {
        let n = ru.release().split(".");
        return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in B)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => (n in B)) || B.CI_NAME === "codeship" ? 1 : r;
      if ("TEAMCITY_VERSION" in B)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(B.TEAMCITY_VERSION) ? 1 : 0;
      if (B.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in B) {
        let n = parseInt((B.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (B.TERM_PROGRAM) {
          case "iTerm.app":
            return n >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(B.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(B.TERM) || ("COLORTERM" in B) ? 1 : r;
    }
    function nu(e) {
      let t = Dn(e, e && e.isTTY);
      return On(t);
    }
    yo.exports = { supportsColor: nu, stdout: On(Dn(true, go.isatty(1))), stderr: On(Dn(true, go.isatty(2))) };
  });
  var xo = V((H, Pr) => {
    var iu = import.meta.require("tty"), wr = import.meta.require("util");
    H.init = pu;
    H.log = lu;
    H.formatArgs = su;
    H.save = uu;
    H.load = cu;
    H.useColors = ou;
    H.destroy = wr.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    H.colors = [6, 2, 3, 4, 5, 1];
    try {
      let e = _n();
      e && (e.stderr || e).level >= 2 && (H.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    H.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
      let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o) => o.toUpperCase()), n = process.env[t];
      return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), e[r] = n, e;
    }, {});
    function ou() {
      return "colors" in H.inspectOpts ? !!H.inspectOpts.colors : iu.isatty(process.stderr.fd);
    }
    function su(e) {
      let { namespace: t, useColors: r } = this;
      if (r) {
        let n = this.color, i = "\x1B[3" + (n < 8 ? n : "8;5;" + n), o = `  ${i};1m${t} \x1B[0m`;
        e[0] = o + e[0].split(`
`).join(`
` + o), e.push(i + "m+" + Pr.exports.humanize(this.diff) + "\x1B[0m");
      } else
        e[0] = au() + t + " " + e[0];
    }
    function au() {
      return H.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }
    function lu(...e) {
      return process.stderr.write(wr.format(...e) + `
`);
    }
    function uu(e) {
      e ? process.env.DEBUG = e : delete process.env.DEBUG;
    }
    function cu() {
      return process.env.DEBUG;
    }
    function pu(e) {
      e.inspectOpts = {};
      let t = Object.keys(H.inspectOpts);
      for (let r = 0;r < t.length; r++)
        e.inspectOpts[t[r]] = H.inspectOpts[t[r]];
    }
    Pr.exports = kn()(H);
    var { formatters: ho } = Pr.exports;
    ho.o = function(e) {
      return this.inspectOpts.colors = this.useColors, wr.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
    };
    ho.O = function(e) {
      return this.inspectOpts.colors = this.useColors, wr.inspect(e, this.inspectOpts);
    };
  });
  var Ln = V((Pm, Nn) => {
    typeof process > "u" || process.type === "renderer" || false || process.__nwjs ? Nn.exports = mo() : Nn.exports = xo();
  });
  var So = V((ef, Un) => {
    var A = Un.exports;
    Un.exports.default = A;
    var I = "\x1B[", kt = "\x1B]", at = "\x07", Rr = ";", Mo = false;
    A.cursorTo = (e, t) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t != "number" ? I + (e + 1) + "G" : I + (t + 1) + ";" + (e + 1) + "H";
    };
    A.cursorMove = (e, t) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      let r = "";
      return e < 0 ? r += I + -e + "D" : e > 0 && (r += I + e + "C"), t < 0 ? r += I + -t + "A" : t > 0 && (r += I + t + "B"), r;
    };
    A.cursorUp = (e = 1) => I + e + "A";
    A.cursorDown = (e = 1) => I + e + "B";
    A.cursorForward = (e = 1) => I + e + "C";
    A.cursorBackward = (e = 1) => I + e + "D";
    A.cursorLeft = I + "G";
    A.cursorSavePosition = Mo ? "\x1B7" : I + "s";
    A.cursorRestorePosition = Mo ? "\x1B8" : I + "u";
    A.cursorGetPosition = I + "6n";
    A.cursorNextLine = I + "E";
    A.cursorPrevLine = I + "F";
    A.cursorHide = I + "?25l";
    A.cursorShow = I + "?25h";
    A.eraseLines = (e) => {
      let t = "";
      for (let r = 0;r < e; r++)
        t += A.eraseLine + (r < e - 1 ? A.cursorUp() : "");
      return e && (t += A.cursorLeft), t;
    };
    A.eraseEndLine = I + "K";
    A.eraseStartLine = I + "1K";
    A.eraseLine = I + "2K";
    A.eraseDown = I + "J";
    A.eraseUp = I + "1J";
    A.eraseScreen = I + "2J";
    A.scrollUp = I + "S";
    A.scrollDown = I + "T";
    A.clearScreen = "\x1Bc";
    A.clearTerminal = process.platform === "win32" ? `${A.eraseScreen}${I}0f` : `${A.eraseScreen}${I}3J${I}H`;
    A.beep = at;
    A.link = (e, t) => [kt, "8", Rr, Rr, t, at, e, kt, "8", Rr, Rr, at].join("");
    A.image = (e, t = {}) => {
      let r = `${kt}1337;File=inline=1`;
      return t.width && (r += `;width=${t.width}`), t.height && (r += `;height=${t.height}`), t.preserveAspectRatio === false && (r += ";preserveAspectRatio=0"), r + ":" + e.toString("base64") + at;
    };
    A.iTerm = { setCwd: (e = process.cwd()) => `${kt}50;CurrentDir=${e}${at}`, annotation: (e, t = {}) => {
      let r = `${kt}1337;`, n = typeof t.x < "u", i = typeof t.y < "u";
      if ((n || i) && !(n && i && typeof t.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replace(/\|/g, ""), r += t.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t.length > 0 ? r += (n ? [e, t.length, t.x, t.y] : [t.length, e]).join("|") : r += e, r + at;
    } };
  });
  var Fo = V((tf, ko) => {
    var hu = _n(), lt = Fn();
    function Io(e) {
      if (/^\d{3,4}$/.test(e)) {
        let r = /(\d{1,2})(\d{2})/.exec(e);
        return { major: 0, minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) };
      }
      let t = (e || "").split(".").map((r) => parseInt(r, 10));
      return { major: t[0], minor: t[1], patch: t[2] };
    }
    function Kn(e) {
      let { env: t } = process;
      if ("FORCE_HYPERLINK" in t)
        return !(t.FORCE_HYPERLINK.length > 0 && parseInt(t.FORCE_HYPERLINK, 10) === 0);
      if (lt("no-hyperlink") || lt("no-hyperlinks") || lt("hyperlink=false") || lt("hyperlink=never"))
        return false;
      if (lt("hyperlink=true") || lt("hyperlink=always") || ("NETLIFY" in t))
        return true;
      if (!hu.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || ("CI" in t) || ("TEAMCITY_VERSION" in t))
        return false;
      if ("TERM_PROGRAM" in t) {
        let r = Io(t.TERM_PROGRAM_VERSION);
        switch (t.TERM_PROGRAM) {
          case "iTerm.app":
            return r.major === 3 ? r.minor >= 1 : r.major > 3;
          case "WezTerm":
            return r.major >= 20200620;
          case "vscode":
            return r.major > 1 || r.major === 1 && r.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t) {
        if (t.VTE_VERSION === "0.50.0")
          return false;
        let r = Io(t.VTE_VERSION);
        return r.major > 0 || r.minor >= 50;
      }
      return false;
    }
    ko.exports = { supportsHyperlink: Kn, stdout: Kn(process.stdout), stderr: Kn(process.stderr) };
  });
  var Do = V((rf, Ft) => {
    var xu = So(), Qn = Fo(), Oo = (e, t, { target: r = "stdout", ...n } = {}) => Qn[r] ? xu.link(e, t) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, t) : `${e} (\u200B${t}\u200B)`;
    Ft.exports = (e, t, r = {}) => Oo(e, t, r);
    Ft.exports.stderr = (e, t, r = {}) => Oo(e, t, { target: "stderr", ...r });
    Ft.exports.isSupported = Qn.stdout;
    Ft.exports.stderr.isSupported = Qn.stderr;
  });
  var Ko = V((wf, Ou) => {
    Ou.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Go = V((Pf, Fr) => {
    var Du = import.meta.require("fs"), Qo = import.meta.require("path"), _u = import.meta.require("os"), Nu = Ko(), Lu = Nu.version, $u = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function qu(e) {
      let t = {}, r = e.toString();
      r = r.replace(/\r\n?/mg, `
`);
      let n;
      for (;(n = $u.exec(r)) != null; ) {
        let i = n[1], o = n[2] || "";
        o = o.trim();
        let s = o[0];
        o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), t[i] = o;
      }
      return t;
    }
    function Wn(e) {
      console.log(`[dotenv@${Lu}][DEBUG] ${e}`);
    }
    function Vu(e) {
      return e[0] === "~" ? Qo.join(_u.homedir(), e.slice(1)) : e;
    }
    function ju(e) {
      let t = Qo.resolve(process.cwd(), ".env"), r = "utf8", n = !!(e && e.debug), i = !!(e && e.override);
      e && (e.path != null && (t = Vu(e.path)), e.encoding != null && (r = e.encoding));
      try {
        let o = kr.parse(Du.readFileSync(t, { encoding: r }));
        return Object.keys(o).forEach(function(s) {
          Object.prototype.hasOwnProperty.call(process.env, s) ? (i === true && (process.env[s] = o[s]), n && Wn(i === true ? `"${s}" is already defined in \`process.env\` and WAS overwritten` : `"${s}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s] = o[s];
        }), { parsed: o };
      } catch (o) {
        return n && Wn(`Failed to load ${t} ${o.message}`), { error: o };
      }
    }
    var kr = { config: ju, parse: qu };
    Fr.exports.config = kr.config;
    Fr.exports.parse = kr.parse;
    Fr.exports = kr;
  });
  var Zo = V((Sf, Yo) => {
    Yo.exports = (e) => {
      let t = e.match(/^[ \t]*(?=\S)/gm);
      return t ? t.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
    };
  });
  var es = V((If, Xo) => {
    var Qu = Zo();
    Xo.exports = (e) => {
      let t = Qu(e);
      if (t === 0)
        return e;
      let r = new RegExp(`^[ \\t]{${t}}`, "gm");
      return e.replace(r, "");
    };
  });
  var ts = V((kf, Gu) => {
    Gu.exports = { name: "@prisma/engines-version", version: "5.4.1-2.ac9d7041ed77bcc8a8dbd2ab6616b39013829574", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.18.4", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var Xn = V((Dr) => {
    Object.defineProperty(Dr, "__esModule", { value: true });
    Dr.enginesVersion = undefined;
    Dr.enginesVersion = ts().prisma.enginesVersion;
  });
  var ii = V((Kf, is) => {
    is.exports = (e, t = 1, r) => {
      if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof t != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);
      if (typeof r.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
      if (t === 0)
        return e;
      let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n, r.indent.repeat(t));
    };
  });
  var ls = V((Jf, as) => {
    as.exports = ({ onlyFirst: e = false } = {}) => {
      let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t, e ? undefined : "g");
    };
  });
  var li = V((Hf, us) => {
    var rc = ls();
    us.exports = (e) => typeof e == "string" ? e.replace(rc(), "") : e;
  });
  var cs = V((Yf, Nr) => {
    Nr.exports = (e = {}) => {
      let t;
      if (e.repoUrl)
        t = e.repoUrl;
      else if (e.user && e.repo)
        t = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r = new URL(`${t}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n) {
        let o = e[i];
        if (o !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o = o.join(",");
          }
          r.searchParams.set(i, o);
        }
      }
      return r.toString();
    };
    Nr.exports.default = Nr.exports;
  });
  var Ui = V((CP, Ka) => {
    Ka.exports = function() {
      function e(t, r, n, i, o) {
        return t < r || n < r ? t > n ? n + 1 : t + 1 : i === o ? r : r + 1;
      }
      return function(t, r) {
        if (t === r)
          return 0;
        if (t.length > r.length) {
          var n = t;
          t = r, r = n;
        }
        for (var i = t.length, o = r.length;i > 0 && t.charCodeAt(i - 1) === r.charCodeAt(o - 1); )
          i--, o--;
        for (var s = 0;s < i && t.charCodeAt(s) === r.charCodeAt(s); )
          s++;
        if (i -= s, o -= s, i === 0 || o < 3)
          return o;
        var a = 0, l, u, c, p, d, f, y, g, P, T, C, x, R = [];
        for (l = 0;l < i; l++)
          R.push(l + 1), R.push(t.charCodeAt(s + l));
        for (var ce = R.length - 1;a < o - 3; )
          for (P = r.charCodeAt(s + (u = a)), T = r.charCodeAt(s + (c = a + 1)), C = r.charCodeAt(s + (p = a + 2)), x = r.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0;l < ce; l += 2)
            y = R[l], g = R[l + 1], u = e(y, u, c, P, g), c = e(u, c, p, T, g), p = e(c, p, d, C, g), f = e(p, d, f, x, g), R[l] = f, d = p, p = c, c = u, u = y;
        for (;a < o; )
          for (P = r.charCodeAt(s + (u = a)), f = ++a, l = 0;l < ce; l += 2)
            y = R[l], R[l] = f = e(y, u, f, P, R[l + 1]), u = y;
        return f;
      };
    }();
  });
  var sm = {};
  St(sm, { DMMF: () => pe, DMMFClass: () => xr, Debug: () => $n, Decimal: () => Pe, Extensions: () => Rn, MetricsClient: () => dt, NotFoundError: () => Re, ObjectEnumValue: () => xe, PrismaClientInitializationError: () => F, PrismaClientKnownRequestError: () => U, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => K, PrismaClientValidationError: () => X, Public: () => Mn, Sql: () => oe, Types: () => Sn, defineDmmfProperty: () => ms, empty: () => ys, getPrismaClient: () => Dl, itxClientDenyList: () => zi, join: () => gs, makeStrictEnum: () => _l, objectEnumNames: () => ic, objectEnumValues: () => $r, raw: () => gi, sqltag: () => yi, warnEnvConflicts: () => Nl, warnOnce: () => qt });
  module.exports = Ul(sm);
  var Rn = {};
  St(Rn, { defineExtension: () => to, getExtensionContext: () => ro });
  var Mn = {};
  St(Mn, { validator: () => no });
  var Sn = {};
  St(Sn, { Extensions: () => io, Public: () => oo, Result: () => so, Utils: () => ao });
  var io = {};
  var oo = {};
  var so = {};
  var ao = {};
  var Ie = (e, t) => {
    let r = {};
    for (let n of e) {
      let i = n[t];
      r[i] = n;
    }
    return r;
  };
  var xr = class {
    constructor(t) {
      this.document = t;
      this.compositeNames = new Set(this.datamodel.types.map((r) => r.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
    }
    get datamodel() {
      return this.document.datamodel;
    }
    get mappings() {
      return this.document.mappings;
    }
    get schema() {
      return this.document.schema;
    }
    get inputObjectTypes() {
      return this.schema.inputObjectTypes;
    }
    get outputObjectTypes() {
      return this.schema.outputObjectTypes;
    }
    isComposite(t) {
      return this.compositeNames.has(t);
    }
    getOtherOperationNames() {
      return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
    }
    hasEnumInNamespace(t, r) {
      return this.schema.enumTypes[r]?.find((n) => n.name === t) !== undefined;
    }
    resolveInputObjectType(t) {
      return this.inputTypesByName.get(In(t.type, t.namespace));
    }
    resolveOutputObjectType(t) {
      if (t.location === "outputObjectTypes")
        return this.outputObjectTypes[t.namespace ?? "prisma"].find((r) => r.name === t.type);
    }
    buildModelMap() {
      return Ie(this.datamodel.models, "name");
    }
    buildTypeMap() {
      return Ie(this.datamodel.types, "name");
    }
    buildTypeModelMap() {
      return { ...this.buildTypeMap(), ...this.buildModelMap() };
    }
    buildMappingsMap() {
      return Ie(this.mappings.modelOperations, "model");
    }
    buildMergedOutputTypeMap() {
      return { model: Ie(this.schema.outputObjectTypes.model, "name"), prisma: Ie(this.schema.outputObjectTypes.prisma, "name") };
    }
    buildRootFieldMap() {
      return { ...Ie(this.outputTypeMap.prisma.Query.fields, "name"), ...Ie(this.outputTypeMap.prisma.Mutation.fields, "name") };
    }
    buildInputTypesMap() {
      let t = new Map;
      for (let r of this.inputObjectTypes.prisma)
        t.set(In(r.name, "prisma"), r);
      if (!this.inputObjectTypes.model)
        return t;
      for (let r of this.inputObjectTypes.model)
        t.set(In(r.name, "model"), r);
      return t;
    }
  };
  var pe;
  ((t) => {
    let e;
    ((x) => (x.findUnique = "findUnique", x.findUniqueOrThrow = "findUniqueOrThrow", x.findFirst = "findFirst", x.findFirstOrThrow = "findFirstOrThrow", x.findMany = "findMany", x.create = "create", x.createMany = "createMany", x.update = "update", x.updateMany = "updateMany", x.upsert = "upsert", x.delete = "delete", x.deleteMany = "deleteMany", x.groupBy = "groupBy", x.count = "count", x.aggregate = "aggregate", x.findRaw = "findRaw", x.aggregateRaw = "aggregateRaw"))(e = t.ModelAction || (t.ModelAction = {}));
  })(pe || (pe = {}));
  var vr = S(Ln());
  var du = 100;
  var It = [];
  typeof process < "u" && typeof process.stderr?.write != "function" && (vr.default.log = console.debug ?? console.log);
  var $n = Object.assign(mu, vr.default);
  var D = $n;
  var qn;
  var wo;
  var Po;
  var vo;
  var To = true;
  typeof process < "u" && ({ FORCE_COLOR: qn, NODE_DISABLE_COLORS: wo, NO_COLOR: Po, TERM: vo } = process.env || {}, To = process.stdout && process.stdout.isTTY);
  var fu = { enabled: !wo && Po == null && vo !== "dumb" && (qn != null && qn !== "0" || To) };
  var Tm = _(0, 0);
  var ne = _(1, 22);
  var Fe = _(2, 22);
  var Cm = _(3, 23);
  var te = _(4, 24);
  var Am = _(7, 27);
  var Rm = _(8, 28);
  var Mm = _(9, 29);
  var Sm = _(30, 39);
  var me = _(31, 39);
  var Ge = _(32, 39);
  var he = _(33, 39);
  var ot = _(34, 39);
  var Im = _(35, 39);
  var Oe = _(36, 39);
  var km = _(37, 39);
  var Tr = _(90, 39);
  var Fm = _(90, 39);
  var Om = _(40, 49);
  var Dm = _(41, 49);
  var _m = _(42, 49);
  var Nm = _(43, 49);
  var Lm = _(44, 49);
  var $m = _(45, 49);
  var qm = _(46, 49);
  var Vm = _(47, 49);
  var Co = S(import.meta.require("fs"));
  var Cr = "libquery_engine";
  var $o = S(import.meta.require("child_process"));
  var Gn = S(import.meta.require("fs/promises"));
  var Sr = S(import.meta.require("os"));
  var Ar = Symbol("@ts-pattern/matcher");
  var Ao = "@ts-pattern/anonymous-select-key";
  var Ro = function(e) {
    return !!(e && typeof e == "object");
  };
  var Bn = function(e) {
    return e && !!e[Ar];
  };
  var gu = function e(t, r, n) {
    if (Ro(t)) {
      if (Bn(t)) {
        var i = t[Ar]().match(r), o = i.matched, s = i.selections;
        return o && s && Object.keys(s).forEach(function(l) {
          return n(l, s[l]);
        }), o;
      }
      if (!Ro(r))
        return false;
      if (Array.isArray(t))
        return !!Array.isArray(r) && t.length === r.length && t.every(function(l, u) {
          return e(l, r[u], n);
        });
      if (t instanceof Map)
        return r instanceof Map && Array.from(t.keys()).every(function(l) {
          return e(t.get(l), r.get(l), n);
        });
      if (t instanceof Set) {
        if (!(r instanceof Set))
          return false;
        if (t.size === 0)
          return r.size === 0;
        if (t.size === 1) {
          var a = Array.from(t.values())[0];
          return Bn(a) ? Array.from(r.values()).every(function(l) {
            return e(a, l, n);
          }) : r.has(a);
        }
        return Array.from(t.values()).every(function(l) {
          return r.has(l);
        });
      }
      return Object.keys(t).every(function(l) {
        var u, c = t[l];
        return ((l in r) || Bn(u = c) && u[Ar]().matcherType === "optional") && e(c, r[l], n);
      });
    }
    return Object.is(r, t);
  };
  var Gm = Je(function(e) {
    return true;
  });
  var Jm = Je(function(e) {
    return typeof e == "string";
  });
  var Hm = Je(function(e) {
    return typeof e == "number";
  });
  var Wm = Je(function(e) {
    return typeof e == "boolean";
  });
  var zm = Je(function(e) {
    return typeof e == "bigint";
  });
  var Ym = Je(function(e) {
    return typeof e == "symbol";
  });
  var Zm = Je(function(e) {
    return e == null;
  });
  var yu = function() {
    function e(r, n) {
      this.value = undefined, this.cases = undefined, this.value = r, this.cases = n;
    }
    var t = e.prototype;
    return t.with = function() {
      var r = [].slice.call(arguments), n = r[r.length - 1], i = [r[0]], o = [];
      return r.length === 3 && typeof r[1] == "function" ? (i.push(r[0]), o.push(r[1])) : r.length > 2 && i.push.apply(i, r.slice(1, r.length - 1)), new e(this.value, this.cases.concat([{ match: function(s) {
        var a = {}, l = !!(i.some(function(u) {
          return gu(u, s, function(c, p) {
            a[c] = p;
          });
        }) && o.every(function(u) {
          return u(s);
        }));
        return { matched: l, value: l && Object.keys(a).length ? Ao in a ? a[Ao] : a : s };
      }, handler: n }]));
    }, t.when = function(r, n) {
      return new e(this.value, this.cases.concat([{ match: function(i) {
        return { matched: !!r(i), value: i };
      }, handler: n }]));
    }, t.otherwise = function(r) {
      return new e(this.value, this.cases.concat([{ match: function(n) {
        return { matched: true, value: n };
      }, handler: r }])).run();
    }, t.exhaustive = function() {
      return this.run();
    }, t.run = function() {
      for (var r = this.value, n = undefined, i = 0;i < this.cases.length; i++) {
        var o = this.cases[i], s = o.match(this.value);
        if (s.matched) {
          r = s.value, n = o.handler;
          break;
        }
      }
      if (!n) {
        var a;
        try {
          a = JSON.stringify(this.value);
        } catch {
          a = this.value;
        }
        throw new Error("Pattern matching error: no pattern matches value " + a);
      }
      return n(r, this.value);
    }, e;
  }();
  var qo = import.meta.require("util");
  var _o = S(Do());
  var bu = { warn: he("prisma:warn") };
  var Eu = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var wu = (0, qo.promisify)($o.default.exec);
  var ie = D("prisma:get-platform");
  var Pu = ["1.0.x", "1.1.x", "3.0.x"];
  var Mr = {};
  var Hn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "openbsd", "netbsd", "arm"];
  var Yn = S(Go());
  var Or = S(import.meta.require("fs"));
  var ct = S(import.meta.require("path"));
  var zn = D("prisma:tryLoadEnv");
  var zo = "library";
  var Ju = S(Xn());
  var N = S(import.meta.require("path"));
  var Hu = S(Xn());
  var Df = D("prisma:engines");
  N.default.join(import.meta.dir, "../query-engine-darwin");
  N.default.join(import.meta.dir, "../query-engine-darwin-arm64");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-1.0.x");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-1.1.x");
  N.default.join(import.meta.dir, "../query-engine-debian-openssl-3.0.x");
  N.default.join(import.meta.dir, "../query-engine-linux-static-x64");
  N.default.join(import.meta.dir, "../query-engine-linux-static-arm64");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-1.0.x");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-1.1.x");
  N.default.join(import.meta.dir, "../query-engine-rhel-openssl-3.0.x");
  N.default.join(import.meta.dir, "../libquery_engine-darwin.dylib.node");
  N.default.join(import.meta.dir, "../libquery_engine-darwin-arm64.dylib.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-debian-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-musl.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  N.default.join(import.meta.dir, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  N.default.join(import.meta.dir, "../query_engine-windows.dll.node");
  var ei = S(import.meta.require("fs"));
  var ns = D("chmodPlusX");
  var Nt = S(import.meta.require("path"));
  var os = S(ii());
  var oi = class {
    constructor(t) {
      this.config = t;
    }
    toString() {
      let { config: t } = this, r = t.provider.fromEnvVar ? `env("${t.provider.fromEnvVar}")` : t.provider.value, n = JSON.parse(JSON.stringify({ provider: r, binaryTargets: Wu(t.binaryTargets) }));
      return `generator ${t.name} {
${(0, os.default)(zu(n), 2)}
}`;
    }
  };
  var $t = {};
  St($t, { error: () => ec, info: () => Xu, log: () => Zu, query: () => tc, should: () => ss, tags: () => Lt, warn: () => ai });
  var Lt = { error: me("prisma:error"), warn: he("prisma:warn"), info: Oe("prisma:info"), query: ot("prisma:query") };
  var ss = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var ci = (e, t) => e.reduce((r, n) => (r[t(n)] = n, r), {});
  var ps = new Set;
  var qt = (e, t, ...r) => {
    ps.has(e) || (ps.add(e), ai(t, ...r));
  };
  var U = class extends Error {
    constructor(r, { code: n, clientVersion: i, meta: o, batchRequestIdx: s }) {
      super(r);
      this.name = "PrismaClientKnownRequestError", this.code = n, this.clientVersion = i, this.meta = o, Object.defineProperty(this, "batchRequestIdx", { value: s, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  E(U, "PrismaClientKnownRequestError");
  var Re = class extends U {
    constructor(t, r) {
      super(t, { code: "P2025", clientVersion: r }), this.name = "NotFoundError";
    }
  };
  E(Re, "NotFoundError");
  var F = class e extends Error {
    constructor(r, n, i) {
      super(r);
      this.name = "PrismaClientInitializationError", this.clientVersion = n, this.errorCode = i, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  E(F, "PrismaClientInitializationError");
  var ue = class extends Error {
    constructor(r, n) {
      super(r);
      this.name = "PrismaClientRustPanicError", this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  E(ue, "PrismaClientRustPanicError");
  var K = class extends Error {
    constructor(r, { clientVersion: n, batchRequestIdx: i }) {
      super(r);
      this.name = "PrismaClientUnknownRequestError", this.clientVersion = n, Object.defineProperty(this, "batchRequestIdx", { value: i, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  E(K, "PrismaClientUnknownRequestError");
  var X = class extends Error {
    constructor(r, { clientVersion: n }) {
      super(r);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  E(X, "PrismaClientValidationError");
  var dt = class {
    constructor(t) {
      this._engine = t;
    }
    prometheus(t) {
      return this._engine.metrics({ format: "prometheus", ...t });
    }
    json(t) {
      return this._engine.metrics({ format: "json", ...t });
    }
  };
  var ic = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
  var Lr = Symbol();
  var mi = new WeakMap;
  var xe = class {
    constructor(t) {
      t === Lr ? mi.set(this, `Prisma.${this._getName()}`) : mi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return mi.get(this);
    }
  };
  var jt = class extends xe {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var Bt = class extends jt {
  };
  fi(Bt, "DbNull");
  var Ut = class extends jt {
  };
  fi(Ut, "JsonNull");
  var Kt = class extends jt {
  };
  fi(Kt, "AnyNull");
  var $r = { classes: { DbNull: Bt, JsonNull: Ut, AnyNull: Kt }, instances: { DbNull: new Bt(Lr), JsonNull: new Ut(Lr), AnyNull: new Kt(Lr) } };
  var lc = S(Ln(), 1);
  var oc = class {
    constructor() {
      eo(this, "registeredErrors", []);
    }
    consumeError(e) {
      return this.registeredErrors[e];
    }
    registerNewError(e) {
      let t = 0;
      for (;this.registeredErrors[t] !== undefined; )
        t++;
      return this.registeredErrors[t] = { error: e }, t;
    }
  };
  var fs = (e) => {
    let t = new oc, r = De(t, e.startTransaction.bind(e));
    return { errorRegistry: t, queryRaw: De(t, e.queryRaw.bind(e)), executeRaw: De(t, e.executeRaw.bind(e)), flavour: e.flavour, startTransaction: async (...n) => (await r(...n)).map((o) => sc(t, o)), close: De(t, e.close.bind(e)) };
  };
  var sc = (e, t) => ({ flavour: t.flavour, options: t.options, queryRaw: De(e, t.queryRaw.bind(t)), executeRaw: De(e, t.executeRaw.bind(t)), commit: De(e, t.commit.bind(t)), rollback: De(e, t.rollback.bind(t)), dispose: ac(e, t.dispose.bind(t)) });
  var kl = import.meta.require("async_hooks");
  var Fl = import.meta.require("events");
  var Ol = S(import.meta.require("fs"));
  var yr = S(import.meta.require("path"));
  var oe = class e {
    constructor(t, r) {
      if (t.length - 1 !== r.length)
        throw t.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t.length} strings to have ${t.length - 1} values`);
      let n = r.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
      this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = t[0];
      let i = 0, o = 0;
      for (;i < r.length; ) {
        let s = r[i++], a = t[i];
        if (s instanceof e) {
          this.strings[o] += s.strings[0];
          let l = 0;
          for (;l < s.values.length; )
            this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
          this.strings[o] += a;
        } else
          this.values[o++] = s, this.strings[o] = a;
      }
    }
    get text() {
      let t = 1, r = this.strings[0];
      for (;t < this.strings.length; )
        r += `\$${t}${this.strings[t++]}`;
      return r;
    }
    get sql() {
      let t = 1, r = this.strings[0];
      for (;t < this.strings.length; )
        r += `?${this.strings[t++]}`;
      return r;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var ys = gi("");
  var be = class {
    constructor() {
      this._map = new Map;
    }
    get(t) {
      return this._map.get(t)?.value;
    }
    set(t, r) {
      this._map.set(t, { value: r });
    }
    getOrCreate(t, r) {
      let n = this._map.get(t);
      if (n)
        return n.value;
      let i = r();
      return this.set(t, i), i;
    }
  };
  var bs = import.meta.require("util");
  var Vr = { enumerable: true, configurable: true, writable: true };
  var hs = Symbol.for("nodejs.util.inspect.custom");
  var mt = class {
    constructor(t = 0, r) {
      this.context = r;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t;
    }
    write(t) {
      return typeof t == "string" ? this.currentLine += t : t.write(this), this;
    }
    writeJoined(t, r) {
      let n = r.length - 1;
      for (let i = 0;i < r.length; i++)
        this.write(r[i]), i !== n && this.write(t);
      return this;
    }
    writeLine(t) {
      return this.write(t).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t?.(), this;
    }
    withIndent(t) {
      return this.indent(), t(this), this.unindent(), this;
    }
    afterNextNewline(t) {
      return this.afterNextNewLineCallback = t, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t) {
      return this.marginSymbol = t, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t.slice(1) : t;
    }
  };
  var gt = 9000000000000000;
  var $e = 1e9;
  var hi = "0123456789abcdef";
  var Kr = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var Qr = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var xi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -gt, maxE: gt, crypto: false };
  var vs;
  var Me;
  var w = true;
  var Jr = "[DecimalError] ";
  var Le = Jr + "Invalid argument: ";
  var Ts = Jr + "Precision limit exceeded";
  var Cs = Jr + "crypto unavailable";
  var As = "[object Decimal]";
  var ee = Math.floor;
  var j = Math.pow;
  var cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var pc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var dc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Rs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var ge = 1e7;
  var b = 7;
  var mc = 9007199254740991;
  var fc = Kr.length - 1;
  var bi = Qr.length - 1;
  var m = { toStringTag: As };
  m.absoluteValue = m.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), h(e);
  };
  m.ceil = function() {
    return h(new this.constructor(this), this.e + 1, 2);
  };
  m.clampedTo = m.clamp = function(e, t) {
    var r, n = this, i = n.constructor;
    if (e = new i(e), t = new i(t), !e.s || !t.s)
      return new i(NaN);
    if (e.gt(t))
      throw Error(Le + t);
    return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
  };
  m.comparedTo = m.cmp = function(e) {
    var t, r, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
    if (!s || !a)
      return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
    if (!s[0] || !a[0])
      return s[0] ? l : a[0] ? -u : 0;
    if (l !== u)
      return l;
    if (o.e !== e.e)
      return o.e > e.e ^ l < 0 ? 1 : -1;
    for (n = s.length, i = a.length, t = 0, r = n < i ? n : i;t < r; ++t)
      if (s[t] !== a[t])
        return s[t] > a[t] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
  };
  m.cosine = m.cos = function() {
    var e, t, r = this, n = r.constructor;
    return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = gc(n, Fs(n, r)), n.precision = e, n.rounding = t, h(Me == 2 || Me == 3 ? r.neg() : r, e, t, true)) : new n(1) : new n(NaN);
  };
  m.cubeRoot = m.cbrt = function() {
    var e, t, r, n, i, o, s, a, l, u, c = this, p = c.constructor;
    if (!c.isFinite() || c.isZero())
      return new p(c);
    for (w = false, o = c.s * j(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (r = W(c.d), e = c.e, (o = (e - r.length + 1) % 3) && (r += o == 1 || o == -2 ? "0" : "00"), o = j(r, 1 / 3), e = ee((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? r = "5e" + e : (r = o.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new p(r), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3;; )
      if (a = n, l = a.times(a).times(a), u = l.plus(c), n = O(u.plus(c).times(a), u.plus(l), s + 2, 1), W(a.d).slice(0, s) === (r = W(n.d)).slice(0, s))
        if (r = r.slice(s - 3, s + 1), r == "9999" || !i && r == "4999") {
          if (!i && (h(a, e + 1, 0), a.times(a).times(a).eq(c))) {
            n = a;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (h(n, e + 1, 1), t = !n.times(n).times(n).eq(c));
          break;
        }
    return w = true, h(n, e, p.rounding, t);
  };
  m.decimalPlaces = m.dp = function() {
    var e, t = this.d, r = NaN;
    if (t) {
      if (e = t.length - 1, r = (e - ee(this.e / b)) * b, e = t[e], e)
        for (;e % 10 == 0; e /= 10)
          r--;
      r < 0 && (r = 0);
    }
    return r;
  };
  m.dividedBy = m.div = function(e) {
    return O(this, new this.constructor(e));
  };
  m.dividedToIntegerBy = m.divToInt = function(e) {
    var t = this, r = t.constructor;
    return h(O(t, new r(e), 0, 1, 1), r.precision, r.rounding);
  };
  m.equals = m.eq = function(e) {
    return this.cmp(e) === 0;
  };
  m.floor = function() {
    return h(new this.constructor(this), this.e + 1, 3);
  };
  m.greaterThan = m.gt = function(e) {
    return this.cmp(e) > 0;
  };
  m.greaterThanOrEqualTo = m.gte = function(e) {
    var t = this.cmp(e);
    return t == 1 || t === 0;
  };
  m.hyperbolicCosine = m.cosh = function() {
    var e, t, r, n, i, o = this, s = o.constructor, a = new s(1);
    if (!o.isFinite())
      return new s(o.s ? 1 / 0 : NaN);
    if (o.isZero())
      return a;
    r = s.precision, n = s.rounding, s.precision = r + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Wr(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), o = yt(s, 1, o.times(t), new s(1), true);
    for (var l, u = e, c = new s(8);u--; )
      l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
    return h(o, s.precision = r, s.rounding = n, true);
  };
  m.hyperbolicSine = m.sinh = function() {
    var e, t, r, n, i = this, o = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o(i);
    if (t = o.precision, r = o.rounding, o.precision = t + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
      i = yt(o, 2, i, i, true);
    else {
      e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Wr(5, e)), i = yt(o, 2, i, i, true);
      for (var s, a = new o(5), l = new o(16), u = new o(20);e--; )
        s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
    }
    return o.precision = t, o.rounding = r, h(i, t, r, true);
  };
  m.hyperbolicTangent = m.tanh = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, O(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
  };
  m.inverseCosine = m.acos = function() {
    var e, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, o = r.rounding;
    return n !== -1 ? n === 0 ? t.isNeg() ? fe(r, i, o) : new r(0) : new r(NaN) : t.isZero() ? fe(r, i + 4, o).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = fe(r, i + 4, o).times(0.5), r.precision = i, r.rounding = o, e.minus(t));
  };
  m.inverseHyperbolicCosine = m.acosh = function() {
    var e, t, r = this, n = r.constructor;
    return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, w = false, r = r.times(r).minus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln()) : new n(r);
  };
  m.inverseHyperbolicSine = m.asinh = function() {
    var e, t, r = this, n = r.constructor;
    return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, w = false, r = r.times(r).plus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln());
  };
  m.inverseHyperbolicTangent = m.atanh = function() {
    var e, t, r, n, i = this, o = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, t = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? h(new o(i), e, t, true) : (o.precision = r = n - i.e, i = O(i.plus(1), new o(1).minus(i), r + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = t, i.times(0.5))) : new o(NaN);
  };
  m.inverseSine = m.asin = function() {
    var e, t, r, n, i = this, o = i.constructor;
    return i.isZero() ? new o(i) : (t = i.abs().cmp(1), r = o.precision, n = o.rounding, t !== -1 ? t === 0 ? (e = fe(o, r + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = r + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = r, o.rounding = n, i.times(2)));
  };
  m.inverseTangent = m.atan = function() {
    var e, t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c(u);
      if (u.abs().eq(1) && p + 4 <= bi)
        return s = fe(c, p + 4, d).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c(NaN);
      if (p + 4 <= bi)
        return s = fe(c, p + 4, d).times(0.5), s.s = u.s, s;
    }
    for (c.precision = a = p + 10, c.rounding = 1, r = Math.min(28, a / b + 2 | 0), e = r;e; --e)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (w = false, t = Math.ceil(a / b), n = 1, l = u.times(u), s = new c(u), i = u;e !== -1; )
      if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[t] !== undefined)
        for (e = t;s.d[e] === o.d[e] && e--; )
          ;
    return r && (s = s.times(2 << r - 1)), w = true, h(s, c.precision = p, c.rounding = d, true);
  };
  m.isFinite = function() {
    return !!this.d;
  };
  m.isInteger = m.isInt = function() {
    return !!this.d && ee(this.e / b) > this.d.length - 2;
  };
  m.isNaN = function() {
    return !this.s;
  };
  m.isNegative = m.isNeg = function() {
    return this.s < 0;
  };
  m.isPositive = m.isPos = function() {
    return this.s > 0;
  };
  m.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m.lessThan = m.lt = function(e) {
    return this.cmp(e) < 0;
  };
  m.lessThanOrEqualTo = m.lte = function(e) {
    return this.cmp(e) < 1;
  };
  m.logarithm = m.log = function(e) {
    var t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
    if (e == null)
      e = new c(10), t = true;
    else {
      if (e = new c(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
        return new c(NaN);
      t = e.eq(10);
    }
    if (r = u.d, u.s < 0 || !r || !r[0] || u.eq(1))
      return new c(r && !r[0] ? -1 / 0 : u.s != 1 ? NaN : r ? 0 : 1 / 0);
    if (t)
      if (r.length > 1)
        o = true;
      else {
        for (i = r[0];i % 10 === 0; )
          i /= 10;
        o = i !== 1;
      }
    if (w = false, a = p + f, s = Ne(u, a), n = t ? Gr(c, a + 10) : Ne(e, a), l = O(s, n, a, 1), Jt(l.d, i = p, d))
      do
        if (a += 10, s = Ne(u, a), n = t ? Gr(c, a + 10) : Ne(e, a), l = O(s, n, a, 1), !o) {
          +W(l.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l = h(l, p + 1, 0));
          break;
        }
      while (Jt(l.d, i += 10, d));
    return w = true, h(l, p, d);
  };
  m.minus = m.sub = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.constructor;
    if (e = new y(e), !f.d || !e.d)
      return !f.s || !e.s ? e = new y(NaN) : f.d ? e.s = -e.s : e = new y(e.d || f.s !== e.s ? f : NaN), e;
    if (f.s != e.s)
      return e.s = -e.s, f.plus(e);
    if (u = f.d, d = e.d, a = y.precision, l = y.rounding, !u[0] || !d[0]) {
      if (d[0])
        e.s = -e.s;
      else if (u[0])
        e = new y(f);
      else
        return new y(l === 3 ? -0 : 0);
      return w ? h(e, a, l) : e;
    }
    if (r = ee(e.e / b), c = ee(f.e / b), u = u.slice(), o = c - r, o) {
      for (p = o < 0, p ? (t = u, o = -o, s = d.length) : (t = d, r = c, s = u.length), n = Math.max(Math.ceil(a / b), s) + 2, o > n && (o = n, t.length = 1), t.reverse(), n = o;n--; )
        t.push(0);
      t.reverse();
    } else {
      for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0;n < s; n++)
        if (u[n] != d[n]) {
          p = u[n] < d[n];
          break;
        }
      o = 0;
    }
    for (p && (t = u, u = d, d = t, e.s = -e.s), s = u.length, n = d.length - s;n > 0; --n)
      u[s++] = 0;
    for (n = d.length;n > o; ) {
      if (u[--n] < d[n]) {
        for (i = n;i && u[--i] === 0; )
          u[i] = ge - 1;
        --u[i], u[n] += ge;
      }
      u[n] -= d[n];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --r;
    return u[0] ? (e.d = u, e.e = Hr(u, r), w ? h(e, a, l) : e) : new y(l === 3 ? -0 : 0);
  };
  m.modulo = m.mod = function(e) {
    var t, r = this, n = r.constructor;
    return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? h(new n(r), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (t = O(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = O(r, e, 0, n.modulo, 1), t = t.times(e), w = true, r.minus(t));
  };
  m.naturalExponential = m.exp = function() {
    return Ei(this);
  };
  m.naturalLogarithm = m.ln = function() {
    return Ne(this);
  };
  m.negated = m.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, h(e);
  };
  m.plus = m.add = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
    if (e = new d(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0])
      return c[0] || (e = new d(p)), w ? h(e, a, l) : e;
    if (o = ee(p.e / b), n = ee(e.e / b), u = u.slice(), i = o - n, i) {
      for (i < 0 ? (r = u, i = -i, s = c.length) : (r = c, n = o, s = u.length), o = Math.ceil(a / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, r.length = 1), r.reverse();i--; )
        r.push(0);
      r.reverse();
    }
    for (s = u.length, i = c.length, s - i < 0 && (i = s, r = c, c = u, u = r), t = 0;i; )
      t = (u[--i] = u[i] + c[i] + t) / ge | 0, u[i] %= ge;
    for (t && (u.unshift(t), ++n), s = u.length;u[--s] == 0; )
      u.pop();
    return e.d = u, e.e = Hr(u, n), w ? h(e, a, l) : e;
  };
  m.precision = m.sd = function(e) {
    var t, r = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(Le + e);
    return r.d ? (t = Ms(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
  };
  m.round = function() {
    var e = this, t = e.constructor;
    return h(new t(e), e.e + 1, t.rounding);
  };
  m.sine = m.sin = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = hc(n, Fs(n, r)), n.precision = e, n.rounding = t, h(Me > 2 ? r.neg() : r, e, t, true)) : new n(NaN);
  };
  m.squareRoot = m.sqrt = function() {
    var e, t, r, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
    if (u !== 1 || !a || !a[0])
      return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
    for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (t = W(a), (t.length + l) % 2 == 0 && (t += "0"), u = Math.sqrt(t), l = ee((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? t = "5e" + l : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new c(t)) : n = new c(u.toString()), r = (l = c.precision) + 3;; )
      if (o = n, n = o.plus(O(s, o, r + 2, 1)).times(0.5), W(o.d).slice(0, r) === (t = W(n.d)).slice(0, r))
        if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
          if (!i && (h(o, l + 1, 0), o.times(o).eq(s))) {
            n = o;
            break;
          }
          r += 4, i = 1;
        } else {
          (!+t || !+t.slice(1) && t.charAt(0) == "5") && (h(n, l + 1, 1), e = !n.times(n).eq(s));
          break;
        }
    return w = true, h(n, l, c.rounding, e);
  };
  m.tangent = m.tan = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = O(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, h(Me == 2 || Me == 4 ? r.neg() : r, e, t, true)) : new n(NaN);
  };
  m.times = m.mul = function(e) {
    var t, r, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
    if (e.s *= c.s, !d || !d[0] || !f || !f[0])
      return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
    for (r = ee(c.e / b) + ee(e.e / b), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s;n--; )
      o.push(0);
    for (n = u;--n >= 0; ) {
      for (t = 0, i = l + n;i > n; )
        a = o[i] + f[n] * d[i - n - 1] + t, o[i--] = a % ge | 0, t = a / ge | 0;
      o[i] = (o[i] + t) % ge | 0;
    }
    for (;!o[--s]; )
      o.pop();
    return t ? ++r : o.shift(), e.d = o, e.e = Hr(o, r), w ? h(e, p.precision, p.rounding) : e;
  };
  m.toBinary = function(e, t) {
    return Pi(this, 2, e, t);
  };
  m.toDecimalPlaces = m.toDP = function(e, t) {
    var r = this, n = r.constructor;
    return r = new n(r), e === undefined ? r : (se(e, 0, $e), t === undefined ? t = n.rounding : se(t, 0, 8), h(r, e + r.e + 1, t));
  };
  m.toExponential = function(e, t) {
    var r, n = this, i = n.constructor;
    return e === undefined ? r = we(n, true) : (se(e, 0, $e), t === undefined ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e + 1, t), r = we(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
  };
  m.toFixed = function(e, t) {
    var r, n, i = this, o = i.constructor;
    return e === undefined ? r = we(i) : (se(e, 0, $e), t === undefined ? t = o.rounding : se(t, 0, 8), n = h(new o(i), e + i.e + 1, t), r = we(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
  };
  m.toFraction = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.d, g = f.constructor;
    if (!y)
      return new g(f);
    if (u = r = new g(1), n = l = new g(0), t = new g(n), o = t.e = Ms(y) - f.e - 1, s = o % b, t.d[0] = j(10, s < 0 ? b + s : s), e == null)
      e = o > 0 ? t : u;
    else {
      if (a = new g(e), !a.isInt() || a.lt(u))
        throw Error(Le + a);
      e = a.gt(t) ? o > 0 ? t : u : a;
    }
    for (w = false, a = new g(W(y)), c = g.precision, g.precision = o = y.length * b * 2;p = O(a, t, 0, 1, 1), i = r.plus(p.times(n)), i.cmp(e) != 1; )
      r = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = t, t = a.minus(p.times(i)), a = i;
    return i = O(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(u)), r = r.plus(i.times(n)), l.s = u.s = f.s, d = O(u, n, o, 1).minus(f).abs().cmp(O(l, r, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, r], g.precision = c, w = true, d;
  };
  m.toHexadecimal = m.toHex = function(e, t) {
    return Pi(this, 16, e, t);
  };
  m.toNearest = function(e, t) {
    var r = this, n = r.constructor;
    if (r = new n(r), e == null) {
      if (!r.d)
        return r;
      e = new n(1), t = n.rounding;
    } else {
      if (e = new n(e), t === undefined ? t = n.rounding : se(t, 0, 8), !r.d)
        return e.s ? r : e;
      if (!e.d)
        return e.s && (e.s = r.s), e;
    }
    return e.d[0] ? (w = false, r = O(r, e, 0, t, 1).times(e), w = true, h(r)) : (e.s = r.s, r = e), r;
  };
  m.toNumber = function() {
    return +this;
  };
  m.toOctal = function(e, t) {
    return Pi(this, 8, e, t);
  };
  m.toPower = m.pow = function(e) {
    var t, r, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
    if (!a.d || !e.d || !a.d[0] || !e.d[0])
      return new l(j(+a, u));
    if (a = new l(a), a.eq(1))
      return a;
    if (n = l.precision, o = l.rounding, e.eq(1))
      return h(a, n, o);
    if (t = ee(e.e / b), t >= e.d.length - 1 && (r = u < 0 ? -u : u) <= mc)
      return i = Ss(l, a, r, n), e.s < 0 ? new l(1).div(i) : h(i, n, o);
    if (s = a.s, s < 0) {
      if (t < e.d.length - 1)
        return new l(NaN);
      if (e.d[t] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
        return a.s = s, a;
    }
    return r = j(+a, u), t = r == 0 || !isFinite(r) ? ee(u * (Math.log("0." + W(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = Ei(e.times(Ne(a, n + r)), n), i.d && (i = h(i, n + 5, 1), Jt(i.d, n, o) && (t = n + 10, i = h(Ei(e.times(Ne(a, t + r)), t), t + 5, 1), +W(i.d).slice(n + 1, n + 15) + 1 == 100000000000000 && (i = h(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, h(i, n, o));
  };
  m.toPrecision = function(e, t) {
    var r, n = this, i = n.constructor;
    return e === undefined ? r = we(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (se(e, 1, $e), t === undefined ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e, t), r = we(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
  };
  m.toSignificantDigits = m.toSD = function(e, t) {
    var r = this, n = r.constructor;
    return e === undefined ? (e = n.precision, t = n.rounding) : (se(e, 1, $e), t === undefined ? t = n.rounding : se(t, 0, 8)), h(new n(r), e, t);
  };
  m.toString = function() {
    var e = this, t = e.constructor, r = we(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + r : r;
  };
  m.truncated = m.trunc = function() {
    return h(new this.constructor(this), this.e + 1, 1);
  };
  m.valueOf = m.toJSON = function() {
    var e = this, t = e.constructor, r = we(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
    return e.isNeg() ? "-" + r : r;
  };
  var O = function() {
    function e(n, i, o) {
      var s, a = 0, l = n.length;
      for (n = n.slice();l--; )
        s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
      return a && n.unshift(a), n;
    }
    function t(n, i, o, s) {
      var a, l;
      if (o != s)
        l = o > s ? 1 : -1;
      else
        for (a = l = 0;a < o; a++)
          if (n[a] != i[a]) {
            l = n[a] > i[a] ? 1 : -1;
            break;
          }
      return l;
    }
    function r(n, i, o, s) {
      for (var a = 0;o--; )
        n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
      for (;!n[0] && n.length > 1; )
        n.shift();
    }
    return function(n, i, o, s, a, l) {
      var u, c, p, d, f, y, g, P, T, C, x, R, ce, J, Ke, $, z, Ae, Y, tt, hr = n.constructor, An = n.s == i.s ? 1 : -1, Z = n.d, k = i.d;
      if (!Z || !Z[0] || !k || !k[0])
        return new hr(!n.s || !i.s || (Z ? k && Z[0] == k[0] : !k) ? NaN : Z && Z[0] == 0 || !k ? An * 0 : An / 0);
      for (l ? (f = 1, c = n.e - i.e) : (l = ge, f = b, c = ee(n.e / f) - ee(i.e / f)), Y = k.length, z = Z.length, T = new hr(An), C = T.d = [], p = 0;k[p] == (Z[p] || 0); p++)
        ;
      if (k[p] > (Z[p] || 0) && c--, o == null ? (J = o = hr.precision, s = hr.rounding) : a ? J = o + (n.e - i.e) + 1 : J = o, J < 0)
        C.push(1), y = true;
      else {
        if (J = J / f + 2 | 0, p = 0, Y == 1) {
          for (d = 0, k = k[0], J++;(p < z || d) && J--; p++)
            Ke = d * l + (Z[p] || 0), C[p] = Ke / k | 0, d = Ke % k | 0;
          y = d || p < z;
        } else {
          for (d = l / (k[0] + 1) | 0, d > 1 && (k = e(k, d, l), Z = e(Z, d, l), Y = k.length, z = Z.length), $ = Y, x = Z.slice(0, Y), R = x.length;R < Y; )
            x[R++] = 0;
          tt = k.slice(), tt.unshift(0), Ae = k[0], k[1] >= l / 2 && ++Ae;
          do
            d = 0, u = t(k, x, Y, R), u < 0 ? (ce = x[0], Y != R && (ce = ce * l + (x[1] || 0)), d = ce / Ae | 0, d > 1 ? (d >= l && (d = l - 1), g = e(k, d, l), P = g.length, R = x.length, u = t(g, x, P, R), u == 1 && (d--, r(g, Y < P ? tt : k, P, l))) : (d == 0 && (u = d = 1), g = k.slice()), P = g.length, P < R && g.unshift(0), r(x, g, R, l), u == -1 && (R = x.length, u = t(k, x, Y, R), u < 1 && (d++, r(x, Y < R ? tt : k, R, l))), R = x.length) : u === 0 && (d++, x = [0]), C[p++] = d, u && x[0] ? x[R++] = Z[$] || 0 : (x = [Z[$]], R = 1);
          while (($++ < z || x[0] !== undefined) && J--);
          y = x[0] !== undefined;
        }
        C[0] || C.shift();
      }
      if (f == 1)
        T.e = c, vs = y;
      else {
        for (p = 1, d = C[0];d >= 10; d /= 10)
          p++;
        T.e = p + c * f - 1, h(T, a ? o + T.e + 1 : o, s, y);
      }
      return T;
    };
  }();
  m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
  m[Symbol.toStringTag] = "Decimal";
  var ze = m.constructor = Os(xi);
  Kr = new ze(Kr);
  Qr = new ze(Qr);
  var Pe = ze;
  var Ht = class {
    constructor(t, r, n, i, o) {
      this.modelName = t, this.name = r, this.typeName = n, this.isList = i, this.isEnum = o;
    }
    _toGraphQLInputType() {
      let t = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
      return `${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var zr = class {
    constructor(t) {
      this.value = t;
    }
    write(t) {
      t.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var Yr = (e) => e;
  var Zr = { bold: Yr, red: Yr, green: Yr, dim: Yr, enabled: false };
  var Ds = { bold: ne, red: me, green: Ge, dim: Fe, enabled: true };
  var bt = { write(e) {
    e.writeLine(",");
  } };
  var ve = class {
    constructor(t) {
      this.contents = t;
      this.isUnderlined = false;
      this.color = (t2) => t2;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t) {
      return this.color = t, this;
    }
    write(t) {
      let r = t.getCurrentLineLength();
      t.write(this.color(this.contents)), this.isUnderlined && t.afterNextNewline(() => {
        t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var qe = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Et = class extends qe {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r) {
      return this.items.push(new zr(r)), this;
    }
    getField(r) {
      return this.items[r];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
    }
    write(r) {
      if (this.items.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithItems(r);
    }
    writeEmpty(r) {
      let n = new ve("[]");
      this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
    }
    writeWithItems(r) {
      let { colors: n } = r.context;
      r.writeLine("[").withIndent(() => r.writeJoined(bt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(n.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var _s = ": ";
  var Xr = class {
    constructor(t, r) {
      this.name = t;
      this.value = r;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + _s.length;
    }
    write(t) {
      let r = new ve(this.name);
      this.hasError && r.underline().setColor(t.context.colors.red), t.write(r).write(_s).write(this.value);
    }
  };
  var Q = class e extends qe {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r) {
      this.fields[r.name] = r;
    }
    addSuggestion(r) {
      this.suggestions.push(r);
    }
    getField(r) {
      return this.fields[r];
    }
    getDeepField(r) {
      let [n, ...i] = r, o = this.getField(n);
      if (!o)
        return;
      let s = o;
      for (let a of i) {
        let l;
        if (s.value instanceof e ? l = s.value.getField(a) : s.value instanceof Et && (l = s.value.getField(Number(a))), !l)
          return;
        s = l;
      }
      return s;
    }
    getDeepFieldValue(r) {
      return r.length === 0 ? this : this.getDeepField(r)?.value;
    }
    hasField(r) {
      return !!this.getField(r);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r) {
      delete this.fields[r];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r) {
      return this.getField(r)?.value;
    }
    getDeepSubSelectionValue(r) {
      let n = this;
      for (let i of r) {
        if (!(n instanceof e))
          return;
        let o = n.getSubSelectionValue(i);
        if (!o)
          return;
        n = o;
      }
      return n;
    }
    getDeepSelectionParent(r) {
      let n = this.getSelectionParent();
      if (!n)
        return;
      let i = n;
      for (let o of r) {
        let s = i.value.getFieldValue(o);
        if (!s || !(s instanceof e))
          return;
        let a = s.getSelectionParent();
        if (!a)
          return;
        i = a;
      }
      return i;
    }
    getSelectionParent() {
      let r = this.getField("select");
      if (r?.value instanceof e)
        return { kind: "select", value: r.value };
      let n = this.getField("include");
      if (n?.value instanceof e)
        return { kind: "include", value: n.value };
    }
    getSubSelectionValue(r) {
      return this.getSelectionParent()?.value.fields[r].value;
    }
    getPrintWidth() {
      let r = Object.values(this.fields);
      return r.length == 0 ? 2 : Math.max(...r.map((i) => i.getPrintWidth())) + 2;
    }
    write(r) {
      let n = Object.values(this.fields);
      if (n.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithContents(r, n);
    }
    writeEmpty(r) {
      let n = new ve("{}");
      this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
    }
    writeWithContents(r, n) {
      r.writeLine("{").withIndent(() => {
        r.writeJoined(bt, [...n, ...this.suggestions]).newLine();
      }), r.write("}"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var G = class extends qe {
    constructor(r) {
      super();
      this.text = r;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r) {
      let n = new ve(this.text);
      this.hasError && n.underline().setColor(r.context.colors.red), r.write(n);
    }
  };
  var vi = class {
    constructor(t) {
      this.errorMessages = [];
      this.arguments = t;
    }
    write(t) {
      t.write(this.arguments);
    }
    addErrorMessage(t) {
      this.errorMessages.push(t);
    }
    renderAllMessages(t) {
      return this.errorMessages.map((r) => r(t)).join(`
`);
    }
  };
  var Wt = "<unknown>";
  var op = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var sp = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var lp = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var cp = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var pp = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var mp = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var gp = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Ti = class {
    getLocation() {
      return null;
    }
  };
  var Ci = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t = this._error.stack;
      if (!t)
        return null;
      let n = qs(t).find((i) => {
        if (!i.file)
          return false;
        let o = ni(i.file);
        return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
    }
  };
  var Vs = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var Gs = (e) => Array.isArray(e) ? e : e.split(".");
  var Ai = (e, t) => Gs(t).reduce((r, n) => r && r[n], e);
  var Js = (e, t, r) => Gs(t).reduceRight((n, i, o, s) => Object.assign({}, Ai(e, s.slice(0, o)), { [i]: n }), r);
  var Xs = S(ii());
  var Zs = S(import.meta.require("fs"));
  var Hs = { keyword: Oe, entity: Oe, value: (e) => ne(ot(e)), punctuation: ot, directive: Oe, function: Oe, variable: (e) => ne(ot(e)), string: (e) => ne(Ge(e)), boolean: he, number: Oe, comment: Tr };
  var Ap = (e) => e;
  var rn = {};
  var Rp = 0;
  var v = { manual: rn.Prism && rn.Prism.manual, disableWorkerMessageHandler: rn.Prism && rn.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ye) {
      let t = e;
      return new ye(t.type, v.util.encode(t.content), t.alias);
    } else
      return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++Rp }), e.__id;
  }, clone: function e(t, r) {
    let n, i, o = v.util.type(t);
    switch (r = r || {}, o) {
      case "Object":
        if (i = v.util.objId(t), r[i])
          return r[i];
        n = {}, r[i] = n;
        for (let s in t)
          t.hasOwnProperty(s) && (n[s] = e(t[s], r));
        return n;
      case "Array":
        return i = v.util.objId(t), r[i] ? r[i] : (n = [], r[i] = n, t.forEach(function(s, a) {
          n[a] = e(s, r);
        }), n);
      default:
        return t;
    }
  } }, languages: { extend: function(e, t) {
    let r = v.util.clone(v.languages[e]);
    for (let n in t)
      r[n] = t[n];
    return r;
  }, insertBefore: function(e, t, r, n) {
    n = n || v.languages;
    let i = n[e], o = {};
    for (let a in i)
      if (i.hasOwnProperty(a)) {
        if (a == t)
          for (let l in r)
            r.hasOwnProperty(l) && (o[l] = r[l]);
        r.hasOwnProperty(a) || (o[a] = i[a]);
      }
    let s = n[e];
    return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
      l === s && a != e && (this[a] = o);
    }), o;
  }, DFS: function e(t, r, n, i) {
    i = i || {};
    let o = v.util.objId;
    for (let s in t)
      if (t.hasOwnProperty(s)) {
        r.call(t, s, t[s], n || s);
        let a = t[s], l = v.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, r, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, r, s, i));
      }
  } }, plugins: {}, highlight: function(e, t, r) {
    let n = { code: e, grammar: t, language: r };
    return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ye.stringify(v.util.encode(n.tokens), n.language);
  }, matchGrammar: function(e, t, r, n, i, o, s) {
    for (let g in r) {
      if (!r.hasOwnProperty(g) || !r[g])
        continue;
      if (g == s)
        return;
      let P = r[g];
      P = v.util.type(P) === "Array" ? P : [P];
      for (let T = 0;T < P.length; ++T) {
        let C = P[T], x = C.inside, R = !!C.lookbehind, ce = !!C.greedy, J = 0, Ke = C.alias;
        if (ce && !C.pattern.global) {
          let $ = C.pattern.toString().match(/[imuy]*$/)[0];
          C.pattern = RegExp(C.pattern.source, $ + "g");
        }
        C = C.pattern || C;
        for (let $ = n, z = i;$ < t.length; z += t[$].length, ++$) {
          let Ae = t[$];
          if (t.length > e.length)
            return;
          if (Ae instanceof ye)
            continue;
          if (ce && $ != t.length - 1) {
            C.lastIndex = z;
            var p = C.exec(e);
            if (!p)
              break;
            var c = p.index + (R ? p[1].length : 0), d = p.index + p[0].length, a = $, l = z;
            for (let k = t.length;a < k && (l < d || !t[a].type && !t[a - 1].greedy); ++a)
              l += t[a].length, c >= l && (++$, z = l);
            if (t[$] instanceof ye)
              continue;
            u = a - $, Ae = e.slice(z, l), p.index -= z;
          } else {
            C.lastIndex = 0;
            var p = C.exec(Ae), u = 1;
          }
          if (!p) {
            if (o)
              break;
            continue;
          }
          R && (J = p[1] ? p[1].length : 0);
          var c = p.index + J, p = p[0].slice(J), d = c + p.length, f = Ae.slice(0, c), y = Ae.slice(d);
          let Y = [$, u];
          f && (++$, z += f.length, Y.push(f));
          let tt = new ye(g, x ? v.tokenize(p, x) : p, Ke, p, ce);
          if (Y.push(tt), y && Y.push(y), Array.prototype.splice.apply(t, Y), u != 1 && v.matchGrammar(e, t, r, $, z, true, g), o)
            break;
        }
      }
    }
  }, tokenize: function(e, t) {
    let r = [e], n = t.rest;
    if (n) {
      for (let i in n)
        t[i] = n[i];
      delete t.rest;
    }
    return v.matchGrammar(e, r, t, 0, 0, false), r;
  }, hooks: { all: {}, add: function(e, t) {
    let r = v.hooks.all;
    r[e] = r[e] || [], r[e].push(t);
  }, run: function(e, t) {
    let r = v.hooks.all[e];
    if (!(!r || !r.length))
      for (var n = 0, i;i = r[n++]; )
        i(t);
  } }, Token: ye };
  v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
  v.languages.js = v.languages.javascript;
  v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  v.languages.ts = v.languages.typescript;
  ye.stringify = function(e, t) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r) {
      return ye.stringify(r, t);
    }).join("") : Mp(e.type)(e.content);
  };
  var zs = S(es());
  var nn = class e {
    static read(t) {
      let r;
      try {
        r = Zs.default.readFileSync(t, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(r);
    }
    static fromContent(t) {
      let r = t.split(/\r?\n/);
      return new e(1, r);
    }
    constructor(t, r) {
      this.firstLineNumber = t, this.lines = r;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t, r) {
      if (t < this.firstLineNumber || t > this.lines.length + this.firstLineNumber)
        return this;
      let n = t - this.firstLineNumber, i = [...this.lines];
      return i[n] = r(i[n]), new e(this.firstLineNumber, i);
    }
    mapLines(t) {
      return new e(this.firstLineNumber, this.lines.map((r, n) => t(r, this.firstLineNumber + n)));
    }
    lineAt(t) {
      return this.lines[t - this.firstLineNumber];
    }
    prependSymbolAt(t, r) {
      return this.mapLines((n, i) => i === t ? `${r} ${n}` : `  ${n}`);
    }
    slice(t, r) {
      let n = this.lines.slice(t - 1, r).join(`
`);
      return new e(t, Ys(n).split(`
`));
    }
    highlight() {
      let t = Ws(this.toString());
      return new e(this.firstLineNumber, t.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Ip = { red: me, gray: Tr, dim: Fe, bold: ne, underline: te, highlightSource: (e) => e.highlight() };
  var kp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  var $p = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var qp = ["aggregate", "count", "groupBy"];
  var Si = Symbol();
  var aa = (e) => e;
  var an = class {
    constructor(t, r) {
      this.extension = t;
      this.previous = r;
      this.computedFieldsCache = new be;
      this.modelExtensionsCache = new be;
      this.queryCallbacksCache = new be;
      this.clientExtensions = Vt(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = Vt(() => {
        let t2 = this.previous?.getAllBatchQueryCallbacks() ?? [], r2 = this.extension.query?.$__internalBatch;
        return r2 ? t2.concat(r2) : t2;
      });
    }
    getAllComputedFields(t) {
      return this.computedFieldsCache.getOrCreate(t, () => fa(this.previous?.getAllComputedFields(t), this.extension, t));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t) {
      return this.modelExtensionsCache.getOrCreate(t, () => {
        let r = Te(t);
        return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t) : { ...this.previous?.getAllModelExtensions(t), ...this.extension.model.$allModels, ...this.extension.model[r] };
      });
    }
    getAllQueryCallbacks(t, r) {
      return this.queryCallbacksCache.getOrCreate(`${t}:${r}`, () => {
        let n = this.previous?.getAllQueryCallbacks(t, r) ?? [], i = [], o = this.extension.query;
        return !o || !(o[t] || o.$allModels || o[r] || o.$allOperations) ? n : (o[t] !== undefined && (o[t][r] !== undefined && i.push(o[t][r]), o[t].$allOperations !== undefined && i.push(o[t].$allOperations)), t !== "$none" && o.$allModels !== undefined && (o.$allModels[r] !== undefined && i.push(o.$allModels[r]), o.$allModels.$allOperations !== undefined && i.push(o.$allModels.$allOperations)), o[r] !== undefined && i.push(o[r]), o.$allOperations !== undefined && i.push(o.$allOperations), n.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var ln = class e {
    constructor(t) {
      this.head = t;
    }
    static empty() {
      return new e;
    }
    static single(t) {
      return new e(new an(t));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t) {
      return new e(new an(t, this.head));
    }
    getAllComputedFields(t) {
      return this.head?.getAllComputedFields(t);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t) {
      return this.head?.getAllModelExtensions(t);
    }
    getAllQueryCallbacks(t, r) {
      return this.head?.getAllQueryCallbacks(t, r) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ya = D("prisma:client");
  var ha = { Vercel: "vercel", "Netlify CI": "netlify" };
  var vt = class {
  };
  var Ta = S(import.meta.require("fs"));
  var Xt = S(import.meta.require("path"));
  var zp = D("prisma:client:engines:resolveEnginePath");
  var Yp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Ii = S(li());
  var Sa = S(cs());
  var mn = class extends Error {
    constructor(r, n) {
      super(r);
      this.clientVersion = n.clientVersion, this.cause = n.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends mn {
    constructor(r, n) {
      super(r, n);
      this.isRetryable = n.isRetryable ?? true;
    }
  };
  var Tt = class extends ae {
    constructor(r) {
      super("This request must be retried", M(r, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  E(Tt, "ForcedRetryError");
  var Ye = class extends ae {
    constructor(r, n) {
      super(r, M(n, false));
      this.name = "InvalidDatasourceError";
      this.code = "P5002";
    }
  };
  E(Ye, "InvalidDatasourceError");
  var Ze = class extends ae {
    constructor(r, n) {
      super(r, M(n, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  E(Ze, "NotImplementedYetError");
  var L = class extends ae {
    constructor(r, n) {
      super(r, n);
      this.response = n.response;
      let i = this.response.headers.get("prisma-request-id");
      if (i) {
        let o = `(The request id was: ${i})`;
        this.message = this.message + " " + o;
      }
    }
  };
  var Xe = class extends L {
    constructor(r) {
      super("Schema needs to be uploaded", M(r, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  E(Xe, "SchemaMissingError");
  var ki = "This request could not be understood by the server";
  var er = class extends L {
    constructor(r, n, i) {
      super(n || ki, M(r, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  E(er, "BadRequestError");
  var tr = class extends L {
    constructor(r, n) {
      super("Engine not started: healthcheck timeout", M(r, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n;
    }
  };
  E(tr, "HealthcheckTimeoutError");
  var rr = class extends L {
    constructor(r, n, i) {
      super(n, M(r, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  E(rr, "EngineStartupError");
  var nr = class extends L {
    constructor(r) {
      super("Engine version is not supported", M(r, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  E(nr, "EngineVersionNotSupportedError");
  var Fi = "Request timed out";
  var ir = class extends L {
    constructor(r, n = Fi) {
      super(n, M(r, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  E(ir, "GatewayTimeoutError");
  var Xp = "Interactive transaction error";
  var or = class extends L {
    constructor(r, n = Xp) {
      super(n, M(r, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  E(or, "InteractiveTransactionError");
  var ed = "Request parameters are invalid";
  var sr = class extends L {
    constructor(r, n = ed) {
      super(n, M(r, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  E(sr, "InvalidRequestError");
  var Oi = "Requested resource does not exist";
  var ar = class extends L {
    constructor(r, n = Oi) {
      super(n, M(r, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  E(ar, "NotFoundError");
  var Di = "Unknown server error";
  var Ct = class extends L {
    constructor(r, n, i) {
      super(n || Di, M(r, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  E(Ct, "ServerError");
  var _i = "Unauthorized, check your connection string";
  var lr = class extends L {
    constructor(r, n = _i) {
      super(n, M(r, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  E(lr, "UnauthorizedError");
  var Ni = "Usage exceeded, retry again later";
  var ur = class extends L {
    constructor(r, n = Ni) {
      super(n, M(r, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  E(ur, "UsageExceededError");
  var Da = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.4.1-2.ac9d7041ed77bcc8a8dbd2ab6616b39013829574", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.75", "@swc/jest": "0.2.29", "@types/jest": "29.5.5", "@types/node": "18.18.0", execa: "5.1.1", jest: "29.7.0", typescript: "5.2.2" };
  var pr = class extends ae {
    constructor(r, n) {
      super(`Cannot fetch data from service:
${r}`, M(n, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  E(pr, "RequestError");
  var sd = typeof require < "u" ? require : () => {
  };
  var $i = class {
    constructor(t = {}) {
      this.headers = new Map;
      for (let [r, n] of Object.entries(t))
        if (typeof n == "string")
          this.headers.set(r, n);
        else if (Array.isArray(n))
          for (let i of n)
            this.headers.set(r, i);
    }
    append(t, r) {
      this.headers.set(t, r);
    }
    delete(t) {
      this.headers.delete(t);
    }
    get(t) {
      return this.headers.get(t) ?? null;
    }
    has(t) {
      return this.headers.has(t);
    }
    set(t, r) {
      this.headers.set(t, r);
    }
    forEach(t, r) {
      for (let [n, i] of this.headers)
        t.call(r, i, n, this);
    }
  };
  var ad = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var _a = D("prisma:client:dataproxyEngine");
  var La = 3;
  var qi = D("prisma:client:dataproxyEngine");
  var Vi = class {
    constructor({ apiKey: t, tracingHelper: r, logLevel: n, logQueries: i }) {
      this.apiKey = t, this.tracingHelper = r, this.logLevel = n, this.logQueries = i;
    }
    build({ traceparent: t, interactiveTransaction: r } = {}) {
      let n = { Authorization: `Bearer ${this.apiKey}` };
      this.tracingHelper.isEnabled() && (n.traceparent = t ?? this.tracingHelper.getTraceParent()), r && (n["X-transaction-id"] = r.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
    }
    buildCaptureSettings() {
      let t = [];
      return this.tracingHelper.isEnabled() && t.push("tracing"), this.logLevel && t.push(this.logLevel), this.logQueries && t.push("query"), t;
    }
  };
  var dr = class extends vt {
    constructor(r) {
      super();
      Oa(r), this.config = r, this.env = { ...this.config.env, ...process.env }, this.inlineSchema = r.inlineSchema ?? "", this.inlineDatasources = r.inlineDatasources ?? {}, this.inlineSchemaHash = r.inlineSchemaHash ?? "", this.clientVersion = r.clientVersion ?? "unknown", this.logEmitter = r.logEmitter, this.tracingHelper = this.config.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return "unknown";
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [r, n] = this.extractHostAndApiKey();
        this.host = r, this.headerBuilder = new Vi({ apiKey: n, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries }), this.remoteClientVersion = await Na(r, this.config), qi("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(r) {
      r?.logs?.length && r.logs.forEach((n) => {
        switch (n.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let i = typeof n.attributes.query == "string" ? n.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [o] = i.split("/* traceparent");
              i = o;
            }
            this.logEmitter.emit("query", { query: i, timestamp: n.timestamp, duration: n.attributes.duration_ms, params: n.attributes.params, target: n.attributes.target });
          }
        }
      }), r?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
    }
    on(r, n) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      this.logEmitter.on(r, n);
    }
    async url(r) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
    }
    async uploadSchema() {
      let r = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r, async () => {
        let n = await et(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        n.ok || qi("schema response status", n.status);
        let i = await cr(n, this.clientVersion);
        if (i)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${i.message}` }), i;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
      });
    }
    request(r, { traceparent: n, interactiveTransaction: i, customDataProxyFetch: o }) {
      return this.requestInternal({ body: r, traceparent: n, interactiveTransaction: i, customDataProxyFetch: o });
    }
    async requestBatch(r, { traceparent: n, transaction: i, customDataProxyFetch: o }) {
      let s = i?.kind === "itx" ? i.options : undefined, a = pn(r, i), { batchResult: l, elapsed: u } = await this.requestInternal({ body: a, customDataProxyFetch: o, interactiveTransaction: s, traceparent: n });
      return l.map((c) => ("errors" in c) && c.errors.length > 0 ? Zt(c.errors[0], this.clientVersion) : { data: c, elapsed: u });
    }
    requestInternal({ body: r, traceparent: n, customDataProxyFetch: i, interactiveTransaction: o }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s }) => {
        let a = o ? `${o.payload.endpoint}/graphql` : await this.url("graphql");
        s(a);
        let l = await et(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n, interactiveTransaction: o }), body: JSON.stringify(r), clientVersion: this.clientVersion }, i);
        l.ok || qi("graphql response status", l.status), await this.handleError(await cr(l, this.clientVersion));
        let u = await l.json(), c = u.extensions;
        if (c && this.propagateResponseExtensions(c), u.errors)
          throw u.errors.length === 1 ? Zt(u.errors[0], this.config.clientVersion) : new K(u.errors, { clientVersion: this.config.clientVersion });
        return u;
      } });
    }
    async transaction(r, n, i) {
      let o = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${o[r]} transaction`, callback: async ({ logHttpCall: s }) => {
        if (r === "start") {
          let a = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel }), l = await this.url("transaction/start");
          s(l);
          let u = await et(l, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), body: a, clientVersion: this.clientVersion });
          await this.handleError(await cr(u, this.clientVersion));
          let c = await u.json(), p = c.extensions;
          p && this.propagateResponseExtensions(p);
          let d = c.id, f = c["data-proxy"].endpoint;
          return { id: d, payload: { endpoint: f } };
        } else {
          let a = `${i.payload.endpoint}/${r}`;
          s(a);
          let l = await et(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await cr(l, this.clientVersion));
          let c = (await l.json()).extensions;
          c && this.propagateResponseExtensions(c);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let r = { clientVersion: this.clientVersion }, n = Object.keys(this.inlineDatasources)[0], i = dn({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), o;
      try {
        o = new URL(i);
      } catch {
        throw new Ye(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: s, host: a, searchParams: l } = o;
      if (s !== "prisma:")
        throw new Ye(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
      let u = l.get("api_key");
      if (u === null || u.length < 1)
        throw new Ye(`Error validating datasource \`${n}\`: the URL must contain a valid API key`, r);
      return [a, u];
    }
    metrics() {
      throw new Ze("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r) {
      for (let n = 0;; n++) {
        let i = (o) => {
          this.logEmitter.emit("info", { message: `Calling ${o} (n=${n})` });
        };
        try {
          return await r.callback({ logHttpCall: i });
        } catch (o) {
          if (!(o instanceof ae) || !o.isRetryable)
            throw o;
          if (n >= La)
            throw o instanceof Tt ? o.cause : o;
          this.logEmitter.emit("warn", { message: `Attempt ${n + 1}/${La} failed for ${r.actionGerund}: ${o.message ?? "(unknown)"}` });
          let s = await Fa(n);
          this.logEmitter.emit("warn", { message: `Retrying after ${s}ms` });
        }
      }
    }
    async handleError(r) {
      if (r instanceof Xe)
        throw await this.uploadSchema(), new Tt({ clientVersion: this.clientVersion, cause: r });
      if (r)
        throw r;
    }
  };
  var Ba = S(import.meta.require("fs"));
  var Bi = S(import.meta.require("os"));
  var qa = S(import.meta.require("path"));
  var ji = Symbol("PrismaLibraryEngineCache");
  var fn = class {
    constructor(t) {
      this.config = t;
    }
    async loadLibrary() {
      let t = await Jn(), r = await Ca("library", this.config);
      try {
        return this.config.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => pd(r));
      } catch (n) {
        let i = ri({ e: n, platformInfo: t, id: r });
        throw new F(i, this.config.clientVersion);
      }
    }
  };
  var dd = "P2036";
  var Ce = D("prisma:client:libraryEngine");
  var Va = [...Hn, "native"];
  var ja = 0;
  var mr = class extends vt {
    constructor(r, n = new fn(r)) {
      super();
      try {
        this.datamodel = Ba.default.readFileSync(r.datamodelPath, "utf-8");
      } catch (s) {
        throw s.stack.match(/\/\.next|\/next@|\/next\//) ? new F(`Your schema.prisma could not be found, and we detected that you are using Next.js.
Find out why and learn how to fix this: https://pris.ly/d/schema-not-found-nextjs`, r.clientVersion) : r.isBundled === true ? new F("Prisma Client could not find its `schema.prisma`. This is likely caused by a bundling step, which leads to `schema.prisma` not being copied near the resulting bundle. We would appreciate if you could take the time to share some information with us.\nPlease help us by answering a few questions: https://pris.ly/bundler-investigation-error", r.clientVersion) : s;
      }
      this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.libraryLoader = n, this.logEmitter = r.logEmitter, r.enableDebugLogs && (this.logLevel = "debug");
      let i = Object.keys(r.overrideDatasources)[0], o = r.overrideDatasources[i]?.url;
      i !== undefined && o !== undefined && (this.datasourceOverrides = { [i]: o }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      ja === 10 && console.warn(`${he("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(r, n, i) {
      await this.start();
      let o = JSON.stringify(n), s;
      if (r === "start") {
        let l = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel });
        s = await this.engine?.startTransaction(l, o);
      } else
        r === "commit" ? s = await this.engine?.commitTransaction(i.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(i.id, o));
      let a = this.parseEngineResponse(s);
      if (a.error_code)
        throw new U(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
      return a;
    }
    async instantiateLibrary() {
      if (Ce("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Vn(), this.platform = await this.getPlatform(), await this.loadEngine(), this.version();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      let r = await ut();
      if (!Va.includes(r))
        throw new F(`Unknown ${me("PRISMA_QUERY_ENGINE_LIBRARY")} ${me(ne(r))}. Possible binaryTargets: ${Ge(Va.join(", "))} or a path to the query engine library.
You may have to run ${Ge("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      return r;
    }
    parseEngineResponse(r) {
      if (!r)
        throw new K("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r);
      } catch {
        throw new K("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r = new WeakRef(this), { adapter: n } = this.config;
          n && Ce("Using driver adapter: %O", n), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (i) => {
            r.deref()?.logger(i);
          }, n), ja++;
        } catch (r) {
          let n = r, i = this.parseInitError(n.message);
          throw typeof i == "string" ? n : new F(i.message, this.config.clientVersion, i.error_code);
        }
      }
    }
    logger(r) {
      let n = this.parseEngineResponse(r);
      if (n) {
        if ("span" in n) {
          this.config.tracingHelper.createEngineSpan(n);
          return;
        }
        n.level = n?.level.toLowerCase() ?? "unknown", md(n) ? this.logEmitter.emit("query", { timestamp: new Date, query: n.query, params: n.params, duration: Number(n.duration_ms), target: n.module_path }) : fd(n) ? this.loggerRustPanic = new ue(this.getErrorMessageWithLink(`${n.message}: ${n.reason} in ${n.file}:${n.line}:${n.column}`), this.config.clientVersion) : this.logEmitter.emit(n.level, { timestamp: new Date, message: n.message, target: n.module_path });
      }
    }
    getErrorMessageWithLink(r) {
      return ka({ platform: this.platform, title: r, version: this.config.clientVersion, engineVersion: this.versionInfo?.commit, database: this.config.activeProvider, query: this.lastQuery });
    }
    parseInitError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    parseRequestError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    on(r, n) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      this.logEmitter.on(r, n);
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ce(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r = async () => {
        Ce("library starting");
        try {
          let n = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(n)), this.libraryStarted = true, Ce("library started");
        } catch (n) {
          let i = this.parseInitError(n.message);
          throw typeof i == "string" ? n : new F(i.message, this.config.clientVersion, i.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ce("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let r = async () => {
        await new Promise((i) => setTimeout(i, 5)), Ce("library stopping");
        let n = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(n)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Ce("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r) {
      return this.library?.debugPanic(r);
    }
    async request(r, { traceparent: n, interactiveTransaction: i }) {
      Ce(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let o = JSON.stringify({ traceparent: n }), s = JSON.stringify(r);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(s, o, i?.id), this.lastQuery = s;
        let a = this.parseEngineResponse(await this.executingQueryPromise);
        if (a.errors)
          throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: a, elapsed: 0 };
      } catch (a) {
        if (a instanceof F)
          throw a;
        if (a.code === "GenericFailure" && a.message?.startsWith("PANIC:"))
          throw new ue(this.getErrorMessageWithLink(a.message), this.config.clientVersion);
        let l = this.parseRequestError(a.message);
        throw typeof l == "string" ? a : new K(`${l.message}
${l.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r, { transaction: n, traceparent: i }) {
      Ce("requestBatch");
      let o = pn(r, n);
      await this.start(), this.lastQuery = JSON.stringify(o), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: i }), $a(n));
      let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
      if (a.errors)
        throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: l, errors: u } = a;
      if (Array.isArray(l))
        return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0]) : { data: c, elapsed: 0 });
      throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
    }
    buildQueryError(r) {
      if (r.user_facing_error.is_panic)
        return new ue(this.getErrorMessageWithLink(r.user_facing_error.message), this.config.clientVersion);
      if (r.user_facing_error.error_code === dd && this.config.adapter) {
        let n = r.user_facing_error.meta?.id;
        _r(typeof n == "number", "Malformed external JS error received from the engine");
        let i = this.config.adapter.errorRegistry.consumeError(n);
        return _r(i, "External error with reported id was not registered"), i.error;
      }
      return Zt(r, this.config.clientVersion);
    }
    async metrics(r) {
      await this.start();
      let n = await this.engine.metrics(JSON.stringify(r));
      return r.format === "prometheus" ? n : this.parseEngineResponse(n);
    }
  };
  var Wa = S(Ui());
  var Se = class {
    constructor(t, r) {
      this.name = t;
      this.value = r;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t) {
      let { colors: { green: r } } = t.context;
      t.addMarginSymbol(r(this.isRequired ? "+" : "?")), t.write(r(this.name)), this.isRequired || t.write(r("?")), t.write(r(": ")), typeof this.value == "string" ? t.write(r(this.value)) : t.write(this.value);
    }
  };
  var hn = class {
    constructor() {
      this.fields = [];
    }
    addField(t, r) {
      return this.fields.push({ write(n) {
        let { green: i, dim: o } = n.context.colors;
        n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")));
      } }), this;
    }
    write(t) {
      let { colors: { green: r } } = t.context;
      t.writeLine(r("{")).withIndent(() => {
        t.writeJoined(bt, this.fields).newLine();
      }).write(r("}")).addMarginSymbol(r("+"));
    }
  };
  var kd = 3;
  var Od = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var Ki = class e {
    constructor(t) {
      this.params = t;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(t) {
      En({ errors: [t], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((t) => ({ name: t.name, typeName: "boolean", isRelation: t.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t) {
      return this.model?.fields.find((r) => r.name === t);
    }
    nestSelection(t) {
      let r = this.findField(t), n = r?.kind === "object" ? r.type : undefined;
      return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(t) });
    }
    nestArgument(t) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t) });
    }
  };
  var nl = (e) => ({ command: e });
  var il = (e) => e.strings.reduce((t, r, n) => `${t}@P${n}${r}`);
  var Ud = /^(\s*alter\s)/i;
  var ll = D("prisma:client");
  var Ji = ({ clientMethod: e, activeProvider: t, activeProviderFlavour: r }) => (n) => {
    r !== undefined && (t = r);
    let i = "", o;
    if (Array.isArray(n)) {
      let [s, ...a] = n;
      i = s, o = { values: gr(a || []), __prismaRawParameters__: true };
    } else
      switch (t) {
        case "sqlite":
        case "mysql": {
          i = n.sql, o = { values: gr(n.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          i = n.text, o = { values: gr(n.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          i = il(n), o = { values: gr(n.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t} provider does not support ${e}`);
      }
    return o?.values ? ll(`prisma.${e}(${i}, ${o.values})`) : ll(`prisma.${e}(${i})`), { query: i, parameters: o };
  };
  var ul = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [t, ...r] = e;
    return new oe(t, r);
  } };
  var cl = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  var dl = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e, t) {
    return t();
  } };
  var Wi = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t) {
      return this.getGlobalTracingHelper().getTraceParent(t);
    }
    createEngineSpan(t) {
      return this.getGlobalTracingHelper().createEngineSpan(t);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t, r) {
      return this.getGlobalTracingHelper().runInChildSpan(t, r);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? dl;
    }
  };
  var Kd = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var zi = Kd;
  var wn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t) {
      this._middlewares.push(t);
    }
    get(t) {
      return this._middlewares[t];
    }
    has(t) {
      return !!this._middlewares[t];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var hl = S(li());
  var Jd = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var Tn = class {
    constructor(t) {
      this.options = t;
      this.tickActive = false;
      this.batches = {};
    }
    request(t) {
      let r = this.options.batchBy(t);
      return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n, i) => {
        this.batches[r].push({ request: t, resolve: n, reject: i });
      })) : this.options.singleLoader(t);
    }
    dispatchBatches() {
      for (let t in this.batches) {
        let r = this.batches[t];
        delete this.batches[t], r.length === 1 ? this.options.singleLoader(r[0].request).then((n) => {
          n instanceof Error ? r[0].reject(n) : r[0].resolve(n);
        }).catch((n) => {
          r[0].reject(n);
        }) : (r.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(r.map((n) => n.request)).then((n) => {
          if (n instanceof Error)
            for (let i = 0;i < r.length; i++)
              r[i].reject(n);
          else
            for (let i = 0;i < r.length; i++) {
              let o = n[i];
              o instanceof Error ? r[i].reject(o) : r[i].resolve(o);
            }
        }).catch((n) => {
          for (let i = 0;i < r.length; i++)
            r[i].reject(n);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var Hd = D("prisma:client:request_handler");
  var Cn = class {
    constructor(t, r) {
      this.logEmitter = r, this.client = t, this.dataloader = new Tn({ batchLoader: ca(async ({ requests: n, customDataProxyFetch: i }) => {
        let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Zi(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: Wd(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n[d], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n) => {
        let i = n.transaction?.kind === "itx" ? xl(n.transaction) : undefined, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Zi(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
        return this.mapQueryEngineResult(n, o);
      }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : yl(n.protocolQuery), batchOrder(n, i) {
        return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(t) {
      try {
        return await this.dataloader.request(t);
      } catch (r) {
        let { clientMethod: n, callsite: i, transaction: o, args: s } = t;
        this.handleAndLogRequestError({ error: r, clientMethod: n, callsite: i, transaction: o, args: s });
      }
    }
    mapQueryEngineResult({ dataPath: t, unpacker: r }, n) {
      let i = n?.data, o = n?.elapsed, s = this.unpack(i, t, r);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: o } : s;
    }
    handleAndLogRequestError(t) {
      try {
        this.handleRequestError(t);
      } catch (r) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t.clientMethod, timestamp: new Date }), r;
      }
    }
    handleRequestError({ error: t, clientMethod: r, callsite: n, transaction: i, args: o }) {
      if (Hd(t), zd(t, i) || t instanceof Re)
        throw t;
      if (t instanceof U && Yd(t)) {
        let a = bl(t.meta);
        En({ args: o, errors: [a], callsite: n, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion });
      }
      let s = t.message;
      throw n && (s = Pt({ callsite: n, originalMethod: r, isPanic: t.isPanic, showColors: this.client._errorFormat === "pretty", message: s })), s = this.sanitizeMessage(s), t.code ? new U(s, { code: t.code, clientVersion: this.client._clientVersion, meta: t.meta, batchRequestIdx: t.batchRequestIdx }) : t.isPanic ? new ue(s, this.client._clientVersion) : t instanceof K ? new K(s, { clientVersion: this.client._clientVersion, batchRequestIdx: t.batchRequestIdx }) : t instanceof F ? new F(s, this.client._clientVersion) : t instanceof ue ? new ue(s, this.client._clientVersion) : (t.clientVersion = this.client._clientVersion, t);
    }
    sanitizeMessage(t) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, hl.default)(t) : t;
    }
    unpack(t, r, n) {
      if (!t || (t.data && (t = t.data), !t))
        return t;
      let i = Object.values(t)[0], o = r.filter((a) => a !== "select" && a !== "include"), s = vn(Ai(i, o));
      return n ? n(s) : s;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var El = "5.4.2";
  var wl = El;
  var Rl = S(Ui());
  var q = class extends Error {
    constructor(t) {
      super(t + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  E(q, "PrismaClientConstructorValidationError");
  var Tl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "__internal"];
  var Cl = ["pretty", "colorless", "minimal"];
  var Al = ["info", "query", "warn", "error"];
  var Xd = { datasources: (e, { datasourceNames: t }) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new q(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [r, n] of Object.entries(e)) {
        if (!t.includes(r)) {
          let i = Rt(r, t) || ` Available datasources: ${t.join(", ")}`;
          throw new q(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n != "object" || Array.isArray(n))
          throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n && typeof n == "object")
          for (let [i, o] of Object.entries(n)) {
            if (i !== "url")
              throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string")
              throw new q(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e, t) => {
    if (e === null)
      return;
    if (e === undefined)
      throw new q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!gn(t).includes("driverAdapters"))
      throw new q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new q(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new q(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!Cl.includes(e)) {
        let t = Rt(e, Cl);
        throw new q(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new q(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function t(r) {
      if (typeof r == "string" && !Al.includes(r)) {
        let n = Rt(r, Al);
        throw new q(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
      }
    }
    for (let r of e) {
      t(r);
      let n = { level: t, emit: (i) => {
        let o = ["stdout", "event"];
        if (!o.includes(i)) {
          let s = Rt(i, o);
          throw new q(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (r && typeof r == "object")
        for (let [i, o] of Object.entries(r))
          if (n[i])
            n[i](o);
          else
            throw new q(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, __internal: (e) => {
    if (!e)
      return;
    let t = ["debug", "hooks", "engine", "measurePerformance"];
    if (typeof e != "object")
      throw new q(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [r] of Object.entries(e))
      if (!t.includes(r)) {
        let n = Rt(r, t);
        throw new q(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
  } };
  var Ue = D("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var tm = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var rm = Symbol.for("prisma.client.transaction.id");
  var nm = { id: 0, nextId() {
    return ++this.id;
  } };
  var om = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// /Users/richardguerre/Projects/flow/node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join3,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.4.2",
    engine: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join3;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.DayScalarFieldEnum = {
    date: "date",
    tasksOrder: "tasksOrder"
  };
  exports.Prisma.NoteScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    date: "date",
    slug: "slug",
    title: "title",
    content: "content"
  };
  exports.Prisma.NoteTagScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    color: "color",
    isPrivate: "isPrivate"
  };
  exports.Prisma.TaskScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    title: "title",
    status: "status",
    completedAt: "completedAt",
    date: "date",
    durationInMinutes: "durationInMinutes",
    itemId: "itemId",
    parentTaskId: "parentTaskId"
  };
  exports.Prisma.TaskTagScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    color: "color",
    isPrivate: "isPrivate"
  };
  exports.Prisma.TaskPluginDataScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    min: "min",
    full: "full",
    pluginSlug: "pluginSlug",
    originalId: "originalId",
    taskId: "taskId"
  };
  exports.Prisma.ItemPluginDataScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    min: "min",
    full: "full",
    pluginSlug: "pluginSlug",
    originalId: "originalId",
    itemId: "itemId"
  };
  exports.Prisma.ItemScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    title: "title",
    isRelevant: "isRelevant",
    scheduledAt: "scheduledAt",
    durationInMinutes: "durationInMinutes",
    isAllDay: "isAllDay",
    color: "color",
    inboxPoints: "inboxPoints",
    listId: "listId"
  };
  exports.Prisma.ListScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    slug: "slug",
    description: "description"
  };
  exports.Prisma.StoreScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    key: "key",
    value: "value",
    pluginSlug: "pluginSlug",
    isSecret: "isSecret",
    isServerOnly: "isServerOnly"
  };
  exports.Prisma.RoutineScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    name: "name",
    actionName: "actionName",
    time: "time",
    repeats: "repeats",
    firstDay: "firstDay",
    lastDay: "lastDay",
    isActive: "isActive",
    steps: "steps"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.JsonNullValueInput = {
    JsonNull: Prisma.JsonNull
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.JsonNullValueFilter = {
    DbNull: Prisma.DbNull,
    JsonNull: Prisma.JsonNull,
    AnyNull: Prisma.AnyNull
  };
  exports.Color = exports.$Enums.Color = {
    slate: "slate",
    gray: "gray",
    zinc: "zinc",
    neutral: "neutral",
    stone: "stone",
    red: "red",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    green: "green",
    emerald: "emerald",
    teal: "teal",
    cyan: "cyan",
    sky: "sky",
    blue: "blue",
    indigo: "indigo",
    violet: "violet",
    purple: "purple",
    fuchsia: "fuchsia",
    pink: "pink",
    rose: "rose"
  };
  exports.TaskStatus = exports.$Enums.TaskStatus = {
    TODO: "TODO",
    DONE: "DONE",
    CANCELED: "CANCELED"
  };
  exports.RepetitionPattern = exports.$Enums.RepetitionPattern = {
    MONDAY: "MONDAY",
    TUESDAY: "TUESDAY",
    WEDNESDAY: "WEDNESDAY",
    THURSDAY: "THURSDAY",
    FRIDAY: "FRIDAY",
    SATURDAY: "SATURDAY",
    SUNDAY: "SUNDAY"
  };
  exports.Prisma.ModelName = {
    Day: "Day",
    Note: "Note",
    NoteTag: "NoteTag",
    Task: "Task",
    TaskTag: "TaskTag",
    TaskPluginData: "TaskPluginData",
    ItemPluginData: "ItemPluginData",
    Item: "Item",
    List: "List",
    Store: "Store",
    Routine: "Routine"
  };
  var config = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/Users/richardguerre/Projects/flow/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "darwin-arm64",
          native: true
        },
        {
          fromEnvVar: null,
          value: "rhel-openssl-3.0.x"
        },
        {
          fromEnvVar: null,
          value: "darwin-arm64"
        },
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x"
        }
      ],
      previewFeatures: []
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../apps/server/.env"
    },
    relativePath: "../../../apps/server/prisma",
    clientVersion: "5.4.2",
    engineVersion: "ac9d7041ed77bcc8a8dbd2ab6616b39013829574",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    postinstall: false,
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "ZGF0YXNvdXJjZSBkYiB7CiAgcHJvdmlkZXIgPSAicG9zdGdyZXNxbCIKICB1cmwgICAgICA9IGVudigiREFUQUJBU0VfVVJMIikKfQoKZ2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgICAgICA9ICJwcmlzbWEtY2xpZW50LWpzIgogIC8vIG5hdGl2ZSBmb3IgZGV2ZWxvcG1lbnQKICAvLyByaGVsLW9wZW5zc2wtMy4wLnggZm9yIHByb2R1Y3Rpb24KICAvLyBkYXJ3aW4tYXJtNjQgZm9yIE0xIE1hY3MKICAvLyBkZWJpYW4tb3BlbnNzbC0zLjAueCBmb3IgR2l0SHViIEFjdGlvbnMgb24gdWJ1bnR1LWxhdGVzdAogIGJpbmFyeVRhcmdldHMgPSBbIm5hdGl2ZSIsICJyaGVsLW9wZW5zc2wtMy4wLngiLCAiZGFyd2luLWFybTY0IiwgImRlYmlhbi1vcGVuc3NsLTMuMC54Il0KfQoKZ2VuZXJhdG9yIHBvdGhvcyB7CiAgcHJvdmlkZXIgICAgPSAicHJpc21hLXBvdGhvcy10eXBlcyIKICBwcmlzbWFVdGlscyA9IHRydWUKfQoKLy8vIEEgZGF5IGEgdXNlciBoYXMgcGxhbm5lZCBvciBhbHJlYWR5IGRvbmUuCi8vLyBEYXlzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gcGxhbm5lZCBhcmUgdmlydHVhbGx5IGNyZWF0ZWQgaW4gdGhlIEdyYXBoUUwgQVBJLgptb2RlbCBEYXkgewogIC8vLyBUaGUgZGF0ZSBvZiB0aGUgZGF5LCB3aGljaCBhY3RzIGFzIHRoZSBJRAogIGRhdGUgICAgICAgRGF0ZVRpbWUgQGlkIEBkYi5EYXRlCiAgLy8vIFRoZSBvcmRlciBvZiB0aGUgdGFza3MgaW4gdGhlIGRheQogIHRhc2tzT3JkZXIgSW50W10KCiAgLy8vIFRoZSB0YXNrcyBsaW5rZWQgdG8gdGhlIGRheS4KICB0YXNrcyAgICAgICAgICAgICBUYXNrW10KICAvLy8gVGhlIG5vdGVzIGxpbmtlZCB0byB0aGUgZGF5LgogIG5vdGVzICAgICAgICAgICAgIE5vdGVbXQogIC8vLyBUaGUgcm91dGluZXMgY29tcGxldGVkIG9uIHRoZSBkYXkuCiAgcm91dGluZXNDb21wbGV0ZWQgUm91dGluZVtdCn0KCi8vLyBBIG5vdGUgdGhhdCB0aGUgdXNlciBoYXMgY3JlYXRlZC4KbW9kZWwgTm90ZSB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgbm90ZQogIGlkICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgbm90ZQogIGNyZWF0ZWRBdCBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIG5vdGUgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIHRoZSBub3RlIHdhcyBjcmVhdGVkCiAgZGF0ZSAgICAgIERhdGVUaW1lIEBkYi5EYXRlCiAgLy8vIFRoZSBkYXkgdGhlIG5vdGUgd2FzIGNyZWF0ZWQKICBkYXkgICAgICAgRGF5ICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2RhdGVdLCByZWZlcmVuY2VzOiBbZGF0ZV0pCiAgLy8vIFRoZSBzbHVnIG9mIHRoZSBub3RlIHdoaWNoIG5lZWRzIHRvIGJlIHVuaXF1ZS4KICAvLy8gSXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIG5vdGUgYW5kIHVwZGF0ZSBpdC4KICBzbHVnICAgICAgU3RyaW5nICAgQHVuaXF1ZQogIC8vLyBUaGUgdGl0bGUgb2YgdGhlIG5vdGUKICB0aXRsZSAgICAgU3RyaW5nCiAgLy8vIFRoZSBjb250ZW50IG9mIHRoZSBub3RlIGluIEhUTUwuIElmIGl0J3MgdGV4dCAoaS5lLiBvbmUgbGluZSksCiAgLy8vIGl0IHdpbGwgbW9zdCBsaWtlbHkgYmUgY29udmVydGVkIHRvIEhUTUwgYnkgdGhlIFRpcFRhcCBlZGl0b3IuCiAgY29udGVudCAgIFN0cmluZwoKICAvLy8gVGhlIHRhZ3Mgb2YgdGhlIG5vdGUKICB0YWdzIE5vdGVUYWdbXQp9CgovLy8gQSB0YWcgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIG5vdGUuCm1vZGVsIE5vdGVUYWcgewogIC8vLyBUaGUgaWQgb2YgdGhlIG5vdGUgdGFnCiAgaWQgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSBub3RlIHRhZwogIGNyZWF0ZWRBdCBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIG5vdGUgdGFnIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgRGF0ZVRpbWUgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbmFtZSBvZiB0aGUgbm90ZSB0YWcKICBuYW1lICAgICAgU3RyaW5nCiAgLy8vIFRoZSBzbHVnIChpLmUuIHRoZSB1cmwtc2FmZSB2ZXJzaW9uKSBvZiB0aGUgbm90ZSB0YWcgbmFtZQogIHNsdWcgICAgICBTdHJpbmcgICBAdW5pcXVlCiAgLy8vIFRoZSBjb2xvciBvZiB0aGUgbm90ZSB0YWcgaW4gaGV4CiAgY29sb3IgICAgIENvbG9yCiAgLy8vIFdoZXRoZXIgbm90ZXMgd2l0aCB0aGlzIHRhZyBzaG91bGQgYmUgcHJpdmF0ZS4gKGRlZmF1bHQ6IHRydWUpCiAgaXNQcml2YXRlIEJvb2xlYW4gIEBkZWZhdWx0KHRydWUpCgogIC8vLyBUaGUgbm90ZXMgd2l0aCB0aGlzIHRhZwogIG5vdGVzIE5vdGVbXQp9CgovLy8gQSB0YXNrIHRoYXQgdGhlIHVzZXIgb3IgYSBwbHVnaW4gaGFzIGNyZWF0ZWQuCm1vZGVsIFRhc2sgewogIC8vLyBUaGUgaWQgb2YgdGhlIHRhc2suCiAgaWQgICAgICAgICAgICAgICAgSW50ICAgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgdGFzawogIGNyZWF0ZWRBdCAgICAgICAgIERhdGVUaW1lICAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSB0YXNrIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICAgICAgICBEYXRlVGltZSAgIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIHRpdGxlIG9mIHRoZSB0YXNrIGluIHRleHQgb3IgSFRNTC4KICB0aXRsZSAgICAgICAgICAgICBTdHJpbmcKICAvLy8gVGhlIHN0YXR1cyBvZiB0aGUgdGFzawogIHN0YXR1cyAgICAgICAgICAgIFRhc2tTdGF0dXMgQGRlZmF1bHQoVE9ETykKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIHRhc2sgd2FzIGNvbXBsZXRlZC4KICBjb21wbGV0ZWRBdCAgICAgICBEYXRlVGltZT8gIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXkgdGhlIHRhc2sgaXMgc2NoZWR1bGVkIGZvcgogIGRheSAgICAgICAgICAgICAgIERheSAgICAgICAgQHJlbGF0aW9uKGZpZWxkczogW2RhdGVdLCByZWZlcmVuY2VzOiBbZGF0ZV0pCiAgLy8vIFRoZSBkYXRlIHRoZSB0YXNrIGlzIHNjaGVkdWxlZCBmb3IKICBkYXRlICAgICAgICAgICAgICBEYXRlVGltZSAgIEBkYi5EYXRlCiAgLy8vIFRoZSBsZW5ndGggb2YgdGltZSB0aGUgdGFzayBpcyBleHBlY3RlZCB0byB0YWtlLgogIGR1cmF0aW9uSW5NaW51dGVzIEludD8KCiAgLy8vIFRoZSBpdGVtIGxpbmtlZCB0byB0aGUgdGFzawogIGl0ZW0gICBJdGVtPyBAcmVsYXRpb24oZmllbGRzOiBbaXRlbUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICBpdGVtSWQgSW50PwoKICAvLy8gVGhlIHBhcmVudCB0YXNrIG9mIHRoZSB0YXNrCiAgcGFyZW50VGFzayAgIFRhc2s/IEByZWxhdGlvbigiU3VidGFzayIsIGZpZWxkczogW3BhcmVudFRhc2tJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgcGFyZW50VGFza0lkIEludD8KCiAgLy8vIFRoZSBzdWJ0YXNrcyBvZiB0aGUgdGFzawogIHN1YnRhc2tzICAgIFRhc2tbXSAgICAgICAgICAgQHJlbGF0aW9uKCJTdWJ0YXNrIikKICAvLy8gVGhlIHRhZ3Mgb2YgdGhlIHRhc2sgCiAgdGFncyAgICAgICAgVGFza1RhZ1tdCiAgLy8vIFRoZSBwbHVnaW4gZGF0YXMgb2YgdGhlIHRhc2sKICBwbHVnaW5EYXRhcyBUYXNrUGx1Z2luRGF0YVtdCn0KCi8vIFRoZSBkZXNjcmlwdGlvbiBvZiBlYWNoIGVudW0gdmFsdWUgaXMgY29waWVkIGludG8gc3JjL2dyYXBocWwvVGFzay50cwovLy8gVGhlIHN0YXR1cyBvZiBhIHRhc2sKZW51bSBUYXNrU3RhdHVzIHsKICAvLy8gV2hlbiB0aGUgdGFzayBpcyBwbGFubmVkIG9yIGluIHByb2dyZXNzLgogIFRPRE8KICAvLy8gV2hlbiB0aGUgdGFzayBpcyBkb25lLgogIERPTkUKICAvLy8gV2hlbiB0aGUgdGFzayB3YXMgZGVjaWRlZCBub3QgdG8gYmUgZG9uZSBhbnltb3JlLgogIENBTkNFTEVECn0KCi8vLyBBIHRhZyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGEgdGFzay4KbW9kZWwgVGFza1RhZyB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgdGFzayB0YWcKICBpZCAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIHRhc2sgdGFnCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgdGFzayB0YWcgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBuYW1lIG9mIHRoZSB0YXNrIHRhZwogIG5hbWUgICAgICBTdHJpbmcKICAvLy8gVGhlIHNsdWcgKGkuZS4gdGhlIHVybC1zYWZlIHZlcnNpb24pIG9mIHRoZSB0YXNrIHRhZyBuYW1lCiAgc2x1ZyAgICAgIFN0cmluZyAgIEB1bmlxdWUKICAvLy8gVGhlIGNvbG9yIG9mIHRoZSB0YXNrIHRhZwogIGNvbG9yICAgICBDb2xvcgogIC8vLyBXaGV0aGVyIHRhc2tzIHdpdGggdGhpcyB0YWcgc2hvdWxkIGJlIHByaXZhdGUuIChkZWZhdWx0OiB0cnVlKQogIGlzUHJpdmF0ZSBCb29sZWFuICBAZGVmYXVsdCh0cnVlKQoKICB0YXNrcyBUYXNrW10KfQoKLy8vIFRoZSBkYXRhIHJlcXVpcmVkIGJ5IGEgcGx1Z2luIHRvIGJlIGxpbmtlZCB0byBhIHRhc2suCm1vZGVsIFRhc2tQbHVnaW5EYXRhIHsKICAvLy8gVGhlIGlkIG9mIHRoZSB0YXNrIHBsdWdpbiBkYXRhCiAgaWQgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgdGFzayBwbHVnaW4gZGF0YQogIGNyZWF0ZWRBdCAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSB0YXNrIHBsdWdpbiBkYXRhIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgIERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIG1pbmltdW0gZGF0YSByZXF1aXJlZCB0byByZW5kZXIgdGhlIGluZm9ybWF0aW9uIG9uIHRhc2sgY2FyZHMuCiAgbWluICAgICAgICBKc29uCiAgLy8vIFRoZSBmdWxsIGRhdGEgcmVxdWlyZWQgYnkgdGhlIHBsdWdpbiB0byBiZSBsaW5rZWQgdG8gdGhlIHRhc2suCiAgZnVsbCAgICAgICBKc29uCiAgLy8vIFRoZSBzbHVnIG9mIHRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBkYXRhCiAgcGx1Z2luU2x1ZyBTdHJpbmcKICAvLy8gVGhlIG9yaWdpbmFsIGlkIG9mIHRoZSB0YXNrIGdpdmVuIGJ5IHRoZSBwbHVnaW4sIGlmIGFueQogIG9yaWdpbmFsSWQgU3RyaW5nPwoKICAvLy8gVGhlIHRhc2sgbGlua2VkIHRvIHRoZSBwbHVnaW4gZGF0YQogIHRhc2sgICBUYXNrIEByZWxhdGlvbihmaWVsZHM6IFt0YXNrSWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIHRhc2tJZCBJbnQKfQoKLy8vIFRoZSBkYXRhIGEgcGx1Z2luIGxpbmtzIHRvIGFuIGl0ZW0uCm1vZGVsIEl0ZW1QbHVnaW5EYXRhIHsKICAvLy8gVGhlIGlkIG9mIHRoZSBpdGVtIHBsdWdpbiBkYXRhCiAgaWQgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSBvZiBjcmVhdGlvbiBvZiB0aGUgaXRlbSBwbHVnaW4gZGF0YQogIGNyZWF0ZWRBdCAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBpdGVtIHBsdWdpbiBkYXRhIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgIERhdGVUaW1lIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIG1pbmltdW0gZGF0YSByZXF1aXJlZCB0byByZW5kZXIgdGhlIGluZm9ybWF0aW9uIG9uIGl0ZW0gY2FyZHMuCiAgbWluICAgICAgICBKc29uCiAgLy8vIFRoZSBmdWxsIGRhdGEgcmVxdWlyZWQgYnkgdGhlIHBsdWdpbiB0byBiZSBsaW5rZWQgdG8gdGhlIGl0ZW0uCiAgZnVsbCAgICAgICBKc29uCiAgLy8vIFRoZSBzbHVnIG9mIHRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBkYXRhCiAgcGx1Z2luU2x1ZyBTdHJpbmcKICAvLy8gVGhlIG9yaWdpbmFsIGlkIG9mIHRoZSBpdGVtIGdpdmVuIGJ5IHRoZSBwbHVnaW4sIGlmIGFueQogIG9yaWdpbmFsSWQgU3RyaW5nPwoKICAvLy8gVGhlIGl0ZW0gbGlua2VkIHRvIHRoZSBwbHVnaW4gZGF0YQogIGl0ZW0gICBJdGVtIEByZWxhdGlvbihmaWVsZHM6IFtpdGVtSWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGl0ZW1JZCBJbnQKfQoKLy8vIEFuIGl0ZW0gY3JlYXRlZCBieSB0aGUgdXNlciBvciBhIHBsdWdpbi4gVGhlIHVzZXIgY2FuIHRoZW4gY3JlYXRlIDEgb3IgbW9yZSB0YXNrcyBmcm9tIHRoZSBpdGVtLgovLy8gSXQgY2FuIGJlIGEgY2FsZW5kYXIgZXZlbnQsIGEgVHJlbGxvIHRhc2ssIGEgTGluZWFyIGlzc3VlLCBhIEdpdEh1YiByZXF1ZXN0IGZvciByZXZpZXcsIGEgbm90aWZpY2F0aW9uLCBldGMuCm1vZGVsIEl0ZW0gewogIC8vLyBUaGUgaWQgb2YgdGhlIGl0ZW0KICBpZCAgICAgICAgICAgICAgICBJbnQgICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIGl0ZW0KICBjcmVhdGVkQXQgICAgICAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBpdGVtIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICAgICAgICBEYXRlVGltZSAgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgdGl0bGUgb2YgdGhlIGl0ZW0uCiAgLy8vIEl0IGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgdGl0bGUgd2hlbiBjcmVhdGluZyBhIHRhc2sgZnJvbSB0aGUgaXRlbS4KICB0aXRsZSAgICAgICAgICAgICBTdHJpbmcKICAvLy8gV2hldGhlciB0aGUgaXRlbSBpcyByZWxldmFudCB0byB0aGUgdXNlciBhbmQgc2hvdWxkIGJlIHNob3duLiAoZGVmYXVsdDogdHJ1ZSkKICAvLy8gRm9yIGV4YW1wbGUgd2hlbiBhIHBsdWdpbiBjcmVhdGVzIGFuIGl0ZW0gZm9yIGEgVHJlbGxvIHRhc2ssIHRoZW4gbGF0ZXIgb24gdGhlIHVzZXIgYXJoaXZlcyB0aGUgdGFzaywgdGhlIGl0ZW0gaXMgbm8gbG9uZ2VyIHJlbGV2YW50LgogIGlzUmVsZXZhbnQgICAgICAgIEJvb2xlYW4gICBAZGVmYXVsdCh0cnVlKQogIC8vLyBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgaXRlbSBpcyBzY2hlZHVsZWQgZm9yLgogIHNjaGVkdWxlZEF0ICAgICAgIERhdGVUaW1lPyBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUgbGVuZ3RoIG9mIHRpbWUgdGhlIGl0ZW0gaXMgZXhwZWN0ZWQgdG8gdGFrZS4gSWYgdGhlIGl0ZW0gaXMgYWxsLWRheSwgdGhpcyBpcyBudWxsLgogIGR1cmF0aW9uSW5NaW51dGVzIEludD8KICAvLy8gV2hldGhlciB0aGUgaXRlbSBpcyBhbGwtZGF5IG9uIHRoZSBkYXRlIG9mIGBzY2hlZHVsZWRBdGAuCiAgaXNBbGxEYXkgICAgICAgICAgQm9vbGVhbiAgIEBkZWZhdWx0KGZhbHNlKQogIC8vLyBUaGUgdGFpbHdpbmQgY29sb3Igb2YgdGhlIGl0ZW0uIFVzZWQgaW4gdGhlIGNhbGVuZGFyIHZpZXcuCiAgY29sb3IgICAgICAgICAgICAgQ29sb3I/CiAgLy8vIFRoZSBudW1iZXIgb2YgaW5ib3ggcG9pbnRzIHRoZSBpdGVtIGhhcyB0byBiZSBzaG93biBpbiB0aGUgaW5ib3guCiAgLy8vIFRoZSBtb3JlIGluYm94IHBvaW50cyBhbiBpdGVtIGhhcywgdGhlIGhpZ2hlciBpdCBpcyBpbiB0aGUgaW5ib3guCiAgaW5ib3hQb2ludHMgICAgICAgSW50PwoKICAvLy8gVGhlIHRhc2tzIGxpbmtlZCB0byB0aGUgaXRlbQogIHRhc2tzICAgICAgIFRhc2tbXQogIC8vLyBUaGUgcGx1Z2luIGRhdGFzIGxpbmtlZCB0byB0aGUgaXRlbQogIHBsdWdpbkRhdGFzIEl0ZW1QbHVnaW5EYXRhW10KICAvLy8gVGhlIGxpc3QgaW4gd2hpY2ggdGhlIGl0ZW0gaXMgaW4KICBsaXN0ICAgICAgICBMaXN0PyAgICAgICAgICAgIEByZWxhdGlvbihmaWVsZHM6IFtsaXN0SWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGxpc3RJZCAgICAgIEludD8KfQoKLy8vIExpc3Qgb2YgaXRlbXMKbW9kZWwgTGlzdCB7CiAgLy8vIFRoZSBpZCBvZiB0aGUgbGlzdAogIGlkICAgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIG9mIGNyZWF0aW9uIG9mIHRoZSBsaXN0CiAgY3JlYXRlZEF0ICAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBsaXN0IHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICBEYXRlVGltZSBAdXBkYXRlZEF0IEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBuYW1lIG9mIHRoZSBsaXN0CiAgbmFtZSAgICAgICAgU3RyaW5nCiAgLy8vIFRoZSBzbHVnIChpLmUuIHRoZSB1cmwtc2FmZSB2ZXJzaW9uKSBvZiB0aGUgbGlzdCBuYW1lCiAgc2x1ZyAgICAgICAgU3RyaW5nICAgQHVuaXF1ZQogIC8vLyBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGxpc3QKICBkZXNjcmlwdGlvbiBTdHJpbmc/CgogIC8vLyBUaGUgaXRlbXMgbGlua2VkIHRvIHRoZSBsaXN0CiAgaXRlbXMgSXRlbVtdCn0KCi8vLyBBIGtleS12YWx1ZSBzdG9yZSBjb250YWluaW5nIHNldHRpbmdzIHRoZSB1c2VyIGhhcyBtb2RpZmllZCBmb3IgYm90aCBGbG93IGFuZCBwbHVnaW5zIChieSBjb252ZW50aW9uLCB0aGUga2V5IGlzIHByZWZpeGVkIHdpdGggdGhlIHBsdWdpbidzIHNsdWcpLCBvciBjb25maWdzIGFuZCBzZWNyZW50cyB0aGF0IHBsdWdpbnMgaGF2ZSBzdG9yZWQgc3VjaCBhcyBBUEkga2V5cy4KbW9kZWwgU3RvcmUgewogIC8vLyBUaGUgaWQgb2YgdGhlIHN0b3JlIGl0ZW0KICBpZCAgICAgICAgICAgSW50ICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIHN0b3JlIGl0ZW0KICBjcmVhdGVkQXQgICAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXB0eigpCiAgLy8vIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBzdG9yZSBpdGVtIHdhcyBsYXN0IHVwZGF0ZWQKICB1cGRhdGVkQXQgICAgRGF0ZVRpbWUgQHVwZGF0ZWRBdCBAZGIuVGltZXN0YW1wdHooKQogIC8vLyBUaGUga2V5IG9mIHRoZSBzdG9yZSBpdGVtCiAga2V5ICAgICAgICAgIFN0cmluZwogIC8vLyBUaGUgdmFsdWUgb2YgdGhlIHN0b3JlIGl0ZW0KICB2YWx1ZSAgICAgICAgSnNvbgogIC8vLyBUaGUgc2x1ZyBvZiB0aGUgcGx1Z2luIHRoZSBzdG9yZSBpdGVtIGlzIGxpbmtlZCB0by4KICBwbHVnaW5TbHVnICAgU3RyaW5nCiAgLy8vIFdoZXRoZXIgdGhlIHN0b3JlIGl0ZW0gaXMgc2VjcmV0LgogIC8vLyBTZWNyZXQgaXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgc2VydmVyLW9ubHkgYXMgd2VsbCAoZXZlbiBpZiB0aGUgdmFsdWUgb2YgaXNTZXJ2ZXJPbmx5IGlzIGZhbHNlKQogIC8vLyBhbmQgY2FuIG9ubHkgYmUgYWNjZXNzZWQgYnkgdGhlIHBsdWdpbiB3aXRoIHRoZSBzYW1lIHBsdWdpblNsdWcuCiAgaXNTZWNyZXQgICAgIEJvb2xlYW4gIEBkZWZhdWx0KGZhbHNlKQogIC8vLyBXaGV0aGVyIHRoZSBzdG9yZSBpdGVtIGlzIHNlcnZlci1vbmx5LgogIC8vLyBTZXJ2ZXItb25seSBpdGVtcyBhcmUgbm90IHNlbnQgdG8gdGhlIGNsaWVudC4KICBpc1NlcnZlck9ubHkgQm9vbGVhbiAgQGRlZmF1bHQoZmFsc2UpCgogIEBAdW5pcXVlKFtwbHVnaW5TbHVnLCBrZXldLCBuYW1lOiAicGx1Z2luU2x1Z19rZXlfdW5pcXVlIikKfQoKLy8vIEEgcm91dGluZSB0aGUgdXNlciBoYXMgc2V0IHVwLgptb2RlbCBSb3V0aW5lIHsKICAvLy8gVGhlIGlkIG9mIHRoZSByb3V0aW5lCiAgaWQgICAgICAgICAgICAgIEludCAgICAgICAgICAgICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgb2YgY3JlYXRpb24gb2YgdGhlIHJvdXRpbmUKICBjcmVhdGVkQXQgICAgICAgRGF0ZVRpbWUgICAgICAgICAgICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIGRhdGUgYW5kIHRpbWUgdGhlIHJvdXRpbmUgd2FzIGxhc3QgdXBkYXRlZAogIHVwZGF0ZWRBdCAgICAgICBEYXRlVGltZSAgICAgICAgICAgIEB1cGRhdGVkQXQgQGRiLlRpbWVzdGFtcHR6KCkKICAvLy8gVGhlIG5hbWUgb2YgdGhlIHJvdXRpbmUKICBuYW1lICAgICAgICAgICAgU3RyaW5nCiAgLy8vIEFjdGlvbiBuYW1lIHVzZWQgb24gdGhlIGJ1dHRvbiB0byBzdGFydCB0aGUgcm91dGluZQogIGFjdGlvbk5hbWUgICAgICBTdHJpbmcKICAvLy8gVGhlIHRpbWUgdGhlIHJvdXRpbmUgdGFrZXMgcGxhY2UKICB0aW1lICAgICAgICAgICAgRGF0ZVRpbWUgICAgICAgICAgICBAZGIuVGltZSgwKQogIC8vLyBUaGUgcGF0dGVybihzKSB0aGUgcm91dGluZSByZXBlYXRzIG9uCiAgcmVwZWF0cyAgICAgICAgIFJlcGV0aXRpb25QYXR0ZXJuW10KICAvLy8gVGhlIGRhdGUgdGhlIHJvdXRpbmUgc3RhcnRzIHJlcGVhdGluZyBmcm9tCiAgZmlyc3REYXkgICAgICAgIERhdGVUaW1lICAgICAgICAgICAgQGRlZmF1bHQobm93KCkpIEBkYi5EYXRlCiAgLy8vIFRoZSBkYXRlIHRoZSByb3V0aW5lIGVuZCByZXBlYXRpbmcgb24KICBsYXN0RGF5ICAgICAgICAgRGF0ZVRpbWU/ICAgICAgICAgICBAZGIuRGF0ZQogIC8vLyBXaGV0aGVyIHRoZSByb3V0aW5lIGlzIGFjdGl2ZS4gVGhpcyBjYW4gYmUgdXNlZCB0byBwYXVzZSBhIHJvdXRpbmUuCiAgaXNBY3RpdmUgICAgICAgIEJvb2xlYW4gICAgICAgICAgICAgQGRlZmF1bHQodHJ1ZSkKICAvLy8gVGhlIHN0ZXBzIG9mIHRoZSByb3V0aW5lLgogIC8vLyBBIGxpc3Qgb2Ygc3RyaW5ncyBpbiB0aGUgZm9ybWF0IGBbJ2Zsb3cnIG9yIHBsdWdpblNsdWddX1tzdGVwU2x1Z11fW3Nob3VsZFNraXBdYC4KICBzdGVwcyAgICAgICAgICAgU3RyaW5nW10KICAvLy8gVGhlIGRheXMgdGhlIHJvdXRpbmUgaGFzIGJlZW4gY29tcGxldGVkIG9uLgogIGRheXNDb21wbGV0ZWRPbiBEYXlbXQp9CgplbnVtIFJlcGV0aXRpb25QYXR0ZXJuIHsKICBNT05EQVkKICBUVUVTREFZCiAgV0VETkVTREFZCiAgVEhVUlNEQVkKICBGUklEQVkKICBTQVRVUkRBWQogIFNVTkRBWQoKICAvLyBmb2xsb3dpbmcgd2lsbCBiZSBhZGRlZCBsYXRlcgogIC8vIEJJV0VFS0xZX01PTkRBWQogIC8vIEJJV0VFS0xZX1RVRVNEQVkKICAvLyBCSVdFRUtMWV9XRURORVNEQVkKICAvLyBCSVdFRUtMWV9USFVSU0RBWQogIC8vIEJJV0VFS0xZX0ZSSURBWQogIC8vIEJJV0VFS0xZX1NBVFVSREFZCiAgLy8gQklXRUVLTFlfU1VOREFZCiAgLy8gVFJJV0VFS0xZX01PTkRBWQogIC8vIFRSSVdFRUtMWV9UVUVTREFZCiAgLy8gVFJJV0VFS0xZX1dFRE5FU0RBWQogIC8vIFRSSVdFRUtMWV9USFVSU0RBWQogIC8vIFRSSVdFRUtMWV9GUklEQVkKICAvLyBUUklXRUVLTFlfU0FUVVJEQVkKICAvLyBUUklXRUVLTFlfU1VOREFZCiAgLy8gRklSU1RfT0ZfTU9OVEgKICAvLyBMQVNUX09GX01PTlRICn0KCi8vLyBUYWlsd2luZENTUyBjb2xvcnMuIFVzZWZ1bCB0byBnZW5lcmF0ZSBhIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgZnJvbSBlYWNoIGNvbG9yLAovLy8gaW5zdGVhZCBvZiBoYXZpbmcgaW5kZXBlbmRlbnQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvcnMKZW51bSBDb2xvciB7CiAgc2xhdGUKICBncmF5CiAgemluYwogIG5ldXRyYWwKICBzdG9uZQogIHJlZAogIG9yYW5nZQogIGFtYmVyCiAgeWVsbG93CiAgbGltZQogIGdyZWVuCiAgZW1lcmFsZAogIHRlYWwKICBjeWFuCiAgc2t5CiAgYmx1ZQogIGluZGlnbwogIHZpb2xldAogIHB1cnBsZQogIGZ1Y2hzaWEKICBwaW5rCiAgcm9zZQp9Cg==",
    inlineSchemaHash: "f5fd9774574bb0d6ee9228cbac7488f0c1018c222d960657d0718247780d2594",
    noEngine: false
  };
  var fs = import.meta.require("fs");
  config.dirname = import.meta.dir;
  if (!fs.existsSync(path.join(import.meta.dir, "schema.prisma"))) {
    const alternativePaths = [
      "../../node_modules/.prisma/client",
      "../node_modules/.prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config.dirname = path.join(process.cwd(), alternativePath);
    config.isBundled = true;
  }
  config.runtimeDataModel = JSON.parse("{\"models\":{\"Day\":{\"dbName\":null,\"fields\":[{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date of the day, which acts as the ID\"},{\"name\":\"tasksOrder\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The order of the tasks in the day\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"DayToTask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the day.\"},{\"name\":\"notes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Note\",\"relationName\":\"DayToNote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The notes linked to the day.\"},{\"name\":\"routinesCompleted\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Routine\",\"relationName\":\"DayToRoutine\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The routines completed on the day.\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A day a user has planned or already done.\\\\nDays that have not yet been planned are virtually created in the GraphQL API.\"},\"Note\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the note\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the note\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the note was last updated\"},{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the note was created\"},{\"name\":\"day\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToNote\",\"relationFromFields\":[\"date\"],\"relationToFields\":[\"date\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The day the note was created\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the note which needs to be unique.\\\\nIt can be used to retrieve the note and update it.\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the note\"},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The content of the note in HTML. If it's text (i.e. one line),\\\\nit will most likely be converted to HTML by the TipTap editor.\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"NoteTag\",\"relationName\":\"NoteToNoteTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags of the note\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A note that the user has created.\"},\"NoteTag\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the note tag\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the note tag\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the note tag was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the note tag\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the note tag name\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The color of the note tag in hex\"},{\"name\":\"isPrivate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether notes with this tag should be private. (default: true)\"},{\"name\":\"notes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Note\",\"relationName\":\"NoteToNoteTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The notes with this tag\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A tag that can be applied to a note.\"},\"Task\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task.\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task was last updated\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the task in text or HTML.\"},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"TaskStatus\",\"default\":\"TODO\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The status of the task\"},{\"name\":\"completedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time the task was completed.\"},{\"name\":\"day\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToTask\",\"relationFromFields\":[\"date\"],\"relationToFields\":[\"date\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The day the task is scheduled for\"},{\"name\":\"date\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the task is scheduled for\"},{\"name\":\"durationInMinutes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The length of time the task is expected to take.\"},{\"name\":\"item\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToTask\",\"relationFromFields\":[\"itemId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The item linked to the task\"},{\"name\":\"itemId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"parentTask\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"Subtask\",\"relationFromFields\":[\"parentTaskId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The parent task of the task\"},{\"name\":\"parentTaskId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"subtasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"Subtask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The subtasks of the task\"},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskTag\",\"relationName\":\"TaskToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tags of the task \"},{\"name\":\"pluginDatas\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"TaskPluginData\",\"relationName\":\"TaskToTaskPluginData\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin datas of the task\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A task that the user or a plugin has created.\"},\"TaskTag\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task tag\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task tag\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task tag was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the task tag\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the task tag name\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The color of the task tag\"},{\"name\":\"isPrivate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether tasks with this tag should be private. (default: true)\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"TaskToTaskTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A tag that can be applied to a task.\"},\"TaskPluginData\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the task plugin data\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the task plugin data\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the task plugin data was last updated\"},{\"name\":\"min\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The minimum data required to render the information on task cards.\"},{\"name\":\"full\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The full data required by the plugin to be linked to the task.\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin that created the data\"},{\"name\":\"originalId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The original id of the task given by the plugin, if any\"},{\"name\":\"task\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"TaskToTaskPluginData\",\"relationFromFields\":[\"taskId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The task linked to the plugin data\"},{\"name\":\"taskId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"The data required by a plugin to be linked to a task.\"},\"ItemPluginData\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the item plugin data\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the item plugin data\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the item plugin data was last updated\"},{\"name\":\"min\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The minimum data required to render the information on item cards.\"},{\"name\":\"full\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The full data required by the plugin to be linked to the item.\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin that created the data\"},{\"name\":\"originalId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The original id of the item given by the plugin, if any\"},{\"name\":\"item\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToItemPluginData\",\"relationFromFields\":[\"itemId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The item linked to the plugin data\"},{\"name\":\"itemId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"The data a plugin links to an item.\"},\"Item\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the item\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the item\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the item was last updated\"},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The title of the item.\\\\nIt is used as the initial title when creating a task from the item.\"},{\"name\":\"isRelevant\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the item is relevant to the user and should be shown. (default: true)\\\\nFor example when a plugin creates an item for a Trello task, then later on the user arhives the task, the item is no longer relevant.\"},{\"name\":\"scheduledAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time the item is scheduled for.\"},{\"name\":\"durationInMinutes\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The length of time the item is expected to take. If the item is all-day, this is null.\"},{\"name\":\"isAllDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the item is all-day on the date of `scheduledAt`.\"},{\"name\":\"color\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Color\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tailwind color of the item. Used in the calendar view.\"},{\"name\":\"inboxPoints\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The number of inbox points the item has to be shown in the inbox.\\\\nThe more inbox points an item has, the higher it is in the inbox.\"},{\"name\":\"tasks\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Task\",\"relationName\":\"ItemToTask\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The tasks linked to the item\"},{\"name\":\"pluginDatas\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"ItemPluginData\",\"relationName\":\"ItemToItemPluginData\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The plugin datas linked to the item\"},{\"name\":\"list\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"List\",\"relationName\":\"ItemToList\",\"relationFromFields\":[\"listId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The list in which the item is in\"},{\"name\":\"listId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"An item created by the user or a plugin. The user can then create 1 or more tasks from the item.\\\\nIt can be a calendar event, a Trello task, a Linear issue, a GitHub request for review, a notification, etc.\"},\"List\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the list\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the list\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the list was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the list\"},{\"name\":\"slug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug (i.e. the url-safe version) of the list name\"},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The description of the list\"},{\"name\":\"items\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Item\",\"relationName\":\"ItemToList\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The items linked to the list\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"List of items\"},\"Store\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the store item\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the store item\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the store item was last updated\"},{\"name\":\"key\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The key of the store item\"},{\"name\":\"value\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Json\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The value of the store item\"},{\"name\":\"pluginSlug\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The slug of the plugin the store item is linked to.\"},{\"name\":\"isSecret\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the store item is secret.\\\\nSecret items are automatically server-only as well (even if the value of isServerOnly is false)\\\\nand can only be accessed by the plugin with the same pluginSlug.\"},{\"name\":\"isServerOnly\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the store item is server-only.\\\\nServer-only items are not sent to the client.\"}],\"primaryKey\":null,\"uniqueFields\":[[\"pluginSlug\",\"key\"]],\"uniqueIndexes\":[{\"name\":\"pluginSlug_key_unique\",\"fields\":[\"pluginSlug\",\"key\"]}],\"isGenerated\":false,\"documentation\":\"A key-value store containing settings the user has modified for both Flow and plugins (by convention, the key is prefixed with the plugin's slug), or configs and secrents that plugins have stored such as API keys.\"},\"Routine\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The id of the routine\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date and time of creation of the routine\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true,\"documentation\":\"The date and time the routine was last updated\"},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The name of the routine\"},{\"name\":\"actionName\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Action name used on the button to start the routine\"},{\"name\":\"time\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The time the routine takes place\"},{\"name\":\"repeats\",\"kind\":\"enum\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"RepetitionPattern\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The pattern(s) the routine repeats on\"},{\"name\":\"firstDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the routine starts repeating from\"},{\"name\":\"lastDay\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The date the routine end repeating on\"},{\"name\":\"isActive\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"Whether the routine is active. This can be used to pause a routine.\"},{\"name\":\"steps\",\"kind\":\"scalar\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The steps of the routine.\\\\nA list of strings in the format `['flow' or pluginSlug]_[stepSlug]_[shouldSkip]`.\"},{\"name\":\"daysCompletedOn\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Day\",\"relationName\":\"DayToRoutine\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false,\"documentation\":\"The days the routine has been completed on.\"}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false,\"documentation\":\"A routine the user has set up.\"}},\"enums\":{\"TaskStatus\":{\"values\":[{\"name\":\"TODO\",\"dbName\":null,\"documentation\":\"When the task is planned or in progress.\"},{\"name\":\"DONE\",\"dbName\":null,\"documentation\":\"When the task is done.\"},{\"name\":\"CANCELED\",\"dbName\":null,\"documentation\":\"When the task was decided not to be done anymore.\"}],\"dbName\":null,\"documentation\":\"The status of a task\"},\"RepetitionPattern\":{\"values\":[{\"name\":\"MONDAY\",\"dbName\":null},{\"name\":\"TUESDAY\",\"dbName\":null},{\"name\":\"WEDNESDAY\",\"dbName\":null},{\"name\":\"THURSDAY\",\"dbName\":null},{\"name\":\"FRIDAY\",\"dbName\":null},{\"name\":\"SATURDAY\",\"dbName\":null},{\"name\":\"SUNDAY\",\"dbName\":null}],\"dbName\":null},\"Color\":{\"values\":[{\"name\":\"slate\",\"dbName\":null},{\"name\":\"gray\",\"dbName\":null},{\"name\":\"zinc\",\"dbName\":null},{\"name\":\"neutral\",\"dbName\":null},{\"name\":\"stone\",\"dbName\":null},{\"name\":\"red\",\"dbName\":null},{\"name\":\"orange\",\"dbName\":null},{\"name\":\"amber\",\"dbName\":null},{\"name\":\"yellow\",\"dbName\":null},{\"name\":\"lime\",\"dbName\":null},{\"name\":\"green\",\"dbName\":null},{\"name\":\"emerald\",\"dbName\":null},{\"name\":\"teal\",\"dbName\":null},{\"name\":\"cyan\",\"dbName\":null},{\"name\":\"sky\",\"dbName\":null},{\"name\":\"blue\",\"dbName\":null},{\"name\":\"indigo\",\"dbName\":null},{\"name\":\"violet\",\"dbName\":null},{\"name\":\"purple\",\"dbName\":null},{\"name\":\"fuchsia\",\"dbName\":null},{\"name\":\"pink\",\"dbName\":null},{\"name\":\"rose\",\"dbName\":null}],\"dbName\":null,\"documentation\":\"TailwindCSS colors. Useful to generate a foreground and background color from each color,\\\\ninstead of having independent foreground and background colors\"}},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(import.meta.dir, "libquery_engine-darwin-arm64.dylib.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-darwin-arm64.dylib.node");
  path.join(import.meta.dir, "libquery_engine-rhel-openssl-3.0.x.so.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-rhel-openssl-3.0.x.so.node");
  path.join(import.meta.dir, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(import.meta.dir, "schema.prisma");
  path.join(process.cwd(), "../../node_modules/.prisma/client/schema.prisma");
});

// /Users/richardguerre/Projects/flow/node_modules/@prisma/client/index.js
var require_client2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_client()
  };
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e();
  })(exports, function() {
    var t = 1000, e = 60000, n = 3600000, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t(e2, n2) {
      if (e2.date() < n2.date())
        return -t(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === undefined;
    } }, g = "en", D = {};
    D[g] = M;
    var p = function(t2) {
      return t2 instanceof _;
    }, S = function t(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if (typeof e2 == "string") {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, w = function(t2, e2) {
      if (p(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, O = v;
    O.l = S, O.i = p, O.w = function(t2, e2) {
      return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var { date: e2, utc: n2 } = t3;
          if (e2 === null)
            return new Date(NaN);
          if (O.u(e2))
            return new Date;
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = w(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return w(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < w(t2);
      }, m2.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), l2 = function(t3, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (h2) {
          case c:
            return r2 ? l2(1, 0) : l2(31, 11);
          case f:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[O.p(t2)]();
      }, m2.add = function(r2, h2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = O.p(h2), y2 = function(t2) {
          var e2 = w(l2);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($2 === f)
          return this.set(f, this.$M + r2);
        if ($2 === c)
          return this.set(c, this.$y + r2);
        if ($2 === a)
          return y2(1);
        if ($2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, c2 = function(t3) {
          return O.s(s2 % 12 || 12, t3, "0");
        }, d2 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e3) {
          return e3 || $2[t3] || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
        return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h] = g2 / 3, $2[o] = (v2 - m3) / 604800000, $2[a] = (v2 - m3) / 86400000, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t, $2)[y2] || v2, l2 ? g2 : O.a(g2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
      T[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
      return w(1000 * t2);
    }, w.en = D[g], w.Ls = D, w.p = {}, w;
  });
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
  })(exports, function() {
    var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e2) {
      return (e2 = +e2) + (e2 > 68 ? 1900 : 2000);
    };
    var a = function(e2) {
      return function(t2) {
        this[e2] = +t2;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
      (this.zone || (this.zone = {})).offset = function(e3) {
        if (!e3)
          return 0;
        if (e3 === "Z")
          return 0;
        var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
        return n2 === 0 ? 0 : t2[0] === "+" ? -n2 : n2;
      }(e2);
    }], h = function(e2) {
      var t2 = o[e2];
      return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
    }, u = function(e2, t2) {
      var n2, r2 = o.meridiem;
      if (r2) {
        for (var i2 = 1;i2 <= 24; i2 += 1)
          if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = e2 === (t2 ? "pm" : "PM");
      return n2;
    }, d = { A: [i, function(e2) {
      this.afternoon = u(e2, false);
    }], a: [i, function(e2) {
      this.afternoon = u(e2, true);
    }], S: [/\d/, function(e2) {
      this.milliseconds = 100 * +e2;
    }], SS: [n, function(e2) {
      this.milliseconds = 10 * +e2;
    }], SSS: [/\d{3}/, function(e2) {
      this.milliseconds = +e2;
    }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
      var t2 = o.ordinal, n2 = e2.match(/\d+/);
      if (this.day = n2[0], t2)
        for (var r2 = 1;r2 <= 31; r2 += 1)
          t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
    }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
      var t2 = h("months"), n2 = (h("monthsShort") || t2.map(function(e3) {
        return e3.slice(0, 3);
      })).indexOf(e2) + 1;
      if (n2 < 1)
        throw new Error;
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(e2) {
      var t2 = h("months").indexOf(e2) + 1;
      if (t2 < 1)
        throw new Error;
      this.month = t2 % 12 || t2;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
      this.year = s(e2);
    }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
    function c(n2) {
      var r2, i2;
      r2 = n2, i2 = o && o.formats;
      for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
        var o2 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
          return t3 || n4.slice(1);
        });
      })).match(t), a2 = s2.length, f2 = 0;f2 < a2; f2 += 1) {
        var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l = u2 && u2[1];
        s2[f2] = l ? { regex: c2, parser: l } : h2.replace(/^\[|\]$/g, "");
      }
      return function(e2) {
        for (var t2 = {}, n3 = 0, r3 = 0;n3 < a2; n3 += 1) {
          var i3 = s2[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var { regex: o2, parser: f3 } = i3, h3 = e2.slice(r3), u3 = o2.exec(h3)[0];
            f3.call(t2, u3), e2 = e2.replace(u3, "");
          }
        }
        return function(e3) {
          var t3 = e3.afternoon;
          if (t3 !== undefined) {
            var n4 = e3.hours;
            t3 ? n4 < 12 && (e3.hours += 12) : n4 === 12 && (e3.hours = 0), delete e3.afternoon;
          }
        }(t2), t2;
      };
    }
    return function(e2, t2, n2) {
      n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
      var r2 = t2.prototype, i2 = r2.parse;
      r2.parse = function(e3) {
        var { date: t3, utc: r3, args: s2 } = e3;
        this.$u = r3;
        var a2 = s2[1];
        if (typeof a2 == "string") {
          var f2 = s2[2] === true, h2 = s2[3] === true, u2 = f2 || h2, d2 = s2[2];
          h2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
            try {
              if (["x", "X"].indexOf(t4) > -1)
                return new Date((t4 === "X" ? 1000 : 1) * e4);
              var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h3 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = new Date, m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
              i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
              var p = a3 || 0, v = f3 || 0, D = h3 || 0, g = u3 || 0;
              return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1000)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
            } catch (e5) {
              return new Date("");
            }
          }(t3, a2, r3), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l = a2.length, m = 1;m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M = n2.apply(this, s2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          }
        else
          i2.call(this, e3);
      };
    };
  });
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS((exports, module) => {
  (function(t, i) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_utc = i();
  })(exports, function() {
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
      var u = f.prototype;
      n.utc = function(t2) {
        var i2 = { date: t2, utc: true, args: arguments };
        return new f(i2);
      }, u.utc = function(i2) {
        var e2 = n(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e2.add(this.utcOffset(), t) : e2;
      }, u.local = function() {
        return n(this.toDate(), { locale: this.$L, utc: false });
      };
      var o = u.parse;
      u.parse = function(t2) {
        t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
      };
      var r = u.init;
      u.init = function() {
        if (this.$u) {
          var t2 = this.$d;
          this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
        } else
          r.call(this);
      };
      var a = u.utcOffset;
      u.utcOffset = function(s2, f2) {
        var n2 = this.$utils().u;
        if (n2(s2))
          return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
        if (typeof s2 == "string" && (s2 = function(t2) {
          t2 === undefined && (t2 = "");
          var s3 = t2.match(i);
          if (!s3)
            return null;
          var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
          return u3 === 0 ? 0 : n3 === "+" ? u3 : -u3;
        }(s2), s2 === null))
          return this;
        var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f2)
          return o2.$offset = u2, o2.$u = s2 === 0, o2;
        if (s2 !== 0) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
        } else
          o2 = this.utc();
        return o2;
      };
      var h = u.format;
      u.format = function(t2) {
        var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i2);
      }, u.valueOf = function() {
        var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 60000 * t2;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var l = u.toDate;
      u.toDate = function(t2) {
        return t2 === "s" && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
      };
      var c = u.diff;
      u.diff = function(t2, i2, e2) {
        if (t2 && this.$u === t2.$u)
          return c.call(this, t2, i2, e2);
        var s2 = this.local(), f2 = n(t2).local();
        return c.call(s2, f2, i2, e2);
      };
    };
  });
});

// /Users/richardguerre/Projects/flow/node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_timezone = e();
  })(exports, function() {
    var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
    return function(n, i, o) {
      var r, a = function(t2, n2, i2) {
        i2 === undefined && (i2 = {});
        var o2 = new Date(t2), r2 = function(t3, n3) {
          n3 === undefined && (n3 = {});
          var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
          return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
        }(n2, i2);
        return r2.formatToParts(o2);
      }, u = function(e2, n2) {
        for (var i2 = a(e2, n2), r2 = [], u2 = 0;u2 < i2.length; u2 += 1) {
          var f2 = i2[u2], s2 = f2.type, m = f2.value, c = t[s2];
          c >= 0 && (r2[c] = parseInt(m, 10));
        }
        var d = r2[3], l = d === 24 ? 0 : d, v = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", h = +e2;
        return (o.utc(v).valueOf() - (h -= h % 1000)) / 60000;
      }, f = i.prototype;
      f.tz = function(t2, e2) {
        t2 === undefined && (t2 = r);
        var n2 = this.utcOffset(), i2 = this.toDate(), a2 = i2.toLocaleString("en-US", { timeZone: t2 }), u2 = Math.round((i2 - new Date(a2)) / 1000 / 60), f2 = o(a2).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u2, true);
        if (e2) {
          var s2 = f2.utcOffset();
          f2 = f2.add(n2 - s2, "minute");
        }
        return f2.$x.$timezone = t2, f2;
      }, f.offsetName = function(t2) {
        var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, { timeZoneName: t2 }).find(function(t3) {
          return t3.type.toLowerCase() === "timezonename";
        });
        return n2 && n2.value;
      };
      var s = f.startOf;
      f.startOf = function(t2, e2) {
        if (!this.$x || !this.$x.$timezone)
          return s.call(this, t2, e2);
        var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));
        return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
      }, o.tz = function(t2, e2, n2) {
        var i2 = n2 && e2, a2 = n2 || e2 || r, f2 = u(+o(), a2);
        if (typeof t2 != "string")
          return o(t2).tz(a2);
        var s2 = function(t3, e3, n3) {
          var i3 = t3 - 60 * e3 * 1000, o2 = u(i3, n3);
          if (e3 === o2)
            return [i3, e3];
          var r2 = u(i3 -= 60 * (o2 - e3) * 1000, n3);
          return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1000, Math.max(o2, r2)];
        }(o.utc(t2, i2).valueOf(), f2, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
        return d.$x.$timezone = a2, d;
      }, o.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o.tz.setDefault = function(t2) {
        r = t2;
      };
    };
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/plans.js
var require_plans = __commonJS((exports, module) => {
  var locked = function(schema3, query3) {
    if (Array.isArray(query3)) {
      query3 = query3.join(";\n");
    }
    return `
    BEGIN;
    SET LOCAL statement_timeout = '30s';
    ${advisoryLock(schema3)};
    ${query3};
    COMMIT;
  `;
  };
  var create = function(schema3, version2) {
    const commands = [
      createSchema(schema3),
      createVersionTable(schema3),
      createJobStateEnum(schema3),
      createJobTable(schema3),
      cloneJobTableForArchive(schema3),
      createScheduleTable(schema3),
      createSubscriptionTable(schema3),
      addIdIndexToArchive(schema3),
      addArchivedOnToArchive(schema3),
      addArchivedOnIndexToArchive(schema3),
      createIndexJobName(schema3),
      createIndexJobFetch(schema3),
      createIndexSingletonOn(schema3),
      createIndexSingletonKeyOn(schema3),
      createIndexSingletonKey(schema3),
      createIndexSingletonQueue(schema3),
      insertVersion(schema3, version2)
    ];
    return locked(schema3, commands);
  };
  var createSchema = function(schema3) {
    return `
    CREATE SCHEMA IF NOT EXISTS ${schema3}
  `;
  };
  var createVersionTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.version (
      version int primary key,
      maintained_on timestamp with time zone,
      cron_on timestamp with time zone
    )
  `;
  };
  var createJobStateEnum = function(schema3) {
    return `
    CREATE TYPE ${schema3}.job_state AS ENUM (
      '${states.created}',
      '${states.retry}',
      '${states.active}',
      '${states.completed}',
      '${states.expired}',
      '${states.cancelled}',
      '${states.failed}'
    )
  `;
  };
  var createJobTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.job (
      id uuid primary key not null default gen_random_uuid(),
      name text not null,
      priority integer not null default(0),
      data jsonb,
      state ${schema3}.job_state not null default('${states.created}'),
      retryLimit integer not null default(0),
      retryCount integer not null default(0),
      retryDelay integer not null default(0),
      retryBackoff boolean not null default false,
      startAfter timestamp with time zone not null default now(),
      startedOn timestamp with time zone,
      singletonKey text,
      singletonOn timestamp without time zone,
      expireIn interval not null default interval '15 minutes',
      createdOn timestamp with time zone not null default now(),
      completedOn timestamp with time zone,
      keepUntil timestamp with time zone NOT NULL default now() + interval '14 days',
      on_complete boolean not null default false,
      output jsonb
    )
  `;
  };
  var cloneJobTableForArchive = function(schema3) {
    return `CREATE TABLE ${schema3}.archive (LIKE ${schema3}.job)`;
  };
  var addArchivedOnToArchive = function(schema3) {
    return `ALTER TABLE ${schema3}.archive ADD archivedOn timestamptz NOT NULL DEFAULT now()`;
  };
  var addArchivedOnIndexToArchive = function(schema3) {
    return `CREATE INDEX archive_archivedon_idx ON ${schema3}.archive(archivedon)`;
  };
  var addIdIndexToArchive = function(schema3) {
    return `CREATE INDEX archive_id_idx ON ${schema3}.archive(id)`;
  };
  var setMaintenanceTime = function(schema3) {
    return `UPDATE ${schema3}.version SET maintained_on = now()`;
  };
  var getMaintenanceTime = function(schema3) {
    return `SELECT maintained_on, EXTRACT( EPOCH FROM (now() - maintained_on) ) seconds_ago FROM ${schema3}.version`;
  };
  var setCronTime = function(schema3, time) {
    time = time || "now()";
    return `UPDATE ${schema3}.version SET cron_on = ${time}`;
  };
  var getCronTime = function(schema3) {
    return `SELECT cron_on, EXTRACT( EPOCH FROM (now() - cron_on) ) seconds_ago FROM ${schema3}.version`;
  };
  var deleteQueue = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `DELETE FROM ${schema3}.job WHERE name = \$1 and state < '${options.before}'`;
  };
  var deleteAllQueues = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `DELETE FROM ${schema3}.job WHERE state < '${options.before}'`;
  };
  var clearStorage = function(schema3) {
    return `TRUNCATE ${schema3}.job, ${schema3}.archive`;
  };
  var getQueueSize = function(schema3, options = {}) {
    options.before = options.before || states.active;
    assert(options.before in states, `${options.before} is not a valid state`);
    return `SELECT count(*) as count FROM ${schema3}.job WHERE name = \$1 AND state < '${options.before}'`;
  };
  var createIndexSingletonKey = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < '${states.completed}' AND singletonOn IS NULL AND NOT singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
  `;
  };
  var createIndexSingletonQueue = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < '${states.active}' AND singletonOn IS NULL AND singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
  `;
  };
  var createIndexSingletonOn = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonOn ON ${schema3}.job (name, singletonOn) WHERE state < '${states.expired}' AND singletonKey IS NULL
  `;
  };
  var createIndexSingletonKeyOn = function(schema3) {
    return `
    CREATE UNIQUE INDEX job_singletonKeyOn ON ${schema3}.job (name, singletonOn, singletonKey) WHERE state < '${states.expired}'
  `;
  };
  var createIndexJobName = function(schema3) {
    return `
    CREATE INDEX job_name ON ${schema3}.job (name text_pattern_ops)
  `;
  };
  var createIndexJobFetch = function(schema3) {
    return `
    CREATE INDEX job_fetch ON ${schema3}.job (name text_pattern_ops, startAfter) WHERE state < '${states.active}'
  `;
  };
  var createScheduleTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.schedule (
      name text primary key,
      cron text not null,
      timezone text,
      data jsonb,
      options jsonb,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now()
    )
  `;
  };
  var createSubscriptionTable = function(schema3) {
    return `
    CREATE TABLE ${schema3}.subscription (
      event text not null,
      name text not null,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now(),
      PRIMARY KEY(event, name)
    )
  `;
  };
  var getSchedules = function(schema3) {
    return `
    SELECT * FROM ${schema3}.schedule
  `;
  };
  var schedule = function(schema3) {
    return `
    INSERT INTO ${schema3}.schedule (name, cron, timezone, data, options)
    VALUES (\$1, \$2, \$3, \$4, \$5)
    ON CONFLICT (name) DO UPDATE SET
      cron = EXCLUDED.cron,
      timezone = EXCLUDED.timezone,
      data = EXCLUDED.data,
      options = EXCLUDED.options,
      updated_on = now()
  `;
  };
  var unschedule = function(schema3) {
    return `
    DELETE FROM ${schema3}.schedule
    WHERE name = \$1
  `;
  };
  var subscribe3 = function(schema3) {
    return `
    INSERT INTO ${schema3}.subscription (event, name)
    VALUES (\$1, \$2)
    ON CONFLICT (event, name) DO UPDATE SET
      event = EXCLUDED.event,
      name = EXCLUDED.name,
      updated_on = now()
  `;
  };
  var unsubscribe = function(schema3) {
    return `
    DELETE FROM ${schema3}.subscription
    WHERE event = \$1 and name = \$2
  `;
  };
  var getQueuesForEvent = function(schema3) {
    return `
    SELECT name FROM ${schema3}.subscription
    WHERE event = \$1
  `;
  };
  var getTime = function() {
    return "SELECT round(date_part('epoch', now()) * 1000) as time";
  };
  var getVersion = function(schema3) {
    return `SELECT version from ${schema3}.version`;
  };
  var setVersion = function(schema3, version2) {
    return `UPDATE ${schema3}.version SET version = '${version2}'`;
  };
  var versionTableExists = function(schema3) {
    return `SELECT to_regclass('${schema3}.version') as name`;
  };
  var insertVersion = function(schema3, version2) {
    return `INSERT INTO ${schema3}.version(version) VALUES ('${version2}')`;
  };
  var fetchNextJob = function(schema3) {
    return (includeMetadata, enforceSingletonQueueActiveLimit) => `
    WITH nextJob as (
      SELECT id
      FROM ${schema3}.job j
      WHERE state < '${states.active}'
        AND name LIKE \$1
        AND startAfter < now()
        ${enforceSingletonQueueActiveLimit ? `AND (
          CASE
            WHEN singletonKey IS NOT NULL
              AND singletonKey LIKE '${SINGLETON_QUEUE_KEY_ESCAPED}%'
              THEN NOT EXISTS (
                SELECT 1
                FROM ${schema3}.job active_job
                WHERE active_job.state = '${states.active}'
                  AND active_job.name = j.name
                  AND active_job.singletonKey = j.singletonKey
                  LIMIT 1
              )
            ELSE
              true
          END
        )` : ""}
      ORDER BY priority desc, createdOn, id
      LIMIT \$2
      FOR UPDATE SKIP LOCKED
    )
    UPDATE ${schema3}.job j SET
      state = '${states.active}',
      startedOn = now(),
      retryCount = CASE WHEN state = '${states.retry}' THEN retryCount + 1 ELSE retryCount END
    FROM nextJob
    WHERE j.id = nextJob.id
    RETURNING ${includeMetadata ? "j.*" : "j.id, name, data"}, EXTRACT(epoch FROM expireIn) as expire_in_seconds
  `;
  };
  var buildJsonCompletionObject = function(withResponse) {
    return `jsonb_build_object(
    'request', jsonb_build_object('id', id, 'name', name, 'data', data),
    'response', ${withResponse ? "$2::jsonb" : "null"},
    'state', state,
    'retryCount', retryCount,
    'createdOn', createdOn,
    'startedOn', startedOn,
    'completedOn', completedOn,
    'failed', CASE WHEN state = '${states.completed}' THEN false ELSE true END
  )`;
  };
  var completeJobs = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET completedOn = now(),
        state = '${states.completed}',
        output = \$2::jsonb
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state = '${states.active}'
      RETURNING *
    ), completion_jobs as (
      INSERT INTO ${schema3}.job (name, data, keepUntil)
      SELECT
        '${COMPLETION_JOB_PREFIX}' || name,
        ${buildJsonCompletionObject(true)},
        ${keepUntilInheritance}
      FROM results
      WHERE NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
        AND on_complete
    )
    SELECT COUNT(*) FROM results
  `;
  };
  var failJobs = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET state = CASE
          WHEN retryCount < retryLimit
          THEN '${states.retry}'::${schema3}.job_state
          ELSE '${states.failed}'::${schema3}.job_state
          END,
        completedOn = ${retryCompletedOnCase},
        startAfter = ${retryStartAfterCase},
        output = \$2::jsonb
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state < '${states.completed}'
      RETURNING *
    ), completion_jobs as (
      INSERT INTO ${schema3}.job (name, data, keepUntil)
      SELECT
        '${COMPLETION_JOB_PREFIX}' || name,
        ${buildJsonCompletionObject(true)},
        ${keepUntilInheritance}
      FROM results
      WHERE state = '${states.failed}'
        AND NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
        AND on_complete
    )
    SELECT COUNT(*) FROM results
  `;
  };
  var expire = function(schema3) {
    return `
    WITH results AS (
      UPDATE ${schema3}.job
      SET state = CASE
          WHEN retryCount < retryLimit THEN '${states.retry}'::${schema3}.job_state
          ELSE '${states.expired}'::${schema3}.job_state
          END,
        completedOn = ${retryCompletedOnCase},
        startAfter = ${retryStartAfterCase}
      WHERE state = '${states.active}'
        AND (startedOn + expireIn) < now()
      RETURNING *
    )
    INSERT INTO ${schema3}.job (name, data, keepUntil)
    SELECT
      '${COMPLETION_JOB_PREFIX}' || name,
      ${buildJsonCompletionObject()},
      ${keepUntilInheritance}
    FROM results
    WHERE state = '${states.expired}'
      AND NOT name LIKE '${COMPLETION_JOB_PREFIX}%'
      AND on_complete
  `;
  };
  var cancelJobs = function(schema3) {
    return `
    with results as (
      UPDATE ${schema3}.job
      SET completedOn = now(),
        state = '${states.cancelled}'
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
        AND state < '${states.completed}'
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
  };
  var resumeJobs = function(schema3) {
    return `
    with results as (
      UPDATE ${schema3}.job
      SET completedOn = NULL,
        state = '${states.created}'
      WHERE id IN (SELECT UNNEST(\$1::uuid[]))
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
  };
  var insertJob = function(schema3) {
    return `
    INSERT INTO ${schema3}.job (
      id,
      name,
      priority,
      state,
      retryLimit,
      startAfter,
      expireIn,
      data,
      singletonKey,
      singletonOn,
      retryDelay,
      retryBackoff,
      keepUntil,
      on_complete
    )
    SELECT
      id,
      name,
      priority,
      state,
      retryLimit,
      startAfter,
      expireIn,
      data,
      singletonKey,
      singletonOn,
      retryDelay,
      retryBackoff,
      keepUntil,
      on_complete
    FROM
    ( SELECT *,
        CASE
          WHEN right(keepUntilValue, 1) = 'Z' THEN CAST(keepUntilValue as timestamp with time zone)
          ELSE startAfter + CAST(COALESCE(keepUntilValue,'0') as interval)
          END as keepUntil
      FROM
      ( SELECT *,
          CASE
            WHEN right(startAfterValue, 1) = 'Z' THEN CAST(startAfterValue as timestamp with time zone)
            ELSE now() + CAST(COALESCE(startAfterValue,'0') as interval)
            END as startAfter
        FROM
        ( SELECT
            \$1::uuid as id,
            \$2::text as name,
            \$3::int as priority,
            '${states.created}'::${schema3}.job_state as state,
            \$4::int as retryLimit,
            \$5::text as startAfterValue,
            CAST(\$6 as interval) as expireIn,
            \$7::jsonb as data,
            \$8::text as singletonKey,
            CASE
              WHEN \$9::integer IS NOT NULL THEN 'epoch'::timestamp + '1 second'::interval * (\$9 * floor((date_part('epoch', now()) + \$10) / \$9))
              ELSE NULL
              END as singletonOn,
            \$11::int as retryDelay,
            \$12::bool as retryBackoff,
            \$13::text as keepUntilValue,
            \$14::boolean as on_complete
        ) j1
      ) j2
    ) j3
    ON CONFLICT DO NOTHING
    RETURNING id
  `;
  };
  var insertJobs = function(schema3) {
    return `
    INSERT INTO ${schema3}.job (
      id,
      name,
      data,
      priority,
      startAfter,
      expireIn,
      retryLimit,
      retryDelay,
      retryBackoff,
      singletonKey,
      keepUntil,
      on_complete
    )
    SELECT
      COALESCE(id, gen_random_uuid()) as id,
      name,
      data,
      COALESCE(priority, 0) as priority,
      COALESCE("startAfter", now()) as startAfter,
      COALESCE("expireInSeconds", 15 * 60) * interval '1s' as expireIn,
      COALESCE("retryLimit", 0) as retryLimit,
      COALESCE("retryDelay", 0) as retryDelay,
      COALESCE("retryBackoff", false) as retryBackoff,
      "singletonKey",
      COALESCE("keepUntil", now() + interval '14 days') as keepUntil,
      COALESCE("onComplete", false) as onComplete
    FROM json_to_recordset(\$1) as x(
      id uuid,
      name text,
      priority integer,
      data jsonb,
      "retryLimit" integer,
      "retryDelay" integer,
      "retryBackoff" boolean,
      "startAfter" timestamp with time zone,
      "singletonKey" text,
      "expireInSeconds" integer,
      "keepUntil" timestamp with time zone,
      "onComplete" boolean
    )
    ON CONFLICT DO NOTHING
  `;
  };
  var purge = function(schema3, interval) {
    return `
    DELETE FROM ${schema3}.archive
    WHERE archivedOn < (now() - interval '${interval}')
  `;
  };
  var archive = function(schema3, completedInterval, failedInterval = completedInterval) {
    return `
    WITH archived_rows AS (
      DELETE FROM ${schema3}.job
      WHERE (
          state <> '${states.failed}' AND completedOn < (now() - interval '${completedInterval}')
        )
        OR (
          state = '${states.failed}' AND completedOn < (now() - interval '${failedInterval}')
        )
        OR (
          state < '${states.active}' AND keepUntil < now()
        )
      RETURNING *
    )
    INSERT INTO ${schema3}.archive (
      id, name, priority, data, state, retryLimit, retryCount, retryDelay, retryBackoff, startAfter, startedOn, singletonKey, singletonOn, expireIn, createdOn, completedOn, keepUntil, on_complete, output
    )
    SELECT
      id, name, priority, data, state, retryLimit, retryCount, retryDelay, retryBackoff, startAfter, startedOn, singletonKey, singletonOn, expireIn, createdOn, completedOn, keepUntil, on_complete, output
    FROM archived_rows
  `;
  };
  var countStates = function(schema3) {
    return `
    SELECT name, state, count(*) size
    FROM ${schema3}.job
    GROUP BY rollup(name), rollup(state)
  `;
  };
  var advisoryLock = function(schema3) {
    return `SELECT pg_advisory_xact_lock(
      ('x' || md5(current_database() || '.pgboss.${schema3}'))::bit(64)::bigint
  )`;
  };
  var assertMigration = function(schema3, version2) {
    return `SELECT version::int/(version::int-${version2}) from ${schema3}.version`;
  };
  var getJobById = function(schema3) {
    return getJobByTableAndId(schema3, "job");
  };
  var getArchivedJobById = function(schema3) {
    return getJobByTableAndId(schema3, "archive");
  };
  var getJobByTableAndId = function(schema3, table) {
    return `SELECT * From ${schema3}.${table} WHERE id = \$1`;
  };
  var assert = import.meta.require("assert");
  var states = {
    created: "created",
    retry: "retry",
    active: "active",
    completed: "completed",
    expired: "expired",
    cancelled: "cancelled",
    failed: "failed"
  };
  var DEFAULT_SCHEMA = "pgboss";
  var COMPLETION_JOB_PREFIX = `__state__${states.completed}__`;
  var SINGLETON_QUEUE_KEY = "__pgboss__singleton_queue";
  var SINGLETON_QUEUE_KEY_ESCAPED = SINGLETON_QUEUE_KEY.replace(/_/g, "\\_");
  var MIGRATE_RACE_MESSAGE = "division by zero";
  var CREATE_RACE_MESSAGE = "already exists";
  module.exports = {
    create,
    insertVersion,
    getVersion,
    setVersion,
    versionTableExists,
    fetchNextJob,
    completeJobs,
    cancelJobs,
    resumeJobs,
    failJobs,
    insertJob,
    insertJobs,
    getTime,
    getSchedules,
    schedule,
    unschedule,
    subscribe: subscribe3,
    unsubscribe,
    getQueuesForEvent,
    expire,
    archive,
    purge,
    countStates,
    deleteQueue,
    deleteAllQueues,
    clearStorage,
    getQueueSize,
    getMaintenanceTime,
    setMaintenanceTime,
    getCronTime,
    setCronTime,
    locked,
    assertMigration,
    getArchivedJobById,
    getJobById,
    states: { ...states },
    COMPLETION_JOB_PREFIX,
    SINGLETON_QUEUE_KEY,
    MIGRATE_RACE_MESSAGE,
    CREATE_RACE_MESSAGE,
    DEFAULT_SCHEMA
  };
  var retryCompletedOnCase = `CASE
          WHEN retryCount < retryLimit
          THEN NULL
          ELSE now()
          END`;
  var retryStartAfterCase = `CASE
          WHEN retryCount = retryLimit THEN startAfter
          WHEN NOT retryBackoff THEN now() + retryDelay * interval '1'
          ELSE now() +
            (
                retryDelay * 2 ^ LEAST(16, retryCount + 1) / 2
                +
                retryDelay * 2 ^ LEAST(16, retryCount + 1) / 2 * random()
            )
            * interval '1'
          END`;
  var keepUntilInheritance = "keepUntil + (keepUntil - startAfter)";
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/attorney.js
var require_attorney = __commonJS((exports, module) => {
  var checkSendArgs = function(args, defaults) {
    let name, data, options;
    if (typeof args[0] === "string") {
      name = args[0];
      data = args[1];
      assert(typeof data !== "function", "send() cannot accept a function as the payload.  Did you intend to use work()?");
      options = args[2];
    } else if (typeof args[0] === "object") {
      assert(args.length === 1, "send object API only accepts 1 argument");
      const job = args[0];
      assert(job, "boss requires all jobs to have a name");
      name = job.name;
      data = job.data;
      options = job.options;
    }
    options = options || {};
    assert(name, "boss requires all jobs to have a queue name");
    assert(typeof options === "object", "options should be an object");
    options = { ...options };
    assert(!("priority" in options) || Number.isInteger(options.priority), "priority must be an integer");
    options.priority = options.priority || 0;
    applyRetryConfig(options, defaults);
    applyExpirationConfig(options, defaults);
    applyRetentionConfig(options, defaults);
    applyCompletionConfig(options, defaults);
    applySingletonKeyConfig(options);
    const { startAfter, singletonSeconds, singletonMinutes, singletonHours } = options;
    options.startAfter = startAfter instanceof Date && typeof startAfter.toISOString === "function" ? startAfter.toISOString() : startAfter > 0 ? "" + startAfter : typeof startAfter === "string" ? startAfter : null;
    options.singletonSeconds = singletonHours > 0 ? singletonHours * 60 * 60 : singletonMinutes > 0 ? singletonMinutes * 60 : singletonSeconds > 0 ? singletonSeconds : null;
    assert(!singletonSeconds || singletonSeconds <= defaults.archiveSeconds, `throttling interval ${singletonSeconds}s cannot exceed archive interval ${defaults.archiveSeconds}s`);
    return { name, data, options };
  };
  var checkInsertArgs = function(jobs) {
    assert(Array.isArray(jobs), `jobs argument should be an array.  Received '${typeof jobs}'`);
    return jobs.map((job) => {
      job = { ...job };
      applySingletonKeyConfig(job);
      return job;
    });
  };
  var applySingletonKeyConfig = function(options) {
    if (options.singletonKey && options.useSingletonQueue && options.singletonKey !== SINGLETON_QUEUE_KEY) {
      options.singletonKey = SINGLETON_QUEUE_KEY + options.singletonKey;
    }
    delete options.useSingletonQueue;
  };
  var checkWorkArgs = function(name, args, defaults) {
    let options, callback;
    assert(name, "missing job name");
    if (args.length === 1) {
      callback = args[0];
      options = {};
    } else if (args.length > 1) {
      options = args[0] || {};
      callback = args[1];
    }
    assert(typeof callback === "function", "expected callback to be a function");
    assert(typeof options === "object", "expected config to be an object");
    options = { ...options };
    applyNewJobCheckInterval(options, defaults);
    assert(!("teamConcurrency" in options) || Number.isInteger(options.teamConcurrency) && options.teamConcurrency >= 1 && options.teamConcurrency <= 1000, "teamConcurrency must be an integer between 1 and 1000");
    assert(!("teamSize" in options) || Number.isInteger(options.teamSize) && options.teamSize >= 1, "teamSize must be an integer > 0");
    assert(!("batchSize" in options) || Number.isInteger(options.batchSize) && options.batchSize >= 1, "batchSize must be an integer > 0");
    assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
    assert(!("enforceSingletonQueueActiveLimit" in options) || typeof options.enforceSingletonQueueActiveLimit === "boolean", "enforceSingletonQueueActiveLimit must be a boolean");
    return { options, callback };
  };
  var checkFetchArgs = function(name, batchSize, options) {
    assert(name, "missing queue name");
    name = sanitizeQueueNameForFetch(name);
    assert(!batchSize || Number.isInteger(batchSize) && batchSize >= 1, "batchSize must be an integer > 0");
    assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
    assert(!("enforceSingletonQueueActiveLimit" in options) || typeof options.enforceSingletonQueueActiveLimit === "boolean", "enforceSingletonQueueActiveLimit must be a boolean");
    return { name };
  };
  var sanitizeQueueNameForFetch = function(name) {
    return name.replace(/[%_*]/g, (match) => match === "*" ? "%" : "\\" + match);
  };
  var getConfig = function(value) {
    assert(value && (typeof value === "object" || typeof value === "string"), "configuration assert: string or config object is required to connect to postgres");
    const config = typeof value === "string" ? { connectionString: value } : { ...value };
    applyDatabaseConfig(config);
    applyMaintenanceConfig(config);
    applyArchiveConfig(config);
    applyArchiveFailedConfig(config);
    applyDeleteConfig(config);
    applyMonitoringConfig(config);
    applyUuidConfig(config);
    applyNewJobCheckInterval(config);
    applyExpirationConfig(config);
    applyRetentionConfig(config);
    applyCompletionConfig(config);
    return config;
  };
  var applyDatabaseConfig = function(config) {
    if (config.schema) {
      assert(typeof config.schema === "string", "configuration assert: schema must be a string");
      assert(config.schema.length <= 50, "configuration assert: schema name cannot exceed 50 characters");
      assert(!/\W/.test(config.schema), `configuration assert: ${config.schema} cannot be used as a schema. Only alphanumeric characters and underscores are allowed`);
    }
    config.schema = config.schema || DEFAULT_SCHEMA;
  };
  var applyArchiveConfig = function(config) {
    const ARCHIVE_DEFAULT = 60 * 60 * 12;
    assert(!("archiveCompletedAfterSeconds" in config) || config.archiveCompletedAfterSeconds >= 1, "configuration assert: archiveCompletedAfterSeconds must be at least every second and less than ");
    config.archiveSeconds = config.archiveCompletedAfterSeconds || ARCHIVE_DEFAULT;
    config.archiveInterval = `${config.archiveSeconds} seconds`;
    if (config.archiveSeconds < 60) {
      emitWarning2(WARNINGS.CRON_DISABLED);
    }
  };
  var applyArchiveFailedConfig = function(config) {
    assert(!("archiveFailedAfterSeconds" in config) || config.archiveFailedAfterSeconds >= 1, "configuration assert: archiveFailedAfterSeconds must be at least every second and less than ");
    config.archiveFailedSeconds = config.archiveFailedAfterSeconds || config.archiveSeconds;
    config.archiveFailedInterval = `${config.archiveFailedSeconds} seconds`;
    if (config.archiveFailedSeconds < 60 && config.archiveSeconds >= 60) {
      emitWarning2(WARNINGS.CRON_DISABLED);
    }
  };
  var applyCompletionConfig = function(config, defaults) {
    assert(!("onComplete" in config) || config.onComplete === true || config.onComplete === false, "configuration assert: onComplete must be either true or false");
    if (!("onComplete" in config)) {
      config.onComplete = defaults ? defaults.onComplete : false;
    }
  };
  var applyRetentionConfig = function(config, defaults) {
    assert(!("retentionSeconds" in config) || config.retentionSeconds >= 1, "configuration assert: retentionSeconds must be at least every second");
    assert(!("retentionMinutes" in config) || config.retentionMinutes >= 1, "configuration assert: retentionMinutes must be at least every minute");
    assert(!("retentionHours" in config) || config.retentionHours >= 1, "configuration assert: retentionHours must be at least every hour");
    assert(!("retentionDays" in config) || config.retentionDays >= 1, "configuration assert: retentionDays must be at least every day");
    const keepUntil = "retentionDays" in config ? `${config.retentionDays} days` : ("retentionHours" in config) ? `${config.retentionHours} hours` : ("retentionMinutes" in config) ? `${config.retentionMinutes} minutes` : ("retentionSeconds" in config) ? `${config.retentionSeconds} seconds` : defaults ? defaults.keepUntil : "14 days";
    config.keepUntil = keepUntil;
  };
  var applyExpirationConfig = function(config, defaults) {
    if ("expireIn" in config) {
      emitWarning2(WARNINGS.EXPIRE_IN_REMOVED);
    }
    assert(!("expireInSeconds" in config) || config.expireInSeconds >= 1, "configuration assert: expireInSeconds must be at least every second");
    assert(!("expireInMinutes" in config) || config.expireInMinutes >= 1, "configuration assert: expireInMinutes must be at least every minute");
    assert(!("expireInHours" in config) || config.expireInHours >= 1, "configuration assert: expireInHours must be at least every hour");
    const expireIn = "expireInHours" in config ? `${config.expireInHours} hours` : ("expireInMinutes" in config) ? `${config.expireInMinutes} minutes` : ("expireInSeconds" in config) ? `${config.expireInSeconds} seconds` : defaults ? defaults.expireIn : "15 minutes";
    config.expireIn = expireIn;
  };
  var applyRetryConfig = function(config, defaults) {
    assert(!("retryDelay" in config) || Number.isInteger(config.retryDelay) && config.retryDelay >= 0, "retryDelay must be an integer >= 0");
    assert(!("retryLimit" in config) || Number.isInteger(config.retryLimit) && config.retryLimit >= 0, "retryLimit must be an integer >= 0");
    assert(!("retryBackoff" in config) || (config.retryBackoff === true || config.retryBackoff === false), "retryBackoff must be either true or false");
    if (defaults) {
      config.retryDelay = config.retryDelay || defaults.retryDelay;
      config.retryLimit = config.retryLimit || defaults.retryLimit;
      config.retryBackoff = config.retryBackoff || defaults.retryBackoff;
    }
    config.retryDelay = config.retryDelay || 0;
    config.retryLimit = config.retryLimit || 0;
    config.retryBackoff = !!config.retryBackoff;
    config.retryDelay = config.retryBackoff && !config.retryDelay ? 1 : config.retryDelay;
    config.retryLimit = config.retryDelay && !config.retryLimit ? 1 : config.retryLimit;
  };
  var applyNewJobCheckInterval = function(config, defaults) {
    const second = 1000;
    assert(!("newJobCheckInterval" in config) || config.newJobCheckInterval >= 100, "configuration assert: newJobCheckInterval must be at least every 100ms");
    assert(!("newJobCheckIntervalSeconds" in config) || config.newJobCheckIntervalSeconds >= 1, "configuration assert: newJobCheckIntervalSeconds must be at least every second");
    config.newJobCheckInterval = ("newJobCheckIntervalSeconds" in config) ? config.newJobCheckIntervalSeconds * second : ("newJobCheckInterval" in config) ? config.newJobCheckInterval : defaults ? defaults.newJobCheckInterval : second * 2;
  };
  var applyMaintenanceConfig = function(config) {
    assert(!("maintenanceIntervalSeconds" in config) || config.maintenanceIntervalSeconds >= 1, "configuration assert: maintenanceIntervalSeconds must be at least every second");
    assert(!("maintenanceIntervalMinutes" in config) || config.maintenanceIntervalMinutes >= 1, "configuration assert: maintenanceIntervalMinutes must be at least every minute");
    config.maintenanceIntervalSeconds = ("maintenanceIntervalMinutes" in config) ? config.maintenanceIntervalMinutes * 60 : ("maintenanceIntervalSeconds" in config) ? config.maintenanceIntervalSeconds : 120;
  };
  var applyDeleteConfig = function(config) {
    assert(!("deleteAfterSeconds" in config) || config.deleteAfterSeconds >= 1, "configuration assert: deleteAfterSeconds must be at least every second");
    assert(!("deleteAfterMinutes" in config) || config.deleteAfterMinutes >= 1, "configuration assert: deleteAfterMinutes must be at least every minute");
    assert(!("deleteAfterHours" in config) || config.deleteAfterHours >= 1, "configuration assert: deleteAfterHours must be at least every hour");
    assert(!("deleteAfterDays" in config) || config.deleteAfterDays >= 1, "configuration assert: deleteAfterDays must be at least every day");
    const deleteAfter = "deleteAfterDays" in config ? `${config.deleteAfterDays} days` : ("deleteAfterHours" in config) ? `${config.deleteAfterHours} hours` : ("deleteAfterMinutes" in config) ? `${config.deleteAfterMinutes} minutes` : ("deleteAfterSeconds" in config) ? `${config.deleteAfterSeconds} seconds` : "7 days";
    config.deleteAfter = deleteAfter;
  };
  var applyMonitoringConfig = function(config) {
    assert(!("monitorStateIntervalSeconds" in config) || config.monitorStateIntervalSeconds >= 1, "configuration assert: monitorStateIntervalSeconds must be at least every second");
    assert(!("monitorStateIntervalMinutes" in config) || config.monitorStateIntervalMinutes >= 1, "configuration assert: monitorStateIntervalMinutes must be at least every minute");
    config.monitorStateIntervalSeconds = ("monitorStateIntervalMinutes" in config) ? config.monitorStateIntervalMinutes * 60 : ("monitorStateIntervalSeconds" in config) ? config.monitorStateIntervalSeconds : null;
    const TEN_MINUTES_IN_SECONDS = 600;
    assert(!("clockMonitorIntervalSeconds" in config) || config.clockMonitorIntervalSeconds >= 1 && config.clockMonitorIntervalSeconds <= TEN_MINUTES_IN_SECONDS, "configuration assert: clockMonitorIntervalSeconds must be between 1 second and 10 minutes");
    assert(!("clockMonitorIntervalMinutes" in config) || config.clockMonitorIntervalMinutes >= 1 && config.clockMonitorIntervalMinutes <= 10, "configuration assert: clockMonitorIntervalMinutes must be between 1 and 10");
    config.clockMonitorIntervalSeconds = ("clockMonitorIntervalMinutes" in config) ? config.clockMonitorIntervalMinutes * 60 : ("clockMonitorIntervalSeconds" in config) ? config.clockMonitorIntervalSeconds : TEN_MINUTES_IN_SECONDS;
    assert(!("cronMonitorIntervalSeconds" in config) || config.cronMonitorIntervalSeconds >= 1 && config.cronMonitorIntervalSeconds <= 60, "configuration assert: cronMonitorIntervalSeconds must be between 1 and 60 seconds");
    config.cronMonitorIntervalSeconds = ("cronMonitorIntervalSeconds" in config) ? config.cronMonitorIntervalSeconds : 60;
    assert(!("cronWorkerIntervalSeconds" in config) || config.cronWorkerIntervalSeconds >= 1 && config.cronWorkerIntervalSeconds <= 60, "configuration assert: cronWorkerIntervalSeconds must be between 1 and 60 seconds");
    config.cronWorkerIntervalSeconds = ("cronWorkerIntervalSeconds" in config) ? config.cronWorkerIntervalSeconds : 4;
  };
  var applyUuidConfig = function(config) {
    assert(!("uuid" in config) || config.uuid === "v1" || config.uuid === "v4", "configuration assert: uuid option only supports v1 or v4");
    config.uuid = config.uuid || "v4";
  };
  var warnClockSkew = function(message) {
    emitWarning2(WARNINGS.CLOCK_SKEW, message, { force: true });
  };
  var emitWarning2 = function(warning, message, options = {}) {
    const { force } = options;
    if (force || !warning.warned) {
      warning.warned = true;
      message = `${warning.message} ${message || ""}`;
      process.emitWarning(message, warning.type, warning.code);
    }
  };
  var assert = import.meta.require("assert");
  var { DEFAULT_SCHEMA, SINGLETON_QUEUE_KEY } = require_plans();
  module.exports = {
    getConfig,
    checkSendArgs,
    checkInsertArgs,
    checkWorkArgs,
    checkFetchArgs,
    warnClockSkew
  };
  var WARNINGS = {
    EXPIRE_IN_REMOVED: {
      message: "\'expireIn\' option detected. This option has been removed. Use expireInSeconds, expireInMinutes or expireInHours.",
      code: "pg-boss-w01"
    },
    CLOCK_SKEW: {
      message: "Timekeeper detected clock skew between this instance and the database server. This will not affect scheduling operations, but this warning is shown any time the skew exceeds 60 seconds.",
      code: "pg-boss-w02"
    },
    CRON_DISABLED: {
      message: "Archive interval is set less than 60s.  Cron processing is disabled.",
      code: "pg-boss-w03"
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/migrationStore.js
var require_migrationStore = __commonJS((exports, module) => {
  var flatten = function(schema3, commands, version2) {
    commands.unshift(plans.assertMigration(schema3, version2));
    commands.push(plans.setVersion(schema3, version2));
    return plans.locked(schema3, commands);
  };
  var rollback = function(schema3, version2, migrations) {
    migrations = migrations || getAll(schema3);
    const result = migrations.find((i) => i.version === version2);
    assert(result, `Version ${version2} not found.`);
    return flatten(schema3, result.uninstall || [], result.previous);
  };
  var next = function(schema3, version2, migrations) {
    migrations = migrations || getAll(schema3);
    const result = migrations.find((i) => i.previous === version2);
    assert(result, `Version ${version2} not found.`);
    return flatten(schema3, result.install, result.version);
  };
  var migrate = function(value, version2, migrations) {
    let schema3, config;
    if (typeof value === "string") {
      config = null;
      schema3 = value;
    } else {
      config = value;
      schema3 = config.schema;
    }
    migrations = migrations || getAll(schema3, config);
    const result = migrations.filter((i) => i.previous >= version2).sort((a, b) => a.version - b.version).reduce((acc, i) => {
      acc.install = acc.install.concat(i.install);
      acc.version = i.version;
      return acc;
    }, { install: [], version: version2 });
    assert(result.install.length > 0, `Version ${version2} not found.`);
    return flatten(schema3, result.install, result.version);
  };
  var getAll = function(schema3) {
    return [
      {
        release: "7.4.0",
        version: 20,
        previous: 19,
        install: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey LIKE '\\_\\_pgboss\\_\\_singleton\\_queue%'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey LIKE '\\_\\_pgboss\\_\\_singleton\\_queue%'`
        ],
        uninstall: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey = '__pgboss__singleton_queue'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey = '__pgboss__singleton_queue'`
        ]
      },
      {
        release: "7.0.0",
        version: 19,
        previous: 18,
        install: [
          `CREATE TABLE ${schema3}.subscription (
          event text not null,
          name text not null,
          created_on timestamp with time zone not null default now(),
          updated_on timestamp with time zone not null default now(),
          PRIMARY KEY(event, name)
        )`
        ],
        uninstall: [
          `DROP TABLE ${schema3}.subscription`
        ]
      },
      {
        release: "6.1.1",
        version: 18,
        previous: 17,
        install: [
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT false`
        ]
      },
      {
        release: "6.0.0",
        version: 17,
        previous: 16,
        install: [
          `DROP INDEX ${schema3}.job_singletonKey`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL AND NOT singletonKey = '__pgboss__singleton_queue'`,
          `CREATE UNIQUE INDEX job_singleton_queue ON ${schema3}.job (name, singletonKey) WHERE state < 'active' AND singletonOn IS NULL AND singletonKey = '__pgboss__singleton_queue'`,
          `CREATE INDEX IF NOT EXISTS job_fetch ON ${schema3}.job (name text_pattern_ops, startAfter) WHERE state < 'active'`,
          `ALTER TABLE ${schema3}.job ADD output jsonb`,
          `ALTER TABLE ${schema3}.archive ADD output jsonb`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT false`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN keepuntil SET DEFAULT now() + interval '14 days'`
        ],
        uninstall: [
          `DROP INDEX ${schema3}.job_fetch`,
          `DROP INDEX ${schema3}.job_singleton_queue`,
          `DROP INDEX ${schema3}.job_singletonKey`,
          `CREATE UNIQUE INDEX job_singletonKey ON ${schema3}.job (name, singletonKey) WHERE state < 'completed' AND singletonOn IS NULL`,
          `ALTER TABLE ${schema3}.job DROP COLUMN output`,
          `ALTER TABLE ${schema3}.archive DROP COLUMN output`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN keepuntil SET DEFAULT now() + interval '30 days'`
        ]
      },
      {
        release: "5.2.0",
        version: 16,
        previous: 15,
        install: [
          `ALTER TABLE ${schema3}.job ADD on_complete boolean`,
          `UPDATE ${schema3}.job SET on_complete = true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET DEFAULT true`,
          `ALTER TABLE ${schema3}.job ALTER COLUMN on_complete SET NOT NULL`,
          `ALTER TABLE ${schema3}.archive ADD on_complete boolean`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.job DROP COLUMN on_complete`,
          `ALTER TABLE ${schema3}.archive DROP COLUMN on_complete`
        ]
      },
      {
        release: "5.0.6",
        version: 15,
        previous: 14,
        install: [
          `ALTER TABLE ${schema3}.version ADD cron_on timestamp with time zone`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.version DROP COLUMN cron_on`
        ]
      },
      {
        release: "5.0.0",
        version: 14,
        previous: 13,
        install: [
          `ALTER TABLE ${schema3}.version ADD maintained_on timestamp with time zone`
        ],
        uninstall: [
          `ALTER TABLE ${schema3}.version DROP COLUMN maintained_on`
        ]
      }
    ];
  };
  var assert = import.meta.require("assert");
  var plans = require_plans();
  module.exports = {
    rollback,
    next,
    migrate,
    getAll
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/version.json
var require_version = __commonJS((exports, module) => {
  module.exports = {
    schema: 20
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/contractor.js
var require_contractor = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var plans = require_plans();
  var { DEFAULT_SCHEMA } = plans;
  var migrationStore = require_migrationStore();
  var schemaVersion = require_version().schema;

  class Contractor {
    static constructionPlans(schema3 = DEFAULT_SCHEMA) {
      return plans.create(schema3, schemaVersion);
    }
    static migrationPlans(schema3 = DEFAULT_SCHEMA, version2 = schemaVersion - 1) {
      return migrationStore.migrate(schema3, version2);
    }
    static rollbackPlans(schema3 = DEFAULT_SCHEMA, version2 = schemaVersion) {
      return migrationStore.rollback(schema3, version2);
    }
    constructor(db, config) {
      this.config = config;
      this.db = db;
      this.migrations = this.config.migrations || migrationStore.getAll(this.config.schema);
    }
    async version() {
      const result = await this.db.executeSql(plans.getVersion(this.config.schema));
      return result.rows.length ? parseInt(result.rows[0].version) : null;
    }
    async isInstalled() {
      const result = await this.db.executeSql(plans.versionTableExists(this.config.schema));
      return result.rows.length ? result.rows[0].name : null;
    }
    async start() {
      const installed = await this.isInstalled();
      if (installed) {
        const version2 = await this.version();
        if (schemaVersion > version2) {
          await this.migrate(version2);
        }
      } else {
        await this.create();
      }
    }
    async create() {
      try {
        const commands = plans.create(this.config.schema, schemaVersion);
        await this.db.executeSql(commands);
      } catch (err) {
        assert(err.message.includes(plans.CREATE_RACE_MESSAGE), err);
      }
    }
    async migrate(version2) {
      try {
        const commands = migrationStore.migrate(this.config, version2, this.migrations);
        await this.db.executeSql(commands);
      } catch (err) {
        assert(err.message.includes(plans.MIGRATE_RACE_MESSAGE), err);
      }
    }
    async next(version2) {
      const commands = migrationStore.next(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    }
    async rollback(version2) {
      const commands = migrationStore.rollback(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    }
  }
  module.exports = Contractor;
});

// /Users/richardguerre/Projects/flow/node_modules/delay/index.js
var require_delay = __commonJS((exports, module) => {
  var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
  var createAbortError = () => {
    const error8 = new Error("Delay aborted");
    error8.name = "AbortError";
    return error8;
  };
  var createDelay = ({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (ms, { value, signal } = {}) => {
    if (signal && signal.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFn;
    const clear = defaultClear || clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFn(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject2) => {
      settle = () => {
        cleanup();
        if (willResolve) {
          resolve(value);
        } else {
          reject2(value);
        }
      };
      rejectFn = reject2;
      timeoutId = (set || setTimeout)(settle, ms);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    delayPromise.clear = () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    };
    return delayPromise;
  };
  var createWithTimers = (clearAndSet) => {
    const delay2 = createDelay({ ...clearAndSet, willResolve: true });
    delay2.reject = createDelay({ ...clearAndSet, willResolve: false });
    delay2.range = (minimum, maximum, options) => delay2(randomInteger(minimum, maximum), options);
    return delay2;
  };
  var delay = createWithTimers();
  delay.createWithTimers = createWithTimers;
  module.exports = delay;
  module.exports.default = delay;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate3 = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate3;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  };
  var stringify4 = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = stringify4;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node3 = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node3 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node3 == null) {
        node3 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node3[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse2 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse2;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify2();
  var _parse = _interopRequireDefault(require_parse2());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify2();
  var _default = v4;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/version.js
var require_version2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version2 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version2;
  exports.default = _default;
});

// /Users/richardguerre/Projects/flow/node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version2());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify2());
  var _parse = _interopRequireDefault(require_parse2());
});

// /Users/richardguerre/Projects/flow/node_modules/lodash.debounce/index.js
var require_lodash = __commonJS((exports, module) => {
  var debounce = function(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = ("maxWait" in options);
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = ("trailing" in options) ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = undefined;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }
    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  };
  var isObject2 = function(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  };
  var isObjectLike11 = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike11(value) && objectToString.call(value) == symbolTag;
  };
  var toNumber = function(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root6 = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var now = function() {
    return root6.Date.now();
  };
  module.exports = debounce;
});

// /Users/richardguerre/Projects/flow/node_modules/serialize-error/index.js
var require_serialize_error = __commonJS((exports, module) => {
  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
  }
  var commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  var isCalled = Symbol(".toJSON called");
  var toJSON = (from) => {
    from[isCalled] = true;
    const json = from.toJSON();
    delete from[isCalled];
    return json;
  };
  var destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value === "function") {
        continue;
      }
      if (!value || typeof value !== "object") {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  var serializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === "object" && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value === "function") {
      return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
  };
  var deserializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
      return value;
    }
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const newError = new Error;
      destroyCircular({
        from: value,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value);
  };
  module.exports = {
    serializeError,
    deserializeError
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/worker.js
var require_worker = __commonJS((exports, module) => {
  var delay = require_delay();
  var WORKER_STATES = {
    created: "created",
    active: "active",
    stopping: "stopping",
    stopped: "stopped"
  };

  class Worker {
    constructor({ id, name, options, interval, fetch: fetch6, onFetch, onError }) {
      this.id = id;
      this.name = name;
      this.options = options;
      this.fetch = fetch6;
      this.onFetch = onFetch;
      this.onError = onError;
      this.interval = interval;
      this.jobs = [];
      this.createdOn = Date.now();
      this.lastFetchedOn = null;
      this.lastJobStartedOn = null;
      this.lastJobEndedOn = null;
      this.lastError = null;
      this.lastErrorOn = null;
      this.state = WORKER_STATES.created;
      this.stopping = false;
      this.stopped = false;
      this.loopDelayPromise = null;
      this.beenNotified = false;
    }
    notify() {
      this.beenNotified = true;
      if (this.loopDelayPromise) {
        this.loopDelayPromise.clear();
      }
    }
    async start() {
      this.state = WORKER_STATES.active;
      while (!this.stopping) {
        const started = Date.now();
        try {
          this.beenNotified = false;
          const jobs = await this.fetch();
          this.lastFetchedOn = Date.now();
          if (jobs) {
            this.jobs = jobs;
            this.lastJobStartedOn = this.lastFetchedOn;
            await this.onFetch(jobs);
            this.lastJobEndedOn = Date.now();
            this.jobs = [];
          }
        } catch (err) {
          this.lastErrorOn = Date.now();
          this.lastError = err;
          err.message = `${err.message} (Queue: ${this.name}, Worker: ${this.id})`;
          this.onError(err);
        }
        const duration = Date.now() - started;
        this.lastJobDuration = duration;
        if (!this.stopping && !this.beenNotified && duration < this.interval) {
          this.loopDelayPromise = delay(this.interval - duration);
          await this.loopDelayPromise;
          this.loopDelayPromise = null;
        }
      }
      this.stopping = false;
      this.stopped = true;
      this.state = WORKER_STATES.stopped;
    }
    stop() {
      this.stopping = true;
      this.state = WORKER_STATES.stopping;
      if (this.loopDelayPromise) {
        this.loopDelayPromise.clear();
      }
    }
  }
  module.exports = Worker;
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  var identity2 = function(value) {
    return value;
  };
  exports.parse = function(source2, transform) {
    return new ArrayParser(source2, transform).parse();
  };

  class ArrayParser {
    constructor(source2, transform) {
      this.source = source2;
      this.transform = transform || identity2;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source2, transform) {
      return {
        parse: function() {
          return array.parse(source2, transform);
        }
      };
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var getDate = function(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var date = new Date(year, month, day2);
    if (is0To99(year)) {
      date.setFullYear(year);
    }
    return date;
  };
  var timeZoneOffset = function(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type2 = zone[1];
    if (type2 === "Z") {
      return 0;
    }
    var sign = type2 === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  };
  var bcYearToNegativeYear = function(year) {
    return -(year - 1);
  };
  var is0To99 = function(num) {
    return num >= 0 && num < 100;
  };
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date = new Date(Date.UTC(year, month, day2, hour, minute, second, ms));
      if (is0To99(year)) {
        date.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date.setTime(date.getTime() - offset);
      }
    } else {
      date = new Date(year, month, day2, hour, minute, second, ms);
      if (is0To99(year)) {
        date.setFullYear(year);
      }
    }
    return date;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  var extend = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (hasOwnProperty3.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  module.exports = extend;
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var PostgresInterval = function(raw2) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw2);
    }
    extend(this, parse2(raw2));
  };
  var parseMilliseconds = function(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  };
  var parse2 = function(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  };
  var extend = require_mutable();
  module.exports = PostgresInterval;
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
});

// /Users/richardguerre/Projects/flow/node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input6) {
    if (/^\\x/.test(input6)) {
      return new Buffer(input6.substr(2), "hex");
    }
    var output2 = "";
    var i = 0;
    while (i < input6.length) {
      if (input6[i] !== "\\") {
        output2 += input6[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input6.substr(i + 1, 3))) {
          output2 += String.fromCharCode(parseInt(input6.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input6.length && input6[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output2 += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output2, "binary");
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var allowNull = function(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  };
  var parseBool = function(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  };
  var parseBoolArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  };
  var parseBaseTenInt = function(string) {
    return parseInt(string, 10);
  };
  var parseIntegerArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  };
  var parseBigIntegerArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  };
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate2 = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate2(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate2);
    register(1114, parseDate2);
    register(1184, parseDate2);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var readInt8 = function(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  };
  var BASE = 1e6;
  module.exports = readInt8;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : (-Infinity);
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate2 = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse2 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse2(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse2(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate2.bind(null, false));
    register(1184, parseDate2.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var noParse = function(val) {
    return String(val);
  };
  var getTypeParser = function(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  };
  var setTypeParser = function(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  };
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : "richardguerre",
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var escapeElement = function(elementRepresentation) {
    var escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + escaped + '"';
  };
  var arrayString = function(val) {
    var result = "{";
    for (var i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (val[i] instanceof Buffer) {
        result += "\\\\x" + val[i].toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  };
  var prepareObject = function(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  };
  var pad = function(number, digits) {
    number = "" + number;
    while (number.length < digits) {
      number = "0" + number;
    }
    return number;
  };
  var dateToString = function(date) {
    var offset = -date.getTimezoneOffset();
    var year = date.getFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = pad(year, 4) + "-" + pad(date.getMonth() + 1, 2) + "-" + pad(date.getDate(), 2) + "T" + pad(date.getHours(), 2) + ":" + pad(date.getMinutes(), 2) + ":" + pad(date.getSeconds(), 2) + "." + pad(date.getMilliseconds(), 3);
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += pad(Math.floor(offset / 60), 2) + ":" + pad(offset % 60, 2);
    if (isBCYear)
      ret += " BC";
    return ret;
  };
  var dateToStringUTC = function(date) {
    var year = date.getUTCFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = pad(year, 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + "T" + pad(date.getUTCHours(), 2) + ":" + pad(date.getUTCMinutes(), 2) + ":" + pad(date.getUTCSeconds(), 2) + "." + pad(date.getUTCMilliseconds(), 3);
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  };
  var normalizeQueryConfig = function(config, values4, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values4) {
      if (typeof values4 === "function") {
        config.callback = values4;
      } else {
        config.values = values4;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  };
  var defaults = require_defaults();
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (val instanceof Buffer) {
      return val;
    }
    if (ArrayBuffer.isView(val)) {
      var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
      if (buf.length === val.byteLength) {
        return buf;
      }
      return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
    }
    if (val instanceof Date) {
      if (defaults.parseInputDatesAsUTC) {
        return dateToStringUTC(val);
      } else {
        return dateToString(val);
      }
    }
    if (Array.isArray(val)) {
      return arrayString(val);
    }
    if (typeof val === "object") {
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    var hasBackslash = false;
    var escaped = "'";
    for (var i = 0;i < str.length; i++) {
      var c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var md5 = function(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  };
  var postgresMd5PasswordHash = function(user, password, salt) {
    var inner = md5(password + user);
    var outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  };
  var sha256 = function(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  };
  var hmacSha256 = function(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  };
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var randomBytes = function(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  };
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    var inner = await md5(password + user);
    var outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params3 = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params3, key, 32 * 8, ["deriveBits"]);
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var startSession = function(mechanisms) {
    if (mechanisms.indexOf("SCRAM-SHA-256") === -1) {
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    return {
      mechanism: "SCRAM-SHA-256",
      clientNonce,
      response: "n,,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  };
  async function continueSession(session, password, serverData) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    var clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    var serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    var clientFinalMessageWithoutProof = "c=biws,r=" + sv.nonce;
    var authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    var saltBytes = Buffer.from(sv.salt, "base64");
    var saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    var clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    var storedKey = await crypto2.sha256(clientKey);
    var clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    var clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    var serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    var serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  var finalizeSession = function(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  };
  var isPrintableChars = function(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  };
  var isBase64 = function(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  };
  var parseAttributePairs = function(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  };
  var parseServerFirstMessage = function(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  };
  var parseServerFinalMessage = function(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  };
  var xorBuffers = function(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  };
  var crypto2 = require_utils4();
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var TypeOverrides = function(userTypes) {
    this._types = userTypes || types24;
    this.text = {};
    this.binary = {};
  };
  var types24 = require_pg_types();
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  var parse2 = function(str) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
    }
    try {
      result = new URL(str, "postgres://base");
    } catch (e) {
      result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
      dummyHost = true;
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? import.meta.require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    switch (config.sslmode) {
      case "disable": {
        config.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full": {
        break;
      }
      case "no-verify": {
        config.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return config;
  };
  module.exports = parse2;
  parse2.parse = parse2;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = import.meta.require("dns");
  var defaults = require_defaults();
  var parse2 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {
    } else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params3, config, paramName) {
    var value = config[paramName];
    if (value !== undefined && value !== null) {
      params3.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse2(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse2(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      var params3 = [];
      add(params3, this, "user");
      add(params3, this, "password");
      add(params3, this, "port");
      add(params3, this, "application_name");
      add(params3, this, "fallback_application_name");
      add(params3, this, "connect_timeout");
      add(params3, this, "options");
      var ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params3, ssl, "sslmode");
      add(params3, ssl, "sslca");
      add(params3, ssl, "sslkey");
      add(params3, ssl, "sslcert");
      add(params3, ssl, "sslrootcert");
      if (this.database) {
        params3.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params3.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params3.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params3.join(" "));
      }
      if (this.client_encoding) {
        params3.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params3.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params3.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types24 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types25) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types25;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      var match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      var row = new Array(rowData.length);
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      var row = { ...this._prebuiltEmptyResultObject };
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        var field3 = this.fields[i].name;
        if (rawValue !== null) {
          row[field3] = this._parsers[i](rawValue);
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      for (var i = 0;i < fieldDescriptions.length; i++) {
        var desc = fieldDescriptions[i];
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types24.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._createPrebuiltEmptyResultObject();
    }
    _createPrebuiltEmptyResultObject() {
      var row = {};
      for (var i = 0;i < this.fields.length; i++) {
        row[this.fields[i].name] = null;
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = import.meta.require("events");
  var Result = require_result();
  var utils32 = require_utils3();

  class Query extends EventEmitter {
    constructor(config, values4, callback) {
      super();
      config = utils32.normalizeQueryConfig(config, values4, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this.isPreparedStatement = false;
      this._canceledDueToError = false;
      this._promise = null;
    }
    requiresPreparation() {
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this.types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection2) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection2.sync();
      }
    }
    handleEmptyQuery(connection2) {
      if (this.rows) {
        connection2.sync();
      }
    }
    handleError(err, connection2) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection2) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection2.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        this.prepare(connection2);
      } else {
        connection2.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection2) {
      return this.name && connection2.parsedStatements[this.name];
    }
    handlePortalSuspended(connection2) {
      this._getRows(connection2, this.rows);
    }
    _getRows(connection2, rows) {
      connection2.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection2.sync();
      } else {
        connection2.flush();
      }
    }
    prepare(connection2) {
      this.isPreparedStatement = true;
      if (!this.hasBeenParsed(connection2)) {
        connection2.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection2.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils32.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection2);
        return;
      }
      connection2.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection2, this.rows);
    }
    handleCopyInResponse(connection2) {
      connection2.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection2) {
    }
  }
  module.exports = Query;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      var remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        var oldBuffer = this.buffer;
        var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        var len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      var len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      var result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    var bodyBuffer = writer.addCString("").flush();
    var length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query3 = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse2 = (query4) => {
    const name = query4.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types24 = query4.types || emptyArray;
    var len = types24.length;
    var buffer = writer.addCString(name).addCString(query4.text).addInt16(len);
    for (var i = 0;i < len; i++) {
      buffer.addInt32(types24[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values4, valueMapper) {
    for (let i = 0;i < values4.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values4[i], i) : values4[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values4 = config.values || emptyArray;
    const len = values4.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values4, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute5 = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query: query3,
    parse: parse2,
    bind,
    execute: execute5,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {
      }
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var assert_1 = __importDefault(import.meta.require("assert"));
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser2 {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          assert_1.default.fail(`unknown message code: ${code.toString(16)}`);
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.int32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.int32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          message.name = "authenticationSASL";
          message.mechanisms = [];
          let mechanism;
          do {
            mechanism = this.reader.cstring();
            if (mechanism) {
              message.mechanisms.push(mechanism);
            }
          } while (mechanism);
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\0") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser2;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var parse2 = function(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  exports.parse = parse2;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-cloudflare/dist/empty.js
var exports_empty = {};
__export(exports_empty, {
  default: () => {
    {
      return empty_default;
    }
  }
});
var empty_default;
var init_empty = __esm(() => {
  empty_default = {};
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  exports.getStream = function getStream(ssl) {
    const net = import.meta.require("net");
    if (typeof net.Socket === "function") {
      return new net.Socket;
    } else {
      const { CloudflareSocket } = (init_empty(), __toCommonJS(exports_empty));
      return new CloudflareSocket(ssl);
    }
  };
  exports.getSecureStream = function getSecureStream(options) {
    var tls = import.meta.require("tls");
    if (tls.connect) {
      return tls.connect(options);
    } else {
      options.socket.startTls(options);
      return options.socket;
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var net = import.meta.require("net");
  var EventEmitter = import.meta.require("events").EventEmitter;
  var { parse: parse2, serialize } = require_dist2();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      var self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      var self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error8) {
        if (self2._ending && (error8.code === "ECONNRESET" || error8.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error8);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        var responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        var net2 = import.meta.require("net");
        if (net2.isIP && net2.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse2(stream, (msg) => {
        var eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize.query(text));
    }
    parse(query3) {
      this._send(serialize.parse(query3));
    }
    bind(config) {
      this._send(serialize.bind(config));
    }
    execute(config) {
      this._send(serialize.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// /Users/richardguerre/Projects/flow/node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var transform = function(chunk, enc, cb) {
    let list6;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list6 = buf.split(this.matcher);
      if (list6.length === 1)
        return cb();
      list6.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list6 = this[kLast].split(this.matcher);
    }
    this[kLast] = list6.pop();
    for (let i = 0;i < list6.length; i++) {
      try {
        push2(this, this.mapper(list6[i]));
      } catch (error8) {
        return cb(error8);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  };
  var flush = function(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push2(this, this.mapper(this[kLast]));
      } catch (error8) {
        return cb(error8);
      }
    }
    cb();
  };
  var push2 = function(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  };
  var noop2 = function(incoming) {
    return incoming;
  };
  var split = function(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop2;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop2;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  };
  var { Transform } = import.meta.require("stream");
  var { StringDecoder } = import.meta.require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  module.exports = split;
});

// /Users/richardguerre/Projects/flow/node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var isRegFile = function(mode) {
    return (mode & S_IFMT) == S_IFREG;
  };
  var warn = function() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat("\n");
      warnStream.write(util2.format.apply(util2, args));
    }
  };
  var path = import.meta.require("path");
  var Stream = import.meta.require("stream").Stream;
  var split = require_split2();
  var util2 = import.meta.require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env3 = rawEnv || process.env;
    var file = env3.PGPASSFILE || (isWin ? path.join(env3.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env3.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field3, idx) {
      if (idx == 1) {
        if (Number(connInfo[field3] || defaultPort) === Number(entry[field3])) {
          return prev && true;
        }
      }
      return prev && (entry[field3] === "*" || entry[field3] === connInfo[field3]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i12) {
      var field3 = line.substring(i0, i12);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field3 = field3.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field3;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pgpass/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var fs = import.meta.require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/client.js
var require_client3 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var utils32 = require_utils3();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils4();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      var c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query3) => {
        process.nextTick(() => {
          query3.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      var self2 = this;
      var con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      this.connectionTimeoutHandle;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error8 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error8);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error8);
            } else {
              this._handleErrorEvent(error8);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error8);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject2) => {
        this._connect((error8) => {
          if (error8) {
            reject2(error8);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib3();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete(msg) {
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      var params3 = this.connectionParameters;
      var data = {
        user: params3.user,
        database: params3.database
      };
      var appName = params3.application_name || params3.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params3.replication) {
        data.replication = "" + params3.replication;
      }
      if (params3.statement_timeout) {
        data.statement_timeout = String(parseInt(params3.statement_timeout, 10));
      }
      if (params3.lock_timeout) {
        data.lock_timeout = String(parseInt(params3.lock_timeout, 10));
      }
      if (params3.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params3.idle_in_transaction_session_timeout, 10));
      }
      if (params3.options) {
        data.options = params3.options;
      }
      return data;
    }
    cancel(client2, query3) {
      if (client2.activeQuery === query3) {
        var con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client2.processID, client2.secretKey);
        });
      } else if (client2.queryQueue.indexOf(query3) !== -1) {
        client2.queryQueue.splice(client2.queryQueue.indexOf(query3), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils32.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils32.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values4, callback) {
      var query3;
      var result;
      var readTimeout;
      var readTimeoutTimer;
      var queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query3 = config;
        if (typeof values4 === "function") {
          query3.callback = query3.callback || values4;
        }
      } else {
        readTimeout = this.connectionParameters.query_timeout;
        query3 = new Query(config, values4, callback);
        if (!query3.callback) {
          result = new this._Promise((resolve, reject2) => {
            query3.callback = (err, res) => err ? reject2(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query3.callback;
        readTimeoutTimer = setTimeout(() => {
          var error8 = new Error("Query read timeout");
          process.nextTick(() => {
            query3.handleError(error8, this.connection);
          });
          queryCallback(error8);
          query3.callback = () => {
          };
          var index = this.queryQueue.indexOf(query3);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query3.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query3.binary) {
        query3.binary = true;
      }
      if (query3._result && !query3._result._types) {
        query3._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query3.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query3.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query3);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var throwOnDoubleRelease = function() {
    throw new Error("Release called on client which has already been released to the pool.");
  };
  var promisify = function(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client2) {
      err ? rej(err) : res(client2);
    };
    const result = new Promise2(function(resolve, reject2) {
      res = resolve;
      rej = reject2;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  };
  var makeIdleListener = function(pool, client2) {
    return function idleListener(err) {
      err.client = client2;
      client2.removeListener("error", idleListener);
      client2.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client2);
      pool.emit("error", err, client2);
    };
  };
  var EventEmitter = import.meta.require("events").EventEmitter;
  var NOOP2 = function() {
  };
  var removeWhere = (list6, predicate) => {
    const i = list6.findIndex(predicate);
    return i === -1 ? undefined : list6.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client2, idleListener, timeoutId) {
      this.client = client2;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && ("password" in options)) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {
      };
      this.Client = this.options.Client || Client || require_lib4().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client2 = idleItem.client;
        client2.ref && client2.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client2, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client2) {
      const removed = removeWhere(this._idle, (item) => item.client === client2);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client2);
      client2.end();
      this.emit("remove", client2);
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client2 = new this.Client(this.options);
      this._clients.push(client2);
      const idleListener = makeIdleListener(this, client2);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client2.connection ? client2.connection.stream.destroy() : client2.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client2.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client2.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client2);
          if (timeoutHit) {
            err.message = "Connection terminated due to connection timeout";
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP2);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client2);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client2);
              if (idleIndex !== -1) {
                this._acquireClient(client2, new PendingItem((err2, client3, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client2.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client2, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client2, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client2);
      }
      this.emit("acquire", client2);
      client2.release = this._releaseOnce(client2, idleListener);
      client2.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client2, (err) => {
            if (err) {
              client2.release(err);
              return pendingItem.callback(err, undefined, NOOP2);
            }
            pendingItem.callback(undefined, client2, client2.release);
          });
        } else {
          pendingItem.callback(undefined, client2, client2.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client2, client2.release);
        } else {
          client2.release();
        }
      }
    }
    _releaseOnce(client2, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client2, idleListener, err);
      };
    }
    _release(client2, idleListener, err) {
      client2.on("error", idleListener);
      client2._poolUseCount = (client2._poolUseCount || 0) + 1;
      this.emit("release", err, client2);
      if (err || this.ending || !client2._queryable || client2._ending || client2._poolUseCount >= this.options.maxUses) {
        if (client2._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        this._remove(client2);
        this._pulseQueue();
        return;
      }
      const isExpired = this._expired.has(client2);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client2);
        this._remove(client2);
        this._pulseQueue();
        return;
      }
      let tid;
      if (this.options.idleTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client2);
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client2.unref();
      }
      this._idle.push(new IdleItem(client2, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values4, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values4 === "function") {
        cb = values4;
        values4 = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client2) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client2.release(err2);
          cb(err2);
        };
        client2.once("error", onError);
        this.log("dispatching query");
        try {
          client2.query(text, values4, (err2, res) => {
            this.log("query dispatched");
            client2.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client2.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client2.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client2) => acc + (this._expired.has(client2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// /Users/richardguerre/Projects/flow/node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports, module) => {
  var fileUriToPath = function(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf("/");
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {
    } else {
      path = sep + path;
    }
    return host + path;
  };
  var sep = import.meta.require("path").sep || "/";
  module.exports = fileUriToPath;
});

// /Users/richardguerre/Projects/flow/node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports, module) => {
  var bindings = function(opts) {
    if (typeof opts == "string") {
      opts = { bindings: opts };
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports.getRoot(exports.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var tries = [], i = 0, l = opts.try.length, n, b, err;
    for (;i < l; i++) {
      n = join3.apply(null, opts.try[i].map(function(p) {
        return opts[p] || p;
      }));
      tries.push(n);
      try {
        b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
        if (!opts.path) {
          b.path = n;
        }
        return b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
          throw e;
        }
      }
    }
    err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
      return opts.arrow + a;
    }).join("\n"));
    err.tries = tries;
    throw err;
  };
  var __filename = "/Users/richardguerre/Projects/flow/node_modules/bindings/bindings.js";
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join3 = path.join;
  var dirname = path.dirname;
  var exists = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  module.exports = exports = bindings;
  exports.getFileName = function getFileName(calling_file) {
    var { prepareStackTrace: origPST, stackTraceLimit: origSTL } = Error, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e, st) {
      for (var i = 0, l = st.length;i < l; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports.getRoot = function getRoot(file) {
    var dir = dirname(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists(join3(dir, "package.json")) || exists(join3(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join3(dir, "..");
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/libpq/index.js
var require_libpq = __commonJS((exports, module) => {
  var __dirname = "/Users/richardguerre/Projects/flow/node_modules/libpq";
  var PQ = module.exports = require_bindings()("addon.node").PQ;
  var assert = import.meta.require("assert");
  if (!module.parent) {
    path = import.meta.require("path");
    console.log(path.normalize(__dirname + "/src"));
  }
  var path;
  var EventEmitter = import.meta.require("events").EventEmitter;
  var assert = import.meta.require("assert");
  for (key in EventEmitter.prototype) {
    PQ.prototype[key] = EventEmitter.prototype[key];
  }
  var key;
  PQ.prototype.connectSync = function(paramString) {
    this.connected = true;
    if (!paramString) {
      paramString = "";
    }
    var connected = this.$connectSync(paramString);
    if (!connected) {
      var err = new Error(this.errorMessage());
      this.finish();
      throw err;
    }
  };
  PQ.prototype.connect = function(paramString, cb) {
    this.connected = true;
    if (typeof paramString == "function") {
      cb = paramString;
      paramString = "";
    }
    if (!paramString) {
      paramString = "";
    }
    assert(cb, "Must provide a connection callback");
    if (process.domain) {
      cb = process.domain.bind(cb);
    }
    this.$connect(paramString, cb);
  };
  PQ.prototype.errorMessage = function() {
    return this.$getLastErrorMessage();
  };
  PQ.prototype.socket = function() {
    return this.$socket();
  };
  PQ.prototype.serverVersion = function() {
    return this.$serverVersion();
  };
  PQ.prototype.finish = function() {
    this.connected = false;
    this.$finish();
  };
  PQ.prototype.exec = function(commandText) {
    if (!commandText) {
      commandText = "";
    }
    this.$exec(commandText);
  };
  PQ.prototype.execParams = function(commandText, parameters) {
    if (!commandText) {
      commandText = "";
    }
    if (!parameters) {
      parameters = [];
    }
    assert(Array.isArray(parameters), "Parameters must be an array");
    this.$execParams(commandText, parameters);
  };
  PQ.prototype.prepare = function(statementName, commandText, nParams) {
    assert.equal(arguments.length, 3, "Must supply 3 arguments");
    if (!statementName) {
      statementName = "";
    }
    if (!commandText) {
      commandText = "";
    }
    nParams = Number(nParams) || 0;
    this.$prepare(statementName, commandText, nParams);
  };
  PQ.prototype.execPrepared = function(statementName, parameters) {
    if (!statementName) {
      statementName = "";
    }
    if (!parameters) {
      parameters = [];
    }
    assert(Array.isArray(parameters), "Parameters must be an array");
    this.$execPrepared(statementName, parameters);
  };
  PQ.prototype.sendQuery = function(commandText) {
    if (!commandText) {
      commandText = "";
    }
    return this.$sendQuery(commandText);
  };
  PQ.prototype.sendQueryParams = function(commandText, parameters) {
    if (!commandText) {
      commandText = "";
    }
    if (!parameters) {
      parameters = [];
    }
    assert(Array.isArray(parameters), "Parameters must be an array");
    return this.$sendQueryParams(commandText, parameters);
  };
  PQ.prototype.sendPrepare = function(statementName, commandText, nParams) {
    assert.equal(arguments.length, 3, "Must supply 3 arguments");
    if (!statementName) {
      statementName = "";
    }
    if (!commandText) {
      commandText = "";
    }
    nParams = Number(nParams) || 0;
    return this.$sendPrepare(statementName, commandText, nParams);
  };
  PQ.prototype.sendQueryPrepared = function(statementName, parameters) {
    if (!statementName) {
      statementName = "";
    }
    if (!parameters) {
      parameters = [];
    }
    assert(Array.isArray(parameters), "Parameters must be an array");
    return this.$sendQueryPrepared(statementName, parameters);
  };
  PQ.prototype.getResult = function() {
    return this.$getResult();
  };
  PQ.prototype.resultStatus = function() {
    return this.$resultStatus();
  };
  PQ.prototype.resultErrorMessage = function() {
    return this.$resultErrorMessage();
  };
  PQ.prototype.resultErrorFields = function() {
    return this.$resultErrorFields();
  };
  PQ.prototype.clear = function() {
    this.$clear();
  };
  PQ.prototype.ntuples = function() {
    return this.$ntuples();
  };
  PQ.prototype.nfields = function() {
    return this.$nfields();
  };
  PQ.prototype.fname = function(offset) {
    return this.$fname(offset);
  };
  PQ.prototype.ftype = function(offset) {
    return this.$ftype(offset);
  };
  PQ.prototype.getvalue = function(row, col) {
    return this.$getvalue(row, col);
  };
  PQ.prototype.getisnull = function(row, col) {
    return this.$getisnull(row, col);
  };
  PQ.prototype.cmdStatus = function() {
    return this.$cmdStatus();
  };
  PQ.prototype.cmdTuples = function() {
    return this.$cmdTuples();
  };
  PQ.prototype.startReader = function() {
    assert(this.connected, "Must be connected to start reader");
    this.$startRead();
  };
  PQ.prototype.stopReader = function() {
    this.$stopRead();
  };
  PQ.prototype.writable = function(cb) {
    assert(this.connected, "Must be connected to start writer");
    this.$startWrite();
    return this.once("writable", cb);
  };
  PQ.prototype.consumeInput = function() {
    return this.$consumeInput();
  };
  PQ.prototype.isBusy = function() {
    return this.$isBusy();
  };
  PQ.prototype.setNonBlocking = function(truthy) {
    return this.$setNonBlocking(truthy ? 1 : 0);
  };
  PQ.prototype.isNonBlocking = function() {
    return this.$isNonBlocking();
  };
  PQ.prototype.flush = function() {
    return this.$flush();
  };
  PQ.prototype.escapeLiteral = function(input6) {
    if (!input6)
      return input6;
    return this.$escapeLiteral(input6);
  };
  PQ.prototype.escapeIdentifier = function(input6) {
    if (!input6)
      return input6;
    return this.$escapeIdentifier(input6);
  };
  PQ.prototype.notifies = function() {
    return this.$notifies();
  };
  PQ.prototype.putCopyData = function(buffer) {
    assert(buffer instanceof Buffer);
    return this.$putCopyData(buffer);
  };
  PQ.prototype.putCopyEnd = function(errorMessage) {
    if (errorMessage) {
      return this.$putCopyEnd(errorMessage);
    }
    return this.$putCopyEnd();
  };
  PQ.prototype.getCopyData = function(async) {
    return this.$getCopyData(!!async);
  };
  PQ.prototype.cancel = function() {
    return this.$cancel();
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/node_modules/postgres-array/index.js
var require_postgres_array2 = __commonJS((exports) => {
  var ArrayParser = function(source2, transform) {
    this.source = source2;
    this.transform = transform || identity2;
    this.position = 0;
    this.entries = [];
    this.recorded = [];
    this.dimension = 0;
  };
  var identity2 = function(value) {
    return value;
  };
  exports.parse = function(source2, transform) {
    return new ArrayParser(source2, transform).parse();
  };
  ArrayParser.prototype.isEof = function() {
    return this.position >= this.source.length;
  };
  ArrayParser.prototype.nextCharacter = function() {
    var character = this.source[this.position++];
    if (character === "\\") {
      return {
        value: this.source[this.position++],
        escaped: true
      };
    }
    return {
      value: character,
      escaped: false
    };
  };
  ArrayParser.prototype.record = function(character) {
    this.recorded.push(character);
  };
  ArrayParser.prototype.newEntry = function(includeEmpty) {
    var entry;
    if (this.recorded.length > 0 || includeEmpty) {
      entry = this.recorded.join("");
      if (entry === "NULL" && !includeEmpty) {
        entry = null;
      }
      if (entry !== null)
        entry = this.transform(entry);
      this.entries.push(entry);
      this.recorded = [];
    }
  };
  ArrayParser.prototype.parse = function(nested) {
    var character, parser, quote;
    while (!this.isEof()) {
      character = this.nextCharacter();
      if (character.value === "{" && !quote) {
        this.dimension++;
        if (this.dimension > 1) {
          parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
          this.entries.push(parser.parse(true));
          this.position += parser.position - 2;
        }
      } else if (character.value === "}" && !quote) {
        this.dimension--;
        if (!this.dimension) {
          this.newEntry();
          if (nested)
            return this.entries;
        }
      } else if (character.value === '"' && !character.escaped) {
        if (quote)
          this.newEntry(true);
        quote = !quote;
      } else if (character.value === "," && !quote) {
        this.newEntry();
      } else {
        this.record(character.value);
      }
    }
    if (this.dimension !== 0) {
      throw new Error("array dimension not balanced");
    }
    return this.entries;
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser2 = __commonJS((exports, module) => {
  var array = require_postgres_array2();
  module.exports = {
    create: function(source2, transform) {
      return {
        parse: function() {
          return array.parse(source2, transform);
        }
      };
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/lib/textParsers.js
var require_textParsers2 = __commonJS((exports, module) => {
  var allowNull = function(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  };
  var parseBool = function(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  };
  var parseBoolArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  };
  var parseBaseTenInt = function(string) {
    return parseInt(string, 10);
  };
  var parseIntegerArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  };
  var parseBigIntegerArray = function(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  };
  var array = require_postgres_array2();
  var arrayParser = require_arrayParser2();
  var parseDate2 = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate2(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    var arr = parseStringArray(value);
    if (!arr) {
      return arr;
    }
    return arr.map(function(el) {
      return JSON.parse(el);
    });
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate2);
    register(1114, parseDate2);
    register(1184, parseDate2);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers2 = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : (-Infinity);
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate2 = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse2 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse2(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse2(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate2.bind(null, false));
    register(1184, parseDate2.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/node_modules/pg-types/index.js
var require_pg_types2 = __commonJS((exports) => {
  var noParse = function(val) {
    return String(val);
  };
  var getTypeParser = function(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  };
  var setTypeParser = function(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  };
  var textParsers = require_textParsers2();
  var binaryParsers = require_binaryParsers2();
  var arrayParser = require_arrayParser2();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  var typeParsers = {
    text: {},
    binary: {}
  };
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/lib/build-result.js
var require_build_result = __commonJS((exports, module) => {
  var buildResult = function(pq, types24, arrayMode) {
    const result = new Result(types24, arrayMode);
    result.consumeCommand(pq);
    result.consumeFields(pq);
    result.consumeRows(pq);
    return result;
  };

  class Result {
    constructor(types24, arrayMode) {
      this._types = types24;
      this._arrayMode = arrayMode;
      this.command = undefined;
      this.rowCount = undefined;
      this.fields = [];
      this.rows = [];
    }
    consumeCommand(pq) {
      this.command = pq.cmdStatus().split(" ")[0];
      this.rowCount = parseInt(pq.cmdTuples(), 10);
    }
    consumeFields(pq) {
      const nfields = pq.nfields();
      for (var x = 0;x < nfields; x++) {
        this.fields.push({
          name: pq.fname(x),
          dataTypeID: pq.ftype(x)
        });
      }
    }
    consumeRows(pq) {
      const tupleCount = pq.ntuples();
      for (var i = 0;i < tupleCount; i++) {
        const row = this._arrayMode ? this.consumeRowAsArray(pq, i) : this.consumeRowAsObject(pq, i);
        this.rows.push(row);
      }
    }
    consumeRowAsObject(pq, rowIndex) {
      const row = {};
      for (var j = 0;j < this.fields.length; j++) {
        const value = this.readValue(pq, rowIndex, j);
        row[this.fields[j].name] = value;
      }
      return row;
    }
    consumeRowAsArray(pq, rowIndex) {
      const row = [];
      for (var j = 0;j < this.fields.length; j++) {
        const value = this.readValue(pq, rowIndex, j);
        row.push(value);
      }
      return row;
    }
    readValue(pq, rowIndex, colIndex) {
      var rawValue = pq.getvalue(rowIndex, colIndex);
      if (rawValue === "") {
        if (pq.getisnull(rowIndex, colIndex)) {
          return null;
        }
      }
      const dataTypeId = this.fields[colIndex].dataTypeID;
      return this._types.getTypeParser(dataTypeId)(rawValue);
    }
  }
  module.exports = buildResult;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/lib/copy-stream.js
var require_copy_stream = __commonJS((exports, module) => {
  var Duplex = import.meta.require("stream").Duplex;
  var Writable = import.meta.require("stream").Writable;
  var util2 = import.meta.require("util");
  var CopyStream = module.exports = function(pq, options) {
    Duplex.call(this, options);
    this.pq = pq;
    this._reading = false;
  };
  util2.inherits(CopyStream, Duplex);
  CopyStream.prototype._write = function(chunk, encoding, cb) {
    var result = this.pq.putCopyData(chunk);
    if (result === 1)
      return cb();
    if (result === -1)
      return cb(new Error(this.pq.errorMessage()));
    var self2 = this;
    this.pq.writable(function() {
      self2._write(chunk, encoding, cb);
    });
  };
  CopyStream.prototype.end = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var self2 = this;
    var callback = args.pop();
    if (args.length) {
      this.write(args[0]);
    }
    var result = this.pq.putCopyEnd();
    if (result === 1) {
      return consumeResults(this.pq, function(err2, res) {
        Writable.prototype.end.call(self2);
        if (callback) {
          callback(err2);
        }
      });
    }
    if (result === -1) {
      var err = new Error(this.pq.errorMessage());
      return this.emit("error", err);
    }
    return this.pq.writable(function() {
      return self2.end.apply(self2, callback);
    });
  };
  CopyStream.prototype._consumeBuffer = function(cb) {
    var result = this.pq.getCopyData(true);
    if (result instanceof Buffer) {
      return setImmediate(function() {
        cb(null, result);
      });
    }
    if (result === -1) {
      return cb(null, null);
    }
    if (result === 0) {
      var self2 = this;
      this.pq.once("readable", function() {
        self2.pq.stopReader();
        self2.pq.consumeInput();
        self2._consumeBuffer(cb);
      });
      return this.pq.startReader();
    }
    cb(new Error("Unrecognized read status: " + result));
  };
  CopyStream.prototype._read = function(size) {
    if (this._reading)
      return;
    this._reading = true;
    var self2 = this;
    this._consumeBuffer(function(err, buffer) {
      self2._reading = false;
      if (err) {
        return self2.emit("error", err);
      }
      if (buffer === false) {
        return;
      }
      self2.push(buffer);
    });
  };
  var consumeResults = function(pq, cb) {
    var cleanup = function() {
      pq.removeListener("readable", onReadable);
      pq.stopReader();
    };
    var readError = function(message) {
      cleanup();
      return cb(new Error(message || pq.errorMessage()));
    };
    var onReadable = function() {
      if (!pq.consumeInput()) {
        return readError();
      }
      if (pq.isBusy()) {
        return;
      }
      pq.getResult();
      if (pq.getResult() && pq.resultStatus() !== "PGRES_COPY_OUT") {
        return readError("Only one result at a time is accepted");
      }
      if (pq.resultStatus() === "PGRES_FATAL_ERROR") {
        return readError();
      }
      cleanup();
      return cb(null);
    };
    pq.on("readable", onReadable);
    pq.startReader();
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "pg-native",
    version: "3.0.1",
    description: "A slightly nicer interface to Postgres over node-libpq",
    main: "index.js",
    scripts: {
      test: "mocha && eslint ."
    },
    repository: {
      type: "git",
      url: "git://github.com/brianc/node-pg-native.git"
    },
    keywords: [
      "postgres",
      "pg",
      "libpq"
    ],
    author: "Brian M. Carlson",
    license: "MIT",
    bugs: {
      url: "https://github.com/brianc/node-pg-native/issues"
    },
    homepage: "https://github.com/brianc/node-pg-native",
    dependencies: {
      libpq: "^1.8.10",
      "pg-types": "^1.12.1",
      "readable-stream": "1.0.31"
    },
    devDependencies: {
      async: "^0.9.0",
      "concat-stream": "^1.4.6",
      eslint: "4.2.0",
      "eslint-config-standard": "10.2.1",
      "eslint-plugin-import": "2.7.0",
      "eslint-plugin-node": "5.1.0",
      "eslint-plugin-promise": "3.5.0",
      "eslint-plugin-standard": "3.0.1",
      "generic-pool": "^2.1.1",
      lodash: "^2.4.1",
      mocha: "3.4.2",
      okay: "^0.3.0",
      pg: "*",
      semver: "^4.1.0"
    },
    prettier: {
      printWidth: 200
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-native/index.js
var require_pg_native = __commonJS((exports, module) => {
  var Libpq = require_libpq();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var assert = import.meta.require("assert");
  var types24 = require_pg_types2();
  var buildResult = require_build_result();
  var CopyStream = require_copy_stream();
  var Client = module.exports = function(config) {
    if (!(this instanceof Client)) {
      return new Client(config);
    }
    config = config || {};
    EventEmitter.call(this);
    this.pq = new Libpq;
    this._reading = false;
    this._read = this._read.bind(this);
    this._types = config.types || types24;
    this.arrayMode = config.arrayMode || false;
    this._resultCount = 0;
    this._rows = undefined;
    this._results = undefined;
    this.on("newListener", (event) => {
      if (event !== "notification")
        return;
      this._startReading();
    });
    this.on("result", this._onResult.bind(this));
    this.on("readyForQuery", this._onReadyForQuery.bind(this));
  };
  util2.inherits(Client, EventEmitter);
  Client.prototype.connect = function(params3, cb) {
    this.pq.connect(params3, cb);
  };
  Client.prototype.connectSync = function(params3) {
    this.pq.connectSync(params3);
  };
  Client.prototype.query = function(text, values4, cb) {
    var queryFn;
    if (typeof values4 === "function") {
      cb = values4;
    }
    if (Array.isArray(values4) && values4.length > 0) {
      queryFn = function() {
        return self2.pq.sendQueryParams(text, values4);
      };
    } else {
      queryFn = function() {
        return self2.pq.sendQuery(text);
      };
    }
    var self2 = this;
    self2._dispatchQuery(self2.pq, queryFn, function(err) {
      if (err)
        return cb(err);
      self2._awaitResult(cb);
    });
  };
  Client.prototype.prepare = function(statementName, text, nParams, cb) {
    var self2 = this;
    var fn = function() {
      return self2.pq.sendPrepare(statementName, text, nParams);
    };
    self2._dispatchQuery(self2.pq, fn, function(err) {
      if (err)
        return cb(err);
      self2._awaitResult(cb);
    });
  };
  Client.prototype.execute = function(statementName, parameters, cb) {
    var self2 = this;
    var fn = function() {
      return self2.pq.sendQueryPrepared(statementName, parameters);
    };
    self2._dispatchQuery(self2.pq, fn, function(err, rows) {
      if (err)
        return cb(err);
      self2._awaitResult(cb);
    });
  };
  Client.prototype.getCopyStream = function() {
    this.pq.setNonBlocking(true);
    this._stopReading();
    return new CopyStream(this.pq);
  };
  Client.prototype.cancel = function(cb) {
    assert(cb, "Callback is required");
    var result = this.pq.cancel();
    return setImmediate(function() {
      cb(result === true ? undefined : new Error(result));
    });
  };
  Client.prototype.querySync = function(text, values4) {
    if (values4) {
      this.pq.execParams(text, values4);
    } else {
      this.pq.exec(text);
    }
    throwIfError(this.pq);
    const result = buildResult(this.pq, this._types, this.arrayMode);
    return result.rows;
  };
  Client.prototype.prepareSync = function(statementName, text, nParams) {
    this.pq.prepare(statementName, text, nParams);
    throwIfError(this.pq);
  };
  Client.prototype.executeSync = function(statementName, parameters) {
    this.pq.execPrepared(statementName, parameters);
    throwIfError(this.pq);
    return buildResult(this.pq, this._types, this.arrayMode).rows;
  };
  Client.prototype.escapeLiteral = function(value) {
    return this.pq.escapeLiteral(value);
  };
  Client.prototype.escapeIdentifier = function(value) {
    return this.pq.escapeIdentifier(value);
  };
  module.exports.version = require_package().version;
  Client.prototype.end = function(cb) {
    this._stopReading();
    this.pq.finish();
    if (cb)
      setImmediate(cb);
  };
  Client.prototype._readError = function(message) {
    var err = new Error(message || this.pq.errorMessage());
    this.emit("error", err);
  };
  Client.prototype._stopReading = function() {
    if (!this._reading)
      return;
    this._reading = false;
    this.pq.stopReader();
    this.pq.removeListener("readable", this._read);
  };
  Client.prototype._consumeQueryResults = function(pq) {
    return buildResult(pq, this._types, this.arrayMode);
  };
  Client.prototype._emitResult = function(pq) {
    var status = pq.resultStatus();
    switch (status) {
      case "PGRES_FATAL_ERROR":
        this._queryError = new Error(this.pq.resultErrorMessage());
        break;
      case "PGRES_TUPLES_OK":
      case "PGRES_COMMAND_OK":
      case "PGRES_EMPTY_QUERY":
        const result = this._consumeQueryResults(this.pq);
        this.emit("result", result);
        break;
      case "PGRES_COPY_OUT":
      case "PGRES_COPY_BOTH": {
        break;
      }
      default:
        this._readError("unrecognized command status: " + status);
        break;
    }
    return status;
  };
  Client.prototype._read = function() {
    var pq = this.pq;
    if (!pq.consumeInput()) {
      return this._readError();
    }
    if (pq.isBusy()) {
      return;
    }
    while (pq.getResult()) {
      const resultStatus = this._emitResult(this.pq);
      if (resultStatus === "PGRES_COPY_BOTH" || resultStatus === "PGRES_COPY_OUT") {
        break;
      }
      if (pq.isBusy()) {
        return;
      }
    }
    this.emit("readyForQuery");
    var notice = this.pq.notifies();
    while (notice) {
      this.emit("notification", notice);
      notice = this.pq.notifies();
    }
  };
  Client.prototype._startReading = function() {
    if (this._reading)
      return;
    this._reading = true;
    this.pq.on("readable", this._read);
    this.pq.startReader();
  };
  var throwIfError = function(pq) {
    var err = pq.resultErrorMessage() || pq.errorMessage();
    if (err) {
      throw new Error(err);
    }
  };
  Client.prototype._awaitResult = function(cb) {
    this._queryCallback = cb;
    return this._startReading();
  };
  Client.prototype._waitForDrain = function(pq, cb) {
    var res = pq.flush();
    if (res === 0)
      return cb();
    if (res === -1)
      return cb(pq.errorMessage());
    var self2 = this;
    return pq.writable(function() {
      self2._waitForDrain(pq, cb);
    });
  };
  Client.prototype._dispatchQuery = function(pq, fn, cb) {
    this._stopReading();
    var success = pq.setNonBlocking(true);
    if (!success)
      return cb(new Error("Unable to set non-blocking to true"));
    var sent = fn();
    if (!sent)
      return cb(new Error(pq.errorMessage() || "Something went wrong dispatching the query"));
    this._waitForDrain(pq, cb);
  };
  Client.prototype._onResult = function(result) {
    if (this._resultCount === 0) {
      this._results = result;
      this._rows = result.rows;
    } else if (this._resultCount === 1) {
      this._results = [this._results, result];
      this._rows = [this._rows, result.rows];
    } else {
      this._results.push(result);
      this._rows.push(result.rows);
    }
    this._resultCount++;
  };
  Client.prototype._onReadyForQuery = function() {
    const cb = this._queryCallback;
    this._queryCallback = undefined;
    const err = this._queryError;
    this._queryError = undefined;
    const rows = this._rows;
    this._rows = undefined;
    const results = this._results;
    this._results = undefined;
    this._resultCount = 0;
    if (cb) {
      cb(err, rows || [], results);
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var utils32 = require_utils3();
  var NativeQuery = module.exports = function(config, values4, callback) {
    EventEmitter.call(this);
    config = utils32.normalizeQueryConfig(config, values4, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util2.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    var fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (var key in fields) {
        var normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject2) {
      this._once("end", resolve);
      this._once("error", reject2);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client2) {
    this.state = "running";
    var self2 = this;
    this.native = client2.native;
    client2.native.arrayMode = this._arrayMode;
    var after = function(err, rows, results) {
      client2.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      var values4 = (this.values || []).map(utils32.prepareValue);
      if (client2.namedQueries[this.name]) {
        if (this.text && client2.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client2.native.execute(this.name, values4, after);
      }
      return client2.native.prepare(this.name, this.text, values4.length, function(err) {
        if (err)
          return after(err);
        client2.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values4, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      var vals = this.values.map(utils32.prepareValue);
      client2.native.query(this.text, vals, after);
    } else {
      client2.native.query(this.text, after);
    }
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/native/client.js
var require_client4 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = require_pg_native();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util2 = import.meta.require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    var cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util2.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query3) => {
      process.nextTick(() => {
        query3.native = this.native;
        query3.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    var self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject2) => {
      this._connect((error8) => {
        if (error8) {
          reject2(error8);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values4, callback) {
    var query3;
    var result;
    var readTimeout;
    var readTimeoutTimer;
    var queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query3 = config;
      if (typeof values4 === "function") {
        config.callback = values4;
      }
    } else {
      readTimeout = this.connectionParameters.query_timeout;
      query3 = new NativeQuery(config, values4, callback);
      if (!query3.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject2) => {
          resolveOut = resolve;
          rejectOut = reject2;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query3.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query3.callback;
      readTimeoutTimer = setTimeout(() => {
        var error8 = new Error("Query read timeout");
        process.nextTick(() => {
          query3.handleError(error8, this.connection);
        });
        queryCallback(error8);
        query3.callback = () => {
        };
        var index = this._queryQueue.indexOf(query3);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query3.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query3.native = this.native;
      process.nextTick(() => {
        query3.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query3.native = this.native;
      process.nextTick(() => {
        query3.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query3);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    var self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    var result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject2) {
        cb = (err) => err ? reject2(err) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    var query3 = this._queryQueue.shift();
    if (!query3) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query3;
    query3.submit(this);
    var self2 = this;
    query3.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query3) {
    if (this._activeQuery === query3) {
      this.native.cancel(function() {
      });
    } else if (this._queryQueue.indexOf(query3) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query3), 1);
    }
  };
  Client.prototype.ref = function() {
  };
  Client.prototype.unref = function() {
  };
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var Client = require_client3();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Pool = require_pg_pool();
  var { DatabaseError } = require_dist2();
  var { escapeIdentifier, escapeLiteral } = require_utils3();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client4());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        var native = null;
        try {
          native = new PG(require_client4());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/db.js
var require_db = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var pg = require_lib4();

  class Db extends EventEmitter {
    constructor(config) {
      super();
      config.application_name = config.application_name || "pgboss";
      this.config = config;
    }
    async open() {
      this.pool = new pg.Pool(this.config);
      this.pool.on("error", (error8) => this.emit("error", error8));
      this.opened = true;
    }
    async close() {
      if (!this.pool.ending) {
        this.opened = false;
        await this.pool.end();
      }
    }
    async executeSql(text, values4) {
      if (this.opened) {
        return await this.pool.query(text, values4);
      }
    }
    static quotePostgresStr(str) {
      const delimeter = "$sanitize$";
      if (str.includes(delimeter)) {
        throw new Error(`Attempted to quote string that contains reserved Postgres delimeter: ${str}`);
      }
      return `${delimeter}${str}${delimeter}`;
    }
  }
  module.exports = Db;
});

// /Users/richardguerre/Projects/flow/node_modules/indent-string/index.js
var require_indent_string = __commonJS((exports, module) => {
  module.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// /Users/richardguerre/Projects/flow/node_modules/clean-stack/index.js
var require_clean_stack = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
  var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
  var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
  module.exports = (stack, options) => {
    options = Object.assign({ pretty: false }, options);
    return stack.replace(/\\/g, "/").split("\n").filter((line) => {
      const pathMatches = line.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1]) {
        return true;
      }
      const match = pathMatches[1];
      if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
        return false;
      }
      return !pathRegex.test(match);
    }).filter((line) => line.trim() !== "").map((line) => {
      if (options.pretty) {
        return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
      }
      return line;
    }).join("\n");
  };
});

// /Users/richardguerre/Projects/flow/node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS((exports, module) => {
  var indentString = require_indent_string();
  var cleanStack = require_clean_stack();
  var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");

  class AggregateError extends Error {
    constructor(errors16) {
      if (!Array.isArray(errors16)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors16}`);
      }
      errors16 = [...errors16].map((error8) => {
        if (error8 instanceof Error) {
          return error8;
        }
        if (error8 !== null && typeof error8 === "object") {
          return Object.assign(new Error(error8.message), error8);
        }
        return new Error(error8);
      });
      let message = errors16.map((error8) => {
        return typeof error8.stack === "string" ? cleanInternalStack(cleanStack(error8.stack)) : String(error8);
      }).join("\n");
      message = "\n" + indentString(message, 4);
      super(message);
      this.name = "AggregateError";
      Object.defineProperty(this, "_errors", { value: errors16 });
    }
    *[Symbol.iterator]() {
      for (const error8 of this._errors) {
        yield error8;
      }
    }
  }
  module.exports = AggregateError;
});

// /Users/richardguerre/Projects/flow/node_modules/p-map/index.js
var require_p_map = __commonJS((exports, module) => {
  var AggregateError = require_aggregate_error();
  module.exports = async (iterable, mapper, {
    concurrency = Infinity,
    stopOnError = true
  } = {}) => {
    return new Promise((resolve, reject2) => {
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const result = [];
      const errors16 = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const index = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            if (!stopOnError && errors16.length !== 0) {
              reject2(new AggregateError(errors16));
            } else {
              resolve(result);
            }
          }
          return;
        }
        resolvingCount++;
        (async () => {
          try {
            const element = await nextItem.value;
            result[index] = await mapper(element, index);
            resolvingCount--;
            next();
          } catch (error8) {
            if (stopOnError) {
              isRejected = true;
              reject2(error8);
            } else {
              errors16.push(error8);
              resolvingCount--;
              next();
            }
          }
        })();
      };
      for (let i = 0;i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
  };
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/boss.js
var require_boss = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var { states } = require_plans();
  var { COMPLETION_JOB_PREFIX } = plans;
  var queues = {
    MAINTENANCE: "__pgboss__maintenance",
    MONITOR_STATES: "__pgboss__monitor-states"
  };
  var events2 = {
    error: "error",
    monitorStates: "monitor-states",
    maintenance: "maintenance"
  };

  class Boss extends EventEmitter {
    constructor(db, config) {
      super();
      this.db = db;
      this.config = config;
      this.manager = config.manager;
      this.maintenanceIntervalSeconds = config.maintenanceIntervalSeconds;
      this.monitorStates = config.monitorStateIntervalSeconds !== null;
      if (this.monitorStates) {
        this.monitorIntervalSeconds = config.monitorStateIntervalSeconds;
      }
      this.events = events2;
      this.expireCommand = plans.locked(config.schema, plans.expire(config.schema));
      this.archiveCommand = plans.locked(config.schema, plans.archive(config.schema, config.archiveInterval, config.archiveFailedInterval));
      this.purgeCommand = plans.locked(config.schema, plans.purge(config.schema, config.deleteAfter));
      this.getMaintenanceTimeCommand = plans.getMaintenanceTime(config.schema);
      this.setMaintenanceTimeCommand = plans.setMaintenanceTime(config.schema);
      this.countStatesCommand = plans.countStates(config.schema);
      this.functions = [
        this.expire,
        this.archive,
        this.purge,
        this.countStates,
        this.getQueueNames
      ];
    }
    async supervise() {
      this.metaMonitor();
      await this.manager.deleteQueue(COMPLETION_JOB_PREFIX + queues.MAINTENANCE);
      await this.manager.deleteQueue(queues.MAINTENANCE);
      await this.maintenanceAsync();
      const maintenanceWorkOptions = {
        newJobCheckIntervalSeconds: Math.max(1, this.maintenanceIntervalSeconds / 2)
      };
      await this.manager.work(queues.MAINTENANCE, maintenanceWorkOptions, (job) => this.onMaintenance(job));
      if (this.monitorStates) {
        await this.manager.deleteQueue(COMPLETION_JOB_PREFIX + queues.MONITOR_STATES);
        await this.manager.deleteQueue(queues.MONITOR_STATES);
        await this.monitorStatesAsync();
        const monitorStatesWorkOptions = {
          newJobCheckIntervalSeconds: Math.max(1, this.monitorIntervalSeconds / 2)
        };
        await this.manager.work(queues.MONITOR_STATES, monitorStatesWorkOptions, (job) => this.onMonitorStates(job));
      }
    }
    metaMonitor() {
      this.metaMonitorInterval = setInterval(async () => {
        try {
          if (this.config.__test__throw_meta_monitor) {
            throw new Error(this.config.__test__throw_meta_monitor);
          }
          const { secondsAgo } = await this.getMaintenanceTime();
          if (secondsAgo > this.maintenanceIntervalSeconds * 2) {
            await this.manager.deleteQueue(queues.MAINTENANCE, { before: states.completed });
            await this.maintenanceAsync();
          }
        } catch (err) {
          this.emit(events2.error, err);
        }
      }, this.maintenanceIntervalSeconds * 2 * 1000);
    }
    async maintenanceAsync(options = {}) {
      const { startAfter } = options;
      options = {
        startAfter,
        retentionSeconds: this.maintenanceIntervalSeconds * 4,
        singletonKey: queues.MAINTENANCE,
        onComplete: false
      };
      await this.manager.send(queues.MAINTENANCE, null, options);
    }
    async monitorStatesAsync(options = {}) {
      const { startAfter } = options;
      options = {
        startAfter,
        retentionSeconds: this.monitorIntervalSeconds * 4,
        singletonKey: queues.MONITOR_STATES,
        onComplete: false
      };
      await this.manager.send(queues.MONITOR_STATES, null, options);
    }
    async onMaintenance(job) {
      try {
        if (this.config.__test__throw_maint) {
          throw new Error(this.config.__test__throw_maint);
        }
        const started = Date.now();
        await this.expire();
        await this.archive();
        await this.purge();
        const ended = Date.now();
        await this.setMaintenanceTime();
        this.emit("maintenance", { ms: ended - started });
        if (!this.stopped) {
          await this.manager.complete(job.id);
          await this.maintenanceAsync({ startAfter: this.maintenanceIntervalSeconds });
        }
      } catch (err) {
        this.emit(events2.error, err);
      }
    }
    async onMonitorStates(job) {
      try {
        if (this.config.__test__throw_monitor) {
          throw new Error(this.config.__test__throw_monitor);
        }
        const states2 = await this.countStates();
        this.emit(events2.monitorStates, states2);
        if (!this.stopped && this.monitorStates) {
          await this.manager.complete(job.id);
          await this.monitorStatesAsync({ startAfter: this.monitorIntervalSeconds });
        }
      } catch (err) {
        this.emit(events2.error, err);
      }
    }
    async stop() {
      if (this.config.__test__throw_stop) {
        throw new Error(this.config.__test__throw_stop);
      }
      if (!this.stopped) {
        if (this.metaMonitorInterval) {
          clearInterval(this.metaMonitorInterval);
        }
        await this.manager.offWork(queues.MAINTENANCE);
        if (this.monitorStates) {
          await this.manager.offWork(queues.MONITOR_STATES);
        }
        this.stopped = true;
      }
    }
    async countStates() {
      const stateCountDefault = { ...plans.states };
      Object.keys(stateCountDefault).forEach((key) => {
        stateCountDefault[key] = 0;
      });
      const counts = await this.executeSql(this.countStatesCommand);
      const states2 = counts.rows.reduce((acc, item) => {
        if (item.name) {
          acc.queues[item.name] = acc.queues[item.name] || { ...stateCountDefault };
        }
        const queue = item.name ? acc.queues[item.name] : acc;
        const state = item.state || "all";
        queue[state] = parseFloat(item.size);
        return acc;
      }, { ...stateCountDefault, queues: {} });
      return states2;
    }
    async expire() {
      await this.executeSql(this.expireCommand);
    }
    async archive() {
      await this.executeSql(this.archiveCommand);
    }
    async purge() {
      await this.executeSql(this.purgeCommand);
    }
    async setMaintenanceTime() {
      await this.executeSql(this.setMaintenanceTimeCommand);
    }
    async getMaintenanceTime() {
      if (!this.stopped) {
        const { rows } = await this.db.executeSql(this.getMaintenanceTimeCommand);
        let { maintained_on: maintainedOn, seconds_ago: secondsAgo } = rows[0];
        secondsAgo = secondsAgo !== null ? parseFloat(secondsAgo) : this.maintenanceIntervalSeconds * 10;
        return { maintainedOn, secondsAgo };
      }
    }
    getQueueNames() {
      return queues;
    }
    async executeSql(sql, params3) {
      if (!this.stopped) {
        return await this.db.executeSql(sql, params3);
      }
    }
  }
  module.exports = Boss;
  module.exports.QUEUES = queues;
});

// /Users/richardguerre/Projects/flow/node_modules/luxon/build/node/luxon.js
var require_luxon = __commonJS((exports) => {
  var makeDTF = function(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  };
  var hackyOffset = function(dtf, date) {
    const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  };
  var partsOffset = function(dtf, date) {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i = 0;i < formatted.length; i++) {
      const {
        type: type2,
        value
      } = formatted[i];
      const pos = typeToPos[type2];
      if (type2 === "era") {
        filled[pos] = value;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value, 10);
      }
    }
    return filled;
  };
  var getCachedLF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedDTF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedINF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  };
  var getCachedRTF = function(locString, opts = {}) {
    const {
      base: base18,
      ...cacheKeyOpts
    } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  };
  var systemLocale = function() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  };
  var parseLocaleString = function(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const {
        numberingSystem,
        calendar
      } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  };
  var intlConfigString = function(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  };
  var mapMonths = function(f) {
    const ms = [];
    for (let i = 1;i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  };
  var mapWeekdays = function(f) {
    const ms = [];
    for (let i = 1;i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  };
  var listStuff = function(loc, length, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  };
  var supportsFastNumbers = function(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  };
  var normalizeZone = function(input6, defaultZone2) {
    if (isUndefined(input6) || input6 === null) {
      return defaultZone2;
    } else if (input6 instanceof Zone) {
      return input6;
    } else if (isString(input6)) {
      const lowered = input6.toLowerCase();
      if (lowered === "default")
        return defaultZone2;
      else if (lowered === "local" || lowered === "system")
        return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt")
        return FixedOffsetZone.utcInstance;
      else
        return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input6);
    } else if (isNumber(input6)) {
      return FixedOffsetZone.instance(input6);
    } else if (typeof input6 === "object" && ("offset" in input6) && typeof input6.offset === "function") {
      return input6;
    } else {
      return new InvalidZone(input6);
    }
  };
  var isUndefined = function(o) {
    return typeof o === "undefined";
  };
  var isNumber = function(o) {
    return typeof o === "number";
  };
  var isInteger = function(o) {
    return typeof o === "number" && o % 1 === 0;
  };
  var isString = function(o) {
    return typeof o === "string";
  };
  var isDate = function(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  };
  var hasRelative = function() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e) {
      return false;
    }
  };
  var maybeArray = function(thing) {
    return Array.isArray(thing) ? thing : [thing];
  };
  var bestBy = function(arr, by, compare) {
    if (arr.length === 0) {
      return;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  };
  var pick = function(obj, keys) {
    return keys.reduce((a, k) => {
      a[k] = obj[k];
      return a;
    }, {});
  };
  var hasOwnProperty3 = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  var integerBetween = function(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  };
  var floorMod = function(x, n2) {
    return x - n2 * Math.floor(x / n2);
  };
  var padStart = function(input6, n2 = 2) {
    const isNeg = input6 < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input6).padStart(n2, "0");
    } else {
      padded = ("" + input6).padStart(n2, "0");
    }
    return padded;
  };
  var parseInteger = function(string) {
    if (isUndefined(string) || string === null || string === "") {
      return;
    } else {
      return parseInt(string, 10);
    }
  };
  var parseFloating = function(string) {
    if (isUndefined(string) || string === null || string === "") {
      return;
    } else {
      return parseFloat(string);
    }
  };
  var parseMillis = function(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return;
    } else {
      const f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  };
  var roundTo = function(number, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number * factor) / factor;
  };
  var isLeapYear = function(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var daysInYear = function(year) {
    return isLeapYear(year) ? 366 : 365;
  };
  var daysInMonth = function(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  };
  var objToLocalTS = function(obj) {
    let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
    if (obj.year < 100 && obj.year >= 0) {
      d = new Date(d);
      d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d;
  };
  var weeksInWeekYear = function(weekYear) {
    const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
    return p1 === 4 || p2 === 3 ? 53 : 52;
  };
  var untruncateYear = function(year) {
    if (year > 99) {
      return year;
    } else
      return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
  };
  var parseZoneInfo = function(ts, offsetFormat, locale, timeZone = null) {
    const date = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = {
      timeZoneName: offsetFormat,
      ...intlOpts
    };
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  };
  var signedOffset = function(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  };
  var asNumber = function(value) {
    const numericValue = Number(value);
    if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value}`);
    return numericValue;
  };
  var normalizeObject = function(obj, normalizer) {
    const normalized = {};
    for (const u2 in obj) {
      if (hasOwnProperty3(obj, u2)) {
        const v = obj[u2];
        if (v === undefined || v === null)
          continue;
        normalized[normalizer(u2)] = asNumber(v);
      }
    }
    return normalized;
  };
  var formatOffset = function(offset2, format) {
    const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
    switch (format) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  };
  var timeObject = function(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  };
  var months = function(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  };
  var weekdays = function(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  };
  var eras = function(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  };
  var meridiemForDateTime = function(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  };
  var weekdayForDateTime = function(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  };
  var monthForDateTime = function(dt, length) {
    return months(length)[dt.month - 1];
  };
  var eraForDateTime = function(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  };
  var formatRelativeTime = function(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  };
  var stringifyTokens = function(splits, tokenToString) {
    let s2 = "";
    for (const token of splits) {
      if (token.literal) {
        s2 += token.val;
      } else {
        s2 += tokenToString(token.val);
      }
    }
    return s2;
  };
  var combineRegexes = function(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}\$`);
  };
  var combineExtractors = function(...extractors) {
    return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{
        ...mergedVals,
        ...val
      }, zone || mergedZone, next];
    }, [{}, null, 1]).slice(0, 2);
  };
  var parse2 = function(s2, ...patterns) {
    if (s2 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns) {
      const m = regex.exec(s2);
      if (m) {
        return extractor(m);
      }
    }
    return [null, null];
  };
  var simpleParse = function(...keys) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0;i < keys.length; i++) {
        ret[keys[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  };
  var int = function(match2, pos, fallback) {
    const m = match2[pos];
    return isUndefined(m) ? fallback : parseInteger(m);
  };
  var extractISOYmd = function(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  };
  var extractISOTime = function(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  };
  var extractISOOffset = function(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  };
  var extractIANAZone = function(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  };
  var extractISODuration = function(match2) {
    const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s2[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
    return [{
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }];
  };
  var fromStrings = function(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr)
      result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  };
  var extractRFC2822 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset2;
    if (obsOffset) {
      offset2 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset2 = 0;
    } else {
      offset2 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset2)];
  };
  var preprocessRFC2822 = function(s2) {
    return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  };
  var extractRFC1123Or850 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  };
  var extractASCII = function(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  };
  var parseISODate = function(s2) {
    return parse2(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
  };
  var parseRFC2822Date = function(s2) {
    return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
  };
  var parseHTTPDate = function(s2) {
    return parse2(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
  };
  var parseISODuration = function(s2) {
    return parse2(s2, [isoDuration, extractISODuration]);
  };
  var parseISOTimeOnly = function(s2) {
    return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
  };
  var parseSQL = function(s2) {
    return parse2(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
  };
  var clone$1 = function(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : {
        ...dur.values,
        ...alts.values || {}
      },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  };
  var durationToMillis = function(matrix, vals) {
    var _vals$milliseconds;
    let sum = (_vals$milliseconds = vals.milliseconds) != null ? _vals$milliseconds : 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum += vals[unit] * matrix[unit]["milliseconds"];
      }
    }
    return sum;
  };
  var normalizeValues = function(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits$1.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits$1.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  };
  var removeZeroes = function(vals) {
    const newVals = {};
    for (const [key, value] of Object.entries(vals)) {
      if (value !== 0) {
        newVals[key] = value;
      }
    }
    return newVals;
  };
  var validateStartEnd = function(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
    } else {
      return null;
    }
  };
  var dayDiff = function(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  };
  var highOrderDiffs = function(cursor, later, units) {
    const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
      const days = dayDiff(a, b);
      return (days - days % 7) / 7;
    }], ["days", dayDiff]];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  };
  var diff = function(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter((u2) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0);
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({
          [lowestOrder]: 1
        });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  };
  var parseDigits = function(str) {
    let value = parseInt(str, 10);
    if (isNaN(value)) {
      value = "";
      for (let i = 0;i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value += code - min;
            }
          }
        }
      }
      return parseInt(value, 10);
    } else {
      return value;
    }
  };
  var digitRegex = function({
    numberingSystem
  }, append = "") {
    return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
  };
  var intUnit = function(regex, post = (i) => i) {
    return {
      regex,
      deser: ([s2]) => post(parseDigits(s2))
    };
  };
  var fixListRegex = function(s2) {
    return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  };
  var stripInsensitivities = function(s2) {
    return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  };
  var oneOf = function(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
      };
    }
  };
  var offset = function(regex, groups) {
    return {
      regex,
      deser: ([, h, m]) => signedOffset(h, m),
      groups
    };
  };
  var simple = function(regex) {
    return {
      regex,
      deser: ([s2]) => s2
    };
  };
  var escapeToken = function(value) {
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  };
  var unitForToken = function(token, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({
      regex: RegExp(escapeToken(t.val)),
      deser: ([s2]) => s2,
      literal: true
    }), unitate = (t) => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal(t);
      }
    };
    const unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token;
    return unit;
  };
  var tokenForPart = function(part, formatOpts, resolvedOpts) {
    const {
      type: type2,
      value
    } = part;
    if (type2 === "literal") {
      const isSpace = /^\s+$/.test(value);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value
      };
    }
    const style = formatOpts[type2];
    let actualType = type2;
    if (type2 === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return;
  };
  var buildRegex = function(units) {
    const re = units.map((u2) => u2.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re}\$`, units];
  };
  var match = function(input6, regex, handlers) {
    const matches = input6.match(regex);
    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty3(handlers, i)) {
          const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  };
  var dateTimeFromMatches = function(matches) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }
    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }
    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }
    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }
    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }
    const vals = Object.keys(matches).reduce((r, k) => {
      const f = toField(k);
      if (f) {
        r[f] = matches[k];
      }
      return r;
    }, {});
    return [vals, zone, specificOffset];
  };
  var getDummyDateTime = function() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  };
  var maybeExpandMacroToken = function(token, locale) {
    if (token.literal) {
      return token;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);
    if (tokens == null || tokens.includes(undefined)) {
      return token;
    }
    return tokens;
  };
  var expandMacroTokens = function(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
  };
  var explainFromTokens = function(locale, input6, format) {
    const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
    if (disqualifyingUnit) {
      return {
        input: input6,
        tokens,
        invalidReason: disqualifyingUnit.invalidReason
      };
    } else {
      const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input6, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
      if (hasOwnProperty3(matches, "a") && hasOwnProperty3(matches, "H")) {
        throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
      }
      return {
        input: input6,
        tokens,
        regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset
      };
    }
  };
  var parseFromTokens = function(locale, input6, format) {
    const {
      result,
      zone,
      specificOffset,
      invalidReason
    } = explainFromTokens(locale, input6, format);
    return [result, zone, specificOffset, invalidReason];
  };
  var formatOptsToTokens = function(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
  };
  var unitOutOfRange = function(unit, value) {
    return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
  };
  var dayOfWeek = function(year, month, day2) {
    const d = new Date(Date.UTC(year, month - 1, day2));
    if (year < 100 && year >= 0) {
      d.setUTCFullYear(d.getUTCFullYear() - 1900);
    }
    const js = d.getUTCDay();
    return js === 0 ? 7 : js;
  };
  var computeOrdinal = function(year, month, day2) {
    return day2 + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  };
  var uncomputeOrdinal = function(year, ordinal) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day2 = ordinal - table[month0];
    return {
      month: month0 + 1,
      day: day2
    };
  };
  var gregorianToWeek = function(gregObj) {
    const {
      year,
      month,
      day: day2
    } = gregObj, ordinal = computeOrdinal(year, month, day2), weekday = dayOfWeek(year, month, day2);
    let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear);
    } else if (weekNumber > weeksInWeekYear(year)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return {
      weekYear,
      weekNumber,
      weekday,
      ...timeObject(gregObj)
    };
  };
  var weekToGregorian = function(weekData) {
    const {
      weekYear,
      weekNumber,
      weekday
    } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const {
      month,
      day: day2
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day: day2,
      ...timeObject(weekData)
    };
  };
  var gregorianToOrdinal = function(gregData) {
    const {
      year,
      month,
      day: day2
    } = gregData;
    const ordinal = computeOrdinal(year, month, day2);
    return {
      year,
      ordinal,
      ...timeObject(gregData)
    };
  };
  var ordinalToGregorian = function(ordinalData) {
    const {
      year,
      ordinal
    } = ordinalData;
    const {
      month,
      day: day2
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day: day2,
      ...timeObject(ordinalData)
    };
  };
  var hasInvalidWeekData = function(obj) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.week);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else
      return false;
  };
  var hasInvalidOrdinalData = function(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else
      return false;
  };
  var hasInvalidGregorianData = function(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else
      return false;
  };
  var hasInvalidTimeData = function(obj) {
    const {
      hour,
      minute,
      second,
      millisecond
    } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else
      return false;
  };
  var unsupportedZone = function(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  };
  var possiblyCachedWeekData = function(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  };
  var clone = function(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({
      ...current,
      ...alts,
      old: current
    });
  };
  var fixOffset = function(localTS, o, tz) {
    let utcGuess = localTS - o * 60 * 1000;
    const o2 = tz.offset(utcGuess);
    if (o === o2) {
      return [utcGuess, o];
    }
    utcGuess -= (o2 - o) * 60 * 1000;
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
  };
  var tsToObj = function(ts, offset2) {
    ts += offset2 * 60 * 1000;
    const d = new Date(ts);
    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
      hour: d.getUTCHours(),
      minute: d.getUTCMinutes(),
      second: d.getUTCSeconds(),
      millisecond: d.getUTCMilliseconds()
    };
  };
  var objToTS = function(obj, offset2, zone) {
    return fixOffset(objToLocalTS(obj), offset2, zone);
  };
  var adjustTime = function(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c);
    let [ts, o] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o = inst.zone.offset(ts);
    }
    return {
      ts,
      o
    };
  };
  var parseDataToDateTime = function(parsed, parsedZone, opts, format, text, specificOffset) {
    const {
      setZone,
      zone
    } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
    }
  };
  var toTechFormat = function(dt, format, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format) : null;
  };
  var toISODate = function(o, extended) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c = "";
    if (longFormat && o.c.year >= 0)
      c += "+";
    c += padStart(o.c.year, longFormat ? 6 : 4);
    if (extended) {
      c += "-";
      c += padStart(o.c.month);
      c += "-";
      c += padStart(o.c.day);
    } else {
      c += padStart(o.c.month);
      c += padStart(o.c.day);
    }
    return c;
  };
  var toISOTime = function(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c = padStart(o.c.hour);
    if (extended) {
      c += ":";
      c += padStart(o.c.minute);
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c += ":";
      }
    } else {
      c += padStart(o.c.minute);
    }
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += padStart(o.c.second);
      if (o.c.millisecond !== 0 || !suppressMilliseconds) {
        c += ".";
        c += padStart(o.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c += "Z";
      } else if (o.o < 0) {
        c += "-";
        c += padStart(Math.trunc(-o.o / 60));
        c += ":";
        c += padStart(Math.trunc(-o.o % 60));
      } else {
        c += "+";
        c += padStart(Math.trunc(o.o / 60));
        c += ":";
        c += padStart(Math.trunc(o.o % 60));
      }
    }
    if (extendedZone) {
      c += "[" + o.zone.ianaName + "]";
    }
    return c;
  };
  var normalizeUnit = function(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  };
  var quickDT = function(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
    let ts, o;
    if (!isUndefined(obj.year)) {
      for (const u2 of orderedUnits) {
        if (isUndefined(obj[u2])) {
          obj[u2] = defaultUnitValues[u2];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = zone.offset(tsNow);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = tsNow;
    }
    return new DateTime({
      ts,
      zone,
      loc,
      o
    });
  };
  var diffRelative = function(start, end, opts) {
    const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else
          return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  };
  var lastOpts = function(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  };
  var friendlyDateTime = function(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class LuxonError extends Error {
  }

  class InvalidDateTimeError extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  }

  class InvalidIntervalError extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  }

  class InvalidDurationError extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  }

  class ConflictingSpecificationError extends LuxonError {
  }

  class InvalidUnitError extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  }

  class InvalidArgumentError extends LuxonError {
  }

  class ZoneIsAbstractError extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  }
  var n = "numeric";
  var s = "short";
  var l = "long";
  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };
  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
  };
  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };
  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };
  var TIME_SIMPLE = {
    hour: n,
    minute: n
  };
  var TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };
  var TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
  };
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
  };
  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };

  class Zone {
    get type() {
      throw new ZoneIsAbstractError;
    }
    get name() {
      throw new ZoneIsAbstractError;
    }
    get ianaName() {
      return this.name;
    }
    get isUniversal() {
      throw new ZoneIsAbstractError;
    }
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError;
    }
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError;
    }
    offset(ts) {
      throw new ZoneIsAbstractError;
    }
    equals(otherZone) {
      throw new ZoneIsAbstractError;
    }
    get isValid() {
      throw new ZoneIsAbstractError;
    }
  }
  var singleton$1 = null;

  class SystemZone extends Zone {
    static get instance() {
      if (singleton$1 === null) {
        singleton$1 = new SystemZone;
      }
      return singleton$1;
    }
    get type() {
      return "system";
    }
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    equals(otherZone) {
      return otherZone.type === "system";
    }
    get isValid() {
      return true;
    }
  }
  var dtfCache = {};
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  var ianaZoneCache = {};

  class IANAZone extends Zone {
    static create(name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new IANAZone(name);
      }
      return ianaZoneCache[name];
    }
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    static isValidSpecifier(s2) {
      return this.isValidZone(s2);
    }
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", {
          timeZone: zone
        }).format();
        return true;
      } catch (e) {
        return false;
      }
    }
    constructor(name) {
      super();
      this.zoneName = name;
      this.valid = IANAZone.isValidZone(name);
    }
    get type() {
      return "iana";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      const date = new Date(ts);
      if (isNaN(date))
        return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day2, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day: day2,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0
      });
      let asTS = +date;
      const over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return (asUTC - asTS) / (60 * 1000);
    }
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    get isValid() {
      return this.valid;
    }
  }
  var intlLFCache = {};
  var intlDTCache = {};
  var intlNumCache = {};
  var intlRelCache = {};
  var sysLocaleCache = null;

  class PolyNumberFormatter {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const {
        padTo,
        floor,
        ...otherOpts
      } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = {
          useGrouping: false,
          ...opts
        };
        if (opts.padTo > 0)
          intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  }

  class PolyDateFormatter {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = undefined;
      let z = undefined;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
            minutes: dt.offset
          });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({
          minutes: dt.offset
        });
        this.originalZone = dt.zone;
      }
      const intlOpts = {
        ...this.opts
      };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({
          value
        }) => value).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }

  class PolyRelFormatter {
    constructor(intl, isEnglish, opts) {
      this.opts = {
        style: "long",
        ...opts
      };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  }

  class Locale {
    static fromOpts(opts) {
      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
    }
    static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      return Locale.create(locale, numberingSystem, outputCalendar);
    }
    constructor(locale, numbering, outputCalendar, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = {
        format: {},
        standalone: {}
      };
      this.monthsCache = {
        format: {},
        standalone: {}
      };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: true
      });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: false
      });
    }
    months(length, format = false) {
      return listStuff(this, length, months, () => {
        const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length];
      });
    }
    weekdays(length, format = false) {
      return listStuff(this, length, weekdays, () => {
        const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
        }
        return this.weekdaysCache[formatStr][length];
      });
    }
    meridiems() {
      return listStuff(this, undefined, () => meridiems, () => {
        if (!this.meridiemCache) {
          const intl = {
            hour: "numeric",
            hourCycle: "h12"
          };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
        }
        return this.meridiemCache;
      });
    }
    eras(length) {
      return listStuff(this, length, eras, () => {
        const intl = {
          era: length
        };
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
        }
        return this.eraCache[length];
      });
    }
    extract(dt, intlOpts, field3) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field3);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
  }
  var singleton = null;

  class FixedOffsetZone extends Zone {
    static get utcInstance() {
      if (singleton === null) {
        singleton = new FixedOffsetZone(0);
      }
      return singleton;
    }
    static instance(offset2) {
      return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
    }
    static parseSpecifier(s2) {
      if (s2) {
        const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }
    constructor(offset2) {
      super();
      this.fixed = offset2;
    }
    get type() {
      return "fixed";
    }
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    offsetName() {
      return this.name;
    }
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }
    get isUniversal() {
      return true;
    }
    offset() {
      return this.fixed;
    }
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    get isValid() {
      return true;
    }
  }

  class InvalidZone extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    get type() {
      return "invalid";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName() {
      return null;
    }
    formatOffset() {
      return "";
    }
    offset() {
      return NaN;
    }
    equals() {
      return false;
    }
    get isValid() {
      return false;
    }
  }
  var now = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;

  class Settings {
    static get now() {
      return now;
    }
    static set now(n2) {
      now = n2;
    }
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    static get defaultLocale() {
      return defaultLocale;
    }
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    static set throwOnInvalid(t) {
      throwOnInvalid = t;
    }
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
    }
  }
  var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };

  class Formatter {
    static create(locale, opts = {}) {
      return new Formatter(locale, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0;i < fmt.length; i++) {
        const c = fmt.charAt(i);
        if (c === "'") {
          if (currentFull.length > 0) {
            splits.push({
              literal: bracketed || /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c;
        } else if (c === current) {
          currentFull += c;
        } else {
          if (currentFull.length > 0) {
            splits.push({
              literal: /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          currentFull = c;
          current = c;
        }
      }
      if (currentFull.length > 0) {
        splits.push({
          literal: bracketed || /^\s+$/.test(currentFull),
          val: currentFull
        });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }
    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n2, p = 0) {
      if (this.opts.forceSimple) {
        return padStart(n2, p);
      }
      const opts = {
        ...this.opts
      };
      if (p > 0) {
        opts.padTo = p;
      }
      return this.loc.numberFormatter(opts).format(n2);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"), maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era"), tokenToString = (token) => {
        switch (token) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            return formatOffset2({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            return formatOffset2({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter ? string({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
      return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, {
        literal,
        val
      }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
      return stringifyTokens(tokens, tokenToString(collapsed));
    }
  }

  class Invalid {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  }
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}\$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var INVALID$2 = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
  var reverseUnits = orderedUnits$1.slice(0).reverse();

  class Duration {
    constructor(config) {
      const accurate = config.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config.matrix) {
        matrix = config.matrix;
      }
      this.values = config.values;
      this.loc = config.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    static fromMillis(count, opts) {
      return Duration.fromObject({
        milliseconds: count
      }, opts);
    }
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
      }
      return new Duration({
        values: normalizeObject(obj, Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return Duration.fromMillis(durationLike);
      } else if (Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
      }
    }
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new Duration({
          invalid
        });
      }
    }
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    static isDuration(o) {
      return o && o.isLuxonDuration || false;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
    }
    toHuman(opts = {}) {
      if (!this.isValid)
        return INVALID$2;
      const l2 = orderedUnits$1.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({
          style: "unit",
          unitDisplay: "long",
          ...opts,
          unit: unit.slice(0, -1)
        }).format(val);
      }).filter((n2) => n2);
      return this.loc.listFormatter({
        type: "conjunction",
        style: opts.listStyle || "narrow",
        ...opts
      }).format(l2);
    }
    toObject() {
      if (!this.isValid)
        return {};
      return {
        ...this.values
      };
    }
    toISO() {
      if (!this.isValid)
        return null;
      let s2 = "P";
      if (this.years !== 0)
        s2 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0)
        s2 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0)
        s2 += this.weeks + "W";
      if (this.days !== 0)
        s2 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s2 += "T";
      if (this.hours !== 0)
        s2 += this.hours + "H";
      if (this.minutes !== 0)
        s2 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s2 += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
      if (s2 === "P")
        s2 += "T0S";
      return s2;
    }
    toISOTime(opts = {}) {
      if (!this.isValid)
        return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 86400000)
        return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, {
        zone: "UTC"
      });
      return dateTime.toISOTime(opts);
    }
    toJSON() {
      return this.toISO();
    }
    toString() {
      return this.toISO();
    }
    toMillis() {
      if (!this.isValid)
        return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    valueOf() {
      return this.toMillis();
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration), result = {};
      for (const k of orderedUnits$1) {
        if (hasOwnProperty3(dur.values, k) || hasOwnProperty3(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    mapUnits(fn) {
      if (!this.isValid)
        return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber(fn(this.values[k], k));
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    get(unit) {
      return this[Duration.normalizeUnit(unit)];
    }
    set(values4) {
      if (!this.isValid)
        return this;
      const mixed = {
        ...this.values,
        ...normalizeObject(values4, Duration.normalizeUnit)
      };
      return clone$1(this, {
        values: mixed
      });
    }
    reconfigure({
      locale,
      numberingSystem,
      conversionAccuracy,
      matrix
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem
      });
      const opts = {
        loc,
        matrix,
        conversionAccuracy
      };
      return clone$1(this, opts);
    }
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    normalize() {
      if (!this.isValid)
        return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone$1(this, {
        values: vals
      }, true);
    }
    rescale() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone$1(this, {
        values: vals
      }, true);
    }
    shiftTo(...units) {
      if (!this.isValid)
        return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u2) => Duration.normalizeUnit(u2));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits$1) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1000 - i * 1000) / 1000;
        } else if (isNumber(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone$1(this, {
        values: built
      }, true);
    }
    shiftToAll() {
      if (!this.isValid)
        return this;
      return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
    }
    negate() {
      if (!this.isValid)
        return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone$1(this, {
        values: negated
      }, true);
    }
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === undefined || v1 === 0)
          return v2 === undefined || v2 === 0;
        return v1 === v2;
      }
      for (const u2 of orderedUnits$1) {
        if (!eq(this.values[u2], other.values[u2])) {
          return false;
        }
      }
      return true;
    }
  }
  var INVALID$1 = "Invalid Interval";

  class Interval {
    constructor(config) {
      this.s = config.start;
      this.e = config.end;
      this.invalid = config.invalid || null;
      this.isLuxonInterval = true;
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new Interval({
          invalid
        });
      }
    }
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    static after(start, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
      return Interval.fromDateTimes(dt, dt.plus(dur));
    }
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return Interval.fromDateTimes(dt.minus(dur), dt);
    }
    static fromISO(text, opts) {
      const [s2, e] = (text || "").split("/", 2);
      if (s2 && e) {
        let start, startIsValid;
        try {
          start = DateTime.fromISO(s2, opts);
          startIsValid = start.isValid;
        } catch (e2) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e, opts);
          endIsValid = end.isValid;
        } catch (e2) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return Interval.fromDateTimes(start, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e, opts);
          if (dur.isValid) {
            return Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s2, opts);
          if (dur.isValid) {
            return Interval.before(end, dur);
          }
        }
      }
      return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    static isInterval(o) {
      return o && o.isLuxonInterval || false;
    }
    get start() {
      return this.isValid ? this.s : null;
    }
    get end() {
      return this.isValid ? this.e : null;
    }
    get isValid() {
      return this.invalidReason === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    count(unit = "milliseconds") {
      if (!this.isValid)
        return NaN;
      const start = this.start.startOf(unit), end = this.end.startOf(unit);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    isAfter(dateTime) {
      if (!this.isValid)
        return false;
      return this.s > dateTime;
    }
    isBefore(dateTime) {
      if (!this.isValid)
        return false;
      return this.e <= dateTime;
    }
    contains(dateTime) {
      if (!this.isValid)
        return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    set({
      start,
      end
    } = {}) {
      if (!this.isValid)
        return this;
      return Interval.fromDateTimes(start || this.s, end || this.e);
    }
    splitAt(...dateTimes) {
      if (!this.isValid)
        return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
      let {
        s: s2
      } = this, i = 0;
      while (s2 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s2, next));
        s2 = next;
        i += 1;
      }
      return results;
    }
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let {
        s: s2
      } = this, idx = 1, next;
      const results = [];
      while (s2 < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s2, next));
        s2 = next;
        idx += 1;
      }
      return results;
    }
    divideEqually(numberOfParts) {
      if (!this.isValid)
        return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    abutsStart(other) {
      if (!this.isValid)
        return false;
      return +this.e === +other.s;
    }
    abutsEnd(other) {
      if (!this.isValid)
        return false;
      return +other.e === +this.s;
    }
    engulfs(other) {
      if (!this.isValid)
        return false;
      return this.s <= other.s && this.e >= other.e;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    intersection(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
      if (s2 >= e) {
        return null;
      } else {
        return Interval.fromDateTimes(s2, e);
      }
    }
    union(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
      return Interval.fromDateTimes(s2, e);
    }
    static merge(intervals) {
      const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      }, [[], null]);
      if (final) {
        found.push(final);
      }
      return found;
    }
    static xor(intervals) {
      let start = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start = i.time;
        } else {
          if (start && +start !== +i.time) {
            results.push(Interval.fromDateTimes(start, i.time));
          }
          start = null;
        }
      }
      return Interval.merge(results);
    }
    difference(...intervals) {
      return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    toString() {
      if (!this.isValid)
        return INVALID$1;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
    }
    toISO(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    toISODate() {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    toISOTime(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    toFormat(dateFormat, {
      separator = " \u2013 "
    } = {}) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    mapEndpoints(mapFn) {
      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  }

  class Info {
    static hasDST(zone = Settings.defaultZone) {
      const proto2 = DateTime.now().setZone(zone).set({
        month: 12
      });
      return !zone.isUniversal && proto2.offset !== proto2.set({
        month: 6
      }).offset;
    }
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    static normalizeZone(input6) {
      return normalizeZone(input6, Settings.defaultZone);
    }
    static months(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }
    static monthsFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }
    static weekdays(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }
    static weekdaysFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }
    static meridiems({
      locale = null
    } = {}) {
      return Locale.create(locale).meridiems();
    }
    static eras(length = "short", {
      locale = null
    } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }
    static features() {
      return {
        relative: hasRelative()
      };
    }
  }
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  var dummyDateTimeCache = null;
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var INVALID = "Invalid DateTime";
  var MAX_DATE = 8640000000000000;
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

  class DateTime {
    constructor(config) {
      const zone = config.zone || Settings.defaultZone;
      let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
      let c = null, o = null;
      if (!invalid) {
        const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
        if (unchanged) {
          [c, o] = [config.old.c, config.old.o];
        } else {
          const ot = zone.offset(this.ts);
          c = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
          c = invalid ? null : c;
          o = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.c = c;
      this.o = o;
      this.isLuxonDateTime = true;
    }
    static now() {
      return new DateTime({});
    }
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day2, hour, minute, second, millisecond] = args;
      return quickDT({
        year,
        month,
        day: day2,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day2, hour, minute, second, millisecond] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({
        year,
        month,
        day: day2,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static fromJSDate(date, options = {}) {
      const ts = isDate(date) ? date.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return DateTime.invalid("Timestamp out of range");
      } else {
        return new DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new DateTime({
          ts: seconds * 1000,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u2 of units) {
        const v = normalized[u2];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u2] = defaultValues[u2];
        } else {
          normalized[u2] = objNow[u2];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
      }
      return inst;
    }
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    static fromString(text, fmt, opts = {}) {
      return DateTime.fromFormat(text, fmt, opts);
    }
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new DateTime({
          invalid
        });
      }
    }
    static isDateTime(o) {
      return o && o.isLuxonDateTime || false;
    }
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
    }
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t) => t.val).join("");
    }
    get(unit) {
      return this[unit];
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    get zone() {
      return this._zone;
    }
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    get monthShort() {
      return this.isValid ? Info.months("short", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get monthLong() {
      return this.isValid ? Info.months("long", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1,
          day: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 86400000;
      const minuteMs = 60000;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c12 = tsToObj(ts1, o1);
      const c2 = tsToObj(ts2, o2);
      if (c12.hour === c2.hour && c12.minute === c2.minute && c12.second === c2.second && c12.millisecond === c2.millisecond) {
        return [clone(this, {
          ts: ts1
        }), clone(this, {
          ts: ts2
        })];
      }
      return [this];
    }
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    resolvedLocaleOptions(opts = {}) {
      const {
        locale,
        numberingSystem,
        calendar
      } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
      return {
        locale,
        numberingSystem,
        outputCalendar: calendar
      };
    }
    toUTC(offset2 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset2), opts);
    }
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    setZone(zone, {
      keepLocalTime = false,
      keepCalendarTime = false
    } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone(this, {
          ts: newTS,
          zone
        });
      }
    }
    reconfigure({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem,
        outputCalendar
      });
      return clone(this, {
        loc
      });
    }
    setLocale(locale) {
      return this.reconfigure({
        locale
      });
    }
    set(values4) {
      if (!this.isValid)
        return this;
      const normalized = normalizeObject(values4, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian({
          ...gregorianToWeek(this.c),
          ...normalized
        });
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({
          ...gregorianToOrdinal(this.c),
          ...normalized
        });
      } else {
        mixed = {
          ...this.toObject(),
          ...normalized
        };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone(this, {
        ts,
        o
      });
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return clone(this, adjustTime(this, dur));
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone(this, adjustTime(this, dur));
    }
    startOf(unit) {
      if (!this.isValid)
        return this;
      const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        case "quarters":
        case "months":
          o.day = 1;
        case "weeks":
        case "days":
          o.hour = 0;
        case "hours":
          o.minute = 0;
        case "minutes":
          o.second = 0;
        case "seconds":
          o.millisecond = 0;
          break;
      }
      if (normalizedUnit === "weeks") {
        o.weekday = 1;
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }
      return this.set(o);
    }
    endOf(unit) {
      return this.isValid ? this.plus({
        [unit]: 1
      }).startOf(unit).minus(1) : this;
    }
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
    }
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format === "extended";
      let c = toISODate(this, ext);
      c += "T";
      c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c;
    }
    toISODate({
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format === "extended");
    }
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c = includePrefix ? "T" : "";
      return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    }
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    toSQLTime({
      includeOffset = true,
      includeZone = false,
      includeOffsetSpace = true
    } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    toString() {
      return this.isValid ? this.toISO() : INVALID;
    }
    valueOf() {
      return this.toMillis();
    }
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    toSeconds() {
      return this.isValid ? this.ts / 1000 : NaN;
    }
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1000) : NaN;
    }
    toJSON() {
      return this.toISO();
    }
    toBSON() {
      return this.toJSDate();
    }
    toObject(opts = {}) {
      if (!this.isValid)
        return {};
      const base18 = {
        ...this.c
      };
      if (opts.includeConfig) {
        base18.outputCalendar = this.outputCalendar;
        base18.numberingSystem = this.loc.numberingSystem;
        base18.locale = this.loc.locale;
      }
      return base18;
    }
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = {
        locale: this.locale,
        numberingSystem: this.numberingSystem,
        ...opts
      };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(DateTime.now(), unit, opts);
    }
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    hasSame(otherDateTime, unit) {
      if (!this.isValid)
        return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, {
        keepLocalTime: true
      });
      return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
    }
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    toRelative(options = {}) {
      if (!this.isValid)
        return null;
      const base18 = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), padding = options.padding ? this < base18 ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = undefined;
      }
      return diffRelative(base18, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    toRelativeCalendar(options = {}) {
      if (!this.isValid)
        return null;
      return diffRelative(options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    static min(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    static max(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    static fromFormatExplain(text, fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    static fromStringExplain(text, fmt, options = {}) {
      return DateTime.fromFormatExplain(text, fmt, options);
    }
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    static get DATE_MED() {
      return DATE_MED;
    }
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    static get DATE_FULL() {
      return DATE_FULL;
    }
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }
  var VERSION = "3.4.3";
  exports.DateTime = DateTime;
  exports.Duration = Duration;
  exports.FixedOffsetZone = FixedOffsetZone;
  exports.IANAZone = IANAZone;
  exports.Info = Info;
  exports.Interval = Interval;
  exports.InvalidZone = InvalidZone;
  exports.Settings = Settings;
  exports.SystemZone = SystemZone;
  exports.VERSION = VERSION;
  exports.Zone = Zone;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/date.js
var require_date = __commonJS((exports, module) => {
  var CronDate = function(timestamp, tz) {
    var dateOpts = { zone: tz };
    if (!timestamp) {
      this._date = luxon.DateTime.local();
    } else if (timestamp instanceof CronDate) {
      this._date = timestamp._date;
    } else if (timestamp instanceof Date) {
      this._date = luxon.DateTime.fromJSDate(timestamp, dateOpts);
    } else if (typeof timestamp === "number") {
      this._date = luxon.DateTime.fromMillis(timestamp, dateOpts);
    } else if (typeof timestamp === "string") {
      this._date = luxon.DateTime.fromISO(timestamp, dateOpts);
      this._date.isValid || (this._date = luxon.DateTime.fromRFC2822(timestamp, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromSQL(timestamp, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromFormat(timestamp, "EEE, d MMM yyyy HH:mm:ss", dateOpts));
    }
    if (!this._date || !this._date.isValid) {
      throw new Error("CronDate: unhandled timestamp: " + JSON.stringify(timestamp));
    }
    if (tz && tz !== this._date.zoneName) {
      this._date = this._date.setZone(tz);
    }
  };
  var luxon = require_luxon();
  CronDate.prototype.addYear = function() {
    this._date = this._date.plus({ years: 1 });
  };
  CronDate.prototype.addMonth = function() {
    this._date = this._date.plus({ months: 1 }).startOf("month");
  };
  CronDate.prototype.addDay = function() {
    this._date = this._date.plus({ days: 1 }).startOf("day");
  };
  CronDate.prototype.addHour = function() {
    var prev = this._date;
    this._date = this._date.plus({ hours: 1 }).startOf("hour");
    if (this._date <= prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addMinute = function() {
    var prev = this._date;
    this._date = this._date.plus({ minutes: 1 }).startOf("minute");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addSecond = function() {
    var prev = this._date;
    this._date = this._date.plus({ seconds: 1 }).startOf("second");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractYear = function() {
    this._date = this._date.minus({ years: 1 });
  };
  CronDate.prototype.subtractMonth = function() {
    this._date = this._date.minus({ months: 1 }).endOf("month").startOf("second");
  };
  CronDate.prototype.subtractDay = function() {
    this._date = this._date.minus({ days: 1 }).endOf("day").startOf("second");
  };
  CronDate.prototype.subtractHour = function() {
    var prev = this._date;
    this._date = this._date.minus({ hours: 1 }).endOf("hour").startOf("second");
    if (this._date >= prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractMinute = function() {
    var prev = this._date;
    this._date = this._date.minus({ minutes: 1 }).endOf("minute").startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractSecond = function() {
    var prev = this._date;
    this._date = this._date.minus({ seconds: 1 }).startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.getDate = function() {
    return this._date.day;
  };
  CronDate.prototype.getFullYear = function() {
    return this._date.year;
  };
  CronDate.prototype.getDay = function() {
    var weekday = this._date.weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getMonth = function() {
    return this._date.month - 1;
  };
  CronDate.prototype.getHours = function() {
    return this._date.hour;
  };
  CronDate.prototype.getMinutes = function() {
    return this._date.minute;
  };
  CronDate.prototype.getSeconds = function() {
    return this._date.second;
  };
  CronDate.prototype.getMilliseconds = function() {
    return this._date.millisecond;
  };
  CronDate.prototype.getTime = function() {
    return this._date.valueOf();
  };
  CronDate.prototype.getUTCDate = function() {
    return this._getUTC().day;
  };
  CronDate.prototype.getUTCFullYear = function() {
    return this._getUTC().year;
  };
  CronDate.prototype.getUTCDay = function() {
    var weekday = this._getUTC().weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getUTCMonth = function() {
    return this._getUTC().month - 1;
  };
  CronDate.prototype.getUTCHours = function() {
    return this._getUTC().hour;
  };
  CronDate.prototype.getUTCMinutes = function() {
    return this._getUTC().minute;
  };
  CronDate.prototype.getUTCSeconds = function() {
    return this._getUTC().second;
  };
  CronDate.prototype.toISOString = function() {
    return this._date.toUTC().toISO();
  };
  CronDate.prototype.toJSON = function() {
    return this._date.toJSON();
  };
  CronDate.prototype.setDate = function(d) {
    this._date = this._date.set({ day: d });
  };
  CronDate.prototype.setFullYear = function(y) {
    this._date = this._date.set({ year: y });
  };
  CronDate.prototype.setDay = function(d) {
    this._date = this._date.set({ weekday: d });
  };
  CronDate.prototype.setMonth = function(m) {
    this._date = this._date.set({ month: m + 1 });
  };
  CronDate.prototype.setHours = function(h) {
    this._date = this._date.set({ hour: h });
  };
  CronDate.prototype.setMinutes = function(m) {
    this._date = this._date.set({ minute: m });
  };
  CronDate.prototype.setSeconds = function(s) {
    this._date = this._date.set({ second: s });
  };
  CronDate.prototype.setMilliseconds = function(s) {
    this._date = this._date.set({ millisecond: s });
  };
  CronDate.prototype._getUTC = function() {
    return this._date.toUTC();
  };
  CronDate.prototype.toString = function() {
    return this.toDate().toString();
  };
  CronDate.prototype.toDate = function() {
    return this._date.toJSDate();
  };
  CronDate.prototype.isLastDayOfMonth = function() {
    var newDate = this._date.plus({ days: 1 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  CronDate.prototype.isLastWeekdayOfMonth = function() {
    var newDate = this._date.plus({ days: 7 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  module.exports = CronDate;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/field_compactor.js
var require_field_compactor = __commonJS((exports, module) => {
  var buildRange = function(item) {
    return {
      start: item,
      count: 1
    };
  };
  var completeRangeWithItem = function(range, item) {
    range.end = item;
    range.step = item - range.start;
    range.count = 2;
  };
  var finalizeCurrentRange = function(results, currentRange, currentItemRange) {
    if (currentRange) {
      if (currentRange.count === 2) {
        results.push(buildRange(currentRange.start));
        results.push(buildRange(currentRange.end));
      } else {
        results.push(currentRange);
      }
    }
    if (currentItemRange) {
      results.push(currentItemRange);
    }
  };
  var compactField = function(arr) {
    var results = [];
    var currentRange = undefined;
    for (var i = 0;i < arr.length; i++) {
      var currentItem = arr[i];
      if (typeof currentItem !== "number") {
        finalizeCurrentRange(results, currentRange, buildRange(currentItem));
        currentRange = undefined;
      } else if (!currentRange) {
        currentRange = buildRange(currentItem);
      } else if (currentRange.count === 1) {
        completeRangeWithItem(currentRange, currentItem);
      } else {
        if (currentRange.step === currentItem - currentRange.end) {
          currentRange.count++;
          currentRange.end = currentItem;
        } else if (currentRange.count === 2) {
          results.push(buildRange(currentRange.start));
          currentRange = buildRange(currentRange.end);
          completeRangeWithItem(currentRange, currentItem);
        } else {
          finalizeCurrentRange(results, currentRange);
          currentRange = buildRange(currentItem);
        }
      }
    }
    finalizeCurrentRange(results, currentRange);
    return results;
  };
  module.exports = compactField;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/field_stringify.js
var require_field_stringify = __commonJS((exports, module) => {
  var stringifyField = function(arr, min, max) {
    var ranges = compactField(arr);
    if (ranges.length === 1) {
      var singleRange = ranges[0];
      var step = singleRange.step;
      if (step === 1 && singleRange.start === min && singleRange.end === max) {
        return "*";
      }
      if (step !== 1 && singleRange.start === min && singleRange.end === max - step + 1) {
        return "*/" + step;
      }
    }
    var result = [];
    for (var i = 0, l = ranges.length;i < l; ++i) {
      var range = ranges[i];
      if (range.count === 1) {
        result.push(range.start);
        continue;
      }
      var step = range.step;
      if (range.step === 1) {
        result.push(range.start + "-" + range.end);
        continue;
      }
      var multiplier = range.start == 0 ? range.count - 1 : range.count;
      if (range.step * multiplier > range.end) {
        result = result.concat(Array.from({ length: range.end - range.start + 1 }).map(function(_, index) {
          var value = range.start + index;
          if ((value - range.start) % range.step === 0) {
            return value;
          }
          return null;
        }).filter(function(value) {
          return value != null;
        }));
      } else if (range.end === max - range.step + 1) {
        result.push(range.start + "/" + range.step);
      } else {
        result.push(range.start + "-" + range.end + "/" + range.step);
      }
    }
    return result.join(",");
  };
  var compactField = require_field_compactor();
  module.exports = stringifyField;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/expression.js
var require_expression = __commonJS((exports, module) => {
  var CronExpression = function(fields, options) {
    this._options = options;
    this._utc = options.utc || false;
    this._tz = this._utc ? "UTC" : options.tz;
    this._currentDate = new CronDate(options.currentDate, this._tz);
    this._startDate = options.startDate ? new CronDate(options.startDate, this._tz) : null;
    this._endDate = options.endDate ? new CronDate(options.endDate, this._tz) : null;
    this._isIterator = options.iterator || false;
    this._hasIterated = false;
    this._nthDayOfWeek = options.nthDayOfWeek || 0;
    this.fields = CronExpression._freezeFields(fields);
  };
  var CronDate = require_date();
  var stringifyField = require_field_stringify();
  var LOOP_LIMIT = 1e4;
  CronExpression.map = ["second", "minute", "hour", "dayOfMonth", "month", "dayOfWeek"];
  CronExpression.predefined = {
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  CronExpression.constraints = [
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 23, chars: [] },
    { min: 1, max: 31, chars: ["L"] },
    { min: 1, max: 12, chars: [] },
    { min: 0, max: 7, chars: ["L"] }
  ];
  CronExpression.daysInMonth = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  CronExpression.aliases = {
    month: {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12
    },
    dayOfWeek: {
      sun: 0,
      mon: 1,
      tue: 2,
      wed: 3,
      thu: 4,
      fri: 5,
      sat: 6
    }
  };
  CronExpression.parseDefaults = ["0", "*", "*", "*", "*", "*"];
  CronExpression.standardValidCharacters = /^[,*\d/-]+$/;
  CronExpression.dayOfWeekValidCharacters = /^[?,*\dL#/-]+$/;
  CronExpression.dayOfMonthValidCharacters = /^[?,*\dL/-]+$/;
  CronExpression.validCharacters = {
    second: CronExpression.standardValidCharacters,
    minute: CronExpression.standardValidCharacters,
    hour: CronExpression.standardValidCharacters,
    dayOfMonth: CronExpression.dayOfMonthValidCharacters,
    month: CronExpression.standardValidCharacters,
    dayOfWeek: CronExpression.dayOfWeekValidCharacters
  };
  CronExpression._isValidConstraintChar = function _isValidConstraintChar(constraints, value) {
    if (typeof value !== "string") {
      return false;
    }
    return constraints.chars.some(function(char) {
      return value.indexOf(char) > -1;
    });
  };
  CronExpression._parseField = function _parseField(field3, value, constraints) {
    switch (field3) {
      case "month":
      case "dayOfWeek":
        var aliases = CronExpression.aliases[field3];
        value = value.replace(/[a-z]{3}/gi, function(match) {
          match = match.toLowerCase();
          if (typeof aliases[match] !== "undefined") {
            return aliases[match];
          } else {
            throw new Error('Validation error, cannot resolve alias "' + match + '"');
          }
        });
        break;
    }
    if (!CronExpression.validCharacters[field3].test(value)) {
      throw new Error("Invalid characters, got value: " + value);
    }
    if (value.indexOf("*") !== -1) {
      value = value.replace(/\*/g, constraints.min + "-" + constraints.max);
    } else if (value.indexOf("?") !== -1) {
      value = value.replace(/\?/g, constraints.min + "-" + constraints.max);
    }
    function parseSequence(val) {
      var stack = [];
      function handleResult(result) {
        if (result instanceof Array) {
          for (var i2 = 0, c2 = result.length;i2 < c2; i2++) {
            var value2 = result[i2];
            if (CronExpression._isValidConstraintChar(constraints, value2)) {
              stack.push(value2);
              continue;
            }
            if (typeof value2 !== "number" || Number.isNaN(value2) || value2 < constraints.min || value2 > constraints.max) {
              throw new Error("Constraint error, got value " + value2 + " expected range " + constraints.min + "-" + constraints.max);
            }
            stack.push(value2);
          }
        } else {
          if (CronExpression._isValidConstraintChar(constraints, result)) {
            stack.push(result);
            return;
          }
          var numResult = +result;
          if (Number.isNaN(numResult) || numResult < constraints.min || numResult > constraints.max) {
            throw new Error("Constraint error, got value " + result + " expected range " + constraints.min + "-" + constraints.max);
          }
          if (field3 === "dayOfWeek") {
            numResult = numResult % 7;
          }
          stack.push(numResult);
        }
      }
      var atoms = val.split(",");
      if (!atoms.every(function(atom) {
        return atom.length > 0;
      })) {
        throw new Error("Invalid list value format");
      }
      if (atoms.length > 1) {
        for (var i = 0, c = atoms.length;i < c; i++) {
          handleResult(parseRepeat(atoms[i]));
        }
      } else {
        handleResult(parseRepeat(val));
      }
      stack.sort(CronExpression._sortCompareFn);
      return stack;
    }
    function parseRepeat(val) {
      var repeatInterval = 1;
      var atoms = val.split("/");
      if (atoms.length > 2) {
        throw new Error("Invalid repeat: " + val);
      }
      if (atoms.length > 1) {
        if (atoms[0] == +atoms[0]) {
          atoms = [atoms[0] + "-" + constraints.max, atoms[1]];
        }
        return parseRange(atoms[0], atoms[atoms.length - 1]);
      }
      return parseRange(val, repeatInterval);
    }
    function parseRange(val, repeatInterval) {
      var stack = [];
      var atoms = val.split("-");
      if (atoms.length > 1) {
        if (atoms.length < 2) {
          return +val;
        }
        if (!atoms[0].length) {
          if (!atoms[1].length) {
            throw new Error("Invalid range: " + val);
          }
          return +val;
        }
        var min = +atoms[0];
        var max = +atoms[1];
        if (Number.isNaN(min) || Number.isNaN(max) || min < constraints.min || max > constraints.max) {
          throw new Error("Constraint error, got range " + min + "-" + max + " expected range " + constraints.min + "-" + constraints.max);
        } else if (min > max) {
          throw new Error("Invalid range: " + val);
        }
        var repeatIndex = +repeatInterval;
        if (Number.isNaN(repeatIndex) || repeatIndex <= 0) {
          throw new Error("Constraint error, cannot repeat at every " + repeatIndex + " time.");
        }
        if (field3 === "dayOfWeek" && max % 7 === 0) {
          stack.push(0);
        }
        for (var index = min, count = max;index <= count; index++) {
          var exists = stack.indexOf(index) !== -1;
          if (!exists && repeatIndex > 0 && repeatIndex % repeatInterval === 0) {
            repeatIndex = 1;
            stack.push(index);
          } else {
            repeatIndex++;
          }
        }
        return stack;
      }
      return Number.isNaN(+val) ? val : +val;
    }
    return parseSequence(value);
  };
  CronExpression._sortCompareFn = function(a, b) {
    var aIsNumber = typeof a === "number";
    var bIsNumber = typeof b === "number";
    if (aIsNumber && bIsNumber) {
      return a - b;
    }
    if (!aIsNumber && bIsNumber) {
      return 1;
    }
    if (aIsNumber && !bIsNumber) {
      return -1;
    }
    return a.localeCompare(b);
  };
  CronExpression._handleMaxDaysInMonth = function(mappedFields) {
    if (mappedFields.month.length === 1) {
      var daysInMonth = CronExpression.daysInMonth[mappedFields.month[0] - 1];
      if (mappedFields.dayOfMonth[0] > daysInMonth) {
        throw new Error("Invalid explicit day of month definition");
      }
      return mappedFields.dayOfMonth.filter(function(dayOfMonth) {
        return dayOfMonth === "L" ? true : dayOfMonth <= daysInMonth;
      }).sort(CronExpression._sortCompareFn);
    }
  };
  CronExpression._freezeFields = function(fields) {
    for (var i = 0, c = CronExpression.map.length;i < c; ++i) {
      var field3 = CronExpression.map[i];
      var value = fields[field3];
      fields[field3] = Object.freeze(value);
    }
    return Object.freeze(fields);
  };
  CronExpression.prototype._applyTimezoneShift = function(currentDate, dateMathVerb, method) {
    if (method === "Month" || method === "Day") {
      var prevTime = currentDate.getTime();
      currentDate[dateMathVerb + method]();
      var currTime = currentDate.getTime();
      if (prevTime === currTime) {
        if (currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
          currentDate.addHour();
        } else if (currentDate.getMinutes() === 59 && currentDate.getSeconds() === 59) {
          currentDate.subtractHour();
        }
      }
    } else {
      var previousHour = currentDate.getHours();
      currentDate[dateMathVerb + method]();
      var currentHour = currentDate.getHours();
      var diff = currentHour - previousHour;
      if (diff === 2) {
        if (this.fields.hour.length !== 24) {
          this._dstStart = currentHour;
        }
      } else if (diff === 0 && currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
        if (this.fields.hour.length !== 24) {
          this._dstEnd = currentHour;
        }
      }
    }
  };
  CronExpression.prototype._findSchedule = function _findSchedule(reverse) {
    function matchSchedule(value, sequence) {
      for (var i = 0, c = sequence.length;i < c; i++) {
        if (sequence[i] >= value) {
          return sequence[i] === value;
        }
      }
      return sequence[0] === value;
    }
    function isNthDayMatch(date, nthDayOfWeek) {
      if (nthDayOfWeek < 6) {
        if (date.getDate() < 8 && nthDayOfWeek === 1) {
          return true;
        }
        var offset = date.getDate() % 7 ? 1 : 0;
        var adjustedDate = date.getDate() - date.getDate() % 7;
        var occurrence = Math.floor(adjustedDate / 7) + offset;
        return occurrence === nthDayOfWeek;
      }
      return false;
    }
    function isLInExpressions(expressions) {
      return expressions.length > 0 && expressions.some(function(expression) {
        return typeof expression === "string" && expression.indexOf("L") >= 0;
      });
    }
    reverse = reverse || false;
    var dateMathVerb = reverse ? "subtract" : "add";
    var currentDate = new CronDate(this._currentDate, this._tz);
    var startDate = this._startDate;
    var endDate = this._endDate;
    var startTimestamp = currentDate.getTime();
    var stepCount = 0;
    function isLastWeekdayOfMonthMatch(expressions) {
      return expressions.some(function(expression) {
        if (!isLInExpressions([expression])) {
          return false;
        }
        var weekday = Number.parseInt(expression[0]) % 7;
        if (Number.isNaN(weekday)) {
          throw new Error("Invalid last weekday of the month expression: " + expression);
        }
        return currentDate.getDay() === weekday && currentDate.isLastWeekdayOfMonth();
      });
    }
    while (stepCount < LOOP_LIMIT) {
      stepCount++;
      if (reverse) {
        if (startDate && currentDate.getTime() - startDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      } else {
        if (endDate && endDate.getTime() - currentDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      }
      var dayOfMonthMatch = matchSchedule(currentDate.getDate(), this.fields.dayOfMonth);
      if (isLInExpressions(this.fields.dayOfMonth)) {
        dayOfMonthMatch = dayOfMonthMatch || currentDate.isLastDayOfMonth();
      }
      var dayOfWeekMatch = matchSchedule(currentDate.getDay(), this.fields.dayOfWeek);
      if (isLInExpressions(this.fields.dayOfWeek)) {
        dayOfWeekMatch = dayOfWeekMatch || isLastWeekdayOfMonthMatch(this.fields.dayOfWeek);
      }
      var isDayOfMonthWildcardMatch = this.fields.dayOfMonth.length >= CronExpression.daysInMonth[currentDate.getMonth()];
      var isDayOfWeekWildcardMatch = this.fields.dayOfWeek.length === CronExpression.constraints[5].max - CronExpression.constraints[5].min + 1;
      var currentHour = currentDate.getHours();
      if (!dayOfMonthMatch && (!dayOfWeekMatch || isDayOfWeekWildcardMatch)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!isDayOfMonthWildcardMatch && isDayOfWeekWildcardMatch && !dayOfMonthMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (isDayOfMonthWildcardMatch && !isDayOfWeekWildcardMatch && !dayOfWeekMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (this._nthDayOfWeek > 0 && !isNthDayMatch(currentDate, this._nthDayOfWeek)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!matchSchedule(currentDate.getMonth() + 1, this.fields.month)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Month");
        continue;
      }
      if (!matchSchedule(currentHour, this.fields.hour)) {
        if (this._dstStart !== currentHour) {
          this._dstStart = null;
          this._applyTimezoneShift(currentDate, dateMathVerb, "Hour");
          continue;
        } else if (!matchSchedule(currentHour - 1, this.fields.hour)) {
          currentDate[dateMathVerb + "Hour"]();
          continue;
        }
      } else if (this._dstEnd === currentHour) {
        if (!reverse) {
          this._dstEnd = null;
          this._applyTimezoneShift(currentDate, "add", "Hour");
          continue;
        }
      }
      if (!matchSchedule(currentDate.getMinutes(), this.fields.minute)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Minute");
        continue;
      }
      if (!matchSchedule(currentDate.getSeconds(), this.fields.second)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        continue;
      }
      if (startTimestamp === currentDate.getTime()) {
        if (dateMathVerb === "add" || currentDate.getMilliseconds() === 0) {
          this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        } else {
          currentDate.setMilliseconds(0);
        }
        continue;
      }
      break;
    }
    if (stepCount >= LOOP_LIMIT) {
      throw new Error("Invalid expression, loop limit exceeded");
    }
    this._currentDate = new CronDate(currentDate, this._tz);
    this._hasIterated = true;
    return currentDate;
  };
  CronExpression.prototype.next = function next() {
    var schedule = this._findSchedule();
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasNext()
      };
    }
    return schedule;
  };
  CronExpression.prototype.prev = function prev() {
    var schedule = this._findSchedule(true);
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasPrev()
      };
    }
    return schedule;
  };
  CronExpression.prototype.hasNext = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule();
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.hasPrev = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule(true);
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.iterate = function iterate(steps2, callback) {
    var dates = [];
    if (steps2 >= 0) {
      for (var i = 0, c = steps2;i < c; i++) {
        try {
          var item = this.next();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    } else {
      for (var i = 0, c = steps2;i > c; i--) {
        try {
          var item = this.prev();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    }
    return dates;
  };
  CronExpression.prototype.reset = function reset(newDate) {
    this._currentDate = new CronDate(newDate || this._options.currentDate);
  };
  CronExpression.prototype.stringify = function stringify(includeSeconds) {
    var resultArr = [];
    for (var i = includeSeconds ? 0 : 1, c = CronExpression.map.length;i < c; ++i) {
      var field3 = CronExpression.map[i];
      var value = this.fields[field3];
      var constraint = CronExpression.constraints[i];
      if (field3 === "dayOfMonth" && this.fields.month.length === 1) {
        constraint = { min: 1, max: CronExpression.daysInMonth[this.fields.month[0] - 1] };
      } else if (field3 === "dayOfWeek") {
        constraint = { min: 0, max: 6 };
        value = value[value.length - 1] === 7 ? value.slice(0, -1) : value;
      }
      resultArr.push(stringifyField(value, constraint.min, constraint.max));
    }
    return resultArr.join(" ");
  };
  CronExpression.parse = function parse(expression, options) {
    var self2 = this;
    if (typeof options === "function") {
      options = {};
    }
    function parse2(expression2, options2) {
      if (!options2) {
        options2 = {};
      }
      if (typeof options2.currentDate === "undefined") {
        options2.currentDate = new CronDate(undefined, self2._tz);
      }
      if (CronExpression.predefined[expression2]) {
        expression2 = CronExpression.predefined[expression2];
      }
      var fields = [];
      var atoms = (expression2 + "").trim().split(/\s+/);
      if (atoms.length > 6) {
        throw new Error("Invalid cron expression");
      }
      var start = CronExpression.map.length - atoms.length;
      for (var i = 0, c = CronExpression.map.length;i < c; ++i) {
        var field3 = CronExpression.map[i];
        var value = atoms[atoms.length > c ? i : i - start];
        if (i < start || !value) {
          fields.push(CronExpression._parseField(field3, CronExpression.parseDefaults[i], CronExpression.constraints[i]));
        } else {
          var val = field3 === "dayOfWeek" ? parseNthDay(value) : value;
          fields.push(CronExpression._parseField(field3, val, CronExpression.constraints[i]));
        }
      }
      var mappedFields = {};
      for (var i = 0, c = CronExpression.map.length;i < c; i++) {
        var key = CronExpression.map[i];
        mappedFields[key] = fields[i];
      }
      var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
      mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
      return new CronExpression(mappedFields, options2);
      function parseNthDay(val2) {
        var atoms2 = val2.split("#");
        if (atoms2.length > 1) {
          var nthValue = +atoms2[atoms2.length - 1];
          if (/,/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `,` special characters are incompatible");
          }
          if (/\//.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `/` special characters are incompatible");
          }
          if (/-/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `-` special characters are incompatible");
          }
          if (atoms2.length > 2 || Number.isNaN(nthValue) || (nthValue < 1 || nthValue > 5)) {
            throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");
          }
          options2.nthDayOfWeek = nthValue;
          return atoms2[0];
        }
        return val2;
      }
    }
    return parse2(expression, options);
  };
  CronExpression.fieldsToExpression = function fieldsToExpression(fields, options) {
    function validateConstraints(field4, values5, constraints) {
      if (!values5) {
        throw new Error("Validation error, Field " + field4 + " is missing");
      }
      if (values5.length === 0) {
        throw new Error("Validation error, Field " + field4 + " contains no values");
      }
      for (var i2 = 0, c2 = values5.length;i2 < c2; i2++) {
        var value = values5[i2];
        if (CronExpression._isValidConstraintChar(constraints, value)) {
          continue;
        }
        if (typeof value !== "number" || Number.isNaN(value) || value < constraints.min || value > constraints.max) {
          throw new Error("Constraint error, got value " + value + " expected range " + constraints.min + "-" + constraints.max);
        }
      }
    }
    var mappedFields = {};
    for (var i = 0, c = CronExpression.map.length;i < c; ++i) {
      var field3 = CronExpression.map[i];
      var values4 = fields[field3];
      validateConstraints(field3, values4, CronExpression.constraints[i]);
      var copy = [];
      var j = -1;
      while (++j < values4.length) {
        copy[j] = values4[j];
      }
      values4 = copy.sort(CronExpression._sortCompareFn).filter(function(item, pos, ary) {
        return !pos || item !== ary[pos - 1];
      });
      if (values4.length !== copy.length) {
        throw new Error("Validation error, Field " + field3 + " contains duplicate values");
      }
      mappedFields[field3] = values4;
    }
    var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
    mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
    return new CronExpression(mappedFields, options || {});
  };
  module.exports = CronExpression;
});

// /Users/richardguerre/Projects/flow/node_modules/cron-parser/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var CronParser = function() {
  };
  var CronExpression = require_expression();
  CronParser._parseEntry = function _parseEntry(entry) {
    var atoms = entry.split(" ");
    if (atoms.length === 6) {
      return {
        interval: CronExpression.parse(entry)
      };
    } else if (atoms.length > 6) {
      return {
        interval: CronExpression.parse(atoms.slice(0, 6).join(" ")),
        command: atoms.slice(6, atoms.length)
      };
    } else {
      throw new Error("Invalid entry: " + entry);
    }
  };
  CronParser.parseExpression = function parseExpression(expression, options) {
    return CronExpression.parse(expression, options);
  };
  CronParser.fieldsToExpression = function fieldsToExpression(fields, options) {
    return CronExpression.fieldsToExpression(fields, options);
  };
  CronParser.parseString = function parseString(data) {
    var blocks = data.split("\n");
    var response = {
      variables: {},
      expressions: [],
      errors: {}
    };
    for (var i = 0, c = blocks.length;i < c; i++) {
      var block2 = blocks[i];
      var matches = null;
      var entry = block2.trim();
      if (entry.length > 0) {
        if (entry.match(/^#/)) {
          continue;
        } else if (matches = entry.match(/^(.*)=(.*)$/)) {
          response.variables[matches[1]] = matches[2];
        } else {
          var result = null;
          try {
            result = CronParser._parseEntry("0 " + entry);
            response.expressions.push(result.interval);
          } catch (err) {
            response.errors[entry] = err;
          }
        }
      }
    }
    return response;
  };
  CronParser.parseFile = function parseFile(filePath, callback) {
    import.meta.require("fs").readFile(filePath, function(err, data) {
      if (err) {
        callback(err);
        return;
      }
      return callback(null, CronParser.parseString(data.toString()));
    });
  };
  module.exports = CronParser;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/timekeeper.js
var require_timekeeper = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var cronParser = require_parser2();
  var Attorney = require_attorney();
  var pMap = require_p_map();
  var queues = {
    CRON: "__pgboss__cron",
    SEND_IT: "__pgboss__send-it"
  };
  var events2 = {
    error: "error",
    schedule: "schedule"
  };

  class Timekeeper extends EventEmitter {
    constructor(db, config) {
      super();
      this.db = db;
      this.config = config;
      this.manager = config.manager;
      this.skewMonitorIntervalMs = config.clockMonitorIntervalSeconds * 1000;
      this.cronMonitorIntervalMs = config.cronMonitorIntervalSeconds * 1000;
      this.clockSkew = 0;
      this.events = events2;
      this.getTimeCommand = plans.getTime(config.schema);
      this.getSchedulesCommand = plans.getSchedules(config.schema);
      this.scheduleCommand = plans.schedule(config.schema);
      this.unscheduleCommand = plans.unschedule(config.schema);
      this.getCronTimeCommand = plans.getCronTime(config.schema);
      this.setCronTimeCommand = plans.setCronTime(config.schema);
      this.functions = [
        this.schedule,
        this.unschedule,
        this.getSchedules
      ];
      this.stopped = true;
    }
    async start() {
      if (this.config.archiveSeconds < 60 || this.config.archiveFailedSeconds < 60) {
        return;
      }
      await this.cacheClockSkew();
      await this.manager.work(queues.CRON, { newJobCheckIntervalSeconds: this.config.cronWorkerIntervalSeconds }, (job) => this.onCron(job));
      await this.manager.work(queues.SEND_IT, { newJobCheckIntervalSeconds: this.config.cronWorkerIntervalSeconds, teamSize: 50, teamConcurrency: 5 }, (job) => this.onSendIt(job));
      await this.checkSchedulesAsync();
      this.cronMonitorInterval = setInterval(async () => await this.monitorCron(), this.cronMonitorIntervalMs);
      this.skewMonitorInterval = setInterval(async () => await this.cacheClockSkew(), this.skewMonitorIntervalMs);
      this.stopped = false;
    }
    async stop() {
      if (this.stopped) {
        return;
      }
      this.stopped = true;
      await this.manager.offWork(queues.CRON);
      await this.manager.offWork(queues.SEND_IT);
      if (this.skewMonitorInterval) {
        clearInterval(this.skewMonitorInterval);
        this.skewMonitorInterval = null;
      }
      if (this.cronMonitorInterval) {
        clearInterval(this.cronMonitorInterval);
        this.cronMonitorInterval = null;
      }
    }
    async monitorCron() {
      try {
        if (this.config.__test__force_cron_monitoring_error) {
          throw new Error(this.config.__test__force_cron_monitoring_error);
        }
        const { secondsAgo } = await this.getCronTime();
        if (secondsAgo > 60) {
          await this.checkSchedulesAsync();
        }
      } catch (err) {
        this.emit(this.events.error, err);
      }
    }
    async cacheClockSkew() {
      let skew = 0;
      try {
        if (this.config.__test__force_clock_monitoring_error) {
          throw new Error(this.config.__test__force_clock_monitoring_error);
        }
        const { rows } = await this.db.executeSql(this.getTimeCommand);
        const local = Date.now();
        const dbTime = parseFloat(rows[0].time);
        skew = dbTime - local;
        const skewSeconds = Math.abs(skew) / 1000;
        if (skewSeconds >= 60 || this.config.__test__force_clock_skew_warning) {
          Attorney.warnClockSkew(`Instance clock is ${skewSeconds}s ${skew > 0 ? "slower" : "faster"} than database.`);
        }
      } catch (err) {
        this.emit(this.events.error, err);
      } finally {
        this.clockSkew = skew;
      }
    }
    async checkSchedulesAsync() {
      const opts = {
        retryLimit: 2,
        retentionSeconds: 60,
        onComplete: false
      };
      await this.manager.sendDebounced(queues.CRON, null, opts, 60);
    }
    async onCron() {
      if (this.stopped)
        return;
      try {
        if (this.config.__test__throw_clock_monitoring) {
          throw new Error(this.config.__test__throw_clock_monitoring);
        }
        const items = await this.getSchedules();
        const sending = items.filter((i) => this.shouldSendIt(i.cron, i.timezone));
        if (sending.length && !this.stopped) {
          await pMap(sending, (it) => this.send(it), { concurrency: 5 });
        }
        if (this.stopped)
          return;
        await this.setCronTime();
      } catch (err) {
        this.emit(this.events.error, err);
      }
      if (this.stopped)
        return;
      await this.checkSchedulesAsync();
    }
    shouldSendIt(cron, tz) {
      const interval = cronParser.parseExpression(cron, { tz });
      const prevTime = interval.prev();
      const databaseTime = Date.now() + this.clockSkew;
      const prevDiff = (databaseTime - prevTime.getTime()) / 1000;
      return prevDiff < 60;
    }
    async send(job) {
      const options = {
        singletonKey: job.name,
        singletonSeconds: 60,
        onComplete: false
      };
      await this.manager.send(queues.SEND_IT, job, options);
    }
    async onSendIt(job) {
      if (this.stopped)
        return;
      const { name, data, options } = job.data;
      await this.manager.send(name, data, options);
    }
    async getSchedules() {
      const { rows } = await this.db.executeSql(this.getSchedulesCommand);
      return rows;
    }
    async schedule(name, cron, data, options = {}) {
      const { tz = "UTC" } = options;
      cronParser.parseExpression(cron, { tz });
      Attorney.checkSendArgs([name, data, options], this.config);
      const values4 = [name, cron, tz, data, options];
      const result = await this.db.executeSql(this.scheduleCommand, values4);
      return result ? result.rowCount : null;
    }
    async unschedule(name) {
      const result = await this.db.executeSql(this.unscheduleCommand, [name]);
      return result ? result.rowCount : null;
    }
    async setCronTime() {
      await this.db.executeSql(this.setCronTimeCommand);
    }
    async getCronTime() {
      const { rows } = await this.db.executeSql(this.getCronTimeCommand);
      let { cron_on: cronOn, seconds_ago: secondsAgo } = rows[0];
      secondsAgo = secondsAgo !== null ? parseFloat(secondsAgo) : 61;
      return { cronOn, secondsAgo };
    }
  }
  module.exports = Timekeeper;
  module.exports.QUEUES = queues;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/manager.js
var require_manager = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var EventEmitter = import.meta.require("events");
  var delay = require_delay();
  var uuid = require_dist();
  var debounce = require_lodash();
  var { serializeError: stringify4 } = require_serialize_error();
  var Attorney = require_attorney();
  var Worker = require_worker();
  var Db = require_db();
  var pMap = require_p_map();
  var { QUEUES: BOSS_QUEUES } = require_boss();
  var { QUEUES: TIMEKEEPER_QUEUES } = require_timekeeper();
  var INTERNAL_QUEUES = Object.values(BOSS_QUEUES).concat(Object.values(TIMEKEEPER_QUEUES)).reduce((acc, i) => ({ ...acc, [i]: i }), {});
  var plans = require_plans();
  var { COMPLETION_JOB_PREFIX, SINGLETON_QUEUE_KEY } = plans;
  var WIP_EVENT_INTERVAL = 2000;
  var WIP_DEBOUNCE_OPTIONS = { leading: true, trailing: true, maxWait: WIP_EVENT_INTERVAL };
  var events2 = {
    error: "error",
    wip: "wip"
  };
  var resolveWithinSeconds = async (promise, seconds) => {
    const timeout = Math.max(1, seconds) * 1000;
    const reject2 = delay.reject(timeout, { value: new Error(`handler execution exceeded ${timeout}ms`) });
    let result;
    try {
      result = await Promise.race([promise, reject2]);
    } finally {
      try {
        reject2.clear();
      } catch {
      }
    }
    return result;
  };

  class Manager extends EventEmitter {
    constructor(db, config) {
      super();
      this.config = config;
      this.db = db;
      this.events = events2;
      this.workers = new Map;
      this.nextJobCommand = plans.fetchNextJob(config.schema);
      this.insertJobCommand = plans.insertJob(config.schema);
      this.insertJobsCommand = plans.insertJobs(config.schema);
      this.completeJobsCommand = plans.completeJobs(config.schema);
      this.cancelJobsCommand = plans.cancelJobs(config.schema);
      this.resumeJobsCommand = plans.resumeJobs(config.schema);
      this.failJobsCommand = plans.failJobs(config.schema);
      this.getJobByIdCommand = plans.getJobById(config.schema);
      this.getArchivedJobByIdCommand = plans.getArchivedJobById(config.schema);
      this.subscribeCommand = plans.subscribe(config.schema);
      this.unsubscribeCommand = plans.unsubscribe(config.schema);
      this.getQueuesForEventCommand = plans.getQueuesForEvent(config.schema);
      this.functions = [
        this.complete,
        this.cancel,
        this.resume,
        this.fail,
        this.fetch,
        this.fetchCompleted,
        this.work,
        this.offWork,
        this.notifyWorker,
        this.onComplete,
        this.offComplete,
        this.publish,
        this.subscribe,
        this.unsubscribe,
        this.insert,
        this.send,
        this.sendDebounced,
        this.sendThrottled,
        this.sendOnce,
        this.sendAfter,
        this.sendSingleton,
        this.deleteQueue,
        this.deleteAllQueues,
        this.clearStorage,
        this.getQueueSize,
        this.getJobById
      ];
      this.emitWipThrottled = debounce(() => this.emit(events2.wip, this.getWipData()), WIP_EVENT_INTERVAL, WIP_DEBOUNCE_OPTIONS);
    }
    start() {
      this.stopping = false;
    }
    async stop() {
      this.stopping = true;
      for (const sub of this.workers.values()) {
        if (!INTERNAL_QUEUES[sub.name]) {
          await this.offWork(sub.name);
        }
      }
    }
    async work(name, ...args) {
      const { options, callback } = Attorney.checkWorkArgs(name, args, this.config);
      return await this.watch(name, options, callback);
    }
    async onComplete(name, ...args) {
      const { options, callback } = Attorney.checkWorkArgs(name, args, this.config);
      return await this.watch(COMPLETION_JOB_PREFIX + name, options, callback);
    }
    addWorker(worker) {
      this.workers.set(worker.id, worker);
    }
    removeWorker(worker) {
      this.workers.delete(worker.id);
    }
    getWorkers() {
      return Array.from(this.workers.values());
    }
    emitWip(name) {
      if (!INTERNAL_QUEUES[name]) {
        this.emitWipThrottled();
      }
    }
    getWipData(options = {}) {
      const { includeInternal = false } = options;
      const data = this.getWorkers().map(({
        id,
        name,
        options: options2,
        state,
        jobs,
        createdOn,
        lastFetchedOn,
        lastJobStartedOn,
        lastJobEndedOn,
        lastError,
        lastErrorOn
      }) => ({
        id,
        name,
        options: options2,
        state,
        count: jobs.length,
        createdOn,
        lastFetchedOn,
        lastJobStartedOn,
        lastJobEndedOn,
        lastError,
        lastErrorOn
      })).filter((i) => i.count > 0 && (!INTERNAL_QUEUES[i.name] || includeInternal));
      return data;
    }
    async watch(name, options, callback) {
      if (this.stopping) {
        throw new Error("Workers are disabled. pg-boss is stopping.");
      }
      const {
        newJobCheckInterval: interval = this.config.newJobCheckInterval,
        batchSize,
        teamSize = 1,
        teamConcurrency = 1,
        teamRefill: refill = false,
        includeMetadata = false,
        enforceSingletonQueueActiveLimit = false
      } = options;
      const id = uuid.v4();
      let queueSize = 0;
      let refillTeamPromise;
      let resolveRefillTeam;
      const createTeamRefillPromise = () => {
        refillTeamPromise = new Promise((resolve) => {
          resolveRefillTeam = resolve;
        });
      };
      createTeamRefillPromise();
      const onRefill = () => {
        queueSize--;
        resolveRefillTeam();
        createTeamRefillPromise();
      };
      const fetch6 = () => this.fetch(name, batchSize || teamSize - queueSize, { includeMetadata, enforceSingletonQueueActiveLimit });
      const onFetch = async (jobs) => {
        if (this.config.__test__throw_worker) {
          throw new Error("__test__throw_worker");
        }
        this.emitWip(name);
        if (batchSize) {
          const maxExpiration = jobs.reduce((acc, i) => Math.max(acc, i.expire_in_seconds), 0);
          await resolveWithinSeconds(Promise.all([callback(jobs)]), maxExpiration).then(() => this.complete(jobs.map((job) => job.id))).catch((err) => this.fail(jobs.map((job) => job.id), err));
        } else {
          if (refill) {
            queueSize += jobs.length || 1;
          }
          const allTeamPromise = pMap(jobs, (job) => resolveWithinSeconds(callback(job), job.expire_in_seconds).then((result) => this.complete(job.id, result)).catch((err) => this.fail(job.id, err)).then(() => refill ? onRefill() : null), { concurrency: teamConcurrency }).catch(() => {
          });
          if (refill) {
            if (queueSize < teamSize) {
              return;
            } else {
              await refillTeamPromise;
            }
          } else {
            await allTeamPromise;
          }
        }
        this.emitWip(name);
      };
      const onError = (error8) => {
        this.emit(events2.error, { ...error8, message: error8.message, stack: error8.stack, queue: name, worker: id });
      };
      const worker = new Worker({ id, name, options, interval, fetch: fetch6, onFetch, onError });
      this.addWorker(worker);
      worker.start();
      return id;
    }
    async offWork(value) {
      assert(value, "Missing required argument");
      const query3 = typeof value === "string" ? { filter: (i) => i.name === value } : typeof value === "object" && value.id ? { filter: (i) => i.id === value.id } : null;
      assert(query3, "Invalid argument. Expected string or object: { id }");
      const workers = this.getWorkers().filter((i) => query3.filter(i) && !i.stopping && !i.stopped);
      if (workers.length === 0) {
        return;
      }
      for (const worker of workers) {
        worker.stop();
      }
      setImmediate(async () => {
        while (!workers.every((w) => w.stopped)) {
          await delay(1000);
        }
        for (const worker of workers) {
          this.removeWorker(worker);
        }
      });
    }
    notifyWorker(workerId) {
      if (this.workers.has(workerId)) {
        this.workers.get(workerId).notify();
      }
    }
    async subscribe(event, name) {
      assert(event, "Missing required argument");
      assert(name, "Missing required argument");
      return await this.db.executeSql(this.subscribeCommand, [event, name]);
    }
    async unsubscribe(event, name) {
      assert(event, "Missing required argument");
      assert(name, "Missing required argument");
      return await this.db.executeSql(this.unsubscribeCommand, [event, name]);
    }
    async publish(event, ...args) {
      assert(event, "Missing required argument");
      const result = await this.db.executeSql(this.getQueuesForEventCommand, [event]);
      if (!result || result.rowCount === 0) {
        return [];
      }
      return await Promise.all(result.rows.map(({ name }) => this.send(name, ...args)));
    }
    async offComplete(value) {
      if (typeof value === "string") {
        value = COMPLETION_JOB_PREFIX + value;
      }
      return await this.offWork(value);
    }
    async send(...args) {
      const { name, data, options } = Attorney.checkSendArgs(args, this.config);
      return await this.createJob(name, data, options);
    }
    async sendOnce(name, data, options, key) {
      options = options ? { ...options } : {};
      options.singletonKey = key || name;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendSingleton(name, data, options) {
      options = options ? { ...options } : {};
      options.singletonKey = SINGLETON_QUEUE_KEY;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendAfter(name, data, options, after) {
      options = options ? { ...options } : {};
      options.startAfter = after;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendThrottled(name, data, options, seconds, key) {
      options = options ? { ...options } : {};
      options.singletonSeconds = seconds;
      options.singletonNextSlot = false;
      options.singletonKey = key;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async sendDebounced(name, data, options, seconds, key) {
      options = options ? { ...options } : {};
      options.singletonSeconds = seconds;
      options.singletonNextSlot = true;
      options.singletonKey = key;
      const result = Attorney.checkSendArgs([name, data, options], this.config);
      return await this.createJob(result.name, result.data, result.options);
    }
    async createJob(name, data, options, singletonOffset = 0) {
      const {
        db: wrapper,
        expireIn,
        priority,
        startAfter,
        keepUntil,
        singletonKey = null,
        singletonSeconds,
        retryBackoff,
        retryLimit,
        retryDelay,
        onComplete
      } = options;
      const id = uuid[this.config.uuid]();
      const values4 = [
        id,
        name,
        priority,
        retryLimit,
        startAfter,
        expireIn,
        data,
        singletonKey,
        singletonSeconds,
        singletonOffset,
        retryDelay,
        retryBackoff,
        keepUntil,
        onComplete
      ];
      const db = wrapper || this.db;
      const result = await db.executeSql(this.insertJobCommand, values4);
      if (result && result.rowCount === 1) {
        return result.rows[0].id;
      }
      if (!options.singletonNextSlot) {
        return null;
      }
      options.startAfter = this.getDebounceStartAfter(singletonSeconds, this.timekeeper.clockSkew);
      options.singletonNextSlot = false;
      singletonOffset = singletonSeconds;
      return await this.createJob(name, data, options, singletonOffset);
    }
    async insert(jobs, options = {}) {
      const { db: wrapper } = options;
      const db = wrapper || this.db;
      const checkedJobs = Attorney.checkInsertArgs(jobs);
      const data = JSON.stringify(checkedJobs);
      return await db.executeSql(this.insertJobsCommand, [data]);
    }
    getDebounceStartAfter(singletonSeconds, clockOffset) {
      const debounceInterval = singletonSeconds * 1000;
      const now = Date.now() + clockOffset;
      const slot = Math.floor(now / debounceInterval) * debounceInterval;
      let startAfter = singletonSeconds - Math.floor((now - slot) / 1000) || 1;
      if (singletonSeconds > 1) {
        startAfter++;
      }
      return startAfter;
    }
    async fetch(name, batchSize, options = {}) {
      const values4 = Attorney.checkFetchArgs(name, batchSize, options);
      const db = options.db || this.db;
      const preparedStatement = this.nextJobCommand(options.includeMetadata || false, options.enforceSingletonQueueActiveLimit || false);
      const statementValues = [values4.name, batchSize || 1];
      let result;
      if (options.enforceSingletonQueueActiveLimit && !options.db) {
        const fetchQuery = preparedStatement.replace("$1", Db.quotePostgresStr(statementValues[0])).replace("$2", statementValues[1].toString());
        const [_begin, _setLocal, fetchResult, _commit] = await db.executeSql([
          "BEGIN",
          "SET LOCAL jit = OFF",
          fetchQuery,
          "COMMIT"
        ].join(";\n"));
        result = fetchResult;
      } else {
        result = await db.executeSql(preparedStatement, statementValues);
      }
      if (!result || result.rows.length === 0) {
        return null;
      }
      return result.rows.length === 1 && !batchSize ? result.rows[0] : result.rows;
    }
    async fetchCompleted(name, batchSize, options = {}) {
      return await this.fetch(COMPLETION_JOB_PREFIX + name, batchSize, options);
    }
    mapCompletionIdArg(id, funcName) {
      const errorMessage = `${funcName}() requires an id`;
      assert(id, errorMessage);
      const ids = Array.isArray(id) ? id : [id];
      assert(ids.length, errorMessage);
      return ids;
    }
    mapCompletionDataArg(data) {
      if (data === null || typeof data === "undefined" || typeof data === "function") {
        return null;
      }
      const result = typeof data === "object" && !Array.isArray(data) ? data : { value: data };
      return stringify4(result);
    }
    mapCompletionResponse(ids, result) {
      return {
        jobs: ids,
        requested: ids.length,
        updated: result && result.rows ? parseInt(result.rows[0].count) : 0
      };
    }
    async complete(id, data, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "complete");
      const result = await db.executeSql(this.completeJobsCommand, [ids, this.mapCompletionDataArg(data)]);
      return this.mapCompletionResponse(ids, result);
    }
    async fail(id, data, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "fail");
      const result = await db.executeSql(this.failJobsCommand, [ids, this.mapCompletionDataArg(data)]);
      return this.mapCompletionResponse(ids, result);
    }
    async cancel(id, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "cancel");
      const result = await db.executeSql(this.cancelJobsCommand, [ids]);
      return this.mapCompletionResponse(ids, result);
    }
    async resume(id, options = {}) {
      const db = options.db || this.db;
      const ids = this.mapCompletionIdArg(id, "resume");
      const result = await db.executeSql(this.resumeJobsCommand, [ids]);
      return this.mapCompletionResponse(ids, result);
    }
    async deleteQueue(queue, options) {
      assert(queue, "Missing queue name argument");
      const sql = plans.deleteQueue(this.config.schema, options);
      const result = await this.db.executeSql(sql, [queue]);
      return result ? result.rowCount : null;
    }
    async deleteAllQueues(options) {
      const sql = plans.deleteAllQueues(this.config.schema, options);
      const result = await this.db.executeSql(sql);
      return result ? result.rowCount : null;
    }
    async clearStorage() {
      const sql = plans.clearStorage(this.config.schema);
      await this.db.executeSql(sql);
    }
    async getQueueSize(queue, options) {
      assert(queue, "Missing queue name argument");
      const sql = plans.getQueueSize(this.config.schema, options);
      const result = await this.db.executeSql(sql, [queue]);
      return result ? parseFloat(result.rows[0].count) : null;
    }
    async getJobById(id, options = {}) {
      const db = options.db || this.db;
      const result1 = await db.executeSql(this.getJobByIdCommand, [id]);
      if (result1 && result1.rows && result1.rows.length === 1) {
        return result1.rows[0];
      }
      const result2 = await db.executeSql(this.getArchivedJobByIdCommand, [id]);
      if (result2 && result2.rows && result2.rows.length === 1) {
        return result2.rows[0];
      }
      return null;
    }
  }
  module.exports = Manager;
});

// /Users/richardguerre/Projects/flow/node_modules/pg-boss/src/index.js
var require_src = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var plans = require_plans();
  var Attorney = require_attorney();
  var Contractor = require_contractor();
  var Manager = require_manager();
  var Timekeeper = require_timekeeper();
  var Boss = require_boss();
  var Db = require_db();
  var delay = require_delay();
  var events2 = {
    error: "error",
    stopped: "stopped"
  };

  class PgBoss extends EventEmitter {
    static getConstructionPlans(schema3) {
      return Contractor.constructionPlans(schema3);
    }
    static getMigrationPlans(schema3, version2) {
      return Contractor.migrationPlans(schema3, version2);
    }
    static getRollbackPlans(schema3, version2) {
      return Contractor.rollbackPlans(schema3, version2);
    }
    constructor(value) {
      const config = Attorney.getConfig(value);
      super();
      const db = getDb(config);
      if (db.isOurs) {
        promoteEvent.call(this, db, "error");
      }
      const manager2 = new Manager(db, config);
      Object.keys(manager2.events).forEach((event) => promoteEvent.call(this, manager2, manager2.events[event]));
      manager2.functions.forEach((func) => promoteFunction.call(this, manager2, func));
      const bossConfig = { ...config, manager: manager2 };
      const boss = new Boss(db, bossConfig);
      Object.keys(boss.events).forEach((event) => promoteEvent.call(this, boss, boss.events[event]));
      boss.functions.forEach((func) => promoteFunction.call(this, boss, func));
      const timekeeper = new Timekeeper(db, bossConfig);
      Object.keys(timekeeper.events).forEach((event) => promoteEvent.call(this, timekeeper, timekeeper.events[event]));
      timekeeper.functions.forEach((func) => promoteFunction.call(this, timekeeper, func));
      manager2.timekeeper = timekeeper;
      this.stoppingOn = null;
      this.stopped = true;
      this.config = config;
      this.db = db;
      this.boss = boss;
      this.contractor = new Contractor(db, config);
      this.manager = manager2;
      this.timekeeper = timekeeper;
      function getDb(config2) {
        if (config2.db) {
          return config2.db;
        }
        const db2 = new Db(config2);
        db2.isOurs = true;
        return db2;
      }
      function promoteFunction(obj, func) {
        this[func.name] = (...args) => {
          const shouldRun = !this.started || !((func.name === "work" || func.name === "onComplete") && (this.stopped || this.stoppingOn));
          if (shouldRun) {
            return func.apply(obj, args);
          } else {
            const state = this.stoppingOn ? "stopping" : this.stopped ? "stopped" : !this.started ? "not started" : "started";
            return Promise.reject(new Error(`pg-boss is ${state}.`));
          }
        };
      }
      function promoteEvent(emitter, event) {
        emitter.on(event, (arg) => this.emit(event, arg));
      }
    }
    async start() {
      if (!this.stopped) {
        return this;
      }
      if (this.db.isOurs && !this.db.opened) {
        await this.db.open();
      }
      await this.contractor.start();
      this.stopped = false;
      this.started = true;
      this.manager.start();
      if (!this.config.noSupervisor) {
        await this.boss.supervise();
      }
      if (!this.config.noScheduling) {
        await this.timekeeper.start();
      }
      return this;
    }
    async stop(options = {}) {
      if (this.stoppingOn) {
        return;
      }
      if (this.stopped) {
        this.emit(events2.stopped);
      }
      let { destroy = false, graceful = true, timeout = 30000 } = options;
      timeout = Math.max(timeout, 1000);
      this.stoppingOn = Date.now();
      await this.manager.stop();
      await this.timekeeper.stop();
      const shutdown = async () => {
        this.stopped = true;
        this.stoppingOn = null;
        if (this.db.isOurs && this.db.opened && destroy) {
          await this.db.close();
        }
        this.emit(events2.stopped);
      };
      if (!graceful) {
        await this.boss.stop();
        await shutdown();
        return;
      }
      setImmediate(async () => {
        let closing = false;
        try {
          while (Date.now() - this.stoppingOn < timeout) {
            if (this.manager.getWipData({ includeInternal: closing }).length === 0) {
              if (closing) {
                break;
              }
              closing = true;
              await this.boss.stop();
            }
            await delay(1000);
          }
          await this.boss.stop();
          await shutdown();
        } catch (err) {
          this.emit(events2.error, err);
        }
      });
    }
  }
  module.exports = PgBoss;
  module.exports.states = plans.states;
});

// /Users/richardguerre/Projects/flow/node_modules/elysia/dist/bun/index.js
var eW = Object.create;
var { defineProperty: S6, getPrototypeOf: $X, getOwnPropertyNames: YX } = Object;
var WX = Object.prototype.hasOwnProperty;
var Q1 = ($, Y, W) => {
  W = $ != null ? eW($X($)) : {};
  const X = Y || !$ || !$.__esModule ? S6(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of YX($))
    if (!WX.call(X, Z))
      S6(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var J0 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var b6 = J0((O7, a$) => {
  var s1 = function() {
  }, QX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, I6 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new QX(W, X || $, Z), J = V0 ? V0 + Y : Y;
    if (!$._events[J])
      $._events[J] = Q, $._eventsCount++;
    else if (!$._events[J].fn)
      $._events[J].push(Q);
    else
      $._events[J] = [$._events[J], Q];
    return $;
  }, K$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new s1;
    else
      delete $._events[Y];
  }, G0 = function() {
    this._events = new s1, this._eventsCount = 0;
  }, ZX = Object.prototype.hasOwnProperty, V0 = "~";
  if (Object.create) {
    if (s1.prototype = Object.create(null), !new s1().__proto__)
      V0 = false;
  }
  G0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (ZX.call(W, X))
        Y.push(V0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  G0.prototype.listeners = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, Q = X.length, J = new Array(Q);Z < Q; Z++)
      J[Z] = X[Z].fn;
    return J;
  };
  G0.prototype.listenerCount = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  G0.prototype.emit = function $(Y, W, X, Z, Q, J) {
    var z = V0 ? V0 + Y : Y;
    if (!this._events[z])
      return false;
    var U = this._events[z], D = arguments.length, B, j;
    if (U.fn) {
      if (U.once)
        this.removeListener(Y, U.fn, undefined, true);
      switch (D) {
        case 1:
          return U.fn.call(U.context), true;
        case 2:
          return U.fn.call(U.context, W), true;
        case 3:
          return U.fn.call(U.context, W, X), true;
        case 4:
          return U.fn.call(U.context, W, X, Z), true;
        case 5:
          return U.fn.call(U.context, W, X, Z, Q), true;
        case 6:
          return U.fn.call(U.context, W, X, Z, Q, J), true;
      }
      for (j = 1, B = new Array(D - 1);j < D; j++)
        B[j - 1] = arguments[j];
      U.fn.apply(U.context, B);
    } else {
      var b = U.length, S;
      for (j = 0;j < b; j++) {
        if (U[j].once)
          this.removeListener(Y, U[j].fn, undefined, true);
        switch (D) {
          case 1:
            U[j].fn.call(U[j].context);
            break;
          case 2:
            U[j].fn.call(U[j].context, W);
            break;
          case 3:
            U[j].fn.call(U[j].context, W, X);
            break;
          case 4:
            U[j].fn.call(U[j].context, W, X, Z);
            break;
          default:
            if (!B)
              for (S = 1, B = new Array(D - 1);S < D; S++)
                B[S - 1] = arguments[S];
            U[j].fn.apply(U[j].context, B);
        }
      }
    }
    return true;
  };
  G0.prototype.on = function $(Y, W, X) {
    return I6(this, Y, W, X, false);
  };
  G0.prototype.once = function $(Y, W, X) {
    return I6(this, Y, W, X, true);
  };
  G0.prototype.removeListener = function $(Y, W, X, Z) {
    var Q = V0 ? V0 + Y : Y;
    if (!this._events[Q])
      return this;
    if (!W)
      return K$(this, Q), this;
    var J = this._events[Q];
    if (J.fn) {
      if (J.fn === W && (!Z || J.once) && (!X || J.context === X))
        K$(this, Q);
    } else {
      for (var z = 0, U = [], D = J.length;z < D; z++)
        if (J[z].fn !== W || Z && !J[z].once || X && J[z].context !== X)
          U.push(J[z]);
      if (U.length)
        this._events[Q] = U.length === 1 ? U[0] : U;
      else
        K$(this, Q);
    }
    return this;
  };
  G0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = V0 ? V0 + Y : Y, this._events[W])
        K$(this, W);
    } else
      this._events = new s1, this._eventsCount = 0;
    return this;
  };
  G0.prototype.off = G0.prototype.removeListener;
  G0.prototype.addListener = G0.prototype.on;
  G0.prefixed = V0;
  G0.EventEmitter = G0;
  if (typeof a$ !== "undefined")
    a$.exports = G0;
});
var x0 = J0((d6) => {
  var JX = function($) {
    return j$($) && (Symbol.asyncIterator in $);
  }, zX = function($) {
    return j$($) && (Symbol.iterator in $);
  }, HX = function($) {
    return ArrayBuffer.isView($);
  }, qX = function($) {
    return $ instanceof Promise;
  }, MX = function($) {
    return $ instanceof Uint8Array;
  }, NX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, FX = function($, Y) {
    return Y in $;
  }, UX = function($) {
    return j$($) && f6($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, AX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E6 = function($) {
    return $ === undefined;
  }, V6 = function($) {
    return $ === null;
  }, x6 = function($) {
    return typeof $ === "boolean";
  }, e$ = function($) {
    return typeof $ === "number";
  }, BX = function($) {
    return e$($) && Number.isInteger($);
  }, k6 = function($) {
    return typeof $ === "bigint";
  }, g6 = function($) {
    return typeof $ === "string";
  }, f6 = function($) {
    return typeof $ === "function";
  }, T6 = function($) {
    return typeof $ === "symbol";
  }, DX = function($) {
    return k6($) || x6($) || V6($) || e$($) || g6($) || T6($) || E6($);
  };
  Object.defineProperty(d6, "__esModule", { value: true });
  d6.IsValueType = d6.IsSymbol = d6.IsFunction = d6.IsString = d6.IsBigInt = d6.IsInteger = d6.IsNumber = d6.IsBoolean = d6.IsNull = d6.IsUndefined = d6.IsArray = d6.IsObject = d6.IsPlainObject = d6.HasPropertyKey = d6.IsDate = d6.IsUint8Array = d6.IsPromise = d6.IsTypedArray = d6.IsIterator = d6.IsAsyncIterator = undefined;
  d6.IsAsyncIterator = JX;
  d6.IsIterator = zX;
  d6.IsTypedArray = HX;
  d6.IsPromise = qX;
  d6.IsUint8Array = MX;
  d6.IsDate = NX;
  d6.HasPropertyKey = FX;
  d6.IsPlainObject = UX;
  d6.IsObject = j$;
  d6.IsArray = AX;
  d6.IsUndefined = E6;
  d6.IsNull = V6;
  d6.IsBoolean = x6;
  d6.IsNumber = e$;
  d6.IsInteger = BX;
  d6.IsBigInt = k6;
  d6.IsString = g6;
  d6.IsFunction = f6;
  d6.IsSymbol = T6;
  d6.IsValueType = DX;
});
var f0 = J0((m6) => {
  Object.defineProperty(m6, "__esModule", { value: true });
  m6.Type = m6.JsonType = m6.JavaScriptTypeBuilder = m6.JsonTypeBuilder = m6.TypeBuilder = m6.TypeBuilderError = m6.TransformEncodeBuilder = m6.TransformDecodeBuilder = m6.TemplateLiteralDslParser = m6.TemplateLiteralGenerator = m6.TemplateLiteralGeneratorError = m6.TemplateLiteralFinite = m6.TemplateLiteralFiniteError = m6.TemplateLiteralParser = m6.TemplateLiteralParserError = m6.TemplateLiteralResolver = m6.TemplateLiteralPattern = m6.TemplateLiteralPatternError = m6.UnionResolver = m6.KeyArrayResolver = m6.KeyArrayResolverError = m6.KeyResolver = m6.ObjectMap = m6.Intrinsic = m6.IndexedAccessor = m6.TypeClone = m6.TypeExtends = m6.TypeExtendsResult = m6.TypeExtendsError = m6.ExtendsUndefined = m6.TypeGuard = m6.TypeGuardUnknownTypeError = m6.ValueGuard = m6.FormatRegistry = m6.TypeBoxError = m6.TypeRegistry = m6.PatternStringExact = m6.PatternNumberExact = m6.PatternBooleanExact = m6.PatternString = m6.PatternNumber = m6.PatternBoolean = m6.Kind = m6.Hint = m6.Optional = m6.Readonly = m6.Transform = undefined;
  m6.Transform = Symbol.for("TypeBox.Transform");
  m6.Readonly = Symbol.for("TypeBox.Readonly");
  m6.Optional = Symbol.for("TypeBox.Optional");
  m6.Hint = Symbol.for("TypeBox.Hint");
  m6.Kind = Symbol.for("TypeBox.Kind");
  m6.PatternBoolean = "(true|false)";
  m6.PatternNumber = "(0|[1-9][0-9]*)";
  m6.PatternString = "(.*)";
  m6.PatternBooleanExact = `^${m6.PatternBoolean}$`;
  m6.PatternNumberExact = `^${m6.PatternNumber}$`;
  m6.PatternStringExact = `^${m6.PatternString}$`;
  var $8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })($8 || (m6.TypeRegistry = $8 = {}));

  class $1 extends Error {
    constructor($) {
      super($);
    }
  }
  m6.TypeBoxError = $1;
  var v6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })(v6 || (m6.FormatRegistry = v6 = {}));
  var V;
  (function($) {
    function Y(D) {
      return Array.isArray(D);
    }
    $.IsArray = Y;
    function W(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = W;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function Q(D) {
      return typeof D === "number";
    }
    $.IsNumber = Q;
    function J(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = J;
    function z(D) {
      return typeof D === "string";
    }
    $.IsString = z;
    function U(D) {
      return D === undefined;
    }
    $.IsUndefined = U;
  })(V || (m6.ValueGuard = V = {}));

  class i6 extends $1 {
  }
  m6.TypeGuardUnknownTypeError = i6;
  var A;
  (function($) {
    function Y(M) {
      try {
        return new RegExp(M), true;
      } catch {
        return false;
      }
    }
    function W(M) {
      if (!V.IsString(M))
        return false;
      for (let l = 0;l < M.length; l++) {
        const S0 = M.charCodeAt(l);
        if (S0 >= 7 && S0 <= 13 || S0 === 27 || S0 === 127)
          return false;
      }
      return true;
    }
    function X(M) {
      return J(M) || X0(M);
    }
    function Z(M) {
      return V.IsUndefined(M) || V.IsBigInt(M);
    }
    function Q(M) {
      return V.IsUndefined(M) || V.IsNumber(M);
    }
    function J(M) {
      return V.IsUndefined(M) || V.IsBoolean(M);
    }
    function z(M) {
      return V.IsUndefined(M) || V.IsString(M);
    }
    function U(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M) && Y(M);
    }
    function D(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M);
    }
    function B(M) {
      return V.IsUndefined(M) || X0(M);
    }
    function j(M) {
      return _(M, "Any") && z(M.$id);
    }
    $.TAny = j;
    function b(M) {
      return _(M, "Array") && M.type === "array" && z(M.$id) && X0(M.items) && Q(M.minItems) && Q(M.maxItems) && J(M.uniqueItems) && B(M.contains) && Q(M.minContains) && Q(M.maxContains);
    }
    $.TArray = b;
    function S(M) {
      return _(M, "AsyncIterator") && M.type === "AsyncIterator" && z(M.$id) && X0(M.items);
    }
    $.TAsyncIterator = S;
    function N(M) {
      return _(M, "BigInt") && M.type === "bigint" && z(M.$id) && Z(M.exclusiveMaximum) && Z(M.exclusiveMinimum) && Z(M.maximum) && Z(M.minimum) && Z(M.multipleOf);
    }
    $.TBigInt = N;
    function O(M) {
      return _(M, "Boolean") && M.type === "boolean" && z(M.$id);
    }
    $.TBoolean = O;
    function P(M) {
      return _(M, "Constructor") && M.type === "Constructor" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TConstructor = P;
    function F(M) {
      return _(M, "Date") && M.type === "Date" && z(M.$id) && Q(M.exclusiveMaximumTimestamp) && Q(M.exclusiveMinimumTimestamp) && Q(M.maximumTimestamp) && Q(M.minimumTimestamp) && Q(M.multipleOfTimestamp);
    }
    $.TDate = F;
    function w(M) {
      return _(M, "Function") && M.type === "Function" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TFunction = w;
    function I(M) {
      return _(M, "Integer") && M.type === "integer" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TInteger = I;
    function G(M) {
      return _(M, "Intersect") && (V.IsString(M.type) && M.type !== "object" ? false : true) && V.IsArray(M.allOf) && M.allOf.every((l) => X0(l) && !w0(l)) && z(M.type) && (J(M.unevaluatedProperties) || B(M.unevaluatedProperties)) && z(M.$id);
    }
    $.TIntersect = G;
    function k(M) {
      return _(M, "Iterator") && M.type === "Iterator" && z(M.$id) && X0(M.items);
    }
    $.TIterator = k;
    function _(M, l) {
      return e(M) && M[m6.Kind] === l;
    }
    $.TKindOf = _;
    function e(M) {
      return V.IsObject(M) && (m6.Kind in M) && V.IsString(M[m6.Kind]);
    }
    $.TKind = e;
    function o(M) {
      return b0(M) && V.IsString(M.const);
    }
    $.TLiteralString = o;
    function r(M) {
      return b0(M) && V.IsNumber(M.const);
    }
    $.TLiteralNumber = r;
    function g0(M) {
      return b0(M) && V.IsBoolean(M.const);
    }
    $.TLiteralBoolean = g0;
    function b0(M) {
      return _(M, "Literal") && z(M.$id) && (V.IsBoolean(M.const) || V.IsNumber(M.const) || V.IsString(M.const));
    }
    $.TLiteral = b0;
    function E0(M) {
      return _(M, "Never") && V.IsObject(M.not) && Object.getOwnPropertyNames(M.not).length === 0;
    }
    $.TNever = E0;
    function H0(M) {
      return _(M, "Not") && X0(M.not);
    }
    $.TNot = H0;
    function z0(M) {
      return _(M, "Null") && M.type === "null" && z(M.$id);
    }
    $.TNull = z0;
    function u0(M) {
      return _(M, "Number") && M.type === "number" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TNumber = u0;
    function a0(M) {
      return _(M, "Object") && M.type === "object" && z(M.$id) && V.IsObject(M.properties) && X(M.additionalProperties) && Q(M.minProperties) && Q(M.maxProperties) && Object.entries(M.properties).every(([l, S0]) => W(l) && X0(S0));
    }
    $.TObject = a0;
    function v0(M) {
      return _(M, "Promise") && M.type === "Promise" && z(M.$id) && X0(M.item);
    }
    $.TPromise = v0;
    function R(M) {
      return _(M, "Record") && M.type === "object" && z(M.$id) && X(M.additionalProperties) && V.IsObject(M.patternProperties) && ((l) => {
        const S0 = Object.getOwnPropertyNames(l.patternProperties);
        return S0.length === 1 && Y(S0[0]) && V.IsObject(l.patternProperties) && X0(l.patternProperties[S0[0]]);
      })(M);
    }
    $.TRecord = R;
    function f(M) {
      return V.IsObject(M) && (m6.Hint in M) && M[m6.Hint] === "Recursive";
    }
    $.TRecursive = f;
    function i(M) {
      return _(M, "Ref") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TRef = i;
    function n(M) {
      return _(M, "String") && M.type === "string" && z(M.$id) && Q(M.minLength) && Q(M.maxLength) && U(M.pattern) && D(M.format);
    }
    $.TString = n;
    function q0(M) {
      return _(M, "Symbol") && M.type === "symbol" && z(M.$id);
    }
    $.TSymbol = q0;
    function B0(M) {
      return _(M, "TemplateLiteral") && M.type === "string" && V.IsString(M.pattern) && M.pattern[0] === "^" && M.pattern[M.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = B0;
    function D0(M) {
      return _(M, "This") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TThis = D0;
    function w0(M) {
      return V.IsObject(M) && (m6.Transform in M);
    }
    $.TTransform = w0;
    function M0(M) {
      return _(M, "Tuple") && M.type === "array" && z(M.$id) && V.IsNumber(M.minItems) && V.IsNumber(M.maxItems) && M.minItems === M.maxItems && (V.IsUndefined(M.items) && V.IsUndefined(M.additionalItems) && M.minItems === 0 || V.IsArray(M.items) && M.items.every((l) => X0(l)));
    }
    $.TTuple = M0;
    function B1(M) {
      return _(M, "Undefined") && M.type === "undefined" && z(M.$id);
    }
    $.TUndefined = B1;
    function K(M) {
      return E(M) && M.anyOf.every((l) => o(l) || r(l));
    }
    $.TUnionLiteral = K;
    function E(M) {
      return _(M, "Union") && z(M.$id) && V.IsObject(M) && V.IsArray(M.anyOf) && M.anyOf.every((l) => X0(l));
    }
    $.TUnion = E;
    function L(M) {
      return _(M, "Uint8Array") && M.type === "Uint8Array" && z(M.$id) && Q(M.minByteLength) && Q(M.maxByteLength);
    }
    $.TUint8Array = L;
    function p(M) {
      return _(M, "Unknown") && z(M.$id);
    }
    $.TUnknown = p;
    function T(M) {
      return _(M, "Unsafe");
    }
    $.TUnsafe = T;
    function d(M) {
      return _(M, "Void") && M.type === "void" && z(M.$id);
    }
    $.TVoid = d;
    function W0(M) {
      return V.IsObject(M) && M[m6.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function j0(M) {
      return V.IsObject(M) && M[m6.Optional] === "Optional";
    }
    $.TOptional = j0;
    function X0(M) {
      return V.IsObject(M) && (j(M) || b(M) || O(M) || N(M) || S(M) || P(M) || F(M) || w(M) || I(M) || G(M) || k(M) || b0(M) || E0(M) || H0(M) || z0(M) || u0(M) || a0(M) || v0(M) || R(M) || i(M) || n(M) || q0(M) || B0(M) || D0(M) || M0(M) || B1(M) || E(M) || L(M) || p(M) || T(M) || d(M) || e(M) && $8.Has(M[m6.Kind]));
    }
    $.TSchema = X0;
  })(A || (m6.TypeGuard = A = {}));
  var p6;
  (function($) {
    function Y(W) {
      return W[m6.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[m6.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[m6.Kind] === "Undefined" ? true : W[m6.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(p6 || (m6.ExtendsUndefined = p6 = {}));

  class Z8 extends $1 {
  }
  m6.TypeExtendsError = Z8;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (m6.TypeExtendsResult = C = {}));
  var j1;
  (function($) {
    function Y(H) {
      return H === C.False ? H : C.True;
    }
    function W(H) {
      throw new Z8(H);
    }
    function X(H) {
      return A.TNever(H) || A.TIntersect(H) || A.TUnion(H) || A.TUnknown(H) || A.TAny(H);
    }
    function Z(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : W("StructuralRight");
    }
    function Q(H, q) {
      return C.True;
    }
    function J(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) && q.anyOf.some(($0) => A.TAny($0) || A.TUnknown($0)) ? C.True : A.TUnion(q) ? C.Union : A.TUnknown(q) ? C.True : A.TAny(q) ? C.True : C.Union;
    }
    function z(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) ? C.True : C.False;
    }
    function U(H, q) {
      return A.TObject(q) && B0(q) ? C.True : X(q) ? Z(H, q) : !A.TArray(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function D(H, q) {
      return X(q) ? Z(H, q) : !A.TAsyncIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function B(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBigInt(q) ? C.True : C.False;
    }
    function j(H, q) {
      return A.TLiteral(H) && V.IsBoolean(H.const) ? C.True : A.TBoolean(H) ? C.True : C.False;
    }
    function b(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBoolean(q) ? C.True : C.False;
    }
    function S(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TConstructor(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function N(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TDate(q) ? C.True : C.False;
    }
    function O(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TFunction(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function P(H, q) {
      return A.TLiteral(H) && V.IsNumber(H.const) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function F(H, q) {
      return A.TInteger(q) || A.TNumber(q) ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : C.False;
    }
    function w(H, q) {
      return q.allOf.every(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function I(H, q) {
      return H.allOf.some(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function G(H, q) {
      return X(q) ? Z(H, q) : !A.TIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function k(H, q) {
      return A.TLiteral(q) && q.const === H.const ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : C.False;
    }
    function _(H, q) {
      return C.False;
    }
    function e(H, q) {
      return C.True;
    }
    function o(H) {
      let [q, $0] = [H, 0];
      while (true) {
        if (!A.TNot(q))
          break;
        q = q.not, $0 += 1;
      }
      return $0 % 2 === 0 ? q : m6.Type.Unknown();
    }
    function r(H, q) {
      return A.TNot(H) ? Q0(o(H), q) : A.TNot(q) ? Q0(H, o(q)) : W("Invalid fallthrough for Not");
    }
    function g0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TNull(q) ? C.True : C.False;
    }
    function b0(H, q) {
      return A.TLiteralNumber(H) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function E0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TInteger(q) || A.TNumber(q) ? C.True : C.False;
    }
    function H0(H, q) {
      return Object.getOwnPropertyNames(H.properties).length === q;
    }
    function z0(H) {
      return B0(H);
    }
    function u0(H) {
      return H0(H, 0) || H0(H, 1) && ("description" in H.properties) && A.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (A.TString(H.properties.description.anyOf[0]) && A.TUndefined(H.properties.description.anyOf[1]) || A.TString(H.properties.description.anyOf[1]) && A.TUndefined(H.properties.description.anyOf[0]));
    }
    function a0(H) {
      return H0(H, 0);
    }
    function v0(H) {
      return H0(H, 0);
    }
    function R(H) {
      return H0(H, 0);
    }
    function f(H) {
      return H0(H, 0);
    }
    function i(H) {
      return B0(H);
    }
    function n(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && ("length" in H.properties) && Y(Q0(H.properties.length, q)) === C.True;
    }
    function q0(H) {
      return H0(H, 0);
    }
    function B0(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && ("length" in H.properties) && Y(Q0(H.properties.length, q)) === C.True;
    }
    function D0(H) {
      const q = m6.Type.Function([m6.Type.Any()], m6.Type.Any());
      return H0(H, 0) || H0(H, 1) && ("then" in H.properties) && Y(Q0(H.properties.then, q)) === C.True;
    }
    function w0(H, q) {
      return Q0(H, q) === C.False ? C.False : A.TOptional(H) && !A.TOptional(q) ? C.False : C.True;
    }
    function M0(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) || A.TLiteralString(H) && z0(q) || A.TLiteralNumber(H) && a0(q) || A.TLiteralBoolean(H) && v0(q) || A.TSymbol(H) && u0(q) || A.TBigInt(H) && R(q) || A.TString(H) && z0(q) || A.TSymbol(H) && u0(q) || A.TNumber(H) && a0(q) || A.TInteger(H) && a0(q) || A.TBoolean(H) && v0(q) || A.TUint8Array(H) && i(q) || A.TDate(H) && f(q) || A.TConstructor(H) && q0(q) || A.TFunction(H) && n(q) ? C.True : A.TRecord(H) && A.TString(E(H)) ? (() => {
        return q[m6.Hint] === "Record" ? C.True : C.False;
      })() : A.TRecord(H) && A.TNumber(E(H)) ? (() => {
        return H0(q, 0) ? C.True : C.False;
      })() : C.False;
    }
    function B1(H, q) {
      return X(q) ? Z(H, q) : A.TRecord(q) ? p(H, q) : !A.TObject(q) ? C.False : (() => {
        for (let $0 of Object.getOwnPropertyNames(q.properties)) {
          if (!($0 in H.properties))
            return C.False;
          if (w0(H.properties[$0], q.properties[$0]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function K(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && D0(q) ? C.True : !A.TPromise(q) ? C.False : Y(Q0(H.item, q.item));
    }
    function E(H) {
      return m6.PatternNumberExact in H.patternProperties ? m6.Type.Number() : (m6.PatternStringExact in H.patternProperties) ? m6.Type.String() : W("Unknown record key pattern");
    }
    function L(H) {
      return m6.PatternNumberExact in H.patternProperties ? H.patternProperties[m6.PatternNumberExact] : (m6.PatternStringExact in H.patternProperties) ? H.patternProperties[m6.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(H, q) {
      const [$0, h0] = [E(q), L(q)];
      return A.TLiteralString(H) && A.TNumber($0) && Y(Q0(H, h0)) === C.True ? C.True : A.TUint8Array(H) && A.TNumber($0) ? Q0(H, h0) : A.TString(H) && A.TNumber($0) ? Q0(H, h0) : A.TArray(H) && A.TNumber($0) ? Q0(H, h0) : A.TObject(H) ? (() => {
        for (let aW of Object.getOwnPropertyNames(H.properties))
          if (w0(h0, H.properties[aW]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function T(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TRecord(q) ? C.False : Q0(L(H), L(q));
    }
    function d(H, q) {
      return A.TLiteral(H) && V.IsString(H.const) ? C.True : A.TString(H) ? C.True : C.False;
    }
    function W0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? C.True : C.False;
    }
    function j0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TSymbol(q) ? C.True : C.False;
    }
    function X0(H, q) {
      return A.TTemplateLiteral(H) ? Q0(J1.Resolve(H), q) : A.TTemplateLiteral(q) ? Q0(H, J1.Resolve(q)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function M(H, q) {
      return A.TArray(q) && H.items !== undefined && H.items.every(($0) => Q0($0, q.items) === C.True);
    }
    function l(H, q) {
      return A.TNever(H) ? C.True : A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : C.False;
    }
    function S0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && B0(q) ? C.True : A.TArray(q) && M(H, q) ? C.True : !A.TTuple(q) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) || !V.IsUndefined(H.items) && V.IsUndefined(q.items) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) ? C.True : H.items.every(($0, h0) => Q0($0, q.items[h0]) === C.True) ? C.True : C.False;
    }
    function l$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TUint8Array(q) ? C.True : C.False;
    }
    function t$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TVoid(q) ? tW(H, q) : A.TUndefined(q) ? C.True : C.False;
    }
    function s$(H, q) {
      return q.anyOf.some(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function cW(H, q) {
      return H.anyOf.every(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function O6(H, q) {
      return C.True;
    }
    function lW(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TAny(q) ? Q(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : A.TArray(q) ? z(H, q) : A.TTuple(q) ? l(H, q) : A.TObject(q) ? M0(H, q) : A.TUnknown(q) ? C.True : C.False;
    }
    function tW(H, q) {
      return A.TUndefined(H) ? C.True : A.TUndefined(H) ? C.True : C.False;
    }
    function sW(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : A.TObject(q) ? M0(H, q) : A.TVoid(q) ? C.True : C.False;
    }
    function Q0(H, q) {
      return A.TTemplateLiteral(H) || A.TTemplateLiteral(q) ? X0(H, q) : A.TNot(H) || A.TNot(q) ? r(H, q) : A.TAny(H) ? J(H, q) : A.TArray(H) ? U(H, q) : A.TBigInt(H) ? B(H, q) : A.TBoolean(H) ? b(H, q) : A.TAsyncIterator(H) ? D(H, q) : A.TConstructor(H) ? S(H, q) : A.TDate(H) ? N(H, q) : A.TFunction(H) ? O(H, q) : A.TInteger(H) ? F(H, q) : A.TIntersect(H) ? I(H, q) : A.TIterator(H) ? G(H, q) : A.TLiteral(H) ? k(H, q) : A.TNever(H) ? e(H, q) : A.TNull(H) ? g0(H, q) : A.TNumber(H) ? E0(H, q) : A.TObject(H) ? B1(H, q) : A.TRecord(H) ? T(H, q) : A.TString(H) ? W0(H, q) : A.TSymbol(H) ? j0(H, q) : A.TTuple(H) ? S0(H, q) : A.TPromise(H) ? K(H, q) : A.TUint8Array(H) ? l$(H, q) : A.TUndefined(H) ? t$(H, q) : A.TUnion(H) ? cW(H, q) : A.TUnknown(H) ? lW(H, q) : A.TVoid(H) ? sW(H, q) : W(`Unknown left type operand '${H[m6.Kind]}'`);
    }
    function rW(H, q) {
      return Q0(H, q);
    }
    $.Extends = rW;
  })(j1 || (m6.TypeExtends = j1 = {}));
  var m;
  (function($) {
    function Y(J) {
      const z = Object.getOwnPropertyNames(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {}), U = Object.getOwnPropertySymbols(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {});
      return { ...z, ...U };
    }
    function W(J) {
      return J.map((z) => X(z));
    }
    function X(J) {
      return V.IsArray(J) ? W(J) : V.IsObject(J) ? Y(J) : J;
    }
    function Z(J) {
      return J.map((z) => Q(z));
    }
    $.Rest = Z;
    function Q(J, z = {}) {
      return { ...X(J), ...z };
    }
    $.Type = Q;
  })(m || (m6.TypeClone = m = {}));
  var Y8;
  (function($) {
    function Y(S) {
      return S.map((N) => {
        const { [m6.Optional]: O, ...P } = m.Type(N);
        return P;
      });
    }
    function W(S) {
      return S.every((N) => A.TOptional(N));
    }
    function X(S) {
      return S.some((N) => A.TOptional(N));
    }
    function Z(S) {
      return W(S.allOf) ? m6.Type.Optional(m6.Type.Intersect(Y(S.allOf))) : S;
    }
    function Q(S) {
      return X(S.anyOf) ? m6.Type.Optional(m6.Type.Union(Y(S.anyOf))) : S;
    }
    function J(S) {
      return S[m6.Kind] === "Intersect" ? Z(S) : S[m6.Kind] === "Union" ? Q(S) : S;
    }
    function z(S, N) {
      const O = S.allOf.reduce((P, F) => {
        const w = j(F, N);
        return w[m6.Kind] === "Never" ? P : [...P, w];
      }, []);
      return J(m6.Type.Intersect(O));
    }
    function U(S, N) {
      const O = S.anyOf.map((P) => j(P, N));
      return J(m6.Type.Union(O));
    }
    function D(S, N) {
      const O = S.properties[N];
      return V.IsUndefined(O) ? m6.Type.Never() : m6.Type.Union([O]);
    }
    function B(S, N) {
      const O = S.items;
      if (V.IsUndefined(O))
        return m6.Type.Never();
      const P = O[N];
      if (V.IsUndefined(P))
        return m6.Type.Never();
      return P;
    }
    function j(S, N) {
      return S[m6.Kind] === "Intersect" ? z(S, N) : S[m6.Kind] === "Union" ? U(S, N) : S[m6.Kind] === "Object" ? D(S, N) : S[m6.Kind] === "Tuple" ? B(S, N) : m6.Type.Never();
    }
    function b(S, N, O = {}) {
      const P = N.map((F) => j(S, F.toString()));
      return J(m6.Type.Union(P, O));
    }
    $.Resolve = b;
  })(Y8 || (m6.IndexedAccessor = Y8 = {}));
  var V1;
  (function($) {
    function Y(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toLowerCase()}${b}`;
    }
    function W(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toUpperCase()}${b}`;
    }
    function X(B) {
      return B.toUpperCase();
    }
    function Z(B) {
      return B.toLowerCase();
    }
    function Q(B, j) {
      const b = f1.ParseExact(B.pattern);
      if (!T1.Check(b))
        return { ...B, pattern: J(B.pattern, j) };
      const O = [...d1.Generate(b)].map((w) => m6.Type.Literal(w)), P = z(O, j), F = m6.Type.Union(P);
      return m6.Type.TemplateLiteral([F]);
    }
    function J(B, j) {
      return typeof B === "string" ? j === "Uncapitalize" ? Y(B) : j === "Capitalize" ? W(B) : j === "Uppercase" ? X(B) : j === "Lowercase" ? Z(B) : B : B.toString();
    }
    function z(B, j) {
      if (B.length === 0)
        return [];
      const [b, ...S] = B;
      return [D(b, j), ...z(S, j)];
    }
    function U(B, j) {
      return A.TTemplateLiteral(B) ? Q(B, j) : A.TUnion(B) ? m6.Type.Union(z(B.anyOf, j)) : A.TLiteral(B) ? m6.Type.Literal(J(B.const, j)) : B;
    }
    function D(B, j) {
      return U(B, j);
    }
    $.Map = D;
  })(V1 || (m6.Intrinsic = V1 = {}));
  var x1;
  (function($) {
    function Y(J, z) {
      return m6.Type.Intersect(J.allOf.map((U) => Z(U, z)), { ...J });
    }
    function W(J, z) {
      return m6.Type.Union(J.anyOf.map((U) => Z(U, z)), { ...J });
    }
    function X(J, z) {
      return z(J);
    }
    function Z(J, z) {
      return J[m6.Kind] === "Intersect" ? Y(J, z) : J[m6.Kind] === "Union" ? W(J, z) : J[m6.Kind] === "Object" ? X(J, z) : J;
    }
    function Q(J, z, U) {
      return { ...Z(m.Type(J), z), ...U };
    }
    $.Map = Q;
  })(x1 || (m6.ObjectMap = x1 = {}));
  var P$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function W(D, B) {
      return D.allOf.reduce((j, b) => [...j, ...J(b, B)], []);
    }
    function X(D, B) {
      const j = D.anyOf.map((b) => J(b, B));
      return [...j.reduce((b, S) => S.map((N) => j.every((O) => O.includes(N)) ? b.add(N) : b)[0], new Set)];
    }
    function Z(D, B) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function Q(D, B) {
      return B.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function J(D, B) {
      return A.TIntersect(D) ? W(D, B) : A.TUnion(D) ? X(D, B) : A.TObject(D) ? Z(D, B) : A.TRecord(D) ? Q(D, B) : [];
    }
    function z(D, B) {
      return [...new Set(J(D, B))];
    }
    $.ResolveKeys = z;
    function U(D) {
      return `^(${z(D, { includePatterns: true }).map((b) => `(${Y(b)})`).join("|")})$`;
    }
    $.ResolvePattern = U;
  })(P$ || (m6.KeyResolver = P$ = {}));

  class Q8 extends $1 {
  }
  m6.KeyArrayResolverError = Q8;
  var r1;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : A.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : A.TLiteral(W) ? [W.const] : A.TTemplateLiteral(W) ? (() => {
        const X = f1.ParseExact(W.pattern);
        if (!T1.Check(X))
          throw new Q8("Cannot resolve keys from infinite template expression");
        return [...d1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(r1 || (m6.KeyArrayResolver = r1 = {}));
  var W8;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m6.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return m6.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(W8 || (m6.UnionResolver = W8 = {}));

  class J8 extends $1 {
  }
  m6.TemplateLiteralPatternError = J8;
  var O$;
  (function($) {
    function Y(Q) {
      throw new J8(Q);
    }
    function W(Q) {
      return Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(Q, J) {
      return A.TTemplateLiteral(Q) ? Q.pattern.slice(1, Q.pattern.length - 1) : A.TUnion(Q) ? `(${Q.anyOf.map((z) => X(z, J)).join("|")})` : A.TNumber(Q) ? `${J}${m6.PatternNumber}` : A.TInteger(Q) ? `${J}${m6.PatternNumber}` : A.TBigInt(Q) ? `${J}${m6.PatternNumber}` : A.TString(Q) ? `${J}${m6.PatternString}` : A.TLiteral(Q) ? `${J}${W(Q.const.toString())}` : A.TBoolean(Q) ? `${J}${m6.PatternBoolean}` : Y(`Unexpected Kind '${Q[m6.Kind]}'`);
    }
    function Z(Q) {
      return `^${Q.map((J) => X(J, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m6.TemplateLiteralPattern = O$ = {}));
  var J1;
  (function($) {
    function Y(W) {
      const X = f1.ParseExact(W.pattern);
      if (!T1.Check(X))
        return m6.Type.String();
      const Z = [...d1.Generate(X)].map((Q) => m6.Type.Literal(Q));
      return m6.Type.Union(Z);
    }
    $.Resolve = Y;
  })(J1 || (m6.TemplateLiteralResolver = J1 = {}));

  class S$ extends $1 {
  }
  m6.TemplateLiteralParserError = S$;
  var f1;
  (function($) {
    function Y(S, N, O) {
      return S[N] === O && S.charCodeAt(N - 1) !== 92;
    }
    function W(S, N) {
      return Y(S, N, "(");
    }
    function X(S, N) {
      return Y(S, N, ")");
    }
    function Z(S, N) {
      return Y(S, N, "|");
    }
    function Q(S) {
      if (!(W(S, 0) && X(S, S.length - 1)))
        return false;
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (N === 0 && O !== S.length - 1)
          return false;
      }
      return true;
    }
    function J(S) {
      return S.slice(1, S.length - 1);
    }
    function z(S) {
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (Z(S, O) && N === 0)
          return true;
      }
      return false;
    }
    function U(S) {
      for (let N = 0;N < S.length; N++)
        if (W(S, N))
          return true;
      return false;
    }
    function D(S) {
      let [N, O] = [0, 0];
      const P = [];
      for (let w = 0;w < S.length; w++) {
        if (W(S, w))
          N += 1;
        if (X(S, w))
          N -= 1;
        if (Z(S, w) && N === 0) {
          const I = S.slice(O, w);
          if (I.length > 0)
            P.push(j(I));
          O = w + 1;
        }
      }
      const F = S.slice(O);
      if (F.length > 0)
        P.push(j(F));
      if (P.length === 0)
        return { type: "const", const: "" };
      if (P.length === 1)
        return P[0];
      return { type: "or", expr: P };
    }
    function B(S) {
      function N(F, w) {
        if (!W(F, w))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let I = 0;
        for (let G = w;G < F.length; G++) {
          if (W(F, G))
            I += 1;
          if (X(F, G))
            I -= 1;
          if (I === 0)
            return [w, G];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function O(F, w) {
        for (let I = w;I < F.length; I++)
          if (W(F, I))
            return [w, I];
        return [w, F.length];
      }
      const P = [];
      for (let F = 0;F < S.length; F++)
        if (W(S, F)) {
          const [w, I] = N(S, F), G = S.slice(w, I + 1);
          P.push(j(G)), F = I;
        } else {
          const [w, I] = O(S, F), G = S.slice(w, I);
          if (G.length > 0)
            P.push(j(G));
          F = I - 1;
        }
      return P.length === 0 ? { type: "const", const: "" } : P.length === 1 ? P[0] : { type: "and", expr: P };
    }
    function j(S) {
      return Q(S) ? j(J(S)) : z(S) ? D(S) : U(S) ? B(S) : { type: "const", const: S };
    }
    $.Parse = j;
    function b(S) {
      return j(S.slice(1, S.length - 1));
    }
    $.ParseExact = b;
  })(f1 || (m6.TemplateLiteralParser = f1 = {}));

  class z8 extends $1 {
  }
  m6.TemplateLiteralFiniteError = z8;
  var T1;
  (function($) {
    function Y(J) {
      throw new z8(J);
    }
    function W(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "0" && J.expr[1].type === "const" && J.expr[1].const === "[1-9][0-9]*";
    }
    function X(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "true" && J.expr[1].type === "const" && J.expr[1].const === "false";
    }
    function Z(J) {
      return J.type === "const" && J.const === ".*";
    }
    function Q(J) {
      return X(J) ? true : W(J) || Z(J) ? false : J.type === "and" ? J.expr.every((z) => Q(z)) : J.type === "or" ? J.expr.every((z) => Q(z)) : J.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = Q;
  })(T1 || (m6.TemplateLiteralFinite = T1 = {}));

  class H8 extends $1 {
  }
  m6.TemplateLiteralGeneratorError = H8;
  var d1;
  (function($) {
    function* Y(J) {
      if (J.length === 1)
        return yield* J[0];
      for (let z of J[0])
        for (let U of Y(J.slice(1)))
          yield `${z}${U}`;
    }
    function* W(J) {
      return yield* Y(J.expr.map((z) => [...Q(z)]));
    }
    function* X(J) {
      for (let z of J.expr)
        yield* Q(z);
    }
    function* Z(J) {
      return yield J.const;
    }
    function* Q(J) {
      return J.type === "and" ? yield* W(J) : J.type === "or" ? yield* X(J) : J.type === "const" ? yield* Z(J) : (() => {
        throw new H8("Unknown expression");
      })();
    }
    $.Generate = Q;
  })(d1 || (m6.TemplateLiteralGenerator = d1 = {}));
  var X8;
  (function($) {
    function* Y(Q) {
      const J = Q.trim().replace(/"|'/g, "");
      return J === "boolean" ? yield m6.Type.Boolean() : J === "number" ? yield m6.Type.Number() : J === "bigint" ? yield m6.Type.BigInt() : J === "string" ? yield m6.Type.String() : yield (() => {
        const z = J.split("|").map((U) => m6.Type.Literal(U.trim()));
        return z.length === 0 ? m6.Type.Never() : z.length === 1 ? z[0] : m6.Type.Union(z);
      })();
    }
    function* W(Q) {
      if (Q[1] !== "{") {
        const J = m6.Type.Literal("$"), z = X(Q.slice(1));
        return yield* [J, ...z];
      }
      for (let J = 2;J < Q.length; J++)
        if (Q[J] === "}") {
          const z = Y(Q.slice(2, J)), U = X(Q.slice(J + 1));
          return yield* [...z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function* X(Q) {
      for (let J = 0;J < Q.length; J++)
        if (Q[J] === "$") {
          const z = m6.Type.Literal(Q.slice(0, J)), U = W(Q.slice(J));
          return yield* [z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(X8 || (m6.TemplateLiteralDslParser = X8 = {}));

  class q8 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new M8(this.schema, $);
    }
  }
  m6.TransformDecodeBuilder = q8;

  class M8 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = m.Type(this.schema);
      return A.TTransform(Y) ? (() => {
        const Z = { Encode: (Q) => Y[m6.Transform].Encode($(Q)), Decode: (Q) => this.decode(Y[m6.Transform].Decode(Q)) };
        return { ...Y, [m6.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [m6.Transform]: W };
      })();
    }
  }
  m6.TransformEncodeBuilder = M8;
  var TX = 0;

  class N8 extends $1 {
  }
  m6.TypeBuilderError = N8;

  class F8 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new N8($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...Q } = W;
        return Q;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m6.TypeBuilder = F8;

  class L$ extends F8 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...m.Type($), [m6.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...m.Type($), [m6.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Array", type: "array", items: m.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = m6.Type.Intersect($, {}), Z = P$.ResolveKeys(W, { includePatterns: false }).reduce((Q, J) => ({ ...Q, [J]: m6.Type.Index(W, [J]) }), {});
      return m6.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const W = Object.getOwnPropertyNames($).filter((Q) => isNaN(Q)).map((Q) => $[Q]), Z = [...new Set(W)].map((Q) => m6.Type.Literal(Q));
      return this.Union(Z, { ...Y, [m6.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (j1.Extends($, Y)) {
        case C.Union:
          return this.Union([m.Type(W, Z), m.Type(X, Z)]);
        case C.True:
          return m.Type(W, Z);
        case C.False:
          return m.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Exclude(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Exclude($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) === C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? this.Never(W) : m.Type($, W);
    }
    Extract($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Extract(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Extract($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) !== C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? m.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return A.TArray($) && A.TNumber(Y) ? (() => {
        return m.Type($.items, W);
      })() : A.TTuple($) && A.TNumber(Y) ? (() => {
        const Z = (V.IsUndefined($.items) ? [] : $.items).map((Q) => m.Type(Q));
        return this.Union(Z, W);
      })() : (() => {
        const X = r1.Resolve(Y), Z = m.Type($);
        return Y8.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m6.Type.Never();
      if ($.length === 1)
        return m.Type($[0], Y);
      if ($.some((Q) => A.TTransform(Q)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((Q) => A.TObject(Q)), X = m.Rest($), Z = A.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: m.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || A.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return A.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === m6.PatternNumberExact ? this.Number(Y) : W === m6.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : A.TTuple($) ? (() => {
        const X = (V.IsUndefined($.items) ? [] : $.items).map((Z, Q) => m6.Type.Literal(Q.toString()));
        return this.Union(X, Y);
      })() : A.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = P$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m6.Kind]: "Not", not: m.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((z) => A.TOptional($[z])), Z = W.filter((z) => !X.includes(z)), Q = A.TSchema(Y.additionalProperties) ? { additionalProperties: m.Type(Y.additionalProperties) } : {}, J = W.reduce((z, U) => ({ ...z, [U]: m.Type($[U]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J, required: Z }) : this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J });
    }
    Omit($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(W.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return A.TTemplateLiteral($) ? (() => {
        const X = f1.ParseExact($.pattern);
        return T1.Check(X) ? this.Object([...d1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: m.Type(Y) }), {}), W) : this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: m.Type(Y) } });
      })() : A.TUnion($) ? (() => {
        const X = W8.Resolve($);
        if (A.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, J) => ({ ...Q, [J.const]: m.Type(Y) }), {});
          return this.Object(Z, { ...W, [m6.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : A.TLiteral($) ? (() => {
        return V.IsString($.const) || V.IsNumber($.const) ? this.Object({ [$.const]: m.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : A.TInteger($) || A.TNumber($) ? (() => {
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [m6.PatternNumberExact]: m.Type(Y) } });
      })() : A.TString($) ? (() => {
        const X = V.IsUndefined($.pattern) ? m6.PatternStringExact : $.pattern;
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [X]: m.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (V.IsUndefined(Y.$id))
        Y.$id = `T${TX++}`;
      const W = $({ [m6.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [m6.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (V.IsString($))
        return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $ });
      if (V.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(W.properties[Q], [m6.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return A.TTuple($) && !V.IsUndefined($.items) ? m.Rest($.items) : A.TIntersect($) ? m.Rest($.allOf) : A.TUnion($) ? m.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = V.IsString($) ? O$.Create(X8.Parse($)) : O$.Create($);
      return this.Create({ ...Y, [m6.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new q8($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], Q = m.Rest($), J = $.length > 0 ? { ...Y, [m6.Kind]: "Tuple", type: "array", items: Q, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [m6.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(J);
    }
    Uncapitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return A.TTemplateLiteral($) ? J1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(m.Type(W[0], Y));
        const X = m.Rest(W);
        return this.Create({ ...Y, [m6.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m6.Kind]: $[m6.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uppercase"), ...Y };
    }
  }
  m6.JsonTypeBuilder = L$;

  class U8 extends L$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "AsyncIterator", type: "AsyncIterator", items: m.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...W(Q)];
      })() : X;
      return A.TIntersect($) ? m6.Type.Intersect(W($.allOf)) : A.TUnion($) ? m6.Type.Union(W($.anyOf)) : A.TPromise($) ? this.Awaited($.item) : m.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Iterator", type: "Iterator", items: m.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Promise", type: "Promise", item: m.Type($) });
    }
    RegExp($, Y = {}) {
      const W = V.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m6.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m6.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Void", type: "void" });
    }
  }
  m6.JavaScriptTypeBuilder = U8;
  m6.JsonType = new L$;
  m6.Type = new U8;
});
var P8 = J0((n6) => {
  var w8 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[z1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(n6, "__esModule", { value: true });
  n6.DefaultErrorFunction = n6.TypeSystemPolicy = n6.TypeSystemErrorFunction = n6.TypeSystem = n6.TypeSystemDuplicateFormat = n6.TypeSystemDuplicateTypeKind = undefined;
  var C$ = x0(), y = $$(), z1 = f0();

  class K8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateTypeKind = K8;

  class j8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateFormat = j8;
  var u6;
  (function($) {
    function Y(X, Z) {
      if (z1.TypeRegistry.Has(X))
        throw new K8(X);
      return z1.TypeRegistry.Set(X, Z), (Q = {}) => z1.Type.Unsafe({ ...Q, [z1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (z1.FormatRegistry.Has(X))
        throw new j8(X);
      return z1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })(u6 || (n6.TypeSystem = u6 = {}));
  var h6;
  (function($) {
    let Y = w8;
    function W() {
      Y = w8;
    }
    $.Reset = W;
    function X(Q) {
      Y = Q;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(h6 || (n6.TypeSystemErrorFunction = h6 = {}));
  var o6;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(J, z) {
      return $.ExactOptionalPropertyTypes ? z in J : J[z] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      const z = (0, C$.IsObject)(J);
      return $.AllowArrayObject ? z : z && !(0, C$.IsArray)(J);
    }
    $.IsObjectLike = W;
    function X(J) {
      return W(J) && !(J instanceof Date) && !(J instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(J) {
      const z = (0, C$.IsNumber)(J);
      return $.AllowNaN ? z : z && Number.isFinite(J);
    }
    $.IsNumberLike = Z;
    function Q(J) {
      const z = (0, C$.IsUndefined)(J);
      return $.AllowNullVoid ? z || J === null : z;
    }
    $.IsVoidLike = Q;
  })(o6 || (n6.TypeSystemPolicy = o6 = {}));
  n6.DefaultErrorFunction = w8;
});
var D1 = J0((l6) => {
  var IZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new O8($);
    return Y[W];
  };
  Object.defineProperty(l6, "__esModule", { value: true });
  l6.Deref = l6.TypeDereferenceError = undefined;
  var CZ = f0();

  class O8 extends CZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l6.TypeDereferenceError = O8;
  l6.Deref = IZ;
});
var Y$ = J0((e6) => {
  function* EZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var VZ = function($) {
    R0(T0.Array);
    for (let Y of $)
      v1(Y);
  }, xZ = function($) {
    R0(T0.Boolean), R0($ ? 1 : 0);
  }, kZ = function($) {
    R0(T0.BigInt), r6.setBigInt64(0, $);
    for (let Y of a6)
      R0(Y);
  }, gZ = function($) {
    R0(T0.Date), v1($.getTime());
  }, fZ = function($) {
    R0(T0.Null);
  }, TZ = function($) {
    R0(T0.Number), r6.setFloat64(0, $);
    for (let Y of a6)
      R0(Y);
  }, dZ = function($) {
    R0(T0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      v1(Y), v1($[Y]);
  }, yZ = function($) {
    R0(T0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of EZ($.charCodeAt(Y)))
        R0(W);
  }, vZ = function($) {
    R0(T0.Symbol), v1($.description);
  }, pZ = function($) {
    R0(T0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      R0($[Y]);
  }, iZ = function($) {
    return R0(T0.Undefined);
  }, v1 = function($) {
    if ((0, o0.IsArray)($))
      return VZ($);
    if ((0, o0.IsBoolean)($))
      return xZ($);
    if ((0, o0.IsBigInt)($))
      return kZ($);
    if ((0, o0.IsDate)($))
      return gZ($);
    if ((0, o0.IsNull)($))
      return fZ($);
    if ((0, o0.IsNumber)($))
      return TZ($);
    if ((0, o0.IsPlainObject)($))
      return dZ($);
    if ((0, o0.IsString)($))
      return yZ($);
    if ((0, o0.IsSymbol)($))
      return vZ($);
    if ((0, o0.IsUint8Array)($))
      return pZ($);
    if ((0, o0.IsUndefined)($))
      return iZ($);
    throw new S8($);
  }, R0 = function($) {
    y1 = y1 ^ _Z[$], y1 = y1 * GZ % RZ;
  }, mZ = function($) {
    return y1 = BigInt("14695981039346656037"), v1($), y1;
  };
  Object.defineProperty(e6, "__esModule", { value: true });
  e6.Hash = e6.ByteMarker = e6.ValueHashError = undefined;
  var o0 = x0();

  class S8 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e6.ValueHashError = S8;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e6.ByteMarker = T0 = {}));
  var y1 = BigInt("14695981039346656037"), [GZ, RZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], _Z = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), s6 = new Float64Array(1), r6 = new DataView(s6.buffer), a6 = new Uint8Array(s6.buffer);
  e6.Hash = mZ;
});
var $$ = J0((WY) => {
  var t = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: p1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* nZ($, Y, W, X) {
  }
  function* cZ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Array, $, W, X);
    if (t($.minItems) && !(X.length >= $.minItems))
      yield g(x.ArrayMinItems, $, W, X);
    if (t($.maxItems) && !(X.length <= $.maxItems))
      yield g(x.ArrayMaxItems, $, W, X);
    for (let J = 0;J < X.length; J++)
      yield* L0($.items, Y, `${W}/${J}`, X[J]);
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let z of X) {
        const U = (0, oZ.Hash)(z);
        if (J.has(U))
          return false;
        else
          J.add(U);
      }
      return true;
    }())
      yield g(x.ArrayUniqueItems, $, W, X);
    if (!(t($.contains) || t($.minContains) || t($.maxContains)))
      return;
    const Z = t($.contains) ? $.contains : p0.Type.Never(), Q = X.reduce((J, z, U) => L0(Z, Y, `${W}${U}`, z).next().done === true ? J + 1 : J, 0);
    if (Q === 0)
      yield g(x.ArrayContains, $, W, X);
    if ((0, U0.IsNumber)($.minContains) && Q < $.minContains)
      yield g(x.ArrayMinContains, $, W, X);
    if ((0, U0.IsNumber)($.maxContains) && Q > $.maxContains)
      yield g(x.ArrayMaxContains, $, W, X);
  }
  function* lZ($, Y, W, X) {
    if (!(0, U0.IsAsyncIterator)(X))
      yield g(x.AsyncIterator, $, W, X);
  }
  function* tZ($, Y, W, X) {
    if (!(0, U0.IsBigInt)(X))
      return yield g(x.BigInt, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.BigIntExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.BigIntExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.BigIntMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.BigIntMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(x.BigIntMultipleOf, $, W, X);
  }
  function* sZ($, Y, W, X) {
    if (!(0, U0.IsBoolean)(X))
      yield g(x.Boolean, $, W, X);
  }
  function* rZ($, Y, W, X) {
    yield* L0($.returns, Y, W, X.prototype);
  }
  function* aZ($, Y, W, X) {
    if (!(0, U0.IsDate)(X))
      return yield g(x.Date, $, W, X);
    if (t($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(x.DateExclusiveMaximumTimestamp, $, W, X);
    if (t($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(x.DateExclusiveMinimumTimestamp, $, W, X);
    if (t($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(x.DateMaximumTimestamp, $, W, X);
    if (t($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(x.DateMinimumTimestamp, $, W, X);
    if (t($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(x.DateMultipleOfTimestamp, $, W, X);
  }
  function* eZ($, Y, W, X) {
    if (!(0, U0.IsFunction)(X))
      yield g(x.Function, $, W, X);
  }
  function* $Q($, Y, W, X) {
    if (!(0, U0.IsInteger)(X))
      return yield g(x.Integer, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.IntegerExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.IntegerExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.IntegerMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.IntegerMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.IntegerMultipleOf, $, W, X);
  }
  function* YQ($, Y, W, X) {
    for (let Z of $.allOf) {
      const Q = L0(Z, Y, W, X).next();
      if (!Q.done)
        yield g(x.Intersect, $, W, X), yield Q.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield g(x.IntersectUnevaluatedProperties, $, `${W}/${Q}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const J = L0($.unevaluatedProperties, Y, `${W}/${Q}`, X[Q]).next();
          if (!J.done)
            yield J.value;
        }
    }
  }
  function* WQ($, Y, W, X) {
    if (!(0, U0.IsIterator)(X))
      yield g(x.Iterator, $, W, X);
  }
  function* XQ($, Y, W, X) {
    if (X !== $.const)
      yield g(x.Literal, $, W, X);
  }
  function* ZQ($, Y, W, X) {
    yield g(x.Never, $, W, X);
  }
  function* QQ($, Y, W, X) {
    if (L0($.not, Y, W, X).next().done === true)
      yield g(x.Not, $, W, X);
  }
  function* JQ($, Y, W, X) {
    if (!(0, U0.IsNull)(X))
      yield g(x.Null, $, W, X);
  }
  function* zQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(x.Number, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.NumberExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.NumberExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.NumberMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.NumberMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.NumberMultipleOf, $, W, X);
  }
  function* HQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), J = Object.getOwnPropertyNames(X);
    for (let z of Z) {
      if (J.includes(z))
        continue;
      yield g(x.ObjectRequiredProperty, $.properties[z], `${W}/${z}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let z of J)
        if (!Q.includes(z))
          yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, X[z]);
    }
    if (typeof $.additionalProperties === "object")
      for (let z of J) {
        if (Q.includes(z))
          continue;
        yield* L0($.additionalProperties, Y, `${W}/${z}`, X[z]);
      }
    for (let z of Q) {
      const U = $.properties[z];
      if ($.required && $.required.includes(z)) {
        if (yield* L0(U, Y, `${W}/${z}`, X[z]), p0.ExtendsUndefined.Check($) && !(z in X))
          yield g(x.ObjectRequiredProperty, U, `${W}/${z}`, undefined);
      } else if (p1.TypeSystemPolicy.IsExactOptionalProperty(X, z))
        yield* L0(U, Y, `${W}/${z}`, X[z]);
    }
  }
  function* qQ($, Y, W, X) {
    if (!(0, U0.IsPromise)(X))
      yield g(x.Promise, $, W, X);
  }
  function* MQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const [Z, Q] = Object.entries($.patternProperties)[0], J = new RegExp(Z);
    for (let [z, U] of Object.entries(X))
      if (J.test(z))
        yield* L0(Q, Y, `${W}/${z}`, U);
    if (typeof $.additionalProperties === "object") {
      for (let [z, U] of Object.entries(X))
        if (!J.test(z))
          yield* L0($.additionalProperties, Y, `${W}/${z}`, U);
    }
    if ($.additionalProperties === false)
      for (let [z, U] of Object.entries(X)) {
        if (J.test(z))
          continue;
        return yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, U);
      }
  }
  function* NQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* FQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (t($.minLength) && !(X.length >= $.minLength))
      yield g(x.StringMinLength, $, W, X);
    if (t($.maxLength) && !(X.length <= $.maxLength))
      yield g(x.StringMaxLength, $, W, X);
    if ((0, U0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(x.StringPattern, $, W, X);
    }
    if ((0, U0.IsString)($.format)) {
      if (!p0.FormatRegistry.Has($.format))
        yield g(x.StringFormatUnknown, $, W, X);
      else if (!p0.FormatRegistry.Get($.format)(X))
        yield g(x.StringFormat, $, W, X);
    }
  }
  function* UQ($, Y, W, X) {
    if (!(0, U0.IsSymbol)(X))
      yield g(x.Symbol, $, W, X);
  }
  function* AQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(x.StringPattern, $, W, X);
  }
  function* BQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* DQ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(x.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(x.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* L0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* wQ($, Y, W, X) {
    if (!(0, U0.IsUndefined)(X))
      yield g(x.Undefined, $, W, X);
  }
  function* KQ($, Y, W, X) {
    let Z = 0;
    for (let Q of $.anyOf) {
      const J = [...L0(Q, Y, W, X)];
      if (J.length === 0)
        return;
      Z += J.length;
    }
    if (Z > 0)
      yield g(x.Union, $, W, X);
  }
  function* jQ($, Y, W, X) {
    if (!(0, U0.IsUint8Array)(X))
      return yield g(x.Uint8Array, $, W, X);
    if (t($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(x.Uint8ArrayMaxByteLength, $, W, X);
    if (t($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(x.Uint8ArrayMinByteLength, $, W, X);
  }
  function* PQ($, Y, W, X) {
  }
  function* OQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsVoidLike(X))
      yield g(x.Void, $, W, X);
  }
  function* SQ($, Y, W, X) {
    if (!p0.TypeRegistry.Get($[p0.Kind])($, X))
      yield g(x.Kind, $, W, X);
  }
  function* L0($, Y, W, X) {
    const Z = t($.$id) ? [...Y, $] : Y, Q = $;
    switch (Q[p0.Kind]) {
      case "Any":
        return yield* nZ(Q, Z, W, X);
      case "Array":
        return yield* cZ(Q, Z, W, X);
      case "AsyncIterator":
        return yield* lZ(Q, Z, W, X);
      case "BigInt":
        return yield* tZ(Q, Z, W, X);
      case "Boolean":
        return yield* sZ(Q, Z, W, X);
      case "Constructor":
        return yield* rZ(Q, Z, W, X);
      case "Date":
        return yield* aZ(Q, Z, W, X);
      case "Function":
        return yield* eZ(Q, Z, W, X);
      case "Integer":
        return yield* $Q(Q, Z, W, X);
      case "Intersect":
        return yield* YQ(Q, Z, W, X);
      case "Iterator":
        return yield* WQ(Q, Z, W, X);
      case "Literal":
        return yield* XQ(Q, Z, W, X);
      case "Never":
        return yield* ZQ(Q, Z, W, X);
      case "Not":
        return yield* QQ(Q, Z, W, X);
      case "Null":
        return yield* JQ(Q, Z, W, X);
      case "Number":
        return yield* zQ(Q, Z, W, X);
      case "Object":
        return yield* HQ(Q, Z, W, X);
      case "Promise":
        return yield* qQ(Q, Z, W, X);
      case "Record":
        return yield* MQ(Q, Z, W, X);
      case "Ref":
        return yield* NQ(Q, Z, W, X);
      case "String":
        return yield* FQ(Q, Z, W, X);
      case "Symbol":
        return yield* UQ(Q, Z, W, X);
      case "TemplateLiteral":
        return yield* AQ(Q, Z, W, X);
      case "This":
        return yield* BQ(Q, Z, W, X);
      case "Tuple":
        return yield* DQ(Q, Z, W, X);
      case "Undefined":
        return yield* wQ(Q, Z, W, X);
      case "Union":
        return yield* KQ(Q, Z, W, X);
      case "Uint8Array":
        return yield* jQ(Q, Z, W, X);
      case "Unknown":
        return yield* PQ(Q, Z, W, X);
      case "Void":
        return yield* OQ(Q, Z, W, X);
      default:
        if (!p0.TypeRegistry.Has(Q[p0.Kind]))
          throw new L8($);
        return yield* SQ(Q, Z, W, X);
    }
  }
  var LQ = function(...$) {
    const Y = $.length === 3 ? L0($[0], $[1], "", $[2]) : L0($[0], [], "", $[1]);
    return new C8(Y);
  };
  Object.defineProperty(WY, "__esModule", { value: true });
  WY.Errors = WY.ValueErrorIterator = WY.ValueErrorsUnknownTypeError = WY.ValueErrorType = undefined;
  var U0 = x0(), p1 = P8(), YY = D1(), oZ = Y$(), p0 = f0(), x;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(x || (WY.ValueErrorType = x = {}));

  class L8 extends p0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  WY.ValueErrorsUnknownTypeError = L8;

  class C8 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  WY.ValueErrorIterator = C8;
  WY.Errors = LQ;
});
var I$ = J0((O1) => {
  var GQ = O1 && O1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), RQ = O1 && O1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        GQ(Y, $, W);
  };
  Object.defineProperty(O1, "__esModule", { value: true });
  RQ($$(), O1);
});
var b$ = J0((QY) => {
  Object.defineProperty(QY, "__esModule", { value: true });
  QY.ValuePointer = QY.ValuePointerRootDeleteError = QY.ValuePointerRootSetError = undefined;

  class I8 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  QY.ValuePointerRootSetError = I8;

  class b8 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  QY.ValuePointerRootDeleteError = b8;
  var ZY;
  (function($) {
    function Y(z) {
      return z.indexOf("~") === -1 ? z : z.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(z) {
      if (z === "")
        return;
      let [U, D] = [0, 0];
      for (let B = 0;B < z.length; B++)
        if (z.charAt(B) === "/")
          if (B === 0)
            U = B + 1;
          else
            D = B, yield Y(z.slice(U, D)), U = B + 1;
        else
          D = B;
      yield Y(z.slice(U));
    }
    $.Format = W;
    function X(z, U, D) {
      if (U === "")
        throw new I8(z, U, D);
      let [B, j, b] = [null, z, ""];
      for (let S of W(U)) {
        if (j[S] === undefined)
          j[S] = {};
        B = j, j = j[S], b = S;
      }
      B[b] = D;
    }
    $.Set = X;
    function Z(z, U) {
      if (U === "")
        throw new b8(z, U);
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined || B[b] === null)
          return;
        D = B, B = B[b], j = b;
      }
      if (Array.isArray(D)) {
        const b = parseInt(j);
        D.splice(b, 1);
      } else
        delete D[j];
    }
    $.Delete = Z;
    function Q(z, U) {
      if (U === "")
        return true;
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined)
          return false;
        D = B, B = B[b], j = b;
      }
      return Object.getOwnPropertyNames(D).includes(j);
    }
    $.Has = Q;
    function J(z, U) {
      if (U === "")
        return z;
      let D = z;
      for (let B of W(U)) {
        if (D[B] === undefined)
          return;
        D = D[B];
      }
      return D;
    }
    $.Get = J;
  })(ZY || (QY.ValuePointer = ZY = {}));
});
var i1 = J0((zY) => {
  var VQ = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: G8($[X]) }), {});
  }, xQ = function($) {
    return $.map((Y) => G8(Y));
  }, kQ = function($) {
    return $.slice();
  }, gQ = function($) {
    return new Date($.toISOString());
  }, fQ = function($) {
    return $;
  }, G8 = function($) {
    if ((0, W$.IsArray)($))
      return xQ($);
    if ((0, W$.IsDate)($))
      return gQ($);
    if ((0, W$.IsPlainObject)($))
      return VQ($);
    if ((0, W$.IsTypedArray)($))
      return kQ($);
    if ((0, W$.IsValueType)($))
      return fQ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zY, "__esModule", { value: true });
  zY.Clone = undefined;
  var W$ = x0();
  zY.Clone = G8;
});
var V8 = J0((NY) => {
  var X$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, qY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, MY = function($) {
    return { type: "delete", path: $ };
  };
  function* TQ($, Y, W) {
    if (!(0, _0.IsPlainObject)(W))
      return yield X$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let Q of X) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && Z.includes(Q))
        yield X$(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if ((0, _0.IsUndefined)(Y[Q]) || (0, _0.IsUndefined)(W[Q]))
        continue;
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      yield* G$(`${$}/${String(Q)}`, Y[Q], W[Q]);
    }
    for (let Q of Z) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(Y[Q]))
        yield qY(`${$}/${String(Q)}`, W[Q]);
    }
    for (let Q of X.reverse()) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && !Z.includes(Q))
        yield MY(`${$}/${String(Q)}`);
    }
  }
  function* dQ($, Y, W) {
    if (!(0, _0.IsArray)(W))
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield qY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield MY(`${$}/${X}`);
    }
  }
  function* yQ($, Y, W) {
    if (!(0, _0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
  }
  function* vQ($, Y, W) {
    if (Y === W)
      return;
    yield X$($, W);
  }
  function* G$($, Y, W) {
    if ((0, _0.IsPlainObject)(Y))
      return yield* TQ($, Y, W);
    if ((0, _0.IsArray)(Y))
      return yield* dQ($, Y, W);
    if ((0, _0.IsTypedArray)(Y))
      return yield* yQ($, Y, W);
    if ((0, _0.IsValueType)(Y))
      return yield* vQ($, Y, W);
    throw new E8(Y);
  }
  var pQ = function($, Y) {
    return [...G$("", $, Y)];
  }, iQ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, mQ = function($) {
    return $.length === 0;
  }, uQ = function($, Y) {
    if (iQ(Y))
      return (0, _8.Clone)(Y[0].value);
    if (mQ(Y))
      return (0, _8.Clone)($);
    const W = (0, _8.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          R8.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(NY, "__esModule", { value: true });
  NY.Patch = NY.Diff = NY.ValueDeltaUnableToDiffUnknownValue = NY.ValueDeltaObjectWithSymbolKeyError = NY.Edit = NY.Delete = NY.Update = NY.Insert = undefined;
  var _0 = x0(), i0 = f0(), R8 = b$(), _8 = i1();
  NY.Insert = i0.Type.Object({ type: i0.Type.Literal("insert"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Update = i0.Type.Object({ type: i0.Type.Literal("update"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Delete = i0.Type.Object({ type: i0.Type.Literal("delete"), path: i0.Type.String() });
  NY.Edit = i0.Type.Union([NY.Insert, NY.Update, NY.Delete]);

  class m1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  NY.ValueDeltaObjectWithSymbolKeyError = m1;

  class E8 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  NY.ValueDeltaUnableToDiffUnknownValue = E8;
  NY.Diff = pQ;
  NY.Patch = uQ;
});
var jY = J0((wY) => {
  var lQ = function($, Y, W, X) {
    if (!(0, d0.IsPlainObject)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      const Z = Object.keys(W), Q = Object.keys(X);
      for (let J of Z)
        if (!Q.includes(J))
          delete W[J];
      for (let J of Q)
        if (!Z.includes(J))
          W[J] = null;
      for (let J of Q)
        f8($, `${Y}/${J}`, W[J], X[J]);
    }
  }, tQ = function($, Y, W, X) {
    if (!(0, d0.IsArray)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        f8($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, sQ = function($, Y, W, X) {
    if ((0, d0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
  }, rQ = function($, Y, W, X) {
    if (W === X)
      return;
    R$.ValuePointer.Set($, Y, X);
  }, f8 = function($, Y, W, X) {
    if ((0, d0.IsArray)(X))
      return tQ($, Y, W, X);
    if ((0, d0.IsTypedArray)(X))
      return sQ($, Y, W, X);
    if ((0, d0.IsPlainObject)(X))
      return lQ($, Y, W, X);
    if ((0, d0.IsValueType)(X))
      return rQ($, Y, W, X);
  }, DY = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, aQ = function($, Y) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(Y) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(Y);
  }, eQ = function($, Y) {
    if (DY($) || DY(Y))
      throw new g8;
    if (aQ($, Y))
      throw new k8;
    f8($, "", $, Y);
  };
  Object.defineProperty(wY, "__esModule", { value: true });
  wY.Mutate = wY.ValueMutateInvalidRootMutationError = wY.ValueMutateTypeMismatchError = undefined;
  var d0 = x0(), R$ = b$(), x8 = i1();

  class k8 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wY.ValueMutateTypeMismatchError = k8;

  class g8 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wY.ValueMutateInvalidRootMutationError = g8;
  wY.Mutate = eQ;
});
var SY = J0((PY) => {
  var W4 = function($, Y) {
    if (!(0, H1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => _$($[Z], Y[Z]));
  }, X4 = function($, Y) {
    return (0, H1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, Z4 = function($, Y) {
    if (!(0, H1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, Q4 = function($, Y) {
    if (!(0, H1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, J4 = function($, Y) {
    return $ === Y;
  }, _$ = function($, Y) {
    if ((0, H1.IsPlainObject)($))
      return W4($, Y);
    if ((0, H1.IsDate)($))
      return X4($, Y);
    if ((0, H1.IsTypedArray)($))
      return Q4($, Y);
    if ((0, H1.IsArray)($))
      return Z4($, Y);
    if ((0, H1.IsValueType)($))
      return J4($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PY, "__esModule", { value: true });
  PY.Equal = undefined;
  var H1 = x0();
  PY.Equal = _$;
});
var E$ = J0((q1) => {
  var z4 = q1 && q1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), H4 = q1 && q1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        z4(Y, $, W);
  };
  Object.defineProperty(q1, "__esModule", { value: true });
  q1.ValueErrorType = undefined;
  var q4 = $$();
  Object.defineProperty(q1, "ValueErrorType", { enumerable: true, get: function() {
    return q4.ValueErrorType;
  } });
  H4(P8(), q1);
});
var Q$ = J0((CY) => {
  var N4 = function($) {
    return $[C0.Kind] === "Any" || $[C0.Kind] === "Unknown";
  }, s = function($) {
    return $ !== undefined;
  }, F4 = function($, Y, W) {
    return true;
  }, U4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if (s($.minItems) && !(W.length >= $.minItems))
      return false;
    if (s($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((Q) => I0($.items, Y, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let J of W) {
        const z = (0, M4.Hash)(J);
        if (Q.has(z))
          return false;
        else
          Q.add(z);
      }
      return true;
    }())
      return false;
    if (!(s($.contains) || (0, A0.IsNumber)($.minContains) || (0, A0.IsNumber)($.maxContains)))
      return true;
    const X = s($.contains) ? $.contains : C0.Type.Never(), Z = W.reduce((Q, J) => I0(X, Y, J) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if ((0, A0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, A0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, A4 = function($, Y, W) {
    return (0, A0.IsAsyncIterator)(W);
  }, B4 = function($, Y, W) {
    if (!(0, A0.IsBigInt)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, D4 = function($, Y, W) {
    return (0, A0.IsBoolean)(W);
  }, w4 = function($, Y, W) {
    return I0($.returns, Y, W.prototype);
  }, K4 = function($, Y, W) {
    if (!(0, A0.IsDate)(W))
      return false;
    if (s($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (s($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (s($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (s($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (s($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, j4 = function($, Y, W) {
    return (0, A0.IsFunction)(W);
  }, P4 = function($, Y, W) {
    if (!(0, A0.IsInteger)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, O4 = function($, Y, W) {
    const X = $.allOf.every((Z) => I0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J));
      return X && Q;
    } else if (C0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J) || I0($.unevaluatedProperties, Y, W[J]));
      return X && Q;
    } else
      return X;
  }, S4 = function($, Y, W) {
    return (0, A0.IsIterator)(W);
  }, L4 = function($, Y, W) {
    return W === $.const;
  }, C4 = function($, Y, W) {
    return false;
  }, I4 = function($, Y, W) {
    return !I0($.not, Y, W);
  }, b4 = function($, Y, W) {
    return (0, A0.IsNull)(W);
  }, G4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, R4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!I0(Q, Y, W[Z]))
          return false;
        if ((C0.ExtendsUndefined.Check(Q) || N4(Q)) && !(Z in W))
          return false;
      } else if (Z$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !I0(Q, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((Q) => X.includes(Q) || I0($.additionalProperties, Y, W[Q]));
    else
      return true;
  }, _4 = function($, Y, W) {
    return (0, A0.IsPromise)(W);
  }, E4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X), J = Object.entries(W).every(([D, B]) => {
      return Q.test(D) ? I0(Z, Y, B) : true;
    }), z = typeof $.additionalProperties === "object" ? Object.entries(W).every(([D, B]) => {
      return !Q.test(D) ? I0($.additionalProperties, Y, B) : true;
    }) : true, U = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((D) => {
      return Q.test(D);
    }) : true;
    return J && z && U;
  }, V4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, x4 = function($, Y, W) {
    if (!(0, A0.IsString)(W))
      return false;
    if (s($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (s($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (s($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (s($.format)) {
      if (!C0.FormatRegistry.Has($.format))
        return false;
      return C0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, k4 = function($, Y, W) {
    return (0, A0.IsSymbol)(W);
  }, g4 = function($, Y, W) {
    return (0, A0.IsString)(W) && new RegExp($.pattern).test(W);
  }, f4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, T4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!I0($.items[X], Y, W[X]))
        return false;
    return true;
  }, d4 = function($, Y, W) {
    return (0, A0.IsUndefined)(W);
  }, y4 = function($, Y, W) {
    return $.anyOf.some((X) => I0(X, Y, W));
  }, v4 = function($, Y, W) {
    if (!(0, A0.IsUint8Array)(W))
      return false;
    if (s($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (s($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, p4 = function($, Y, W) {
    return true;
  }, i4 = function($, Y, W) {
    return Z$.TypeSystemPolicy.IsVoidLike(W);
  }, m4 = function($, Y, W) {
    if (!C0.TypeRegistry.Has($[C0.Kind]))
      return false;
    return C0.TypeRegistry.Get($[C0.Kind])($, W);
  }, I0 = function($, Y, W) {
    const X = s($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[C0.Kind]) {
      case "Any":
        return F4(Z, X, W);
      case "Array":
        return U4(Z, X, W);
      case "AsyncIterator":
        return A4(Z, X, W);
      case "BigInt":
        return B4(Z, X, W);
      case "Boolean":
        return D4(Z, X, W);
      case "Constructor":
        return w4(Z, X, W);
      case "Date":
        return K4(Z, X, W);
      case "Function":
        return j4(Z, X, W);
      case "Integer":
        return P4(Z, X, W);
      case "Intersect":
        return O4(Z, X, W);
      case "Iterator":
        return S4(Z, X, W);
      case "Literal":
        return L4(Z, X, W);
      case "Never":
        return C4(Z, X, W);
      case "Not":
        return I4(Z, X, W);
      case "Null":
        return b4(Z, X, W);
      case "Number":
        return G4(Z, X, W);
      case "Object":
        return R4(Z, X, W);
      case "Promise":
        return _4(Z, X, W);
      case "Record":
        return E4(Z, X, W);
      case "Ref":
        return V4(Z, X, W);
      case "String":
        return x4(Z, X, W);
      case "Symbol":
        return k4(Z, X, W);
      case "TemplateLiteral":
        return g4(Z, X, W);
      case "This":
        return f4(Z, X, W);
      case "Tuple":
        return T4(Z, X, W);
      case "Undefined":
        return d4(Z, X, W);
      case "Union":
        return y4(Z, X, W);
      case "Uint8Array":
        return v4(Z, X, W);
      case "Unknown":
        return p4(Z, X, W);
      case "Void":
        return i4(Z, X, W);
      default:
        if (!C0.TypeRegistry.Has(Z[C0.Kind]))
          throw new T8(Z);
        return m4(Z, X, W);
    }
  }, u4 = function(...$) {
    return $.length === 3 ? I0($[0], $[1], $[2]) : I0($[0], [], $[1]);
  };
  Object.defineProperty(CY, "__esModule", { value: true });
  CY.Check = CY.ValueCheckUnknownTypeError = undefined;
  var A0 = x0(), Z$ = E$(), LY = D1(), M4 = Y$(), C0 = f0();

  class T8 extends C0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CY.ValueCheckUnknownTypeError = T8;
  CY.Check = u4;
});
var u8 = J0((_Y) => {
  var n4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, c4 = function($, Y) {
    if ($.uniqueItems === true && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return y0($.items, Y);
      });
    else
      return [];
  }, l4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, t4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, s4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, r4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = y0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, a4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, e4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, Y);
  }, $J = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, YJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const Q = y0(Z, Y);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!(0, o4.Check)($, Y, W))
        throw new p8($);
      return W;
    }
  }, WJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, XJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, ZJ = function($, Y) {
    throw new y8($);
  }, QJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new v8($);
  }, JJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, zJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, HJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return W.has(Z) ? { ...X, [Z]: y0(Q, Y) } : { ...X };
      }, {});
    }
  }, qJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, Y));
  }, MJ = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === k0.PatternStringExact || W === k0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((Q, J) => {
        return { ...Q, [J]: y0(X, Y) };
      }, {});
    else
      return {};
  }, NJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, FJ = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, UJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, AJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    const W = k0.TemplateLiteralParser.ParseExact($.pattern);
    if (!k0.TemplateLiteralFinite.Check(W))
      throw new i8($);
    return k0.TemplateLiteralGenerator.Generate(W).next().value;
  }, BJ = function($, Y) {
    if (RY++ > bY)
      throw new m8($, bY);
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, DJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => y0($.items[X], Y));
  }, wJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, KJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], Y);
  }, jJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, PJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, OJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, SJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, Y) {
    const W = (0, a.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[k0.Kind]) {
      case "Any":
        return n4(X, W);
      case "Array":
        return c4(X, W);
      case "AsyncIterator":
        return l4(X, W);
      case "BigInt":
        return t4(X, W);
      case "Boolean":
        return s4(X, W);
      case "Constructor":
        return r4(X, W);
      case "Date":
        return a4(X, W);
      case "Function":
        return e4(X, W);
      case "Integer":
        return $J(X, W);
      case "Intersect":
        return YJ(X, W);
      case "Iterator":
        return WJ(X, W);
      case "Literal":
        return XJ(X, W);
      case "Never":
        return ZJ(X, W);
      case "Not":
        return QJ(X, W);
      case "Null":
        return JJ(X, W);
      case "Number":
        return zJ(X, W);
      case "Object":
        return HJ(X, W);
      case "Promise":
        return qJ(X, W);
      case "Record":
        return MJ(X, W);
      case "Ref":
        return NJ(X, W);
      case "String":
        return FJ(X, W);
      case "Symbol":
        return UJ(X, W);
      case "TemplateLiteral":
        return AJ(X, W);
      case "This":
        return BJ(X, W);
      case "Tuple":
        return DJ(X, W);
      case "Undefined":
        return wJ(X, W);
      case "Union":
        return KJ(X, W);
      case "Uint8Array":
        return jJ(X, W);
      case "Unknown":
        return PJ(X, W);
      case "Void":
        return OJ(X, W);
      default:
        if (!k0.TypeRegistry.Has(X[k0.Kind]))
          throw new d8(X);
        return SJ(X, W);
    }
  }, LJ = function(...$) {
    return RY = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_Y, "__esModule", { value: true });
  _Y.Create = _Y.ValueCreateRecursiveInstantiationError = _Y.ValueCreateTempateLiteralTypeError = _Y.ValueCreateIntersectTypeError = _Y.ValueCreateNotTypeError = _Y.ValueCreateNeverTypeError = _Y.ValueCreateUnknownTypeError = undefined;
  var a = x0(), o4 = Q$(), GY = D1(), k0 = f0();

  class d8 extends k0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _Y.ValueCreateUnknownTypeError = d8;

  class y8 extends k0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _Y.ValueCreateNeverTypeError = y8;

  class v8 extends k0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _Y.ValueCreateNotTypeError = v8;

  class p8 extends k0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateIntersectTypeError = p8;

  class i8 extends k0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateTempateLiteralTypeError = i8;

  class m8 extends k0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  _Y.ValueCreateRecursiveInstantiationError = m8;
  var bY = 512, RY = 0;
  _Y.Create = LJ;
});
var dY = J0((fY) => {
  var kY = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y);
  }, o8 = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? W : (0, N1.Create)($, Y);
  }, EJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    const X = (0, w1.IsArray)(W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y), Z = (0, w1.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, J = ((0, w1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((U) => Y1($.items, Y, U));
    if ($.uniqueItems !== true)
      return J;
    const z = [...new Set(J)];
    if (!(0, m0.Check)($, Y, z))
      throw new n8($, z);
    return z;
  }, VJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, N1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, J] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && W.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = Y1(J, Y, W.prototype[Q]);
    }
    return Z;
  }, xJ = function($, Y, W) {
    const X = (0, N1.Create)($, Y), Z = (0, w1.IsPlainObject)(X) && (0, w1.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, m0.Check)($, Y, Z) ? Z : (0, N1.Create)($, Y);
  }, kJ = function($, Y, W) {
    throw new c8($);
  }, gJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, N1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [Q, J] of Object.entries($.properties)) {
      if (!X.has(Q) && W[Q] === undefined)
        continue;
      Z[Q] = Y1(J, Y, W[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let J of Object.getOwnPropertyNames(W)) {
        if (Q.includes(J))
          continue;
        Z[J] = Y1($.additionalProperties, Y, W[J]);
      }
    }
    return Z;
  }, fJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, N1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = Y1(Z, Y, z);
    return Q;
  }, TJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, dJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, yJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (!(0, w1.IsArray)(W))
      return (0, N1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => Y1(X, Y, W[Z]));
  }, vJ = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : h8.Create($, Y, W);
  }, Y1 = function($, Y, W) {
    const X = (0, w1.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[M1.Kind]) {
      case "Array":
        return EJ(Z, X, W);
      case "Constructor":
        return VJ(Z, X, W);
      case "Intersect":
        return xJ(Z, X, W);
      case "Never":
        return kJ(Z, X, W);
      case "Object":
        return gJ(Z, X, W);
      case "Record":
        return fJ(Z, X, W);
      case "Ref":
        return TJ(Z, X, W);
      case "This":
        return dJ(Z, X, W);
      case "Tuple":
        return yJ(Z, X, W);
      case "Union":
        return vJ(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return o8(Z, X, W);
      default:
        if (!M1.TypeRegistry.Has(Z[M1.Kind]))
          throw new l8(Z);
        return o8(Z, X, W);
    }
  }, gY = function(...$) {
    return $.length === 3 ? Y1($[0], $[1], $[2]) : Y1($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Cast = fY.Default = fY.DefaultClone = fY.ValueCastUnknownTypeError = fY.ValueCastRecursiveTypeError = fY.ValueCastNeverTypeError = fY.ValueCastArrayUniqueItemsTypeError = undefined;
  var w1 = x0(), N1 = u8(), m0 = Q$(), u1 = i1(), VY = D1(), M1 = f0();

  class n8 extends M1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  fY.ValueCastArrayUniqueItemsTypeError = n8;

  class c8 extends M1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fY.ValueCastNeverTypeError = c8;

  class xY extends M1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fY.ValueCastRecursiveTypeError = xY;

  class l8 extends M1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCastUnknownTypeError = l8;
  var h8;
  (function($) {
    function Y(Z, Q, J) {
      if (Z[M1.Kind] === "Object" && typeof J === "object" && !(0, w1.IsNull)(J)) {
        const z = Z, U = Object.getOwnPropertyNames(J), D = Object.entries(z.properties), [B, j] = [1 / D.length, D.length];
        return D.reduce((b, [S, N]) => {
          const O = N[M1.Kind] === "Literal" && N.const === J[S] ? j : 0, P = (0, m0.Check)(N, Q, J[S]) ? B : 0, F = U.includes(S) ? B : 0;
          return b + (O + P + F);
        }, 0);
      } else
        return (0, m0.Check)(Z, Q, J) ? 1 : 0;
    }
    function W(Z, Q, J) {
      let [z, U] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const B = Y(D, Q, J);
        if (B > U)
          z = D, U = B;
      }
      return z;
    }
    function X(Z, Q, J) {
      if ("default" in Z)
        return Z.default;
      else {
        const z = W(Z, Q, J);
        return gY(z, Q, J);
      }
    }
    $.Create = X;
  })(h8 || (h8 = {}));
  fY.DefaultClone = kY;
  fY.Default = o8;
  fY.Cast = gY;
});
var hY = J0((mY) => {
  var V$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, lJ = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, J$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, z$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, tJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, $9 = function($, Y) {
    const W = pY($);
    return W === Y ? W : $;
  }, Y9 = function($, Y) {
    const W = iY($);
    return W === Y ? W : $;
  }, W9 = function($, Y) {
    const W = vY($);
    return W === Y ? W : $;
  }, X9 = function($, Y) {
    if (typeof $.const === "string")
      return $9(Y, $.const);
    else if (typeof $.const === "number")
      return Y9(Y, $.const);
    else if (typeof $.const === "boolean")
      return W9(Y, $.const);
    else
      return (0, nJ.Clone)(Y);
  }, vY = function($) {
    return J$($) ? true : z$($) ? false : $;
  }, Z9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : z$($) ? BigInt(0) : J$($) ? BigInt(1) : $;
  }, pY = function($) {
    return lJ($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iY = function($) {
    return V$($) ? parseFloat($) : J$($) ? 1 : z$($) ? 0 : $;
  }, Q9 = function($) {
    return V$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : J$($) ? 1 : z$($) ? 0 : $;
  }, J9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, z9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, H9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : J$($) ? new Date(1) : z$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : sJ($) ? new Date(`1970-01-01T${$}.000Z`) : tJ($) ? new Date(`1970-01-01T${$}`) : aJ($) ? new Date(`${$}.000Z`) : rJ($) ? new Date($) : eJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, t8 = function($) {
    return $;
  }, q9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => n0($.items, Y, X));
    return W;
  }, M9 = function($, Y, W) {
    return Z9(W);
  }, N9 = function($, Y, W) {
    return vY(W);
  }, F9 = function($, Y, W) {
    return H9(W);
  }, U9 = function($, Y, W) {
    return Q9(W);
  }, A9 = function($, Y, W) {
    return $.allOf.every((X) => h1.TypeGuard.TObject(X)) ? n0(h1.Type.Composite($.allOf), Y, W) : n0($.allOf[0], Y, W);
  }, B9 = function($, Y, W) {
    return X9($, W);
  }, D9 = function($, Y, W) {
    return J9(W);
  }, w9 = function($, Y, W) {
    return iY(W);
  }, K9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: n0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, j9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = n0(Z, Y, z);
    return Q;
  }, P9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, O9 = function($, Y, W) {
    return pY(W);
  }, S9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, L9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, C9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? n0($.items[Z], Y, X) : X;
      });
    return W;
  }, I9 = function($, Y, W) {
    return z9(W);
  }, b9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = n0(X, Y, W);
      if ((0, cJ.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, n0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[h1.Kind]) {
      case "Array":
        return q9(Z, X, W);
      case "BigInt":
        return M9(Z, X, W);
      case "Boolean":
        return N9(Z, X, W);
      case "Date":
        return F9(Z, X, W);
      case "Integer":
        return U9(Z, X, W);
      case "Intersect":
        return A9(Z, X, W);
      case "Literal":
        return B9(Z, X, W);
      case "Null":
        return D9(Z, X, W);
      case "Number":
        return w9(Z, X, W);
      case "Object":
        return K9(Z, X, W);
      case "Record":
        return j9(Z, X, W);
      case "Ref":
        return P9(Z, X, W);
      case "String":
        return O9(Z, X, W);
      case "Symbol":
        return S9(Z, X, W);
      case "This":
        return L9(Z, X, W);
      case "Tuple":
        return C9(Z, X, W);
      case "Undefined":
        return I9(Z, X, W);
      case "Union":
        return b9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return t8(W);
      default:
        if (!h1.TypeRegistry.Has(Z[h1.Kind]))
          throw new s8(Z);
        return t8(W);
    }
  }, G9 = function(...$) {
    return $.length === 3 ? n0($[0], $[1], $[2]) : n0($[0], [], $[1]);
  };
  Object.defineProperty(mY, "__esModule", { value: true });
  mY.Convert = mY.Default = mY.ValueConvertUnknownTypeError = undefined;
  var Z0 = x0(), nJ = i1(), cJ = Q$(), yY = D1(), h1 = f0();

  class s8 extends h1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mY.ValueConvertUnknownTypeError = s8;
  mY.Default = t8;
  mY.Convert = G9;
});
var e8 = J0((sY) => {
  Object.defineProperty(sY, "__esModule", { value: true });
  sY.EncodeTransform = sY.DecodeTransform = sY.HasTransform = sY.TransformEncodeError = sY.TransformDecodeError = sY.TransformEncodeCheckError = sY.TransformDecodeCheckError = sY.TransformUnknownTypeError = undefined;
  var c0 = x0(), o1 = D1(), h = f0();

  class H$ extends h.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sY.TransformUnknownTypeError = H$;

  class lY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformDecodeCheckError = lY;

  class tY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformEncodeCheckError = tY;

  class r8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformDecodeError = r8;

  class a8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformEncodeError = a8;
  var oY;
  (function($) {
    function Y(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function W(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function X(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Q(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((G) => O(G, I));
    }
    function J(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.not, I);
    }
    function U(w, I) {
      return h.TypeGuard.TTransform(w) || Object.values(w.properties).some((G) => O(G, I)) || h.TypeGuard.TSchema(w.additionalProperties) && O(w.additionalProperties, I);
    }
    function D(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.item, I);
    }
    function B(w, I) {
      const G = Object.getOwnPropertyNames(w.patternProperties)[0], k = w.patternProperties[G];
      return h.TypeGuard.TTransform(w) || O(k, I) || h.TypeGuard.TSchema(w.additionalProperties) && h.TypeGuard.TTransform(w.additionalProperties);
    }
    function j(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function b(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function S(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TSchema(w.items) && w.items.some((G) => O(G, I));
    }
    function N(w, I) {
      return h.TypeGuard.TTransform(w) || w.anyOf.some((G) => O(G, I));
    }
    function O(w, I) {
      const G = (0, c0.IsString)(w.$id) ? [...I, w] : I, k = w;
      if (w.$id && P.has(w.$id))
        return false;
      if (w.$id)
        P.add(w.$id);
      switch (w[h.Kind]) {
        case "Array":
          return Y(k, G);
        case "AsyncIterator":
          return W(k, G);
        case "Constructor":
          return X(k, G);
        case "Function":
          return Z(k, G);
        case "Intersect":
          return Q(k, G);
        case "Iterator":
          return J(k, G);
        case "Not":
          return z(k, G);
        case "Object":
          return U(k, G);
        case "Promise":
          return D(k, G);
        case "Record":
          return B(k, G);
        case "Ref":
          return j(k, G);
        case "This":
          return b(k, G);
        case "Tuple":
          return S(k, G);
        case "Union":
          return N(k, G);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return h.TypeGuard.TTransform(w);
        default:
          if (!h.TypeRegistry.Has(k[h.Kind]))
            throw new H$(k);
          return h.TypeGuard.TTransform(w);
      }
    }
    const P = new Set;
    function F(w, I) {
      return P.clear(), O(w, I);
    }
    $.Has = F;
  })(oY || (sY.HasTransform = oY = {}));
  var nY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Decode(O) : O;
      } catch (P) {
        throw new r8(N, O, P);
      }
    }
    function W(N, O, P) {
      const F = P.map((w) => j(N.items, O, w));
      return Y(N, F);
    }
    function X(N, O, P) {
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return Y(N, P);
      const F = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), w = Object.entries(P).reduce((G, [k, _]) => {
        return !F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, w);
      const I = Object.entries(w).reduce((G, [k, _]) => {
        return F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
      return Y(N, I);
    }
    function Z(N, O, P) {
      const F = j(N.not, O, P);
      return Y(N, F);
    }
    function Q(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.entries(P).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, F);
      const w = N.additionalProperties, I = Object.entries(F).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(w, O, _) };
      }, {});
      return Y(N, I);
    }
    function J(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.getOwnPropertyNames(N.patternProperties)[0], w = N.patternProperties[F], I = new RegExp(F), G = Object.entries(P).reduce((e, [o, r]) => {
        return !I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(w, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, G);
      const k = N.additionalProperties, _ = Object.entries(G).reduce((e, [o, r]) => {
        return I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(k, O, r) };
      }, {});
      return Y(N, _);
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, P[I])) : [];
      return Y(N, F);
    }
    function B(N, O, P) {
      const F = Y(N, P);
      for (let w of N.anyOf) {
        if (!b(w, O, F))
          continue;
        return j(w, O, F);
      }
      return F;
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "Symbol":
          return Y(w, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Decode = S;
  })(nY || (sY.DecodeTransform = nY = {}));
  var cY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Encode(O) : O;
      } catch (P) {
        throw new a8(N, O, P);
      }
    }
    function W(N, O, P) {
      return Y(N, P).map((w) => j(N.items, O, w));
    }
    function X(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return F;
      const w = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), I = Object.entries(F).reduce((G, [k, _]) => {
        return !w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, I);
      return Object.entries(I).reduce((G, [k, _]) => {
        return w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
    }
    function Z(N, O, P) {
      const F = Y(N, P);
      return Y(N.not, F);
    }
    function Q(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.entries(F).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return w;
      const I = N.additionalProperties;
      return Object.entries(w).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(I, O, _) };
      }, {});
    }
    function J(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.getOwnPropertyNames(N.patternProperties)[0], I = N.patternProperties[w], G = new RegExp(w), k = Object.entries(F).reduce((e, [o, r]) => {
        return !G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(I, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, k);
      const _ = N.additionalProperties;
      return Object.entries(k).reduce((e, [o, r]) => {
        return G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(_, O, r) };
      }, {});
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = Y(N, P);
      return (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, F[I])) : [];
    }
    function B(N, O, P) {
      for (let F of N.anyOf) {
        if (!b(F, O, P))
          continue;
        const w = j(F, O, P);
        return Y(N, w);
      }
      return Y(N, P);
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Encode = S;
  })(cY || (sY.EncodeTransform = cY = {}));
});
var JW = J0((ZW) => {
  Object.defineProperty(ZW, "__esModule", { value: true });
  ZW.Value = undefined;
  var aY = I$(), d9 = jY(), y9 = Y$(), v9 = SY(), eY = dY(), p9 = i1(), $W = hY(), YW = u8(), x$ = Q$(), WW = V8(), k$ = e8(), XW;
  (function($) {
    function Y(...N) {
      return eY.Cast.apply(eY, N);
    }
    $.Cast = Y;
    function W(...N) {
      return YW.Create.apply(YW, N);
    }
    $.Create = W;
    function X(...N) {
      return x$.Check.apply(x$, N);
    }
    $.Check = X;
    function Z(...N) {
      return $W.Convert.apply($W, N);
    }
    $.Convert = Z;
    function Q(N) {
      return p9.Clone(N);
    }
    $.Clone = Q;
    function J(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]];
      if (!X(O, P, F))
        throw new k$.TransformDecodeCheckError(O, F, U(O, P, F).First());
      return k$.DecodeTransform.Decode(O, P, F, x$.Check);
    }
    $.Decode = J;
    function z(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]], w = k$.EncodeTransform.Encode(O, P, F, x$.Check);
      if (!X(O, P, w))
        throw new k$.TransformEncodeCheckError(O, F, U(O, P, F).First());
      return w;
    }
    $.Encode = z;
    function U(...N) {
      return aY.Errors.apply(aY, N);
    }
    $.Errors = U;
    function D(N, O) {
      return v9.Equal(N, O);
    }
    $.Equal = D;
    function B(N, O) {
      return WW.Diff(N, O);
    }
    $.Diff = B;
    function j(N) {
      return y9.Hash(N);
    }
    $.Hash = j;
    function b(N, O) {
      return WW.Patch(N, O);
    }
    $.Patch = b;
    function S(N, O) {
      d9.Mutate(N, O);
    }
    $.Mutate = S;
  })(XW || (ZW.Value = XW = {}));
});
var $6 = J0((W1) => {
  Object.defineProperty(W1, "__esModule", { value: true });
  W1.Value = W1.ValuePointer = W1.Delete = W1.Update = W1.Insert = W1.Edit = W1.ValueErrorIterator = W1.ValueErrorType = undefined;
  var zW = I$();
  Object.defineProperty(W1, "ValueErrorType", { enumerable: true, get: function() {
    return zW.ValueErrorType;
  } });
  Object.defineProperty(W1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zW.ValueErrorIterator;
  } });
  var g$ = V8();
  Object.defineProperty(W1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(W1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(W1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(W1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var i9 = b$();
  Object.defineProperty(W1, "ValuePointer", { enumerable: true, get: function() {
    return i9.ValuePointer;
  } });
  var m9 = JW();
  Object.defineProperty(W1, "Value", { enumerable: true, get: function() {
    return m9.Value;
  } });
});
var UW = J0((NW) => {
  Object.defineProperty(NW, "__esModule", { value: true });
  NW.TypeCompiler = NW.Policy = NW.TypeCompilerTypeGuardError = NW.TypeCompilerUnknownTypeError = NW.TypeCheck = undefined;
  var N$ = e8(), c = x0(), r9 = $$(), F$ = E$(), a9 = D1(), e9 = Y$(), F0 = f0();

  class Q6 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = N$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, r9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new N$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? N$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? N$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new N$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  NW.TypeCheck = Q6;
  var F1;
  (function($) {
    function Y(Q) {
      return Q === 36;
    }
    $.DollarSign = Y;
    function W(Q) {
      return Q === 95;
    }
    $.IsUnderscore = W;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(F1 || (F1 = {}));
  var v$;
  (function($) {
    function Y(Q) {
      if (Q.length === 0)
        return false;
      return F1.IsNumeric(Q.charCodeAt(0));
    }
    function W(Q) {
      if (Y(Q))
        return false;
      for (let J = 0;J < Q.length; J++) {
        const z = Q.charCodeAt(J);
        if (!(F1.IsAlpha(z) || F1.IsNumeric(z) || F1.DollarSign(z) || F1.IsUnderscore(z)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, J) {
      return W(J) ? `${Q}.${J}` : `${Q}['${X(J)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var X6;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const Q = W.charCodeAt(Z);
        if (F1.IsNumeric(Q) || F1.IsAlpha(Q))
          X.push(W.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(X6 || (X6 = {}));
  var Z6;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(Z6 || (Z6 = {}));

  class J6 extends F0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  NW.TypeCompilerUnknownTypeError = J6;

  class p$ extends F0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  NW.TypeCompilerTypeGuardError = p$;
  var L1;
  (function($) {
    function Y(J, z, U) {
      return F$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${z}' in ${J} ? ${U} : true)` : `(${v$.Encode(J, z)} !== undefined ? ${U} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}))` : `(typeof ${J} === 'object' && ${J} !== null)`;
    }
    $.IsObjectLike = W;
    function X(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}) && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))` : `(typeof ${J} === 'object' && ${J} !== null && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(J) {
      return !F$.TypeSystemPolicy.AllowNaN ? `(typeof ${J} === 'number' && Number.isFinite(${J}))` : `typeof ${J} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q(J) {
      return F$.TypeSystemPolicy.AllowNullVoid ? `(${J} === undefined || ${J} === null)` : `${J} === undefined`;
    }
    $.IsVoidLike = Q;
  })(L1 || (NW.Policy = L1 = {}));
  var MW;
  (function($) {
    function Y(K) {
      return K[F0.Kind] === "Any" || K[F0.Kind] === "Unknown";
    }
    function* W(K, E, L) {
      yield "true";
    }
    function* X(K, E, L) {
      yield `Array.isArray(${L})`;
      const [p, T] = [B0("value", "any"), B0("acc", "number")];
      if ((0, c.IsNumber)(K.maxItems))
        yield `${L}.length <= ${K.maxItems}`;
      if ((0, c.IsNumber)(K.minItems))
        yield `${L}.length >= ${K.minItems}`;
      const d = f(K.items, E, "value");
      if (yield `${L}.every((${p}) => ${d})`, F0.TypeGuard.TSchema(K.contains) || (0, c.IsNumber)(K.minContains) || (0, c.IsNumber)(K.maxContains)) {
        const W0 = F0.TypeGuard.TSchema(K.contains) ? K.contains : F0.Type.Never(), j0 = f(W0, E, "value"), X0 = (0, c.IsNumber)(K.minContains) ? [`(count >= ${K.minContains})`] : [], M = (0, c.IsNumber)(K.maxContains) ? [`(count <= ${K.maxContains})`] : [], l = `const count = value.reduce((${T}, ${p}) => ${j0} ? acc + 1 : acc, 0)`, S0 = ["(count > 0)", ...X0, ...M].join(" && ");
        yield `((${p}) => { ${l}; return ${S0}})(${L})`;
      }
      if (K.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${L})`;
    }
    function* Z(K, E, L) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${L})`;
    }
    function* Q(K, E, L) {
      if (yield `(typeof ${L} === 'bigint')`, (0, c.IsBigInt)(K.exclusiveMaximum))
        yield `${L} < BigInt(${K.exclusiveMaximum})`;
      if ((0, c.IsBigInt)(K.exclusiveMinimum))
        yield `${L} > BigInt(${K.exclusiveMinimum})`;
      if ((0, c.IsBigInt)(K.maximum))
        yield `${L} <= BigInt(${K.maximum})`;
      if ((0, c.IsBigInt)(K.minimum))
        yield `${L} >= BigInt(${K.minimum})`;
      if ((0, c.IsBigInt)(K.multipleOf))
        yield `(${L} % BigInt(${K.multipleOf})) === 0`;
    }
    function* J(K, E, L) {
      yield `(typeof ${L} === 'boolean')`;
    }
    function* z(K, E, L) {
      yield* v0(K.returns, E, `${L}.prototype`);
    }
    function* U(K, E, L) {
      if (yield `(${L} instanceof Date) && Number.isFinite(${L}.getTime())`, (0, c.IsNumber)(K.exclusiveMaximumTimestamp))
        yield `${L}.getTime() < ${K.exclusiveMaximumTimestamp}`;
      if ((0, c.IsNumber)(K.exclusiveMinimumTimestamp))
        yield `${L}.getTime() > ${K.exclusiveMinimumTimestamp}`;
      if ((0, c.IsNumber)(K.maximumTimestamp))
        yield `${L}.getTime() <= ${K.maximumTimestamp}`;
      if ((0, c.IsNumber)(K.minimumTimestamp))
        yield `${L}.getTime() >= ${K.minimumTimestamp}`;
      if ((0, c.IsNumber)(K.multipleOfTimestamp))
        yield `(${L}.getTime() % ${K.multipleOfTimestamp}) === 0`;
    }
    function* D(K, E, L) {
      yield `(typeof ${L} === 'function')`;
    }
    function* B(K, E, L) {
      if (yield `(typeof ${L} === 'number' && Number.isInteger(${L}))`, (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* j(K, E, L) {
      const p = K.allOf.map((T) => f(T, E, L)).join(" && ");
      if (K.unevaluatedProperties === false) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key))`;
        yield `(${p} && ${d})`;
      } else if (F0.TypeGuard.TSchema(K.unevaluatedProperties)) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key) || ${f(K.unevaluatedProperties, E, `${L}[key]`)})`;
        yield `(${p} && ${d})`;
      } else
        yield `(${p})`;
    }
    function* b(K, E, L) {
      yield `(typeof value === 'object' && Symbol.iterator in ${L})`;
    }
    function* S(K, E, L) {
      if (typeof K.const === "number" || typeof K.const === "boolean")
        yield `(${L} === ${K.const})`;
      else
        yield `(${L} === '${Z6.Escape(K.const)}')`;
    }
    function* N(K, E, L) {
      yield "false";
    }
    function* O(K, E, L) {
      yield `(!${f(K.not, E, L)})`;
    }
    function* P(K, E, L) {
      yield `(${L} === null)`;
    }
    function* F(K, E, L) {
      if (yield L1.IsNumberLike(L), (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* w(K, E, L) {
      if (yield L1.IsObjectLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const p = Object.getOwnPropertyNames(K.properties);
      for (let T of p) {
        const d = v$.Encode(L, T), W0 = K.properties[T];
        if (K.required && K.required.includes(T)) {
          if (yield* v0(W0, E, d), F0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${T}' in ${L})`;
        } else {
          const j0 = f(W0, E, d);
          yield L1.IsExactOptionalProperty(L, T, j0);
        }
      }
      if (K.additionalProperties === false)
        if (K.required && K.required.length === p.length)
          yield `Object.getOwnPropertyNames(${L}).length === ${p.length}`;
        else {
          const T = `[${p.map((d) => `'${d}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${L}).every(key => ${T}.includes(key))`;
        }
      if (typeof K.additionalProperties === "object") {
        const T = f(K.additionalProperties, E, `${L}[key]`), d = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${L}).every(key => ${d}.includes(key) || ${T}))`;
      }
    }
    function* I(K, E, L) {
      yield `(typeof value === 'object' && typeof ${L}.then === 'function')`;
    }
    function* G(K, E, L) {
      if (yield L1.IsRecordLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const [p, T] = Object.entries(K.patternProperties)[0], d = n(`${new RegExp(p)}`), W0 = f(T, E, "value"), j0 = F0.TypeGuard.TSchema(K.additionalProperties) ? f(K.additionalProperties, E, L) : K.additionalProperties === false ? "false" : "true", X0 = `(${d}.test(key) ? ${W0} : ${j0})`;
      yield `(Object.entries(${L}).every(([key, value]) => ${X0}))`;
    }
    function* k(K, E, L) {
      const p = (0, a9.Deref)(K, E);
      if (R.functions.has(K.$ref))
        return yield `${i(K.$ref)}(${L})`;
      yield* v0(p, E, L);
    }
    function* _(K, E, L) {
      if (yield `(typeof ${L} === 'string')`, (0, c.IsNumber)(K.maxLength))
        yield `${L}.length <= ${K.maxLength}`;
      if ((0, c.IsNumber)(K.minLength))
        yield `${L}.length >= ${K.minLength}`;
      if (K.pattern !== undefined)
        yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
      if (K.format !== undefined)
        yield `format('${K.format}', ${L})`;
    }
    function* e(K, E, L) {
      yield `(typeof ${L} === 'symbol')`;
    }
    function* o(K, E, L) {
      yield `(typeof ${L} === 'string')`, yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
    }
    function* r(K, E, L) {
      yield `${i(K.$ref)}(${L})`;
    }
    function* g0(K, E, L) {
      if (yield `Array.isArray(${L})`, K.items === undefined)
        return yield `${L}.length === 0`;
      yield `(${L}.length === ${K.maxItems})`;
      for (let p = 0;p < K.items.length; p++)
        yield `${f(K.items[p], E, `${L}[${p}]`)}`;
    }
    function* b0(K, E, L) {
      yield `${L} === undefined`;
    }
    function* E0(K, E, L) {
      yield `(${K.anyOf.map((T) => f(T, E, L)).join(" || ")})`;
    }
    function* H0(K, E, L) {
      if (yield `${L} instanceof Uint8Array`, (0, c.IsNumber)(K.maxByteLength))
        yield `(${L}.length <= ${K.maxByteLength})`;
      if ((0, c.IsNumber)(K.minByteLength))
        yield `(${L}.length >= ${K.minByteLength})`;
    }
    function* z0(K, E, L) {
      yield "true";
    }
    function* u0(K, E, L) {
      yield L1.IsVoidLike(L);
    }
    function* a0(K, E, L) {
      const p = R.instances.size;
      R.instances.set(p, K), yield `kind('${K[F0.Kind]}', ${p}, ${L})`;
    }
    function* v0(K, E, L, p = true) {
      const T = (0, c.IsString)(K.$id) ? [...E, K] : E, d = K;
      if (p && (0, c.IsString)(K.$id)) {
        const W0 = i(K.$id);
        if (R.functions.has(W0))
          return yield `${W0}(${L})`;
        else {
          const j0 = q0(W0, K, E, "value", false);
          return R.functions.set(W0, j0), yield `${W0}(${L})`;
        }
      }
      switch (d[F0.Kind]) {
        case "Any":
          return yield* W(d, T, L);
        case "Array":
          return yield* X(d, T, L);
        case "AsyncIterator":
          return yield* Z(d, T, L);
        case "BigInt":
          return yield* Q(d, T, L);
        case "Boolean":
          return yield* J(d, T, L);
        case "Constructor":
          return yield* z(d, T, L);
        case "Date":
          return yield* U(d, T, L);
        case "Function":
          return yield* D(d, T, L);
        case "Integer":
          return yield* B(d, T, L);
        case "Intersect":
          return yield* j(d, T, L);
        case "Iterator":
          return yield* b(d, T, L);
        case "Literal":
          return yield* S(d, T, L);
        case "Never":
          return yield* N(d, T, L);
        case "Not":
          return yield* O(d, T, L);
        case "Null":
          return yield* P(d, T, L);
        case "Number":
          return yield* F(d, T, L);
        case "Object":
          return yield* w(d, T, L);
        case "Promise":
          return yield* I(d, T, L);
        case "Record":
          return yield* G(d, T, L);
        case "Ref":
          return yield* k(d, T, L);
        case "String":
          return yield* _(d, T, L);
        case "Symbol":
          return yield* e(d, T, L);
        case "TemplateLiteral":
          return yield* o(d, T, L);
        case "This":
          return yield* r(d, T, L);
        case "Tuple":
          return yield* g0(d, T, L);
        case "Undefined":
          return yield* b0(d, T, L);
        case "Union":
          return yield* E0(d, T, L);
        case "Uint8Array":
          return yield* H0(d, T, L);
        case "Unknown":
          return yield* z0(d, T, L);
        case "Void":
          return yield* u0(d, T, L);
        default:
          if (!F0.TypeRegistry.Has(d[F0.Kind]))
            throw new J6(K);
          return yield* a0(d, T, L);
      }
    }
    const R = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function f(K, E, L, p = true) {
      return `(${[...v0(K, E, L, p)].join(" && ")})`;
    }
    function i(K) {
      return `check_${X6.Encode(K)}`;
    }
    function n(K) {
      const E = `local_${R.variables.size}`;
      return R.variables.set(E, `const ${E} = ${K}`), E;
    }
    function q0(K, E, L, p, T = true) {
      const [d, W0] = ["\n", (l) => "".padStart(l, " ")], j0 = B0("value", "any"), X0 = D0("boolean"), M = [...v0(E, L, p, T)].map((l) => `${W0(4)}${l}`).join(` &&${d}`);
      return `function ${K}(${j0})${X0} {${d}${W0(2)}return (${d}${M}${d}${W0(2)})\n}`;
    }
    function B0(K, E) {
      const L = R.language === "typescript" ? `: ${E}` : "";
      return `${K}${L}`;
    }
    function D0(K) {
      return R.language === "typescript" ? `: ${K}` : "";
    }
    function w0(K, E, L) {
      const p = q0("check", K, E, "value"), T = B0("value", "any"), d = D0("boolean"), W0 = [...R.functions.values()], j0 = [...R.variables.values()], X0 = (0, c.IsString)(K.$id) ? `return function check(${T})${d} {\n  return ${i(K.$id)}(value)\n}` : `return ${p}`;
      return [...j0, ...W0, X0].join("\n");
    }
    function M0(...K) {
      const E = { language: "javascript" }, [L, p, T] = K.length === 2 && (0, c.IsArray)(K[1]) ? [K[0], K[1], E] : K.length === 2 && !(0, c.IsArray)(K[1]) ? [K[0], [], K[1]] : K.length === 3 ? [K[0], K[1], K[2]] : K.length === 1 ? [K[0], [], E] : [null, [], E];
      if (R.language = T.language, R.variables.clear(), R.functions.clear(), R.instances.clear(), !F0.TypeGuard.TSchema(L))
        throw new p$(L);
      for (let d of p)
        if (!F0.TypeGuard.TSchema(d))
          throw new p$(d);
      return w0(L, p, T);
    }
    $.Code = M0;
    function B1(K, E = []) {
      const L = M0(K, E, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", L), T = new Map(R.instances);
      function d(M, l, S0) {
        if (!F0.TypeRegistry.Has(M) || !T.has(l))
          return false;
        const l$ = F0.TypeRegistry.Get(M), t$ = T.get(l);
        return l$(t$, S0);
      }
      function W0(M, l) {
        if (!F0.FormatRegistry.Has(M))
          return false;
        return F0.FormatRegistry.Get(M)(l);
      }
      function j0(M) {
        return (0, e9.Hash)(M);
      }
      const X0 = p(d, W0, j0);
      return new Q6(K, E, X0, L);
    }
    $.Compile = B1;
  })(MW || (NW.TypeCompiler = MW = {}));
});
var BW = J0((l0) => {
  var Z7 = l0 && l0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), Q7 = l0 && l0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        Z7(Y, $, W);
  };
  Object.defineProperty(l0, "__esModule", { value: true });
  l0.ValueErrorIterator = l0.ValueErrorType = undefined;
  var AW = I$();
  Object.defineProperty(l0, "ValueErrorType", { enumerable: true, get: function() {
    return AW.ValueErrorType;
  } });
  Object.defineProperty(l0, "ValueErrorIterator", { enumerable: true, get: function() {
    return AW.ValueErrorIterator;
  } });
  Q7(UW(), l0);
});
var bW = J0((K5, IW) => {
  var H7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, Q = 0, J = Y, z = LW;
    while (Y > -1 && Y < W) {
      var U = CW($[Y + 1], 4), D = CW($[Y + 2], 0), B = U | D, j = U6[B];
      if (z = U6[256 + z + j], Q = Q << 6 | B & U6[364 + j], z === LW)
        X += $.slice(Z, J), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = Y + 3, Y = J = $.indexOf("%", Z);
      else if (z === z7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, CW = function($, Y) {
    var W = q7[$];
    return W === undefined ? 255 : W << Y;
  }, LW = 12, z7 = 0, U6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], q7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  IW.exports = H7;
});
var VW = J0((j5, EW) => {
  var M7 = function($) {
    const Y = new _W;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", Q = -1, J = -1, z = false, U = false, D = false, B = false, j = false, b = 0;
    for (let S = 0;S < W + 1; S++)
      if (b = S !== W ? $.charCodeAt(S) : 38, b === 38) {
        if (j = J > Q, !j)
          J = S;
        if (X = $.slice(Q + 1, J), j || X.length > 0) {
          if (D)
            X = X.replace(RW, " ");
          if (z)
            X = GW(X) || X;
          if (j) {
            if (Z = $.slice(J + 1, S), B)
              Z = Z.replace(RW, " ");
            if (U)
              Z = GW(Z) || Z;
          }
          const N = Y[X];
          if (N === undefined)
            Y[X] = Z;
          else if (N.pop)
            N.push(Z);
          else
            Y[X] = [N, Z];
        }
        Z = "", Q = S, J = S, z = false, U = false, D = false, B = false;
      } else if (b === 61)
        if (J <= Q)
          J = S;
        else
          U = true;
      else if (b === 43)
        if (J > Q)
          B = true;
        else
          D = true;
      else if (b === 37)
        if (J > Q)
          U = true;
        else
          z = true;
    return Y;
  }, GW = bW(), RW = /\+/g, _W = function() {
  };
  _W.prototype = Object.create(null);
  EW.exports = M7;
});
var kW = J0((P5, xW) => {
  var F7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (N7[Q] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += Z1[Q];
          }
          if (++Z === Y)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, W += Z1[192 | Q >> 6] + Z1[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, W += Z1[224 | Q >> 12] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const J = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | J), W += Z1[240 | Q >> 18] + Z1[128 | Q >> 12 & 63] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, Z1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), N7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  xW.exports = { encodeString: F7 };
});
var TW = J0((O5, fW) => {
  var gW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return A6($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : A6("" + $);
    return "";
  }, U7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let J = 0;J < Z; J++) {
      const z = X[J], U = $[z], D = A6(z) + "=";
      if (J)
        Y += W;
      if (Array.isArray(U)) {
        Q = U.length;
        for (let B = 0;B < Q; B++) {
          if (B)
            Y += W;
          Y += D, Y += gW(U[B]);
        }
      } else
        Y += D, Y += gW(U);
    }
    return Y;
  }, { encodeString: A6 } = kW();
  fW.exports = U7;
});
var B6 = J0((S5, B$) => {
  var dW = VW(), yW = TW(), vW = { parse: dW, stringify: yW };
  B$.exports = vW;
  B$.exports.default = vW;
  B$.exports.parse = dW;
  B$.exports.stringify = yW;
});
var _1 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var L6 = ($, Y) => ({ ...$, part: Y });
var C6 = ($) => ({ paramName: $, store: null, inert: null });

class E1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let Q = Y.split(E1.regex.static), J = Y.match(E1.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = _1("/");
    let z = 0;
    for (let U = 0;U < Q.length; ++U) {
      let D = Q[U];
      if (U > 0) {
        let B = J[z++].slice(1);
        if (X.params === null)
          X.params = C6(B);
        else if (X.params.paramName !== B)
          throw Error(`Cannot create route "${Y}" with parameter "${B}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let j = X.params;
        if (j.inert === null) {
          X = j.inert = _1(D);
          continue;
        }
        X = j.inert;
      }
      for (let B = 0;; ) {
        if (B === D.length) {
          if (B < X.part.length) {
            let j = L6(X, X.part.slice(B));
            Object.assign(X, _1(D, [j]));
          }
          break;
        }
        if (B === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(B))) {
            X = X.inert.get(D.charCodeAt(B)), D = D.slice(B), B = 0;
            continue;
          }
          let j = _1(D.slice(B));
          X.inert.set(D.charCodeAt(B), j), X = j;
          break;
        }
        if (D[B] !== X.part[B]) {
          let j = L6(X, X.part.slice(B)), b = _1(D.slice(B));
          Object.assign(X, _1(X.part.slice(0, B), [j, b])), X = b;
          break;
        }
        ++B;
      }
    }
    if (z < J.length) {
      let U = J[z], D = U.slice(1);
      if (X.params === null)
        X.params = C6(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? r$(Y, Y.length, W, 0) : null;
  }
}
var r$ = ($, Y, W, X) => {
  let Z = W?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > Y)
      return null;
    if (Z.length < 15) {
      for (let J = 1, z = X + 1;J < Z.length; ++J, ++z)
        if (Z.charCodeAt(J) !== $.charCodeAt(z))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let J = W.inert.get($.charCodeAt(Q));
    if (J !== undefined) {
      let z = r$($, Y, J, Q);
      if (z !== null)
        return z;
    }
  }
  if (W.params !== null) {
    let J = W.params, z = $.indexOf("/", Q);
    if (z !== Q) {
      if (z === -1 || z >= Y) {
        if (J.store !== null) {
          let U = {};
          return U[J.paramName] = $.substring(Q, Y), { store: J.store, params: U };
        }
      } else if (J.inert !== null) {
        let U = r$($, Y, J.inert, z);
        if (U !== null)
          return U.params[J.paramName] = $.substring(Q, z), U;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(Q, Y) } } : null;
};
var G6 = Q1(b6(), 1);
var R6 = G6.default;
var _6 = ($, Y) => {
  return async function W(X) {
    const Z = X.id;
    if (X.event === "request" && X.type === "begin") {
      const Q = () => {
        let O, P, F = -1;
        const w = [], I = [];
        let G = false;
        const k = new Promise((o) => {
          O = (r) => {
            if (G)
              return;
            else
              G = true;
            o(r);
          };
        });
        let _ = false;
        const e = new Promise((o) => {
          P = (r) => {
            if (_)
              return;
            else
              _ = true;
            if (F === -1)
              F = 0;
            for (;F < I.length; F++) {
              let g0;
              const b0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((E0) => {
                E0(g0);
              }), children: [] };
              g0 = performance.now(), w[F](b0);
            }
            o(r);
          };
        });
        return { signal: k, consumeChild(o) {
          switch (o.type) {
            case "begin":
              w[++F]({ name: o.name, time: o.time, skip: false, end: new Promise((r) => {
                I.push(r);
              }) });
              break;
            case "end":
              I[F](o.time);
              break;
          }
        }, consume(o) {
          switch (o.type) {
            case "begin":
              const r = [], g0 = o.unit ?? 0;
              for (let b0 = 0;b0 < g0; b0++) {
                let E0;
                r.push(new Promise((H0) => {
                  E0 = H0;
                })), w.push(E0);
              }
              O({ name: o.name, time: o.time, skip: false, end: e, children: r });
              break;
            case "end":
              P(o.time);
              break;
          }
        }, resolve() {
          if (G && _)
            return;
          let o;
          const r = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((g0) => {
            g0(o);
          }), children: [] };
          o = performance.now(), O(r), P(o);
        } };
      }, J = Q(), z = Q(), U = Q(), D = Q(), B = Q(), j = Q(), b = Q(), S = Q();
      J.consume(X);
      const N = (O) => {
        if (O.id === Z)
          switch (O.event) {
            case "request":
              J.consume(O);
              break;
            case "request.unit":
              J.consumeChild(O);
              break;
            case "parse":
              z.consume(O);
              break;
            case "parse.unit":
              z.consumeChild(O);
              break;
            case "transform":
              U.consume(O);
              break;
            case "transform.unit":
              U.consumeChild(O);
              break;
            case "beforeHandle":
              D.consume(O);
              break;
            case "beforeHandle.unit":
              D.consumeChild(O);
              break;
            case "handle":
              B.consume(O);
              break;
            case "afterHandle":
              j.consume(O);
              break;
            case "afterHandle.unit":
              j.consumeChild(O);
              break;
            case "error":
              b.consume(O);
              break;
            case "error.unit":
              b.consumeChild(O);
              break;
            case "response":
              if (O.type === "begin")
                J.resolve(), z.resolve(), U.resolve(), D.resolve(), B.resolve(), j.resolve(), b.resolve();
              else
                $.off("event", N);
              S.consume(O);
              break;
            case "response.unit":
              S.consumeChild(O);
              break;
          }
      };
      $.on("event", N), await Y({ id: X.id, context: X.ctx, set: X.ctx?.set, store: X.ctx?.store, time: X.time, request: J.signal, parse: z.signal, transform: U.signal, beforeHandle: D.signal, handle: B.signal, afterHandle: j.signal, error: b.signal, response: S.signal }), $.emit(`res${Z}`, undefined);
    }
  };
};
var Y6 = Q1($6(), 1);
var HW = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var n1 = Symbol("ErrorCode");
var q$ = (HW?.NODE_ENV ?? HW?.ENV) === "production";

class f$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class S1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class M$ extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class P0 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = q$ ? undefined : Y.Errors(W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, Q = q$ ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(Y6.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(Q);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, P0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return Y6.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W6 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class c1 {
  $;
  Y;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator;
  }
  get publish() {
    return ($, Y = undefined, W) => {
      if (this.validator?.Check(Y) === false)
        throw new P0("message", this.validator, Y);
      if (typeof Y === "object")
        Y = JSON.stringify(Y);
      return this.raw.publish($, Y, W), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new P0("message", this.validator, $);
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var o9 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || c9, Q = 0;
  while (Q < $.length) {
    var J = $.indexOf("=", Q);
    if (J === -1)
      break;
    var z = $.indexOf(";", Q);
    if (z === -1)
      z = $.length;
    else if (z < J) {
      Q = $.lastIndexOf(";", J - 1) + 1;
      continue;
    }
    var U = $.slice(Q, J).trim();
    if (W[U] === undefined) {
      var D = $.slice(J + 1, z).trim();
      if (D.charCodeAt(0) === 34)
        D = D.slice(1, -1);
      W[U] = s9(D, Z);
    }
    Q = z + 1;
  }
  return W;
};
var n9 = function($, Y, W) {
  var X = W || {}, Z = X.encode || l9;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$.test($))
    throw new TypeError("argument name is invalid");
  var Q = Z(Y);
  if (Q && !T$.test(Q))
    throw new TypeError("argument val is invalid");
  var J = $ + "=" + Q;
  if (X.maxAge != null) {
    var z = X.maxAge - 0;
    if (isNaN(z) || !isFinite(z))
      throw new TypeError("option maxAge is invalid");
    J += "; Max-Age=" + Math.floor(z);
  }
  if (X.domain) {
    if (!T$.test(X.domain))
      throw new TypeError("option domain is invalid");
    J += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!T$.test(X.path))
      throw new TypeError("option path is invalid");
    J += "; Path=" + X.path;
  }
  if (X.expires) {
    var U = X.expires;
    if (!t9(U) || isNaN(U.valueOf()))
      throw new TypeError("option expires is invalid");
    J += "; Expires=" + U.toUTCString();
  }
  if (X.httpOnly)
    J += "; HttpOnly";
  if (X.secure)
    J += "; Secure";
  if (X.priority) {
    var D = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (D) {
      case "low":
        J += "; Priority=Low";
        break;
      case "medium":
        J += "; Priority=Medium";
        break;
      case "high":
        J += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var B = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (B) {
      case true:
        J += "; SameSite=Strict";
        break;
      case "lax":
        J += "; SameSite=Lax";
        break;
      case "strict":
        J += "; SameSite=Strict";
        break;
      case "none":
        J += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J;
};
var c9 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var l9 = function($) {
  return encodeURIComponent($);
};
var t9 = function($) {
  return h9.call($) === "[object Date]" || $ instanceof Date;
};
var s9 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$ = o9;
var y$ = n9;
var h9 = Object.prototype.toString;
var T$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$ = Q1(f0(), 1);
var U$ = Q1($6(), 1);
var H6 = Q1(BW(), 1);
var z6 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var J7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || t0(Object.getPrototypeOf($));
var U1 = ($, Y, { skipKeys: W } = {}) => {
  if (z6($) && z6(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!z6(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (J7(Z)) {
        $[X] = Z;
        continue;
      }
      $[X] = U1($[X], Z);
    }
  return $;
};
var DW = ($, Y) => U1($, Y, { skipKeys: ["properties"] });
var O0 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var C1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: U1(Y?.detail ?? {}, $?.detail ?? {}), parse: O0($?.parse ?? [], Y?.parse ?? []), transform: O0($?.transform ?? [], Y?.transform ?? []), beforeHandle: O0($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: O0($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: O0($?.onResponse ?? [], Y?.onResponse ?? []), trace: O0($?.trace ?? [], Y?.trace ?? []), error: O0($?.error ?? [], Y?.error ?? []) };
};
var X1 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => U$.Value.Check(Z, Q), Errors: (Q) => U$.Value.Errors(Z, Q), Code: () => "" };
  return H6.TypeCompiler.Compile(Z);
};
var q6 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, Q = (z) => {
    if (X)
      return { schema: z, references: "", checkFunc: () => {
      }, code: "", Check: (U) => U$.Value.Check(z, U), Errors: (U) => U$.Value.Errors(z, U), Code: () => "" };
    return H6.TypeCompiler.Compile(z);
  };
  if (i$.Kind in Z) {
    if (("additionalProperties" in Z) === false)
      Z.additionalProperties = W;
    return { 200: Q(Z) };
  }
  const J = {};
  return Object.keys(Z).forEach((z) => {
    const U = Z[+z];
    if (typeof U === "string") {
      if (U in Y) {
        const D = Y[U];
        D.type === "object" && ("additionalProperties" in D), J[+z] = (i$.Kind in D) ? Q(D) : D;
      }
      return;
    }
    if (U.type === "object" && ("additionalProperties" in U) === false)
      U.additionalProperties = W;
    J[+z] = (i$.Kind in U) ? Q(U) : U;
  }), J;
};
var M6 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var m$ = ($, Y, W) => {
  const X = (Z) => {
    if (W)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: O0($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: O0($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: O0($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: O0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: O0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: O0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: O0($.onResponse, (Y?.onResponse ?? []).map(X)), trace: O0($.trace, ("trace" in Y ? Y.trace ?? [] : []).map(X)), error: O0($.error, (Y?.error ?? []).map(X)), stop: O0($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var wW = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var l1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var N6 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: l1($?.parse), transform: l1($?.transform), beforeHandle: l1($?.beforeHandle), afterHandle: l1($?.afterHandle), onResponse: l1($?.onResponse), error: l1($?.error) };
};
var F6 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var KW = import.meta.require("crypto");
var I1 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  return $ + "." + KW.createHmac("sha256", Y).update($).digest("base64").replace(/\=+$/, "");
};
var u$ = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  var W = $.slice(0, $.lastIndexOf(".")), X = I1(W, Y), Z = Buffer.from(X), Q = Buffer.from($);
  return Z.length === Q.length && KW.timingSafeEqual(Z, Q) ? W : false;
};

class s0 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({ value: "", expires: new Date });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var jW = ($, Y, W) => new Proxy($, { get(X, Z) {
  if (Z in X)
    return X[Z];
  const Q = new s0(undefined, W ? { ...W } : undefined);
  return Q.setter = Y, Q.name = Z, Q;
}, set(X, Z, Q) {
  if (!(Q instanceof s0))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return Q.setter = Y, Q.name = Z, Q.sync(), X[Z] = Q, true;
} });
var h$ = ($, Y, { secret: W, sign: X, ...Z } = {}) => {
  if (!Y)
    return jW({}, $, Z);
  const Q = {}, J = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const z = Object.keys(d$(Y));
  for (let U = 0;U < z.length; U++) {
    const D = z[U];
    let B = d$(Y)[D];
    if (X === true || X?.includes(D)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (J) {
        if (B = u$(B, W), B === false)
          throw new M$(D);
      } else {
        let S = true;
        for (let N = 0;N < W.length; N++) {
          const O = u$(B, W[N]);
          if (O !== false) {
            B = O, S = false;
            break;
          }
        }
        if (S)
          throw new M$(D);
      }
    }
    const j = B.charCodeAt(0);
    if (j === 123 || j === 91)
      try {
        const S = new s0(JSON.parse(B));
        S.setter = $, S.name = D, Q[D] = S;
        continue;
      } catch {
      }
    if (!Number.isNaN(+B))
      B = +B;
    else if (B === "true")
      B = true;
    else if (B === "false")
      B = false;
    const b = new s0(B, Z);
    b.setter = $, b.name = D, Q[D] = b;
  }
  return jW(Q, $);
};
var PW = "toJSON" in new Headers;
var t0 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var OW = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var SW = ($) => {
  if (!$ || typeof $ !== "object" || !t0($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let Q = X.value[Z];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Y.push(y$(W, Q, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(y$(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var A1 = ($, Y) => {
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((Z) => A1(Z, Y));
      case "Function":
        return A1($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = K1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var r0 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q = r0(Z, Y);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return r0($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = r0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var K1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return A$($);
    case "Promise":
      return $.then((W) => {
        const X = K1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return K1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var A$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var pW = Q1(B6(), 1);
var A7 = new Headers().toJSON;
var iW = new RegExp(" (\\w+) = context", "g");
var mW = { value: 0 };
var uW = ({ hasTrace: $, hasTraceSet: Y = false, addFn: W, condition: X = {} }) => {
  if ($)
    return (Z, { name: Q, attribute: J = "", unit: z = 0 } = {}) => {
      const U = Z.indexOf("."), D = U === -1;
      if (Z !== "request" && Z !== "response" && !X[D ? Z : Z.slice(0, U)])
        return () => {
          if (Y && Z === "afterHandle")
            W("\nawait traceDone\n");
        };
      if (D)
        Q ||= Z;
      else
        Q ||= "anonymous";
      W("\n" + `reporter.emit('event', { 
					id,
					event: '${Z}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${D ? `unit: ${z},` : ""}
					${J}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let B = false;
      return () => {
        if (B)
          return;
        if (B = true, W("\n" + `reporter.emit('event', {
							id,
							event: '${Z}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && Z === "afterHandle")
          W("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var D$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var B7 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var K0 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [W];
  if (Z)
    Q.push(Z);
  for (let z of Y.matchAll(iW))
    Q.push(z[1]);
  const J = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [z] of Y.matchAll(J))
    if (z.includes(`{ ${$}`) || z.includes(`, ${$}`))
      return true;
  return false;
};
var w$ = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let J of $.matchAll(iW))
    Z.push(J[1]);
  for (let J of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t1 = Symbol.for("TypeBox.Kind");
var o$ = ($, Y) => {
  if (!Y)
    return;
  if ((t1 in Y) && Y[t1] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (o$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q = 0;Q < Z.anyOf.length; Q++)
          if (o$($, Z.anyOf[Q]))
            return true;
      }
      if ((t1 in Z) && Z[t1] === $)
        return true;
    }
    return false;
  }
  return Y.properties && (t1 in Y.properties) && Y.properties[t1] === $;
};
var D6 = Symbol.for("TypeBox.Transform");
var b1 = ($) => {
  if (!$)
    return;
  if ($.type === "object") {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (b1(X))
          return true;
      } else if (X.anyOf) {
        for (let Q = 0;Q < X.anyOf.length; Q++)
          if (b1(X.anyOf[Q]))
            return true;
      }
      if (D6 in X)
        return true;
    }
    return false;
  }
  return (D6 in $) || $.properties && (D6 in $.properties);
};
var D7 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && ("anyOf" in Y)) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var w7 = /(?:return|=>) \S*\(/g;
var N0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(w7);
};
var hW = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: Q, definitions: J, schema: z, onRequest: U, config: D, reporter: B }) => {
  const j = D.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, b = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((R, f) => `await res${f}(c)`).join(";")}})();\n` : "", S = W.trace.map((R) => R.toString());
  let N = false;
  if (w$(Z.toString()))
    N = true;
  if (!N)
    for (let [R, f] of Object.entries(W)) {
      if (!Array.isArray(f) || !f.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(R))
        continue;
      for (let i of f) {
        if (typeof i !== "function")
          continue;
        if (w$(i.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const O = { parse: S.some((R) => K0("parse", R)), transform: S.some((R) => K0("transform", R)), handle: S.some((R) => K0("handle", R)), beforeHandle: S.some((R) => K0("beforeHandle", R)), afterHandle: S.some((R) => K0("afterHandle", R)), error: j || S.some((R) => K0("error", R)) }, P = W.trace.length > 0;
  let F = "";
  if (P)
    F += "\nconst id = c.$$requestId\n";
  F += j ? "try {\n" : "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((R) => R.toString()) : [], I = N || Y !== "GET" && Y !== "HEAD" && W.type !== "none" && (!!X.body || !!W.type || w.some((R) => K0("body", R))), G = N || X.headers || w.some((R) => K0("headers", R)), k = N || X.cookie || w.some((R) => K0("cookie", R)), _ = X?.cookie?.schema;
  let e = "";
  if (_?.sign) {
    if (!_.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const R = !_.secrets ? undefined : typeof _.secrets === "string" ? _.secrets : _.secrets[0];
    if (e += `const _setCookie = c.set.cookie
		if(_setCookie) {`, _.sign === true)
      e += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = signCookie(cookie.value, '${R}')
			}`;
    else
      for (let f of _.sign)
        e += `if(_setCookie['${f}']?.value) { c.set.cookie['${f}'].value = signCookie(_setCookie['${f}'].value, '${R}') }\n`;
    e += "}\n";
  }
  const { composeValidation: o, composeResponseValidation: r } = B7(j);
  if (G)
    F += A7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (k) {
    const R = (i, n) => {
      const q0 = _?.[i] ?? n;
      if (!q0)
        return typeof n === "string" ? `${i}: "${n}",` : `${i}: ${n},`;
      if (typeof q0 === "string")
        return `${i}: '${q0}',`;
      if (q0 instanceof Date)
        return `${i}: new Date(${q0.getTime()}),`;
      return `${i}: ${q0},`;
    }, f = _ ? `{
			secret: ${_.secrets !== undefined ? typeof _.secrets === "string" ? `'${_.secrets}'` : "[" + _.secrets.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			sign: ${_.sign === true ? true : _.sign !== undefined ? "[" + _.sign.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			${R("domain")}
			${R("expires")}
			${R("httpOnly")}
			${R("maxAge")}
			${R("path", "/")}
			${R("priority")}
			${R("sameSite")}
			${R("secure")}
		}` : "undefined";
    if (G)
      F += `\nc.cookie = parseCookie(c.set, c.headers.cookie, ${f})\n`;
    else
      F += `\nc.cookie = parseCookie(c.set, c.request.headers.get('cookie'), ${f})\n`;
  }
  if (N || X.query || w.some((R) => K0("query", R)))
    F += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const E0 = W.trace.map((R) => R.toString()).some((R) => K0("set", R) || w$(R));
  N || W.trace.some((R) => K0("set", R.toString()));
  const H0 = E0 || k || w.some((R) => K0("set", R)) || U.some((R) => K0("set", R.toString())), z0 = uW({ hasTrace: P, hasTraceSet: E0, condition: O, addFn: (R) => {
    F += R;
  } });
  if (P)
    F += "\nconst traceDone = new Promise(r => { reporter.once(`res${id}`, r) })\n";
  const u0 = I || E0 || N0(Z) || W.parse.length > 0 || W.afterHandle.some(N0) || W.beforeHandle.some(N0) || W.transform.some(N0), a0 = z0("parse", { unit: W.parse.length });
  if (I) {
    const R = D7(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            F += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            F += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            F += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            F += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            F += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        F += "}}";
    } else {
      const i = (() => {
        if (W.parse.length && R && !Array.isArray(W.type)) {
          const n = X?.body?.schema;
          switch (R) {
            case "object":
              if (o$("File", n) || o$("Files", n))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (i)
        F += i;
      else {
        if (F += "\n", F += G ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", F += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          F += "let used = false\n";
          const n = z0("parse", { unit: W.parse.length });
          for (let q0 = 0;q0 < W.parse.length; q0++) {
            const B0 = z0("parse.unit", { name: W.parse[q0].name }), D0 = `bo${q0}`;
            if (q0 !== 0)
              F += "if(!used) {\n";
            if (F += `let ${D0} = parse[${q0}](c, contentType)\n`, F += `if(${D0} instanceof Promise) ${D0} = await ${D0}\n`, F += `if(${D0} !== undefined) { c.body = ${D0}; used = true }\n`, B0(), q0 !== 0)
              F += "}";
          }
          n();
        }
        if (W.parse.length)
          F += "if (!used)";
        F += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, F += "}\n";
      }
    }
    F += "\n";
  }
  if (a0(), W?.transform) {
    const R = z0("transform", { unit: W.transform.length });
    for (let f = 0;f < W.transform.length; f++) {
      const i = W.transform[f], n = z0("transform.unit", { name: i.name });
      if (i.$elysia === "derive")
        F += N0(W.transform[f]) ? `Object.assign(c, await transform[${f}](c));` : `Object.assign(c, transform[${f}](c));`;
      else
        F += N0(W.transform[f]) ? `await transform[${f}](c);` : `transform[${f}](c);`;
      n();
    }
    R();
  }
  if (X) {
    if (F += "\n", X.headers) {
      if (F += `if(headers.Check(c.headers) === false) {
				${o("headers")}
			}`, b1(X.headers.schema))
        F += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (F += `if(params.Check(c.params) === false) {
				${o("params")}
			}`, b1(X.params.schema))
        F += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (F += `if(query.Check(c.query) === false) {
				${o("query")} 
			}`, b1(X.query.schema))
        F += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (F += `if(body.Check(c.body) === false) { 
				${o("body")}
			}`, b1(X.body.schema))
        F += "\nc.body = body.Decode(c.body)\n";
    }
    if (t0(X.cookie?.schema.properties ?? {})) {
      if (F += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${o("cookie", "cookieValue")}
			}`, b1(X.cookie.schema))
        F += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const R = z0("beforeHandle", { unit: W.beforeHandle.length });
    for (let f = 0;f < W.beforeHandle.length; f++) {
      const i = z0("beforeHandle.unit", { name: W.beforeHandle[f].name }), n = `be${f}`;
      if (!D$(W.beforeHandle[f].toString()))
        F += N0(W.beforeHandle[f]) ? `await beforeHandle[${f}](c);\n` : `beforeHandle[${f}](c);\n`, i();
      else {
        F += N0(W.beforeHandle[f]) ? `let ${n} = await beforeHandle[${f}](c);\n` : `let ${n} = beforeHandle[${f}](c);\n`, i(), F += `if(${n} !== undefined) {\n`;
        const B0 = z0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const D0 = n;
          for (let w0 = 0;w0 < W.afterHandle.length; w0++) {
            const M0 = D$(W.afterHandle[w0].toString()), B1 = z0("afterHandle.unit", { name: W.afterHandle[w0].name });
            if (F += `c.response = ${D0}\n`, !M0)
              F += N0(W.afterHandle[w0]) ? `await afterHandle[${w0}](c, ${D0});\n` : `afterHandle[${w0}](c, ${D0});\n`;
            else {
              const K = `af${w0}`;
              F += N0(W.afterHandle[w0]) ? `const ${K} = await afterHandle[${w0}](c);\n` : `const ${K} = afterHandle[${w0}](c);\n`, F += `if(${K} !== undefined) { c.response = ${D0} = ${K} }\n`;
            }
            B1();
          }
        }
        if (B0(), X.response)
          F += r(n);
        F += e, F += `return mapEarlyResponse(${n}, c.set)}\n`;
      }
    }
    R();
  }
  if (W?.afterHandle.length) {
    const R = z0("handle", { name: Z.name });
    if (W.afterHandle.length)
      F += N0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    R();
    const f = z0("afterHandle", { unit: W.afterHandle.length });
    for (let i = 0;i < W.afterHandle.length; i++) {
      const n = `af${i}`, q0 = D$(W.afterHandle[i].toString()), B0 = z0("afterHandle.unit", { name: W.afterHandle[i].name });
      if (!q0)
        F += N0(W.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`, B0();
      else {
        if (X.response)
          F += N0(W.afterHandle[i]) ? `let ${n} = await afterHandle[${i}](c)\n` : `let ${n} = afterHandle[${i}](c)\n`;
        else
          F += N0(W.afterHandle[i]) ? `let ${n} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${n} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
        if (B0(), X.response)
          F += `if(${n} !== undefined) {`, F += r(n), F += `${n} = mapEarlyResponse(${n}, c.set)\n`, F += `if(${n}) {`, f(), F += `return ${n} } }`;
        else
          F += `if(${n}) {`, f(), F += `return ${n}}\n`;
      }
    }
    if (f(), F += "r = c.response\n", X.response)
      F += r();
    if (F += e, H0)
      F += "return mapResponse(r, c.set)\n";
    else
      F += "return mapCompactResponse(r)\n";
  } else {
    const R = z0("handle", { name: Z.name });
    if (X.response)
      if (F += N0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", R(), F += r(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else if (O.handle || k)
      if (F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", R(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else {
      R();
      const f = N0(Z) ? "await handler(c) " : "handler(c)";
      if (z0("afterHandle")(), H0)
        F += `return mapResponse(${f}, c.set)\n`;
      else
        F += `return mapCompactResponse(${f})\n`;
    }
  }
  if (j || b) {
    if (F += `
} catch(error) {`, !u0)
      F += "return (async () => {";
    F += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const R = z0("error", { unit: W.error.length });
    if (W.error.length)
      for (let f = 0;f < W.error.length; f++) {
        const i = `er${f}`, n = z0("error.unit", { name: W.error[f].name });
        if (F += `\nlet ${i} = handleErrors[${f}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, N0(W.error[f]))
          F += `if (${i} instanceof Promise) ${i} = await ${i}\n`;
        n(), F += `${i} = mapEarlyResponse(${i}, set)\n`, F += `if (${i}) {`, F += `return ${i} }\n`;
      }
    if (R(), F += "return handleError(c, error)\n\n", !u0)
      F += "})()";
    if (F += "}", b || P) {
      F += " finally { ";
      const f = z0("response", { unit: W.onResponse.length });
      F += b, f(), F += "}";
    }
  }
  return F = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		reporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((R, f) => `res${f} = onResponse[${f}]`).join(",")}` : ""}

	return ${u0 ? "async" : ""} function(c) {
		${z && J ? "c.schema = schema; c.defs = definitions;" : ""}
		${F}
	}`, Function("hooks", F)({ handler: Z, hooks: W, validator: X, handleError: Q, utils: { mapResponse: A1, mapCompactResponse: K1, mapEarlyResponse: r0, parseQuery: pW.parse }, error: { NotFoundError: S1, ValidationError: P0, InternalServerError: f$ }, schema: z, definitions: J, ERROR_CODE: n1, reporter: B, requestId: mW, parseCookie: h$, signCookie: I1 });
};
var w6 = ($) => {
  let Y = "", W = "";
  for (let j of Object.keys($.decorators))
    Y += `,${j}: app.decorators.${j}`;
  const { router: X, staticRouter: Z } = $, Q = $.event.trace.length > 0, J = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let z = "";
  for (let [j, { code: b, all: S }] of Object.entries(Z.map))
    z += `case '${j}':\nswitch(request.method) {\n${b}\n${S ?? "default: break map"}}\n\n`;
  const U = $.event.request.some(N0);
  W += `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		reporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${U ? "async" : ""} function map(request) {
	`;
  const D = $.event.trace.map((j) => j.toString()), B = uW({ hasTrace: Q, hasTraceSet: $.event.trace.some((j) => {
    const b = j.toString();
    return K0("set", b) || w$(b);
  }), condition: { request: D.some((j) => K0("request", j) || w$(j)) }, addFn: (j) => {
    W += j;
  } });
  if ($.event.request.length) {
    W += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const j = B("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let b = 0;b < $.event.request.length; b++) {
      const S = $.event.request[b], N = D$(S.toString()), O = N0(S), P = B("request.unit", { name: $.event.request[b].name }), F = `re${b}`;
      if (N)
        W += `const ${F} = mapEarlyResponse(
					${O ? "await" : ""} onRequest[${b}](ctx),
					ctx.set
				)\n`, P(), W += `if(${F}) return ${F}\n`;
      else
        W += `${O ? "await" : ""} onRequest[${b}](ctx)\n`, P();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, j(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Y}
		}`, B("request", { unit: $.event.request.length, attribute: D.some((j) => K0("context", j)) || D.some((j) => K0("store", j)) || D.some((j) => K0("set", j)) ? "ctx" : "" })();
  return W += `
		map: switch(path) {
			${z}

			default:
				break
		}

		${J}
	}`, $.handleError = K6($), Function("data", W)({ app: $, mapEarlyResponse: r0, NotFoundError: S1, reporter: $.reporter, requestId: mW });
};
var K6 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(N0) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${N0(X) ? "await " : ""}onError[${W}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (D$(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) return mapResponse(r${W}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: A1, ERROR_CODE: n1 });
};
var n$ = Q1(B6(), 1);
var j6 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, Q = Z.indexOf("/", 11), J = Z.indexOf("?", Q + 1), z = J === -1 ? Z.substring(Q) : Z.substring(Q, J);
  try {
    for (let P = 0;P < $.event.request.length; P++) {
      const F = $.event.request[P];
      let w = F(X);
      if (w instanceof Promise)
        w = await w;
      if (w = r0(w, W), w)
        return w;
    }
    const U = $.dynamicRouter.find(Y.method, z) ?? $.dynamicRouter.find("ALL", z);
    if (!U)
      throw new S1;
    const { handle: D, hooks: B, validator: j, content: b } = U.store;
    let S;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (b)
        switch (b) {
          case "application/json":
            S = await Y.json();
            break;
          case "text/plain":
            S = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            S = n$.parse(await Y.text());
            break;
          case "application/octet-stream":
            S = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            S = {};
            const P = await Y.formData();
            for (let F of P.keys()) {
              if (S[F])
                continue;
              const w = P.getAll(F);
              if (w.length === 1)
                S[F] = w[0];
              else
                S[F] = w;
            }
            break;
        }
      else {
        let P = Y.headers.get("content-type");
        if (P) {
          const F = P.indexOf(";");
          if (F !== -1)
            P = P.slice(0, F);
          for (let w = 0;w < $.event.parse.length; w++) {
            let I = $.event.parse[w](X, P);
            if (I instanceof Promise)
              I = await I;
            if (I) {
              S = I;
              break;
            }
          }
          if (S === undefined)
            switch (P) {
              case "application/json":
                S = await Y.json();
                break;
              case "text/plain":
                S = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                S = n$.parse(await Y.text());
                break;
              case "application/octet-stream":
                S = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                S = {};
                const w = await Y.formData();
                for (let I of w.keys()) {
                  if (S[I])
                    continue;
                  const G = w.getAll(I);
                  if (G.length === 1)
                    S[I] = G[0];
                  else
                    S[I] = G;
                }
                break;
            }
        }
      }
    X.body = S, X.params = U?.params || undefined, X.query = J === -1 ? {} : n$.parse(Z.substring(J + 1)), X.headers = {};
    for (let [P, F] of Y.headers.entries())
      X.headers[P] = F;
    const N = j?.cookie?.schema;
    X.cookie = h$(X.set, X.headers.cookie, N ? { secret: N.secrets !== undefined ? typeof N.secrets === "string" ? N.secrets : N.secrets.join(",") : undefined, sign: N.sign === true ? true : N.sign !== undefined ? typeof N.sign === "string" ? N.sign : N.sign.join(",") : undefined } : undefined);
    for (let P = 0;P < B.transform.length; P++) {
      const F = B.transform[P](X);
      if (B.transform[P].$elysia === "derive")
        if (F instanceof Promise)
          Object.assign(X, await F);
        else
          Object.assign(X, F);
      else if (F instanceof Promise)
        await F;
    }
    if (j) {
      if (j.headers) {
        const P = {};
        for (let F in Y.headers)
          P[F] = Y.headers.get(F);
        if (j.headers.Check(P) === false)
          throw new P0("header", j.headers, P);
      }
      if (j.params?.Check(X.params) === false)
        throw new P0("params", j.params, X.params);
      if (j.query?.Check(X.query) === false)
        throw new P0("query", j.query, X.query);
      if (j.cookie) {
        const P = {};
        for (let [F, w] of Object.entries(X.cookie))
          P[F] = w.value;
        if (j.cookie?.Check(P) === false)
          throw new P0("cookie", j.cookie, P);
      }
      if (j.body?.Check(S) === false)
        throw new P0("body", j.body, S);
    }
    for (let P = 0;P < B.beforeHandle.length; P++) {
      let F = B.beforeHandle[P](X);
      if (F instanceof Promise)
        F = await F;
      if (F !== undefined) {
        X.response = F;
        for (let I = 0;I < B.afterHandle.length; I++) {
          let G = B.afterHandle[I](X);
          if (G instanceof Promise)
            G = await G;
          if (G)
            F = G;
        }
        const w = r0(F, X.set);
        if (w)
          return w;
      }
    }
    let O = D(X);
    if (O instanceof Promise)
      O = await O;
    if (!B.afterHandle.length) {
      const P = j?.response?.[O.status];
      if (P?.Check(O) === false)
        throw new P0("response", P, O);
    } else {
      X.response = O;
      for (let P = 0;P < B.afterHandle.length; P++) {
        let F = B.afterHandle[P](X);
        if (F instanceof Promise)
          F = await F;
        const w = r0(F, X.set);
        if (w !== undefined) {
          const I = j?.response?.[O.status];
          if (I?.Check(w) === false)
            throw new P0("response", I, w);
          return w;
        }
      }
    }
    if (X.set.cookie && N?.sign) {
      const P = !N.secrets ? undefined : typeof N.secrets === "string" ? N.secrets : N.secrets[0];
      if (N.sign === true)
        for (let [F, w] of Object.entries(X.set.cookie))
          X.set.cookie[F].value = I1(w.value, "${secret}");
      else
        for (let F of N.sign) {
          if (!(F in N.properties))
            continue;
          if (X.set.cookie[F]?.value)
            X.set.cookie[F].value = I1(X.set.cookie[F].value, P);
        }
    }
    return A1(O, X.set);
  } catch (U) {
    if (U.status)
      W.status = U.status;
    return $.handleError(X, U);
  } finally {
    for (let U of $.event.onResponse)
      await U(X);
  }
};
var oW = ($) => async (Y, W) => {
  const X = Object.assign(Y, W);
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z](X);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return A1(Q, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var G1 = Q1(E$(), 1);
var Y0 = Q1(f0(), 1);
try {
  G1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), G1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), G1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), G1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var nW = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P6 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < nW($.minSize))
    return false;
  if ($.maxSize && Y.size > nW($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var K7 = G1.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return P6($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!P6($, Y[W]))
      return false;
  return true;
});
Y0.FormatRegistry.Set("numeric", ($) => !isNaN(+$));
Y0.FormatRegistry.Set("ObjectString", ($) => {
  let Y = $.charCodeAt(0);
  if (Y === 9 || Y === 10 || Y === 32)
    Y = $.trimStart().charCodeAt(0);
  if (Y !== 123 && Y !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var R1 = { Numeric: ($) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "numeric", default: 0 }), Y0.Type.Number($)])).Decode((Y) => {
  const W = +Y;
  if (isNaN(W))
    return Y;
  return W;
}).Encode((Y) => Y), ObjectString: ($, Y) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "ObjectString", default: "" }), Y0.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: G1.TypeSystem.Type("File", P6), Files: ($ = {}) => Y0.Type.Transform(Y0.Type.Union([K7($)])).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => Y0.Type.Union([Y0.Type.Null(), $]), MaybeEmpty: ($) => Y0.Type.Union([Y0.Type.Null(), Y0.Type.Undefined(), $]), Cookie: ($, Y) => Y0.Type.Object($, Y) };
Y0.Type.ObjectString = R1.ObjectString;
Y0.Type.Numeric = R1.Numeric;
Y0.Type.File = ($ = {}) => R1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
Y0.Type.Files = ($ = {}) => R1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
Y0.Type.Nullable = ($) => R1.Nullable($);
Y0.Type.MaybeEmpty = R1.MaybeEmpty;
Y0.Type.Cookie = R1.Cookie;

class c$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new R6;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new E1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  dynamicRouter = new E1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let J of Y) {
      if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix && !Q)
        J = this.config.prefix + J;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const z = this.definitions.type;
      let U = X1(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: z, additionalProperties: true });
      if (t0(this.config.cookie ?? {}))
        if (U)
          U.schema = DW(U.schema, this.config.cookie ?? {});
        else
          U = X1(Y0.Type.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: z, additionalProperties: true });
      const D = { body: X1(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: z }), headers: X1(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: z, additionalProperties: true }), params: X1(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: z }), query: X1(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: z }), cookie: U, response: q6(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: z }) }, B = C1(this.event, X), j = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J, { validator: D, hooks: B, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, j, { validator: D, hooks: B, content: X?.type, handle: W });
        this.routes.push({ method: $, path: J, composed: null, handler: W, hooks: B });
        return;
      }
      const b = hW({ path: J, method: $, hooks: B, validator: D, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, reporter: this.reporter }), S = this.routes.findIndex((N) => N.path === J && N.method === $);
      if (S !== -1)
        this.routes.splice(S, 1);
      if (this.routes.push({ method: $, path: J, composed: b, handler: W, hooks: B }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
        const N = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(b), this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`, !this.staticRouter.map[J])
          this.staticRouter.map[J] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J].all = `default: return st${N}(ctx)\n`;
        else
          this.staticRouter.map[J].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[J].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[j])
            this.staticRouter.map[j] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[j].all = `default: return st${N}(ctx)\n`;
          else
            this.staticRouter.map[j].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[j].code}`;
        }
      } else if (this.router.add($, J, b), !this.config.strictPath)
        this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", b);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _6(this.reporter, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[n1] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[n1] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = wW(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new c$({ ...this.config, prefix: "" });
    X.store = this.store;
    const Z = typeof Y === "object", Q = (Z ? W : Y)(X);
    if (this.decorators = U1(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    return this.model(Q.definitions.type), Object.values(X.routes).forEach(({ method: J, path: z, handler: U, hooks: D }) => {
      if (z = (Z ? "" : this.config.prefix) + $ + z, Z) {
        const B = Y, j = D;
        this.add(J, z, U, C1(B, { ...j, error: !j.error ? Q.event.error : Array.isArray(j.error) ? [...j.error, ...Q.event.error] : [j.error, ...Q.event.error] }));
      } else
        this.add(J, z, U, C1(D, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = m$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new c$;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = U1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: Q, handler: J, hooks: z }) => {
      this.add(Z, Q, J, C1($, { ...z, error: !z.error ? X.event.error : Array.isArray(z.error) ? [...z.error, ...X.event.error] : [z.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q) => {
          if (typeof Q === "function")
            return Q(this);
          if (typeof Q.default === "function")
            return Q.default(this);
          return this._use(Q);
        }).then((Q) => Q.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config;
    $.getServer = () => this.getServer();
    const X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Q = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((J) => Q === J))
          return this;
        this.dependencies[Y].push(Q);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Q) => {
        Object.assign(Q, this.decorators), Object.assign(Q.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const Z = this.mount($.fetch);
      return this.routes = this.routes.concat(Z.routes), this;
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q, handler: J, hooks: z } of Object.values($.routes))
      this.add(Z, Q, J, C1(z, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z), this.event = m$(this.event, N6($.event), Z);
      } else
        this.event = m$(this.event, N6($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, Q = async ({ request: J, path: z }) => Z(new Request("http://a.cc" + z || "/", J));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: Q }) => Y(new Request("http://a.cc" + Q.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    let X = null;
    const Z = X1(Y?.body, { models: this.definitions.type }), Q = X1(Y?.response, { models: this.definitions.type }), J = (z) => {
      const U = z.charCodeAt(0);
      if (U === 47 || U === 123)
        try {
          z = JSON.parse(z);
        } catch {
        }
      else if (!Number.isNaN(+z))
        z = +z;
      if (W?.length)
        for (let D = 0;D < W.length; D++) {
          const B = W[D](z);
          if (B !== undefined)
            z = B;
        }
      return z;
    };
    return this.get($, (z) => {
      const { set: U, path: D, qi: B, headers: j, query: b, params: S } = z;
      if (X === null)
        X = this.getServer();
      if (X?.upgrade(z.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(z) : Y.upgrade, data: { validator: Q, open(N) {
        Y.open?.(new c1(N, z));
      }, message: (N, O) => {
        const P = J(O);
        if (Z?.Check(P) === false)
          return void N.send(new P0("message", Z, P).message);
        Y.message?.(new c1(N, z), P);
      }, drain(N) {
        Y.drain?.(new c1(N, z));
      }, close(N, O, P) {
        Y.close?.(new c1(N, z), O, P);
      } } }))
        return;
      return U.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = U1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = U1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (U) => U[0].toUpperCase() + U.slice(1), Q = $ === "prefix" ? (U, D) => X.includes(U.at(-1) ?? "") ? U + D : U + Z(D) : X.includes(W.at(-1) ?? "") ? (U, D) => D + U : (U, D) => D + Z(U), J = (U) => {
      const D = {};
      switch (U) {
        case "decorator":
          for (let B in this.decorators)
            D[Q(W, B)] = this.decorators[B];
          this.decorators = D;
          break;
        case "state":
          for (let B in this.store)
            D[Q(W, B)] = this.store[B];
          this.store = D;
          break;
        case "model":
          for (let B in this.definitions.type)
            D[Q(W, B)] = this.definitions.type[B];
          this.definitions.type = D;
          break;
        case "error":
          for (let B in this.definitions.error)
            D[Q(W, B)] = this.definitions.error[B];
          this.definitions.error = D;
          break;
      }
    }, z = Array.isArray(Y) ? Y : [Y];
    for (let U of z.some((D) => D === "all") ? ["decorator", "state", "model", "error"] : z)
      J(U);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? w6(this) : j6(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w6(this) : j6(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? K6(this) : oW(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !q$, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W6 }, fetch: W, error: this.outerErrorHandler } : { development: !q$, ...this.config.serve, websocket: { ...this.config.websocket, ...W6 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X), this.event.start.length)
      (async () => {
        const Z = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Q = 0;Q < this.event.transform.length; Q++) {
          const J = this.event.transform[Q](Z);
          if (this.event.transform[Q].$elysia === "derive")
            if (J instanceof Promise)
              Object.assign(Z, await J);
            else
              Object.assign(Z, J);
        }
        for (let Q = 0;Q < this.event.start.length; Q++)
          this.event.start[Q](Z);
      })();
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      (async () => {
        const $ = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Y = 0;Y < this.event.transform.length; Y++) {
          const W = this.event.transform[Y]($);
          if (this.event.transform[Y].$elysia === "derive")
            if (W instanceof Promise)
              Object.assign($, await W);
            else
              Object.assign($, W);
        }
        for (let Y = 0;Y < this.event.stop.length; Y++)
          this.event.stop[Y]($);
      })();
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = Y0.Type;

// /Users/richardguerre/Projects/flow/node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: "*",
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: false,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
  const app = new c$({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart === -1)
          return false;
        return origin2 === from.slice(protocolStart + 3);
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set, request) => {
    if (origin === true) {
      set.headers["Vary"] = "*";
      set.headers["Access-Control-Allow-Origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value = processOrigin(origins[i], request, from);
        if (value === true) {
          set.headers["Vary"] = origin ? "Origin" : "*";
          set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") ?? "*";
          return;
        }
        if (value)
          headers.push(value);
      }
    }
    set.headers["Vary"] = "Origin";
    set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set) => {
    if (!methods?.length)
      return;
    if (methods === "*")
      return set.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set.headers["Access-Control-Allow-Methods"] = methods;
    set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  return app.onRequest(({ set, request }) => {
    handleOrigin(set, request);
    handleMethod(set);
    if (allowedHeaders.length)
      set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
    if (exposedHeaders.length)
      set.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
    if (credentials)
      set.headers["Access-Control-Allow-Credentials"] = "true";
  });
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 6,
  patch: 0,
  preReleaseTag: null
});
// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === undefined ? undefined : value.then) === "function";
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp = /\r\n|[\n\r]/g;

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0;i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
var printPrefixedLines = function(lines) {
  const existingLines = lines.filter(([_, line]) => line !== undefined);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/error/GraphQLError.mjs
var toNormalizedOptions = function(args) {
  const firstArg = args[0];
  if (firstArg == null || ("kind" in firstArg) || ("length" in firstArg)) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
};
var undefinedIfEmpty = function(array) {
  return array === undefined || array.length === 0 ? undefined : array;
};
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== undefined ? path : undefined;
    this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
    this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
    this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== undefined && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location3 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location3);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}

class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}

class Token {
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0;i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent = leadingWhitespace(line);
    if (indent === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent < commonIndent) {
      commonIndent = indent;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
};
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0;i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
var isUnicodeScalarValue = function(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
};
var isSupplementaryCodePoint = function(body, location3) {
  return isLeadingSurrogate(body.charCodeAt(location3)) && isTrailingSurrogate(body.charCodeAt(location3 + 1));
};
var isLeadingSurrogate = function(code) {
  return code >= 55296 && code <= 56319;
};
var isTrailingSurrogate = function(code) {
  return code >= 56320 && code <= 57343;
};
var printCodePointAt = function(lexer, location3) {
  const code = lexer.source.body.codePointAt(location3);
  if (code === undefined) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? "'\"'" : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
};
var createToken = function(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
};
var readNextToken = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
};
var readComment = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
};
var readNumber = function(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
};
var readDigits = function(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
};
var readString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readEscapedUnicodeVariableWidth = function(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
};
var readEscapedUnicodeFixedWidth = function(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
};
var read16BitHexCode = function(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
};
var readHexDigit = function(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
};
var readEscapedCharacter = function(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: `\r`,
        size: 2
      };
    case 116:
      return {
        value: "\t",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
};
var readBlockString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readName = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
};

class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
var formatValue = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
};
var formatObjectValue = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
};
var isJSONable = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = function instanceOf3(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (typeof value === "object" && value !== null) {
    var _value$constructor;
    const className = constructor.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}

class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/parser.mjs
function parse(source2, options) {
  const parser = new Parser(source2, options);
  return parser.parseDocument();
}
var getTokenDesc = function(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
};
var getTokenKindDesc = function(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
};

class Parser {
  constructor(source2, options = {}) {
    const sourceObj = isSource(source2) ? source2 : new Source(source2);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
      }
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS = 5;

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var isDigit2 = function(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
};
var DIGIT_0 = 48;
var DIGIT_9 = 57;

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== undefined) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
var stringToArray = function(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0;i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return;
    }
    const rows = this._rows;
    for (let j = 0;j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1;i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1;j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : undefined;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedReplacer = function(str) {
  return escapeSequences[str.charCodeAt(0)];
};
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = new Map;
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = undefined;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = undefined;
  let parent = undefined;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === undefined) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== undefined) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== undefined);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(undefined);
    const leaveList = new Array(visitors.length).fill(undefined);
    for (let i = 0;i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: undefined
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK = Object.freeze({});

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/printer.mjs
function print(ast4) {
  return visit(ast4, printDocASTReducer);
}
var join2 = function(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
};
var block = function(array) {
  return wrap("{\n", indent(join2(array, "\n")), "\n}");
};
var wrap = function(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
};
var indent = function(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
};
var hasMultilineItems = function(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
};
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2([
        node.operation,
        join2([node.name, varDefs]),
        join2(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join2(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join2([
      "...",
      wrap("on ", typeCondition),
      join2(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join2(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join2(["schema", join2(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join2(["scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join2([
      "type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type + wrap(" ", join2(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join2([name + ": " + type, wrap("= ", defaultValue), join2(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join2([
      "interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join2(["union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join2(["enum", name, join2(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join2([name, join2(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join2(["input", name, join2(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join2([
      "extend union",
      name,
      join2(directives, " "),
      wrap("= ", join2(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block(fields)], " ")
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind.VARIABLE:
      return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1;i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var defineInterfaces = function(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
};
var defineFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
var isPlainObj = function(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
};
var fieldsToFieldsConfig = function(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
};
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === undefined;
}
var defineTypes = function(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
  return types;
};
var didYouMeanEnumValue = function(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
};
var defineEnumValues = function(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== undefined ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
};
var defineInputFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === undefined;
}

class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);
    config.serialize == null || typeof config.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLEnumType {
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === undefined) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({
      description: value.description,
      value: value.value,
      deprecationReason: value.deprecationReason,
      extensions: value.extensions,
      astNode: value.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(undefined, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
var serializeObject = function(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
};
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
        nodes: valueNode
      });
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}

class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(false, `@${config.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === undefined) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => ("name" in type) ? type.name : undefined
    },
    description: {
      type: GraphQLString,
      resolve: (type) => ("description" in type) ? type.description : undefined
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => ("ofType" in type) ? type.ofType : undefined
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: undefined,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: undefined,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
var collectReferencedTypes = function(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
};

class GraphQLSchema {
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : undefined;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect(config.types)}.`);
    !config.directives || Array.isArray(config.directives) || devAssert(false, '"directives" must be Array if provided but got: ' + `${inspect(config.directives)}.`);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = Object.create(null);
    this._subTypeMap = Object.create(null);
    this._implementationsMap = Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(false, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== undefined) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== undefined ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === undefined) {
      map = Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== undefined;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== undefined
    };
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/type/validate.mjs
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  const context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema2.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema2) {
  const errors = validateSchema(schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var validateRootTypes = function(context) {
  const schema2 = context.schema;
  const queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema2, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema2, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema2, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
};
var getOperationTypeNode = function(schema2, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap((schemaNode) => {
    var _schemaNode$operation;
    return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
};
var validateDirectives = function(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
        ]);
      }
    }
  }
};
var validateName = function(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
  }
};
var validateTypes = function(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
};
var validateFields = function(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
        ]);
      }
    }
  }
};
var validateInterfaces = function(context, type) {
  const ifaceTypeNames = Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (type === iface) {
      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
};
var validateTypeImplementsInterface = function(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
      ]);
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
        ]);
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
      }
    }
  }
};
var validateTypeImplementsAncestors = function(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
        ...getAllImplementsInterfaceNodes(iface, transitive),
        ...getAllImplementsInterfaceNodes(type, iface)
      ]);
    }
  }
};
var validateUnionMembers = function(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
  }
  const includedTypeNames = Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
};
var validateEnumValues = function(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
};
var validateInputFields = function(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
      ]);
    }
  }
};
var createInputObjectCircularRefsValidator = function(context) {
  const visitedTypes = Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === undefined) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = undefined;
  }
};
var getAllImplementsInterfaceNodes = function(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
};
var getUnionMemberTypeNodes = function(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
  }).filter((typeNode) => typeNode.name.value === typeName);
};
var getDeprecatedDirectiveNode = function(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);
};

class SchemaValidationContext {
  constructor(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(new GraphQLError(message, {
      nodes: _nodes
    }));
  }
  getErrors() {
    return this._errors;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema2, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema2.getType(typeNode.name.value);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/TypeInfo.mjs
var getFieldDef = function(schema2, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
};
function visitWithTypeInfo(typeInfo, visitor3) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor3, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor3, args);
        if (result !== undefined) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor3, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor3, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

class TypeInfo {
  constructor(schema2, initialType, getFieldDefFn) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema2 = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema2.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(undefined);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition10 of node.definitions) {
        if (!isExecutableDefinitionNode(definition10)) {
          const defName = definition10.kind === Kind.SCHEMA_DEFINITION || definition10.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition10.name.value + '"';
          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, {
            nodes: definition10
          }));
        }
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema2 = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema2, type, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
            nodes: node
          }));
        }
      }
    }
  };
}
var getSuggestedTypeNames = function(schema2, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = new Set;
  const usageCount = Object.create(null);
  for (const possibleType of schema2.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
};
var getSuggestedFieldNames = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
            nodes: typeCondition
          }));
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
          nodes: node.typeCondition
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), {
          nodes: argNode
        }));
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), {
              nodes: argNode
            }));
          }
        }
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(new GraphQLError(`Unknown directive "@${name}".`, {
          nodes: node
        }));
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
          nodes: node
        }));
      }
    }
  };
}
var getDirectiveLocationForASTPath = function(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  ("kind" in appliedTo) || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      ("kind" in parentNode) || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
};
var getDirectiveLocationForOperation = function(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, {
          nodes: node.name
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypesMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _12, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), {
          nodes: node
        }));
      }
    }
  };
}
var isSDLNode = function(value) {
  return ("kind" in value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
};
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type) => type.name);

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter((definition12) => definition12.kind === Kind.OPERATION_DEFINITION).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", {
          nodes: node
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", {
          nodes: node
        }));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", {
          nodes: node
        }));
      }
      ++schemaDefinitionsCount;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === undefined) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
          nodes: cyclePath
        }));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = undefined;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "\$${varName}" is not defined.`, {
              nodes: [node, operation]
            }));
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, {
              nodes: fragmentDef
            }));
          }
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "\$${variableName}" is never used.`, {
              nodes: variableDef
            }));
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
var sortFields = function(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
var reasonMessage = function(reason) {
  if (Array.isArray(reason)) {
    return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
  }
  return reason;
};
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet;
  const cachedFieldsAndFragmentNames = new Map;
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
          nodes: fields1.concat(fields2)
        }));
      }
    }
  };
}
var findConflictsWithinSelectionSet = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (let i = 0;i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (let j = i + 1;j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
};
var collectConflictsBetweenFieldsAndFragment = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
      continue;
    }
    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
  }
};
var collectConflictsBetweenFragments = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
  }
};
var findConflictsBetweenSubSelectionSets = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
    }
  }
  return conflicts;
};
var collectConflictsWithin = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0;i < fields.length; i++) {
        for (let j = i + 1;j < fields.length; j++) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var collectConflictsBetween = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var findConflict = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
  const type2 = def2 === null || def2 === undefined ? undefined : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(type2)}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
};
var stringifyArguments = function(fieldNode) {
  var _fieldNode$arguments;
  const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== undefined ? _fieldNode$arguments : [];
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
};
var doTypesConflict = function(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
};
var getFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = Object.create(null);
  const fragmentNames = Object.create(null);
  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
};
var getReferencedFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
};
var _collectFieldsAndFragmentNames = function(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
};
var subfieldConflicts = function(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
};

class PairSet {
  constructor() {
    this._data = new Map;
  }
  has(a, b, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(key2);
    if (result === undefined) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a, b, areMutuallyExclusive) {
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const map = this._data.get(key1);
    if (map === undefined) {
      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    }
  };
}
var getFragmentType = function(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema2 = context.getSchema();
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema2 === null || schema2 === undefined ? undefined : schema2.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
          nodes: defNode ? [defNode, node] : node
        }));
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema2 === null || schema2 === undefined ? undefined : schema2.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
        nodes: node.name
      }));
    }
  }
}
var typeToExtKind = function(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
};
var extensionKindToTypeName = function(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
};
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
              nodes: fieldNode
            }));
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === undefined ? undefined : schema2.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), (arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                nodes: directiveNode
              }));
            }
          }
        }
      }
    }
  };
}
var isRequiredArgumentNode = function(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
              nodes: selectionSet
            }));
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
            nodes: node
          }));
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, undefined);
}
var defaultOnError = function(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
};
var coerceInputValueImpl = function(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect(type)}" not to be null.`));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, undefined);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}" to be an object.`));
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === undefined) {
        if (field.defaultValue !== undefined) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}". ` + error.message, {
          originalError: error
        }));
      }
      return;
    }
    if (parseResult === undefined) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}".`));
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === undefined) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === undefined) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === undefined) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === undefined) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === undefined) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var isMissingVariable = function(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", {
          nodes: node
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: valueNode
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", {
        nodes: valueNode
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw new GraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: valueNode
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
var hasOwnProperty = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/execution/collectFields.mjs
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new Map;
  collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
  return fields;
}
function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new Map;
  const visitedFragmentNames = new Set;
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
var collectFieldsImpl = function(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== undefined) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
};
var shouldIncludeNode = function(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return false;
  }
  return true;
};
var doesFragmentConditionMatch = function(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema2.isSubType(conditionalType, type);
  }
  return false;
};
var getFieldEntryKey = function(node) {
  return node.alias ? node.alias.value : node.name.value;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema2 = context.getSchema();
        const subscriptionType = schema2.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = Object.create(null);
          const document2 = context.getDocument();
          const fragments = Object.create(null);
          for (const definition21 of document2.definitions) {
            if (definition21.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition21.name.value] = definition21;
            }
          }
          const fields = collectFields(schema2, fragments, variableValues, subscriptionType, node.selectionSet);
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
              nodes: extraFieldSelections
            }));
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                nodes: fieldNodes
              }));
            }
          }
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = new Map;
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === undefined) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema2 !== null && schema2 !== undefined && schema2.getDirective(directiveName)) {
        context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
          nodes: node.name
        }));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
          nodes: [knownDirectiveNames[directiveName], node.name]
        }));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = Object.create(null);
  const typeDirectivesMap = Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === undefined) {
          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
        }
      } else {
        seenDirectives = Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
              nodes: [seenDirectives[directiveName], directive]
            }));
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: valueDef.name
        }));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
          nodes: [valueNames[valueName], valueDef.name]
        }));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: fieldDef.name
        }));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
          nodes: [fieldNames[fieldName], fieldDef.name]
        }));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
var hasField = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
          nodes: [knownFragmentNames[fragmentName], node.name]
        }));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, {
          nodes: [knownNames[fieldName], node.name]
        }));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
            nodes: [
              knownOperationNames[operationName.value],
              operationName
            ]
          }));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema2 = context.getSchema();
  const definedOperationTypes = Object.create(null);
  const existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
          nodes: operationType
        }));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, {
          nodes: [alreadyDefinedOperationType, operationType]
        }));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema2 !== null && schema2 !== undefined && schema2.getType(typeName)) {
      context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
        nodes: node.name
      }));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, {
        nodes: [knownTypeNames[typeName], node.name]
      }));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(new GraphQLError(`There can be only one variable named "\$${variableName}".`, {
            nodes: variableNodes.map((node) => node.variable.name)
          }));
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(new GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
            nodes: node
          }));
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), {
          nodes: node
        }));
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(new GraphQLError(`Expected value of type "${inspect(type)}", found ${print(node)}.`, {
          nodes: node
        }));
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
var isValidValueNode = function(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
      nodes: node
    }));
    return;
  }
  try {
    const parseResult = type.parseLiteral(node, undefined);
    if (parseResult === undefined) {
      const typeStr = inspect(locationType);
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
        nodes: node
      }));
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}; ` + error.message, {
        nodes: node,
        originalError: error
      }));
    }
  }
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== undefined && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(new GraphQLError(`Variable "\$${variableName}" cannot be non-input type "${typeName}".`, {
          nodes: node.type
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema2 = context.getSchema();
            const varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(schema2, varType, varDef.defaultValue, type, defaultValue)) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(new GraphQLError(`Variable "\$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                nodes: [varDef, node]
              }));
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
var allowedVariableUsage = function(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== undefined;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/ValidationContext.mjs
class ASTValidationContext {
  constructor(ast8, onError) {
    this._ast = ast8;
    this._fragments = undefined;
    this._fragmentSpreads = new Map;
    this._recursivelyReferencedFragments = new Map;
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}

class SDLValidationContext extends ASTValidationContext {
  constructor(ast8, schema2, onError) {
    super(ast8, onError);
    this._schema = schema2;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}

class ValidationContext extends ASTValidationContext {
  constructor(schema2, ast8, typeInfo, onError) {
    super(ast8, onError);
    this._schema = schema2;
    this._typeInfo = typeInfo;
    this._variableUsages = new Map;
    this._recursiveVariableUsages = new Map;
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: () => false,
        Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/validation/validate.mjs
function validate2(schema2, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema2)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema2);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(schema2, documentAST, typeInfo, (error) => {
    if (errors.length >= maxErrors) {
      errors.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors.push(error);
  });
  const visitor5 = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor5));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === undefined) {
      cache0 = new WeakMap;
    }
    let cache1 = cache0.get(a1);
    if (cache1 === undefined) {
      cache1 = new WeakMap;
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === undefined) {
      cache2 = new WeakMap;
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === undefined) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}

class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
var isLocatedGraphQLError = function(error) {
  return Array.isArray(error.path);
};

// /Users/richardguerre/Projects/flow/node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source2, args, contextValue, info) {
  if (isObjectLike(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition26 of documentAST.definitions) {
    if (definition26.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition26;
      } else if (((_definition$name = definition26.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
        return definition26;
      }
    }
  }
  return operation;
}
// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema3) {
  const schemaConfig = schema3.toConfig();
  const typeMap = keyValMap(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
var sortObjMap = function(map, sortValueFn) {
  const sortedMap = Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
};
var sortByName = function(array) {
  return sortBy(array, (obj) => obj.name);
};
var sortBy = function(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
};
// /Users/richardguerre/Projects/flow/node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema3) {
  return printFilteredSchema(schema3, (n) => !isSpecifiedDirective(n), isDefinedType);
}
var isDefinedType = function(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
};
var printFilteredSchema = function(schema3, directiveFilter, typeFilter) {
  const directives10 = schema3.getDirectives().filter(directiveFilter);
  const types = Object.values(schema3.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema3),
    ...directives10.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
};
var printSchemaDefinition = function(schema3) {
  if (schema3.description == null && isSchemaOfCommonNames(schema3)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema3.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema3) + `schema {\n${operationTypes.join("\n")}\n}`;
};
var isSchemaOfCommonNames = function(schema3) {
  const queryType = schema3.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema3.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
};
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
var printScalar = function(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
};
var printImplementedInterfaces = function(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
};
var printObject = function(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printInterface = function(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printUnion = function(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
};
var printEnum = function(type) {
  const values2 = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
  return printDescription(type) + `enum ${type.name}` + printBlock(values2);
};
var printInputObject = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
  return printDescription(type) + `input ${type.name}` + printBlock(fields);
};
var printFields = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
  return printBlock(fields);
};
var printBlock = function(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
};
var printArgs = function(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
};
var printInputValue = function(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
};
var printDirective = function(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
};
var printDeprecated = function(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
};
var printSpecifiedByURL = function(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
};
var printDescription = function(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString4 = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString4.replace(/\n/g, "\n" + indentation) + "\n";
};
// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/errors.js
var isGraphQLErrorLike = function(error) {
  return error != null && typeof error === "object" && Object.keys(error).every((key) => possibleGraphQLErrorProperties.includes(key));
};
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/inspect.js
function inspect25(value) {
  return formatValue2(value, []);
}
var formatValue2 = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value, seenValues);
    default:
      return String(value);
  }
};
var formatError2 = function(value) {
  if (value instanceof GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};\n ${value.stack}`;
};
var formatObjectValue2 = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable2(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray2(value, seenValues);
  }
  return formatObject2(value, seenValues);
};
var isJSONable2 = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject2 = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray2 = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue2(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag2 = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_RECURSIVE_DEPTH2 = 3;

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject4(value) {
  return value != null && typeof value === "object" && (Symbol.iterator in value);
}
function isObjectLike10(value) {
  return typeof value === "object" && value !== null;
}
function isPromise3(value) {
  return value?.then != null;
}
function promiseReduce(values2, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values2) {
    accumulator = isPromise3(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues2(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== undefined) {
        coercedValues[name] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect25(argType)}" ` + "was not provided.", {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect25(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect25(argType)}" ` + "must not be null.", {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = new WeakMap;
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === undefined) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize33(fn) {
  const memoize3Cache = new WeakMap;
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize3Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const newValue = fn(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = new WeakMap;
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize5Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const cache42 = new WeakMap;
      cache32.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const cache42 = new WeakMap;
      cache3.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = new WeakMap;
      cache3.set(a3, cache4);
      const cache52 = new WeakMap;
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = new WeakMap;
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema3, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema3);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema3) {
  const rootTypes = getRootTypes(schema3);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema3) {
  const rootTypeMap = getRootTypeMap(schema3);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema3) {
  const rootTypeMap = new Map;
  const queryType = schema3.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema3.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema3.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator, callback, rejectCallback) {
  let $return;
  let abruptClose;
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => Promise.reject(error);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (rejectCallback) {
    const reject = rejectCallback;
    mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      return Promise.reject(error).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var asyncMapValue = function(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
};
var iteratorResult = function(value) {
  return { value, done: false };
};

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
class AccumulatorMap extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === undefined) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/directives.js
var GraphQLDeferDirective = new GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FIELD],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/collectFields.js
var collectFieldsImpl2 = function(schema3, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey2(selection), selection);
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema3, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch2(schema3, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
};
function collectFields4(schema3, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap;
  const patches = [];
  collectFieldsImpl2(schema3, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set);
  return { fields, patches };
}
function shouldIncludeNode2(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch2(schema3, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema3, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema3.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey2(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : undefined
  };
}
var collectSubFields = memoize5(function collectSubfields3(schema3, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap;
  const visitedFragmentNames = new Set;
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl2(schema3, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value) {
  return value?.[Symbol.asyncIterator] != null;
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/utils/esm/Path.js
function addPath2(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray2(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray3(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/error.js
var isAggregateError = function(obj) {
  return obj != null && typeof obj === "object" && ("errors" in obj);
};
var hasToString = function(obj) {
  return obj != null && typeof obj.toString === "function";
};
function isGraphQLError(val) {
  return val instanceof GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error, maskedErrorsOpts, logger) {
  const errors3 = new Set;
  if (isAggregateError(error)) {
    for (const singleError of error.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors3.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error) {
      logger.error(error);
    }
    errors3.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error)) {
    errors3.add(error);
  } else if (error instanceof Error) {
    errors3.add(createGraphQLError(error.message, {
      originalError: error
    }));
  } else if (typeof error === "string") {
    errors3.add(createGraphQLError(error, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error)) {
    errors3.add(createGraphQLError(error.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error);
    errors3.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors3);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if (("extensions" in result) && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if (("errors" in result) && result.errors?.length) {
    for (const error of result.errors) {
      if (error.extensions?.http) {
        if (error.extensions.http.headers) {
          Object.assign(headers, error.extensions.http.headers);
        }
        if (isApplicationJson && error.extensions.http.spec) {
          continue;
        }
        if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
          status = error.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.some(isGraphQLError);
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = "<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\"https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/yoga-graphiql.es.js\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>";

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
function useGraphiQL(config) {
  const logger = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || url.pathname === config.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse(response);
        }
      }
    }
  };
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-schema.js
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema3;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema3 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema3) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema3);
      }
    };
  }
  const schemaByRequest = new WeakMap;
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema3 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema3);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema3 = schemaByRequest.get(context.request);
      if (schema3 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema3);
    }
  };
};

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = new WeakMap;

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/utils.js
var getSubscribeArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
};
function mapAsyncIterator2(source2, mapper) {
  const iterator = source2[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: undefined, done: true };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error;
    }
  };
  return stream;
}
var getExecuteArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
};
function isAsyncIterable2(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable2(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return;
}
function finalAsyncIterator(source2, onFinal) {
  const iterator = source2[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source2, onError) {
  const iterator = source2[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error) {
        onError(error);
        return { done: true, value: undefined };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/orchestrator.js
var throwEngineFunctionError = function(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
};
function createEnvelopOrchestrator({ plugins }) {
  let schema3 = null;
  let initDone = false;
  const parse2 = () => throwEngineFunctionError("parse");
  const validate3 = () => throwEngineFunctionError("validate");
  const execute2 = () => throwEngineFunctionError("execute");
  const subscribe2 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema3 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema3,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin] of plugins.entries()) {
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        plugins.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source2, parseOptions) => {
    let result = null;
    let parseFn = parse2;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source: source2, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source2, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source2.toString());
    return result;
  } : () => parse2;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema4, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : undefined;
    let validateFn = validate3;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema4,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema4, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate3;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe2;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await subscribeFn({
        ...args,
        contextValue: context
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable2(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error,
            setError: (err2) => {
              error = err2;
            }
          });
        }
        throw error;
      });
    }
    return result;
  }) : makeSubscribe(subscribe2);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute2;
    let result;
    const afterCalls = [];
    const context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute2);
  initDone = true;
  if (schema3) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema3,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema3;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/create.js
var notEmpty = function(value) {
  return value != null;
};
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator2 = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator2;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/plugins/use-masked-errors.js
function isGraphQLError2(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError2(error) {
  if (isGraphQLError2(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError2(error.originalError);
    }
    return true;
  }
  return false;
}
var createSerializableGraphQLError = function(message, originalError, isDev) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError(error, message));
        }
      };
    }
  };
}
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var createDefaultMaskError = (isDev) => (error, message) => {
  if (isOriginalGraphQLError2(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError(error, message)) });
  }
};

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// /Users/richardguerre/Projects/flow/node_modules/value-or-promise/build/module/ValueOrPromise.js
var isPromiseLike = function(object) {
  return object != null && typeof object.then === "function";
};
var defaultOnRejectedFn = (reason) => {
  throw reason;
};

class ValueOrPromise {
  state;
  constructor(executor) {
    let value;
    try {
      value = executor();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike(value)) {
      this.state = { status: "pending", value };
      return;
    }
    this.state = { status: "fulfilled", value };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
      return onFulfilledFn === undefined ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e) {
      return new ValueOrPromise(() => onRejectedFn(e));
    }
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let rejected = false;
    let reason;
    let containsPromise = false;
    const values2 = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        if (rejected) {
          continue;
        }
        rejected = true;
        reason = state.value;
        continue;
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values2.push(state.value);
    }
    if (containsPromise) {
      if (rejected) {
        Promise.all(values2).catch(() => {
        });
        return new ValueOrPromise(() => {
          throw reason;
        });
      }
      return new ValueOrPromise(() => Promise.all(values2));
    }
    return new ValueOrPromise(() => values2);
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: undefined, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = undefined;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = undefined;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: undefined, done: true };
    },
    async throw(error) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant12(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object, signal) {
  const resolvedObject = Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      resolve();
    });
    Promise.all(Object.entries(object).map(async ([key, value]) => {
      resolvedObject[key] = await value;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/values.js
function getVariableValues2(schema3, varDefNodes, inputs, options) {
  const errors3 = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema3, varDefNodes, inputs, (error) => {
      if (maxErrors != null && errors3.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors3.push(error);
    });
    if (errors3.length === 0) {
      return { coerced };
    }
  } catch (error) {
    errors3.push(error);
  }
  return { errors: errors3 };
}
var coerceVariableValues = function(schema3, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema3, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(createGraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty2(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect25(varType);
        onError(createGraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect25(varType);
      onError(createGraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error) => {
      let prefix = `Variable "\$${varName}" got invalid value ` + inspect25(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray3(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error.message, {
        nodes: varDefNode,
        originalError: error.originalError
      }));
    });
  }
  return coercedValues;
};

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/execute.js
function execute2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
var executeImpl = function(exeContext) {
  return new ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error) => {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }).resolve();
};
var buildResponse = function(data, errors3) {
  return errors3.length === 0 ? { data } : { errors: errors3, data };
};
function buildExecutionContext(args) {
  const { schema: schema3, document: document2, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args;
  assertValidSchema(schema3);
  const fragments = getFragmentsFromDocument(document2);
  let operation;
  for (const definition28 of document2.definitions) {
    switch (definition28.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== undefined) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition28;
        } else if (definition28.name?.value === operationName) {
          operation = definition28;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues2(schema3, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema3,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver2,
    typeResolver: typeResolver ?? defaultTypeResolver2,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver2,
    subsequentPayloads: new Set,
    errors: [],
    signal
  };
}
var buildPerEventExecutionContext = function(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: new Set,
    errors: []
  };
};
var executeOperation = function(exeContext) {
  const { operation, schema: schema3, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema3, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields4(schema3, fragments, variableValues, rootType, operation.selectionSet);
  const path = undefined;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
};
var executeFieldsSerially = function(exeContext, parentType, sourceValue, path, fields) {
  let abortErrorThrown = false;
  return promiseReduce(fields, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath2(path, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      results[responseName] = null;
      return results;
    }
    return new ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray2(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
      return results;
    });
  }, Object.create(null)).resolve();
};
var executeFields = function(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {
  const results = Object.create(null);
  let containsPromise = false;
  let abortErrorThrown = false;
  try {
    for (const [responseName, fieldNodes] of fields) {
      if (exeContext.signal?.aborted) {
        results[responseName] = null;
        continue;
      }
      const fieldPath = addPath2(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== undefined) {
        results[responseName] = result;
        if (isPromise3(result)) {
          containsPromise = true;
        }
      }
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray2(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
};
var executeField = function(exeContext, parentType, source2, fieldNodes, path, asyncPayloadRecord) {
  const errors3 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source2, args, contextValue, info);
    let completed;
    if (isPromise3(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise3(completed)) {
      return completed.then(undefined, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(path));
        const handledError = handleFieldError(error, returnType, errors3);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(path));
    const handledError = handleFieldError(error, returnType, errors3);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
};
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
var handleFieldError = function(error, returnType, errors3) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  errors3.push(error);
  return null;
};
var completeValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect25(returnType));
};
var getStreamValues = function(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant12(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant12(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : undefined
  };
};
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator.return?.();
    exeContext.errors.push(createGraphQLError("Execution aborted", {
      nodes: fieldNodes,
      path: pathToArray2(path),
      originalError: exeContext.signal?.reason
    }));
  });
  const errors3 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath2(path, index, undefined);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
      completedResults.push(handleFieldError(error, itemType, errors3));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors3, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
var completeListValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors3 = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject4(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath2(path, index, undefined);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors3, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
};
var completeListItemValue = function(item, completedResults, errors3, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise3(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise3(completedItem)) {
      completedResults.push(completedItem.then(undefined, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, errors3);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const handledError = handleFieldError(error, itemType, errors3);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
};
var completeLeafValue = function(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect25(returnType)}.serialize(${inspect25(result)})\` to ` + `return non-nullable value, returned: ${inspect25(serializedResult)}`);
  }
  return serializedResult;
};
var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise3(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
};
var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (isObjectType(runtimeTypeName)) {
    throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect25(result)}, received "${inspect25(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
};
var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise3(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
};
var invalidReturnTypeError = function(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect25(result)}.`, {
    nodes: fieldNodes
  });
};
var collectAndExecuteSubfields = function(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields4(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
};
function subscribe2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise3(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults, signal) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  signal?.addEventListener("abort", () => {
    done = true;
    subsequentIterator.throw?.(signal?.reason);
  });
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: undefined,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error) {
      done = true;
      return subsequentIterator.throw(error);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult, signal) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult, signal);
  } else {
    yield someExecutionResult;
  }
}
var mapSourceToResponse = function(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream[Symbol.asyncIterator](), async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload)), exeContext.signal), async function* (error) {
    const wrappedError = createGraphQLError(error.message, {
      originalError: error,
      nodes: [exeContext.operation]
    });
    yield {
      errors: [wrappedError]
    };
  }));
};
var createSourceEventStreamImpl = function(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise3(eventStream)) {
      return eventStream.then(undefined, (error) => ({ errors: [error] }));
    }
    return eventStream;
  } catch (error) {
    return { errors: [error] };
  }
};
var executeSubscription = function(exeContext) {
  const { schema: schema3, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema3.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields4(schema3, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef2(schema3, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path = addPath2(undefined, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise3(result)) {
      return result.then(assertEventStream).then(undefined, (error) => {
        throw locatedError(error, fieldNodes, pathToArray2(path));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray2(path));
  }
};
var assertEventStream = function(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError("Subscription field must return Async Iterable. " + `Received: ${inspect25(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
};
var executeDeferredFragment = function(exeContext, parentType, sourceValue, fields, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);
    if (isPromise3(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
};
var executeStreamField = function(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise3(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise3(completedItem)) {
        completedItem = completedItem.then(undefined, (rawError) => {
          const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
          const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
      completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error) {
    asyncPayloadRecord.errors.push(error);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise3(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error) => {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
};
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: undefined };
    }
    item = value;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise3(completedItem)) {
      completedItem = completedItem.then(undefined, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? undefined;
  while (true) {
    const itemPath = addPath2(path, index, undefined);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error) {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise3(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error) => {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
var filterSubsequentPayloads = function(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray2(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0;i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
};
var getCompletedIncrementalResults = function(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
};
var yieldSubsequentPayloads = function(exeContext) {
  let isDone = false;
  async function next() {
    if (isDone) {
      return { value: undefined, done: true };
    }
    await Promise.race(Array.from(exeContext.subsequentPayloads).map((p) => p.promise));
    if (isDone) {
      return { value: undefined, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: undefined, done: true };
    },
    async throw(error) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error);
    }
  };
};
var isStreamPayload = function(asyncPayload) {
  return asyncPayload.type === "stream";
};
function getFieldDef2(schema3, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema3.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema3.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields4 = memoize33((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document2) {
  const fragments = Object.create(null);
  for (const definition28 of document2.definitions) {
    if (definition28.kind === Kind.FRAGMENT_DEFINITION) {
      fragments[definition28.name.value] = definition28;
    }
  }
  return fragments;
});
var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
  if (isObjectLike10(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise3(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver2 = function(source2, args, contextValue, info) {
  if (isObjectLike10(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};

class DeferredFragmentRecord {
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
}

class StreamRecord {
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
function normalizedExecutor(args) {
  const operationAST = getOperationAST(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe2(args);
  }
  return new ValueOrPromise(() => execute2(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result, args.signal);
    }
    return result;
  }).resolve();
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill = {};
__export(exports_node_ponyfill, {
  fetch: () => {
    {
      return $fetch;
    }
  },
  crypto: () => {
    {
      return $crypto;
    }
  },
  createFetch: () => {
    {
      return $createFetch;
    }
  },
  btoa: () => {
    {
      return $btoa;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern;
    }
  },
  URL: () => {
    {
      return $URL;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder;
    }
  },
  Response: () => {
    {
      return $Response;
    }
  },
  Request: () => {
    {
      return $Request;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream;
    }
  },
  Headers: () => {
    {
      return $Headers;
    }
  },
  FormData: () => {
    {
      return $FormData;
    }
  },
  File: () => {
    {
      return $File;
    }
  },
  Blob: () => {
    {
      return $Blob;
    }
  }
});
var createNodePonyfill = require_create_node_ponyfill();
var ponyfills = createNodePonyfill();
if (!globalThis.Deno && !process.versions.bun) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || import.meta.require(nodelibcurlName);
  } catch (e) {
  }
}
var $fetch = ponyfills.fetch;
var $Headers = ponyfills.Headers;
var $Request = ponyfills.Request;
var $Response = ponyfills.Response;
var $FormData = ponyfills.FormData;
var $ReadableStream = ponyfills.ReadableStream;
var $WritableStream = ponyfills.WritableStream;
var $TransformStream = ponyfills.TransformStream;
var $Blob = ponyfills.Blob;
var $File = ponyfills.File;
var $crypto = ponyfills.crypto;
var $btoa = ponyfills.btoa;
var $TextEncoder = ponyfills.TextEncoder;
var $TextDecoder = ponyfills.TextDecoder;
var $URLPattern = ponyfills.URLPattern;
var $URL = ponyfills.URL;
var $URLSearchParams = ponyfills.URLSearchParams;
var $createFetch = createNodePonyfill;

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/utils.js
function isAsyncIterable3(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
var getPort = function(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
};
var getHostnameWithPort = function(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
};
var buildFullUrl = function(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || "http";
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
};
var isRequestBody = function(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable3(body)) {
    return true;
  }
  return false;
};
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new $URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  const signal = new ServerAdapterRequestAbortSignal;
  if (rawRequest.once) {
    rawRequest.once("end", () => signal.sendAbort());
    rawRequest.once("close", () => signal.sendAbort());
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: nodeRequest.headers,
    body: rawRequest,
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
var configureSocket = function(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
};
var endResponse = function(serverResponse) {
  serverResponse.end(null, null, null);
};
async function sendAsyncIterable(serverResponse, asyncIterable) {
  for await (const chunk of asyncIterable) {
    if (!serverResponse.write(chunk)) {
      break;
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable3(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source2) => {
    const descriptors = Object.getOwnPropertyNames(source2).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source2, key);
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source2).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise4(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value, stopEarlyFn);
    if (isPromise4(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error, ResponseCtor) {
  return new ResponseCtor(error.stack || error.message || error.toString(), {
    status: error.status || 500
  });
}

class ServerAdapterRequestAbortSignal extends EventTarget {
  constructor() {
    super(...arguments);
    this.aborted = false;
    this._onabort = null;
  }
  throwIfAborted() {
    if (this.aborted) {
      throw new DOMException("Aborted", "AbortError");
    }
  }
  sendAbort() {
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("abort", value);
    } else {
      this.removeEventListener("abort", value);
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    body = new fetchAPI.ReadableStream({});
    const readable = body.readable;
    res.onAborted(() => {
      readable.push(null);
    });
    let multipleChunks = false;
    res.onData(function(ab, isLast) {
      const chunk = Buffer.from(ab, 0, ab.byteLength);
      if (!multipleChunks && isLast) {
        readable.push(chunk);
      } else {
        readable.push(Buffer.from(chunk));
      }
      if (isLast) {
        readable.push(null);
      }
      multipleChunks = true;
    });
  }
  const headers = new fetchAPI.Headers;
  req.forEach((key, value) => {
    headers.set(key, value);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal: new ServerAdapterRequestAbortSignal
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse) {
  let resAborted = false;
  uwsResponse.onAborted(function() {
    resAborted = true;
  });
  for await (const chunk of fetchResponse.body) {
    if (resAborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse);
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  const waitUntils = await Promise.allSettled(waitUntilPromises);
  waitUntils.forEach((waitUntil) => {
    if (waitUntil.status === "rejected") {
      console.error(waitUntil.reason);
    }
  });
}
var isRequestAccessible = function(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
};
var addWaitUntil = function(serverContext, waitUntilPromises) {
  serverContext["waitUntil"] = function(promise) {
    if (promise != null) {
      waitUntilPromises.push(promise);
    }
  };
};
var createServerAdapter = function(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...exports_node_ponyfill,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onRequestHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise4(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise4(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise4(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function requestListener(nodeRequest, serverResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: serverResponse
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    let response$;
    try {
      response$ = handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => sendNodeResponse(response, serverResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, serverResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    const serverContext = ctx.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI
    });
    let resAborted = false;
    res.onAborted(() => {
      resAborted = true;
      request.signal.sendAbort();
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => {
        if (!resAborted) {
          return sendResponseToUwsOpts(res, response);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendResponseToUwsOpts(res, response$);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const serverContext = ctx.length > 0 ? Object.assign({}, event, ...ctx) : event;
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const serverContext = (ctx.length > 1 ? completeAssign(...ctx) : ctx[0]) || {};
    if (serverContext.waitUntil == null) {
      const waitUntilPromises = [];
      addWaitUntil(serverContext, waitUntilPromises);
      const response$ = handleRequest(request, serverContext);
      if (waitUntilPromises.length > 0) {
        return handleWaitUntils(waitUntilPromises).then(() => response$);
      }
      return response$;
    }
    return handleRequest(request, serverContext);
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || ("href" in input)) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
      }
      return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
    }
    return handleRequestWithWaitUntil(input, ...maybeCtx);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest,
    fetch: fetchFn,
    handleNodeRequest,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    has: (_, prop) => {
      return (prop in adapterObj) || (prop in genericRequestHandler) || serverAdapterBaseObject && (prop in serverAdapterBaseObject);
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
};
var EMPTY_OBJECT = {};

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      }
      headers["Vary"] = "Access-Control-Request-Headers";
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
function createDefaultErrorHandler(ResponseCtor = $Response) {
  return function defaultErrorHandler(e) {
    if (e.details || e.status || e.headers || e.name === "HTTPError") {
      return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.message, {
        status: e.status,
        headers: e.headers || {}
      });
    }
    console.error(e);
    return ResponseCtor.error();
  };
}
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
        try {
          const response$ = requestHandler(request, serverContext);
          if (isPromise4(response$)) {
            return response$.catch((e) => errorHandler(e, request, serverContext));
          }
          return response$;
        } catch (e) {
          return errorHandler(e, request, serverContext);
        }
      });
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || undefined;
  const query = searchParams.get("query") || undefined;
  const variablesStr = searchParams.get("variables") || undefined;
  const extensionsStr = searchParams.get("extensions") || undefined;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : undefined,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new $URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new $URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// /Users/richardguerre/Projects/flow/node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map;
    try {
      map = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map) {
      const file = requestBody.get(fileIndex);
      const keys = map[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
var extendedTypeof = function(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
};
var isObject = function(val) {
  return extendedTypeof(val) === "object";
};
var expectedParameters = new Set(["query", "variables", "operationName", "extensions"]);

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error of result) {
            error.extensions.http = {
              ...error.extensions.http,
              spec: error.extensions.http?.spec ?? true,
              status: error.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
function assertMutationViaGet(method, document2, operationName) {
  const operation = document2 ? getOperationAST(document2, operationName) ?? undefined : undefined;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (ttl === 0 || start === 0) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined && (allowStale || !this.#isStale(index))) {
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#next[this.#prev[index]] = this.#next[index];
            this.#prev[this.#next[index]] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/utils/create-lru-cache.js
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 3600000;

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document2 = documentCache.get(strDocument);
      if (document2) {
        setParsedDocument(document2);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema3, documentAST, rules },
      setResult
    }) {
      if (schema3 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = new WeakMap;
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema3);
        if (!validationCacheByDocument) {
          validationCacheByDocument = new WeakMap;
          validationCacheBySchema.set(schema3, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-request-parser.js
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}
var DEFAULT_MATCHER = () => true;

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : undefined;
    }
    return newResult;
  }
  return result;
}
var omitInternalsFromError = function(err) {
  if (isGraphQLError(err)) {
    const serializedError = ("toJSON" in err) && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || undefined),
      extensions: Object.keys(extensions).length ? extensions : undefined
    });
  }
  return err;
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder;
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable2(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (value != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions.originalError || isGraphQLError(err.extensions.originalError)));
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12000;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder;
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable2(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode(`event: next\n`));
          const chunk = jsonStringifyResultWithoutInternals(value);
          controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete\n\n`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var getSSEProcessorConfig = function() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
};
function useResultProcessors() {
  const isSubscriptionRequestMap = new WeakMap;
  const sse2 = getSSEProcessorConfig();
  const defaultList = [sse2, multipart2, regular2];
  const subscriptionList = [sse2, regular2];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable2(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}
var multipart2 = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
var regular2 = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && url.pathname !== args.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/process-request.js
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document2 = enveloped.parse(params.query);
  const errors3 = enveloped.validate(enveloped.schema, document2);
  if (errors3.length > 0) {
    return { errors: errors3 };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document: document2,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = getOperationAST(document2, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error7, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error7)) {
    if (error7.originalError) {
      if (error7.originalError.name === "GraphQLError") {
        return error7;
      }
      const extensions = {
        ...error7.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error7.originalError.message,
          stack: error7.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error7.nodes,
        source: error7.source,
        positions: error7.positions,
        path: error7.path,
        extensions
      });
    }
    return error7;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error7 instanceof Error ? {
        message: error7.message,
        stack: error7.stack
      } : error7 : undefined
    }
  });
};

// /Users/richardguerre/Projects/flow/node_modules/graphql-yoga/esm/server.js
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

class YogaServer {
  constructor(options) {
    this.handle = async (request, serverContext) => {
      let url = new Proxy({}, {
        get: (_target, prop, _receiver) => {
          url = new this.fetchAPI.URL(request.url, "http://localhost");
          return Reflect.get(url, prop, url);
        }
      });
      let requestParser;
      const onRequestParseDoneList = [];
      for (const onRequestParse of this.onRequestParseHooks) {
        const onRequestParseResult = await onRequestParse({
          request,
          url,
          requestParser,
          serverContext,
          setRequestParser(parser) {
            requestParser = parser;
          }
        });
        if (onRequestParseResult?.onRequestParseDone != null) {
          onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
        }
      }
      this.logger.debug(`Parsing request to extract GraphQL parameters`);
      if (!requestParser) {
        return new this.fetchAPI.Response(null, {
          status: 415,
          statusText: "Unsupported Media Type"
        });
      }
      let requestParserResult = await requestParser(request);
      for (const onRequestParseDone of onRequestParseDoneList) {
        await onRequestParseDone({
          requestParserResult,
          setRequestParserResult(newParams) {
            requestParserResult = newParams;
          }
        });
      }
      const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
        params,
        request
      }, serverContext))) : this.getResultForParams({
        params: requestParserResult,
        request
      }, serverContext));
      return processResult({
        request,
        result,
        fetchAPI: this.fetchAPI,
        onResultProcessHooks: this.onResultProcessHooks
      });
    };
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...exports_node_ponyfill
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger2 = options?.logging == null ? true : options.logging;
    this.logger = typeof logger2 === "boolean" ? logger2 === true ? createLogger() : createLogger("silent") : typeof logger2 === "string" ? createLogger(logger2) : logger2;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = new WeakSet;
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error8, message) => {
        if (maskedErrorSet.has(error8)) {
          return error8;
        }
        const newError = maskErrorFn(error8, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error8) {
          this.logger.error(error8);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse,
        validate: validate2,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules
      }),
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      useResultProcessors(),
      useErrorHandling((error8, request) => {
        const errors3 = handleError(error8, this.maskedErrorsOpts, this.logger);
        const result = {
          errors: errors3
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache));
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(useUnhandledRoute({
            graphqlEndpoint,
            showLandingPage: options?.landingPage ?? true
          }));
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(useHTTPValidationError());
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const serverContext = args[0];
        const initialContext = {
          ...serverContext,
          request,
          params
        };
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error8) {
      const errors3 = handleError(error8, this.maskedErrorsOpts, this.logger);
      const result = {
        errors: errors3
      };
      return result;
    }
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@repeaterjs/repeater/repeater.js
var __extends = function(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : undefined, done: true };
  }
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
};
var swallow = function(value) {
  if (value != null && typeof value.then === "function") {
    value.then(NOOP, NOOP);
  }
};
var consumeExecution = function(r) {
  var err = r.err;
  var execution = Promise.resolve(r.execution).then(function(value) {
    if (err != null) {
      throw err;
    }
    return value;
  });
  r.err = undefined;
  r.execution = execution.then(function() {
    return;
  }, function() {
    return;
  });
  return r.pending === undefined ? execution : r.pending.then(function() {
    return execution;
  });
};
var createIteration = function(r, value) {
  var done = r.state >= Done;
  return Promise.resolve(value).then(function(value2) {
    if (!done && r.state >= Rejected) {
      return consumeExecution(r).then(function(value3) {
        return {
          value: value3,
          done: true
        };
      });
    }
    return { value: value2, done };
  });
};
var stop = function(r, err) {
  var e_1, _a;
  if (r.state >= Stopped) {
    return;
  }
  r.state = Stopped;
  r.onnext();
  r.onstop();
  if (r.err == null) {
    r.err = err;
  }
  if (r.pushes.length === 0 && (typeof r.buffer === "undefined" || r.buffer.empty)) {
    finish(r);
  } else {
    try {
      for (var _b = __values(r.pushes), _d = _b.next();!_d.done; _d = _b.next()) {
        var push_1 = _d.value;
        push_1.resolve();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
};
var finish = function(r) {
  var e_2, _a;
  if (r.state >= Done) {
    return;
  }
  if (r.state < Stopped) {
    stop(r);
  }
  r.state = Done;
  r.buffer = undefined;
  try {
    for (var _b = __values(r.nexts), _d = _b.next();!_d.done; _d = _b.next()) {
      var next = _d.value;
      var execution = r.pending === undefined ? consumeExecution(r) : r.pending.then(function() {
        return consumeExecution(r);
      });
      next.resolve(createIteration(r, execution));
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  r.pushes = [];
  r.nexts = [];
};
var reject = function(r) {
  if (r.state >= Rejected) {
    return;
  }
  if (r.state < Done) {
    finish(r);
  }
  r.state = Rejected;
};
var push = function(r, value) {
  swallow(value);
  if (r.pushes.length >= MAX_QUEUE_LENGTH) {
    throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
  } else if (r.state >= Stopped) {
    return Promise.resolve(undefined);
  }
  var valueP = r.pending === undefined ? Promise.resolve(value) : r.pending.then(function() {
    return value;
  });
  valueP = valueP.catch(function(err) {
    if (r.state < Stopped) {
      r.err = err;
    }
    reject(r);
    return;
  });
  var nextP;
  if (r.nexts.length) {
    var next_1 = r.nexts.shift();
    next_1.resolve(createIteration(r, valueP));
    if (r.nexts.length) {
      nextP = Promise.resolve(r.nexts[0].value);
    } else {
      nextP = new Promise(function(resolve) {
        return r.onnext = resolve;
      });
    }
  } else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
    r.buffer.add(valueP);
    nextP = Promise.resolve(undefined);
  } else {
    nextP = new Promise(function(resolve) {
      return r.pushes.push({ resolve, value: valueP });
    });
  }
  var floating = true;
  var next = {};
  var unhandled = nextP.catch(function(err) {
    if (floating) {
      throw err;
    }
    return;
  });
  next.then = function(onfulfilled, onrejected) {
    floating = false;
    return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
  };
  next.catch = function(onrejected) {
    floating = false;
    return Promise.prototype.catch.call(nextP, onrejected);
  };
  next.finally = nextP.finally.bind(nextP);
  r.pending = valueP.then(function() {
    return unhandled;
  }).catch(function(err) {
    r.err = err;
    reject(r);
  });
  return next;
};
var createStop = function(r) {
  var stop1 = stop.bind(null, r);
  var stopP = new Promise(function(resolve) {
    return r.onstop = resolve;
  });
  stop1.then = stopP.then.bind(stopP);
  stop1.catch = stopP.catch.bind(stopP);
  stop1.finally = stopP.finally.bind(stopP);
  return stop1;
};
var execute4 = function(r) {
  if (r.state >= Started) {
    return;
  }
  r.state = Started;
  var push1 = push.bind(null, r);
  var stop1 = createStop(r);
  r.execution = new Promise(function(resolve) {
    return resolve(r.executor(push1, stop1));
  });
  r.execution.catch(function() {
    return stop(r);
  });
};
var getIterators = function(values3, options) {
  var e_3, _a;
  var iters = [];
  var _loop_1 = function(value2) {
    if (value2 != null && typeof value2[Symbol.asyncIterator] === "function") {
      iters.push(value2[Symbol.asyncIterator]());
    } else if (value2 != null && typeof value2[Symbol.iterator] === "function") {
      iters.push(value2[Symbol.iterator]());
    } else {
      iters.push(function valueToAsyncIterator() {
        return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!options.yieldValues)
                  return [3, 3];
                return [4, __await(value2)];
              case 1:
                return [4, _a2.sent()];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (!options.returnValues)
                  return [3, 5];
                return [4, __await(value2)];
              case 4:
                return [2, _a2.sent()];
              case 5:
                return [2];
            }
          });
        });
      }());
    }
  };
  try {
    for (var values_1 = __values(values3), values_1_1 = values_1.next();!values_1_1.done; values_1_1 = values_1.next()) {
      var value = values_1_1.value;
      _loop_1(value);
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (values_1_1 && !values_1_1.done && (_a = values_1.return))
        _a.call(values_1);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  return iters;
};
var race = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, stopped, finalIteration, iteration, i_1, _loop_2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            iteration = undefined;
            i_1 = 0;
            _loop_2 = function() {
              var j, iters_1, iters_1_1, iter;
              var e_4, _a2;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    j = i_1;
                    try {
                      for (iters_1 = (e_4 = undefined, __values(iters)), iters_1_1 = iters_1.next();!iters_1_1.done; iters_1_1 = iters_1.next()) {
                        iter = iters_1_1.value;
                        Promise.resolve(iter.next()).then(function(iteration2) {
                          if (iteration2.done) {
                            stop2();
                            if (finalIteration === undefined) {
                              finalIteration = iteration2;
                            }
                          } else if (i_1 === j) {
                            i_1++;
                            advance(iteration2);
                          }
                        }, function(err) {
                          return stop2(err);
                        });
                      }
                    } catch (e_4_1) {
                      e_4 = { error: e_4_1 };
                    } finally {
                      try {
                        if (iters_1_1 && !iters_1_1.done && (_a2 = iters_1.return))
                          _a2.call(iters_1);
                      } finally {
                        if (e_4)
                          throw e_4.error;
                      }
                    }
                    return [4, new Promise(function(resolve) {
                      return advance = resolve;
                    })];
                  case 1:
                    iteration = _b.sent();
                    if (!(iteration !== undefined))
                      return [3, 3];
                    return [4, push2(iteration.value)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    return [2];
                }
              });
            };
            _a.label = 2;
          case 2:
            if (!!stopped)
              return [3, 4];
            return [5, _loop_2()];
          case 3:
            _a.sent();
            return [3, 2];
          case 4:
            return [2, finalIteration && finalIteration.value];
          case 5:
            stop2();
            return [4, Promise.race(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [7];
          case 7:
            return [2];
        }
      });
    });
  });
};
var merge = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { yieldValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advances, stopped, finalIteration;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_5, _a2;
              stopped = true;
              try {
                for (var advances_1 = __values(advances), advances_1_1 = advances_1.next();!advances_1_1.done; advances_1_1 = advances_1.next()) {
                  var advance = advances_1_1.value;
                  advance();
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (advances_1_1 && !advances_1_1.done && (_a2 = advances_1.return))
                    _a2.call(advances_1);
                } finally {
                  if (e_5)
                    throw e_5.error;
                }
              }
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, undefined, undefined, function() {
                var iteration, _a2;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, , 6, 9]);
                      _b.label = 1;
                    case 1:
                      if (!!stopped)
                        return [3, 5];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _b.sent();
                      if (!(iteration !== undefined))
                        return [3, 4];
                      if (iteration.done) {
                        finalIteration = iteration;
                        return [2];
                      }
                      return [4, push2(iteration.value)];
                    case 3:
                      _b.sent();
                      _b.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      _a2 = iter.return;
                      if (!_a2)
                        return [3, 8];
                      return [4, iter.return()];
                    case 7:
                      _a2 = _b.sent();
                      _b.label = 8;
                    case 8:
                      return [7];
                    case 9:
                      return [2];
                  }
                });
              });
            }))];
          case 2:
            _a.sent();
            return [2, finalIteration && finalIteration.value];
          case 3:
            stop2();
            return [7];
          case 4:
            return [2];
        }
      });
    });
  });
};
var zip = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, stopped, iterations, values3;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 6, 8]);
            _a.label = 2;
          case 2:
            if (!!stopped)
              return [3, 5];
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations2) {
              return advance(iterations2);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 3:
            iterations = _a.sent();
            if (iterations === undefined) {
              return [2];
            }
            values3 = iterations.map(function(iteration) {
              return iteration.value;
            });
            if (iterations.some(function(iteration) {
              return iteration.done;
            })) {
              return [2, values3];
            }
            return [4, push2(values3)];
          case 4:
            _a.sent();
            return [3, 2];
          case 5:
            return [3, 8];
          case 6:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 7:
            _a.sent();
            return [7];
          case 8:
            return [2];
        }
      });
    });
  });
};
var latest = function(contenders) {
  var _this = this;
  var iters = getIterators(contenders, {
    yieldValues: true,
    returnValues: true
  });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, undefined, undefined, function() {
      var advance, advances, stopped, iterations_1, values_2;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_6, _a2;
              advance();
              try {
                for (var advances_2 = __values(advances), advances_2_1 = advances_2.next();!advances_2_1.done; advances_2_1 = advances_2.next()) {
                  var advance1 = advances_2_1.value;
                  advance1();
                }
              } catch (e_6_1) {
                e_6 = { error: e_6_1 };
              } finally {
                try {
                  if (advances_2_1 && !advances_2_1.done && (_a2 = advances_2.return))
                    _a2.call(advances_2);
                } finally {
                  if (e_6)
                    throw e_6.error;
                }
              }
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations) {
              return advance(iterations);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 2:
            iterations_1 = _a.sent();
            if (iterations_1 === undefined) {
              return [2];
            }
            values_2 = iterations_1.map(function(iteration) {
              return iteration.value;
            });
            if (iterations_1.every(function(iteration) {
              return iteration.done;
            })) {
              return [2, values_2];
            }
            return [4, push2(values_2.slice())];
          case 3:
            _a.sent();
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, undefined, undefined, function() {
                var iteration;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (iterations_1[i].done) {
                        return [2, iterations_1[i].value];
                      }
                      _a2.label = 1;
                    case 1:
                      if (!!stopped)
                        return [3, 4];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        return advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _a2.sent();
                      if (iteration === undefined) {
                        return [2, iterations_1[i].value];
                      } else if (iteration.done) {
                        return [2, iteration.value];
                      }
                      values_2[i] = iteration.value;
                      return [4, push2(values_2.slice())];
                    case 3:
                      _a2.sent();
                      return [3, 1];
                    case 4:
                      return [2];
                  }
                });
              });
            }))];
          case 4:
            return [2, _a.sent()];
          case 5:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [7];
          case 7:
            return [2];
        }
      });
    });
  });
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
var RepeaterOverflowError = function(_super) {
  __extends(RepeaterOverflowError2, _super);
  function RepeaterOverflowError2(message) {
    var _this = _super.call(this, message) || this;
    Object.defineProperty(_this, "name", {
      value: "RepeaterOverflowError",
      enumerable: false
    });
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(_this, _this.constructor.prototype);
    } else {
      _this.__proto__ = _this.constructor.prototype;
    }
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(_this, _this.constructor);
    }
    return _this;
  }
  return RepeaterOverflowError2;
}(Error);
var FixedBuffer = function() {
  function FixedBuffer2(capacity) {
    if (capacity < 0) {
      throw new RangeError("Capacity may not be less than 0");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(FixedBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FixedBuffer2.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: false,
    configurable: true
  });
  FixedBuffer2.prototype.add = function(value) {
    if (this.full) {
      throw new Error("Buffer full");
    } else {
      this._q.push(value);
    }
  };
  FixedBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return FixedBuffer2;
}();
var SlidingBuffer = function() {
  function SlidingBuffer2(capacity) {
    if (capacity < 1) {
      throw new RangeError("Capacity may not be less than 1");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(SlidingBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SlidingBuffer2.prototype, "full", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  SlidingBuffer2.prototype.add = function(value) {
    while (this._q.length >= this._c) {
      this._q.shift();
    }
    this._q.push(value);
  };
  SlidingBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return SlidingBuffer2;
}();
var DroppingBuffer = function() {
  function DroppingBuffer2(capacity) {
    if (capacity < 1) {
      throw new RangeError("Capacity may not be less than 1");
    }
    this._c = capacity;
    this._q = [];
  }
  Object.defineProperty(DroppingBuffer2.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DroppingBuffer2.prototype, "full", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  DroppingBuffer2.prototype.add = function(value) {
    if (this._q.length < this._c) {
      this._q.push(value);
    }
  };
  DroppingBuffer2.prototype.remove = function() {
    if (this.empty) {
      throw new Error("Buffer empty");
    }
    return this._q.shift();
  };
  return DroppingBuffer2;
}();
var Initial = 0;
var Started = 1;
var Stopped = 2;
var Done = 3;
var Rejected = 4;
var MAX_QUEUE_LENGTH = 1024;
var NOOP = function() {
};
var records = new WeakMap;
var Repeater = function() {
  function Repeater2(executor2, buffer) {
    records.set(this, {
      executor: executor2,
      buffer,
      err: undefined,
      state: Initial,
      pushes: [],
      nexts: [],
      pending: undefined,
      execution: undefined,
      onnext: NOOP,
      onstop: NOOP
    });
  }
  Repeater2.prototype.next = function(value) {
    swallow(value);
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    if (r.nexts.length >= MAX_QUEUE_LENGTH) {
      throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
    }
    if (r.state <= Initial) {
      execute4(r);
    }
    r.onnext(value);
    if (typeof r.buffer !== "undefined" && !r.buffer.empty) {
      var result = createIteration(r, r.buffer.remove());
      if (r.pushes.length) {
        var push_2 = r.pushes.shift();
        r.buffer.add(push_2.value);
        r.onnext = push_2.resolve;
      }
      return result;
    } else if (r.pushes.length) {
      var push_3 = r.pushes.shift();
      r.onnext = push_3.resolve;
      return createIteration(r, push_3.value);
    } else if (r.state >= Stopped) {
      finish(r);
      return createIteration(r, consumeExecution(r));
    }
    return new Promise(function(resolve) {
      return r.nexts.push({ resolve, value });
    });
  };
  Repeater2.prototype.return = function(value) {
    swallow(value);
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    finish(r);
    r.execution = Promise.resolve(r.execution).then(function() {
      return value;
    });
    return createIteration(r, consumeExecution(r));
  };
  Repeater2.prototype.throw = function(err) {
    var r = records.get(this);
    if (r === undefined) {
      throw new Error("WeakMap error");
    }
    if (r.state <= Initial || r.state >= Stopped || typeof r.buffer !== "undefined" && !r.buffer.empty) {
      finish(r);
      if (r.err == null) {
        r.err = err;
      }
      return createIteration(r, consumeExecution(r));
    }
    return this.next(Promise.reject(err));
  };
  Repeater2.prototype[Symbol.asyncIterator] = function() {
    return this;
  };
  Repeater2.race = race;
  Repeater2.merge = merge;
  Repeater2.zip = zip;
  Repeater2.latest = latest;
  return Repeater2;
}();

// /Users/richardguerre/Projects/flow/node_modules/@whatwg-node/events/dist/node-ponyfill.js
var $CustomEvent = globalThis.CustomEvent;
if (!$CustomEvent) {
  $CustomEvent = class CustomEvent extends Event {
    constructor(type, options) {
      super(type, options);
      this.detail = options?.detail ?? null;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/subscription/esm/create-pub-sub.js
var createPubSub = (config) => {
  const target = config?.eventTarget ?? new EventTarget;
  return {
    publish(routingKey, ...args) {
      const payload = args[1] ?? args[0] ?? null;
      const topic = args[1] === undefined ? routingKey : `${routingKey}:${args[0]}`;
      const event = new $CustomEvent(topic, {
        detail: payload
      });
      target.dispatchEvent(event);
    },
    subscribe(...[routingKey, id]) {
      const topic = id === undefined ? routingKey : `${routingKey}:${id}`;
      return new Repeater(function subscriptionRepeater(next, stop2) {
        stop2.then(function subscriptionRepeaterStopHandler() {
          target.removeEventListener(topic, pubsubEventListener);
        });
        target.addEventListener(topic, pubsubEventListener);
        function pubsubEventListener(event) {
          next(event.detail);
        }
      });
    }
  };
};
// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/subscription/esm/operator/map.js
var map = (mapper) => (source2) => new Repeater(async (push2, stop2) => {
  const iterable = source2[Symbol.asyncIterator]();
  stop2.then(() => {
    iterable.return?.();
  });
  let latest2;
  while ((latest2 = await iterable.next()).done === false) {
    await push2(await mapper(latest2.value));
  }
  stop2();
});
// /Users/richardguerre/Projects/flow/node_modules/@graphql-yoga/subscription/esm/utils/pipe.js
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default:
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/builder.js
var _defineProperty22 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/build-cache.js
var _defineProperty9 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/errors.js
class PothosError extends Error {
  constructor(message) {
    super(message);
    this.name = "PothosError";
  }
}

class PothosSchemaError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosSchemaError";
  }
}

class PothosValidationError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosValidationError";
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/merge-plugins.js
var _defineProperty2 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/plugin.js
var _defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/context-cache.js
function createContextCache(create) {
  const cache = new WeakMap;
  return (context, ...args) => {
    const cacheKey = context[contextCacheSymbol] || context;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const entry = create(context, ...args);
    cache.set(cacheKey, entry);
    return entry;
  };
}
var contextCacheSymbol = Symbol.for("Pothos.contextCache");

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/plugin.js
var runCache = new WeakMap;

class BasePlugin {
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  beforeBuild() {
  }
  afterBuild(schema3) {
    return schema3;
  }
  wrapResolve(resolver, fieldConfig) {
    return resolver;
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return subscribe3;
  }
  wrapResolveType(resolveType, typeConfig) {
    return resolveType;
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, new Map);
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  createRequestData(context) {
    throw new PothosError("createRequestData not implemented");
  }
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    _defineProperty(this, "name", undefined);
    _defineProperty(this, "builder", undefined);
    _defineProperty(this, "buildCache", undefined);
    _defineProperty(this, "options", undefined);
    _defineProperty(this, "requestDataMap", createContextCache((ctx) => this.createRequestData(ctx)));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/plugins/merge-plugins.js
class MergedPlugins extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onTypeConfig(config), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onInputFieldConfig(config), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onOutputFieldConfig(config), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config, plugin2) => config === null ? config : plugin2.onEnumValueConfig(config), valueConfig);
  }
  beforeBuild() {
    for (const plugin2 of this.plugins) {
      plugin2.beforeBuild();
    }
  }
  afterBuild(schema3) {
    return this.plugins.reduceRight((nextSchema, plugin2) => plugin2.afterBuild(nextSchema), schema3);
  }
  wrapResolve(resolve, fieldConfig) {
    return this.plugins.reduceRight((nextResolve, plugin2) => plugin2.wrapResolve(nextResolve, fieldConfig), resolve);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return this.plugins.reduceRight((nextSubscribe, plugin2) => plugin2.wrapSubscribe(nextSubscribe, fieldConfig), subscribe3);
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin2) => plugin2.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin2) => plugin2.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin");
    _defineProperty2(this, "plugins", undefined);
    this.plugins = plugins;
  }
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/builtin-scalar.js
var _defineProperty5 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/scalar.js
var _defineProperty4 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/types/type-params.js
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/base.js
var _defineProperty3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

class BaseTypeRef {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  constructor(kind, name) {
    _defineProperty3(this, "kind", undefined);
    _defineProperty3(this, "name", undefined);
    this.kind = kind;
    this.name = name;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/scalar.js
var _outputShapeKey = outputShapeKey;
var _parentShapeKey = parentShapeKey;
var _inputShapeKey = inputShapeKey;

class ScalarRef extends BaseTypeRef {
  constructor(name) {
    super("Scalar", name);
    _defineProperty4(this, "kind", "Scalar");
    _defineProperty4(this, _outputShapeKey, undefined);
    _defineProperty4(this, _parentShapeKey, undefined);
    _defineProperty4(this, _inputShapeKey, undefined);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/builtin-scalar.js
class BuiltinScalarRef extends ScalarRef {
  constructor(type) {
    super(type.name);
    _defineProperty5(this, "type", undefined);
    this.type = type;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input-object.js
var _defineProperty6 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey2 = inputShapeKey;

class InputObjectRef extends BaseTypeRef {
  constructor(name) {
    super("InputObject", name);
    _defineProperty6(this, "kind", "InputObject");
    _defineProperty6(this, _inputShapeKey2, undefined);
  }
}
class ImplementableInputObjectRef extends InputObjectRef {
  implement(options) {
    this.builder.inputType(this, options);
    return this;
  }
  constructor(builder, name) {
    super(name);
    _defineProperty6(this, "builder", undefined);
    this.builder = builder;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input-list.js
var _defineProperty7 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey3 = inputShapeKey;

class InputObjectRef2 extends BaseTypeRef {
  constructor(listType, required) {
    super("InputList", `InputList<${String(listType)}>`);
    _defineProperty7(this, "kind", "InputList");
    _defineProperty7(this, _inputShapeKey3, undefined);
    _defineProperty7(this, "listType", undefined);
    _defineProperty7(this, "required", undefined);
    this.listType = listType;
    this.required = required;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/list.js
var _defineProperty8 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey2 = outputShapeKey;
var _parentShapeKey2 = parentShapeKey;

class ListRef extends BaseTypeRef {
  constructor(listType, nullable) {
    super("List", `List<${String(listType)}>`);
    _defineProperty8(this, "kind", "List");
    _defineProperty8(this, _outputShapeKey2, undefined);
    _defineProperty8(this, _parentShapeKey2, undefined);
    _defineProperty8(this, "listType", undefined);
    _defineProperty8(this, "nullable", undefined);
    this.listType = listType;
    this.nullable = nullable;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/base64.js
function encodeBase64(value) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.btoa === "function") {
    return globalThis1.btoa(value);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value).toString("base64");
  }
  throw new Error("Unable to locate global `btoa` or `Buffer`");
}
function decodeBase64(value) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.atob === "function") {
    return globalThis1.atob(value);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value, "base64").toString();
  }
  throw new Error("Unable to locate global `atob` or `Buffer`");
}
var getGlobalThis = () => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (true)
    return null;
  throw new Error("Unable to locate global `this`");
};
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values3) {
  const result = {};
  if (Array.isArray(values3)) {
    values3.forEach((key) => {
      result[String(key)] = {
        pothosOptions: {}
      };
    });
  } else {
    Object.entries(values3).forEach(([key, value]) => {
      if (value && typeof value === "object") {
        result[key] = {
          ...value,
          pothosOptions: value
        };
      } else if (typeof value === "string") {
        result[value] = {
          pothosOptions: {}
        };
      }
    });
  }
  return result;
}
function valuesFromEnum(Enum, values3) {
  const result = {};
  Object.keys(Enum).filter((key) => typeof Enum[Enum[key]] !== "number").forEach((key) => {
    result[key] = {
      value: Enum[key],
      pothosOptions: {},
      ...values3 === null || values3 === undefined ? undefined : values3[key]
    };
  });
  return result;
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/params.js
function typeFromParam(param, configStore, nullableOption) {
  const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
  const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromParam(param[0], configStore, itemNullable),
      nullable
    };
  }
  if (param instanceof ListRef) {
    return {
      kind: "List",
      type: typeFromParam(param.listType, configStore, param.nullable),
      nullable
    };
  }
  const ref = configStore.getOutputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
    return {
      kind,
      ref,
      nullable
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function unwrapInputFieldType(type) {
  if (type.kind === "List") {
    return unwrapInputFieldType(type.type);
  }
  return type.ref;
}
function inputTypeFromParam(param, configStore, requiredOption) {
  const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
  const required = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromParam(param[0], configStore, itemRequired),
      required
    };
  }
  if (param instanceof InputObjectRef2) {
    return {
      kind: "List",
      type: inputTypeFromParam(param.listType, configStore, param.required),
      required
    };
  }
  const ref = configStore.getInputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref,
      required
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/input.js
function resolveInputTypeConfig(type, buildCache) {
  if (type.kind === "List") {
    return resolveInputTypeConfig(type.type, buildCache);
  }
  const config = buildCache.getTypeConfig(type.ref);
  if (config.kind === "Enum" || config.kind === "Scalar" || config.kind === "InputObject") {
    return config;
  }
  throw new PothosSchemaError(`Unexpected config type ${config.kind} for input ref ${String(type.ref)}`);
}
function mapInputFields(inputs, buildCache, mapper) {
  const filterMappings = new Map;
  return filterMapped(internalMapInputFields(inputs, buildCache, mapper, new Map));
  function filterMapped(map2) {
    if (filterMappings.has(map2)) {
      return filterMappings.get(map2);
    }
    const filtered = new Map;
    filterMappings.set(map2, filtered);
    map2.forEach((mapping, fieldName) => {
      if (mapping.kind === "Enum" || mapping.kind === "Scalar") {
        filtered.set(fieldName, mapping);
        return;
      }
      const hasNestedMappings = checkForMappings(mapping.fields.map);
      if (mapping.value !== null || hasNestedMappings) {
        const filteredTypeFields = filterMapped(mapping.fields.map);
        const mappingForType = {
          ...mapping,
          fields: {
            configs: mapping.fields.configs,
            map: filteredTypeFields
          }
        };
        filtered.set(fieldName, mappingForType);
      }
    });
    return filtered.size > 0 ? filtered : null;
  }
  function checkForMappings(map2, hasMappings = new Map) {
    if (hasMappings.has(map2)) {
      return hasMappings.get(map2);
    }
    hasMappings.set(map2, false);
    let result = false;
    map2.forEach((mapping) => {
      if (mapping.value !== null) {
        result = true;
      } else if (mapping.kind === "InputObject" && mapping.fields.map && checkForMappings(mapping.fields.map, hasMappings)) {
        result = true;
      }
    });
    hasMappings.set(map2, result);
    return result;
  }
}
var internalMapInputFields = function(inputs, buildCache, mapper, seenTypes) {
  const map2 = new Map;
  Object.keys(inputs).forEach((fieldName) => {
    const inputField = inputs[fieldName];
    const typeConfig = resolveInputTypeConfig(inputField.type, buildCache);
    const fieldMapping = mapper(inputField);
    if (typeConfig.kind === "Enum" || typeConfig.kind === "Scalar") {
      if (fieldMapping !== null) {
        map2.set(fieldName, {
          kind: typeConfig.kind,
          isList: inputField.type.kind === "List",
          config: inputField,
          value: fieldMapping
        });
      }
      return;
    }
    const inputFieldConfigs = buildCache.getInputTypeFieldConfigs(unwrapInputFieldType(inputField.type));
    if (!seenTypes.has(typeConfig.name)) {
      const typeEntry = {
        configs: inputFieldConfigs,
        map: new Map
      };
      seenTypes.set(typeConfig.name, typeEntry);
      typeEntry.map = internalMapInputFields(inputFieldConfigs, buildCache, mapper, seenTypes);
    }
    const typeFields = seenTypes.get(typeConfig.name);
    map2.set(fieldName, {
      kind: typeConfig.kind,
      isList: inputField.type.kind === "List",
      config: inputField,
      value: fieldMapping,
      fields: typeFields
    });
  });
  return map2;
};
function createInputValueMapper(argMap, mapValue3) {
  return function mapObject(obj, map2 = argMap, ...args) {
    const mapped = {
      ...obj
    };
    map2.forEach((field, fieldName) => {
      let fieldVal = obj[fieldName];
      if (fieldVal === null || fieldVal === undefined) {
        return;
      }
      if (field.kind === "InputObject" && field.fields.map) {
        fieldVal = field.isList ? fieldVal.map((val) => val && mapObject(val, field.fields.map, ...args)) : mapObject(fieldVal, field.fields.map, ...args);
        mapped[fieldName] = fieldVal;
      }
      if (field.kind !== "InputObject" || field.value !== null) {
        mapped[fieldName] = field.isList ? fieldVal.map((val) => mapValue3(val, field, ...args)) : mapValue3(fieldVal, field, ...args);
      }
    });
    return mapped;
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/utils/index.js
function assertNever(value) {
  throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
  if (!Array.isArray(value)) {
    throw new PothosValidationError("List resolvers must return arrays");
  }
  return true;
}
function isThenable(value) {
  return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
  if (ref === undefined) {
    throw new PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new PothosSchemaError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === undefined) {
      throw new PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function brandWithType(val, type) {
  if (typeof val !== "object" || val === null) {
    return;
  }
  Object.defineProperty(val, typeBrandKey, {
    enumerable: false,
    value: type
  });
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && (typeBrandKey in val)) {
    return val[typeBrandKey];
  }
  return null;
}
function unwrapListParam(param) {
  if (Array.isArray(param)) {
    return unwrapListParam(param[0]);
  }
  if (param instanceof ListRef || param instanceof InputObjectRef2) {
    return unwrapListParam(param.listType);
  }
  return param;
}
function completeValue2(valOrPromise, onSuccess, onError) {
  if (isThenable(valOrPromise)) {
    return Promise.resolve(valOrPromise).then(onSuccess, onError);
  }
  const result = onSuccess(valOrPromise);
  if (isThenable(result)) {
    return Promise.resolve(result);
  }
  return result;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/build-cache.js
class BuildCache {
  getTypeConfig(ref, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref) {
    const typeConfig = this.getTypeConfig(ref, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields = builtType.getFields();
    const fieldConfigs = {};
    Object.keys(fields).forEach((fieldName) => {
      var _fields_fieldName_extensions;
      fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields[fieldName].extensions) === null || _fields_fieldName_extensions === undefined ? undefined : _fields_fieldName_extensions.pothosConfig;
    });
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "InputObject") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof GraphQLInputObjectType) {
        type.getFields();
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Interface") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Object") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Union") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType) {
        type.getFields();
      } else if (type instanceof GraphQLUnionType) {
        type.getTypes();
      }
    });
  }
  buildTypeFromConfig(baseConfig) {
    const config = this.getTypeConfig(baseConfig.name);
    const { name } = config;
    this.typeConfigs.set(name, config);
    switch (config.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config));
        break;
      default:
        assertNever(config);
    }
  }
  addType(ref, type) {
    if (this.types.has(ref)) {
      throw new PothosSchemaError(`reference or name has already been used to create another type (${type.name})`);
    }
    this.types.set(ref, type);
  }
  buildOutputTypeParam(type) {
    if (type.kind === "List") {
      if (type.nullable) {
        return new GraphQLList(this.buildOutputTypeParam(type.type));
      }
      return new GraphQLNonNull(new GraphQLList(this.buildOutputTypeParam(type.type)));
    }
    if (type.nullable) {
      return this.getOutputType(type.ref);
    }
    return new GraphQLNonNull(this.getOutputType(type.ref));
  }
  buildInputTypeParam(type) {
    if (type.kind === "List") {
      if (type.required) {
        return new GraphQLNonNull(new GraphQLList(this.buildInputTypeParam(type.type)));
      }
      return new GraphQLList(this.buildInputTypeParam(type.type));
    }
    if (type.required) {
      return new GraphQLNonNull(this.getInputType(type.ref));
    }
    return this.getInputType(type.ref);
  }
  buildFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config = {
        ...updatedConfig
      };
      const argMap = new Map;
      Object.keys(config.args).forEach((argName) => {
        argMap.set(argName, config.args[argName]);
      });
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      Object.keys(config.args).forEach((argName) => {
        argConfigs[argName] = this.inputFieldConfigs.get(config.args[argName]);
      });
      config.args = argConfigs;
      var _config_resolve;
      const resolve = this.plugin.wrapResolve((_config_resolve = config.resolve) !== null && _config_resolve !== undefined ? _config_resolve : defaultFieldResolver, config);
      const subscribe3 = this.plugin.wrapSubscribe(config.subscribe, config);
      var _config_resolve1;
      built[fieldName] = {
        ...config,
        type: this.buildOutputTypeParam(config.type),
        args,
        extensions: {
          ...config.extensions,
          pothosResolveWrapped: resolve !== ((_config_resolve1 = config.resolve) !== null && _config_resolve1 !== undefined ? _config_resolve1 : defaultFieldResolver),
          pothosSubscribeWrapped: subscribe3 !== config.subscribe,
          pothosOptions: config.pothosOptions,
          pothosConfig: config
        },
        resolve: resolve === defaultFieldResolver ? undefined : resolve,
        subscribe: subscribe3
      };
    }
    return built;
  }
  buildInputFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config = this.inputFieldConfigs.get(originalConfig);
      if (config) {
        built[fieldName] = {
          ...config,
          type: this.buildInputTypeParam(config.type),
          extensions: {
            ...config.extensions,
            pothosOptions: config.pothosOptions,
            pothosConfig: config
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const configs2 = this.configStore.getFields(type.name, "Interface");
    const fields = this.buildFields(configs2);
    return {
      ...interfaceFields,
      ...fields
    };
  }
  getObjectFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const objectFields = this.buildFields(this.configStore.getFields(type.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type) {
    return this.buildFields(this.configStore.getFields(type.name, "Object"));
  }
  getFields(type) {
    if (type instanceof GraphQLObjectType) {
      if (type.name === "Query" || type.name === "Mutation" || type.name === "Subscription") {
        return this.getRootFields(type);
      }
      return this.getObjectFields(type);
    }
    if (type instanceof GraphQLInterfaceType) {
      return this.getInterfaceFields(type);
    }
    throw new PothosSchemaError(`Type ${type.name} does not have fields to resolve`);
  }
  getInputFields(type) {
    return this.buildInputFields(this.configStore.getFields(type.name, "InputObject"));
  }
  getType(ref) {
    if (ref instanceof BuiltinScalarRef) {
      return ref.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref);
    const type = this.types.get(typeConfig.name);
    if (!type) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type;
  }
  getOutputType(ref) {
    const type = this.getType(ref);
    if (type instanceof GraphQLInputObjectType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
    }
    return type;
  }
  getInputType(ref) {
    const type = this.getType(ref);
    if (!type) {
      throw new PothosSchemaError(`Missing implementation of for type ${String(ref)}`);
    }
    if (type instanceof GraphQLObjectType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type instanceof GraphQLInterfaceType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type instanceof GraphQLUnionType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type;
  }
  getTypeOfKind(ref, kind) {
    const type = this.getType(ref);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type instanceof GraphQLObjectType) {
          return type;
        }
        break;
      case "Interface":
        if (type instanceof GraphQLInterfaceType) {
          return type;
        }
        break;
      case "Union":
        if (type instanceof GraphQLUnionType) {
          return type;
        }
        break;
      case "Enum":
        if (type instanceof GraphQLEnumType) {
          return type;
        }
        break;
      case "Scalar":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      case "InputObject":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      default:
        break;
    }
    throw new PothosSchemaError(`Expected ${String(ref)} to be of type ${kind}`);
  }
  buildObject(config) {
    var _config_isTypeOf;
    const type = new GraphQLObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getFields(type),
      isTypeOf: config.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config.isTypeOf) !== null && _config_isTypeOf !== undefined ? _config_isTypeOf : undefined, config) : undefined,
      interfaces: config.kind === "Object" ? () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : undefined
    });
    return type;
  }
  buildInterface(config) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _config_resolveType;
      const resolver = (_config_resolveType = config.resolveType) !== null && _config_resolveType !== undefined ? _config_resolveType : defaultTypeResolver;
      return resolver(parent, context, info, type);
    };
    const type = new GraphQLInterfaceType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      interfaces: () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
    return type;
  }
  buildUnion(config) {
    const resolveType = (parent, context, info, type) => {
      if (typeof parent === "object" && parent !== null && (typeBrandKey in parent)) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config.resolveType) {
        return defaultTypeResolver(parent, context, info, type);
      }
      const resultOrPromise = config.resolveType(parent, context, info, type);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new GraphQLUnionType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      types: () => config.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
  }
  buildInputObject(config) {
    const type = new GraphQLInputObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getInputFields(type)
    });
    return type;
  }
  buildScalar(config) {
    if (config.name === "ID") {
      return GraphQLID;
    }
    if (config.name === "Int") {
      return GraphQLInt;
    }
    if (config.name === "Float") {
      return GraphQLFloat;
    }
    if (config.name === "Boolean") {
      return GraphQLBoolean;
    }
    if (config.name === "String") {
      return GraphQLString;
    }
    return new GraphQLScalarType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  buildEnum(config) {
    const values3 = {};
    for (const key of Object.keys(config.values)) {
      const original = config.values[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values3[key] = this.enumValueConfigs.get(original);
      }
    }
    return new GraphQLEnumType({
      ...config,
      values: values3,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  constructor(builder, options) {
    _defineProperty9(this, "types", new Map);
    _defineProperty9(this, "builder", undefined);
    _defineProperty9(this, "plugin", undefined);
    _defineProperty9(this, "options", undefined);
    _defineProperty9(this, "configStore", undefined);
    _defineProperty9(this, "pluginMap", undefined);
    _defineProperty9(this, "pluginList", undefined);
    _defineProperty9(this, "implementers", new Map);
    _defineProperty9(this, "typeConfigs", new Map);
    _defineProperty9(this, "enumValueConfigs", new Map);
    _defineProperty9(this, "outputFieldConfigs", new Map);
    _defineProperty9(this, "inputFieldConfigs", new Map);
    this.builder = builder;
    this.configStore = builder.configStore;
    this.options = options;
    const plugins3 = {};
    var _builder_options_plugins;
    this.pluginList = ((_builder_options_plugins = builder.options.plugins) !== null && _builder_options_plugins !== undefined ? _builder_options_plugins : []).map((pluginName) => {
      const Plugin = this.builder.constructor.plugins[pluginName];
      if (!Plugin) {
        throw new PothosError(`No plugin named ${pluginName} was registered`);
      }
      plugins3[pluginName] = new Plugin(this, pluginName);
      return plugins3[pluginName];
    });
    this.pluginMap = plugins3;
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/config-store.js
var _defineProperty12 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input.js
var _defineProperty10 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey4 = inputShapeKey;

class InputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty10(this, "kind", undefined);
    _defineProperty10(this, _inputShapeKey4, undefined);
    this.kind = kind;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/output.js
var _defineProperty11 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey3 = outputShapeKey;
var _parentShapeKey3 = parentShapeKey;

class OutputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty11(this, "kind", undefined);
    _defineProperty11(this, _outputShapeKey3, undefined);
    _defineProperty11(this, _parentShapeKey3, undefined);
    this.kind = kind;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/config-store.js
class ConfigStore {
  hasConfig(typeParam) {
    if (typeof typeParam === "string") {
      return this.typeConfigs.has(typeParam);
    }
    return this.refsToName.has(typeParam);
  }
  addUnionTypes(typeName, unionTypes) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Union") {
        throw new PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.types = [
        ...typeConfig.types,
        ...typeof unionTypes === "function" ? unionTypes() : unionTypes
      ];
    });
  }
  addInterfaces(typeName, interfaces) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
        throw new PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.interfaces = [
        ...typeConfig.interfaces,
        ...typeof interfaces === "function" ? interfaces() : interfaces
      ];
    });
  }
  addFieldRef(ref, typeParam, args, getConfig) {
    if (this.fieldRefs.has(ref)) {
      throw new PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
    }
    const typeRefOrName = unwrapListParam(typeParam);
    const argRefs = Object.keys(args).map((argName) => {
      const argRef = args[argName];
      argRef.fieldName = argName;
      argRef.argFor = ref;
      return argRef;
    });
    const checkArgs = () => {
      for (const arg of argRefs) {
        if (this.pendingFields.has(arg)) {
          const unresolvedArgType = this.pendingFields.get(arg);
          this.pendingFields.set(ref, unresolvedArgType);
          this.onTypeConfig(unresolvedArgType, checkArgs);
          return;
        }
      }
      this.pendingFields.delete(ref);
      this.fieldRefs.set(ref, getConfig);
    };
    if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
      checkArgs();
    } else {
      this.pendingFields.set(ref, typeRefOrName);
      this.onTypeConfig(typeRefOrName, () => {
        checkArgs();
      });
    }
  }
  createFieldConfig(ref, name, typeConfig, parentField, kind) {
    if (!this.fieldRefs.has(ref)) {
      if (this.pendingFields.has(ref)) {
        throw new PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
      }
      throw new PothosSchemaError(`Missing definition for ${String(ref)}`);
    }
    const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
    if (kind && config.graphqlKind !== kind) {
      throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
    }
    return config;
  }
  associateRefWithName(ref, name) {
    if (!this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`${name} has not been implemented yet`);
    }
    this.refsToName.set(ref, name);
    if (this.pendingRefResolutions.has(ref)) {
      const cbs = this.pendingRefResolutions.get(ref);
      this.pendingRefResolutions.delete(ref);
      cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
    }
  }
  addTypeConfig(config, ref) {
    const { name } = config;
    if (this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
    }
    this.typeConfigs.set(config.name, config);
    if (ref) {
      this.associateRefWithName(ref, name);
    }
    if (this.pendingRefResolutions.has(name)) {
      const cbs = this.pendingRefResolutions.get(name);
      this.pendingRefResolutions.delete(name);
      cbs.forEach((cb) => void cb(config));
    }
  }
  getTypeConfig(ref, kind) {
    let config;
    if (typeof ref === "string") {
      if (!this.typeConfigs.has(ref)) {
        throw new PothosSchemaError(`Type ${String(ref)} has not been implemented`);
      }
      config = this.typeConfigs.get(ref);
    } else if (this.refsToName.has(ref)) {
      config = this.typeConfigs.get(this.refsToName.get(ref));
    } else if (ref instanceof ListRef || ref instanceof InputObjectRef2) {
      throw new PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
    } else {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    }
    if (kind && config.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
    }
    return config;
  }
  getInputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config = this.typeConfigs.get(ref);
        if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
          throw new PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
        }
        const newRef = new InputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref;
  }
  getOutputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind === "InputObject" || ref.kind === "InputList") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
      }
      if (ref.kind === "List") {
        throw new PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config = this.typeConfigs.get(ref);
        if (config.graphqlKind === "InputObject") {
          throw new PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
        }
        const newRef = new OutputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref;
  }
  onTypeConfig(ref, cb) {
    if (!ref) {
      throw new PothosSchemaError(`${String(ref)} is not a valid type ref`);
    }
    if (this.refsToName.has(ref)) {
      cb(this.getTypeConfig(ref));
    } else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
      cb(this.typeConfigs.get(ref));
    } else if (!this.pending) {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    } else if (this.pendingRefResolutions.has(ref)) {
      this.pendingRefResolutions.get(ref).push(cb);
    } else {
      this.pendingRefResolutions.set(ref, [
        cb
      ]);
    }
  }
  onFieldUse(ref, cb) {
    if (!this.fieldRefCallbacks.has(ref)) {
      this.fieldRefCallbacks.set(ref, []);
    }
    this.fieldRefCallbacks.get(ref).push(cb);
    if (this.fieldRefsToConfigs.has(ref)) {
      this.fieldRefsToConfigs.get(ref).forEach((config) => void cb(config));
    }
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, new Map);
    }
    const fields = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields;
  }
  prepareForBuild() {
    this.pending = false;
    const { pendingActions } = this;
    this.pendingActions = [];
    pendingActions.forEach((fn) => void fn());
    if (this.pendingRefResolutions.size > 0) {
      throw new PothosSchemaError(`Missing implementations for some references (${[
        ...this.pendingRefResolutions.keys()
      ].map((ref) => this.describeRef(ref)).join(", ")}).`);
    }
  }
  onPrepare(cb) {
    if (this.pending) {
      this.pendingActions.push(cb);
    } else {
      cb();
    }
  }
  addFields(typeRef, fields) {
    this.onPrepare(() => void this.onTypeConfig(typeRef, (config) => {
      this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
    }));
  }
  getImplementers(ref) {
    const typeConfig = this.getTypeConfig(ref, "Interface");
    const implementers = [
      ...this.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
    return implementers;
  }
  describeRef(ref) {
    var _find;
    if (typeof ref === "string") {
      return ref;
    }
    if (ref.toString !== {}.toString) {
      return String(ref);
    }
    const usedBy = (_find = [
      ...this.pendingFields.entries()
    ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || _find === undefined ? undefined : _find[0];
    if (usedBy) {
      return `<unnamed ref or enum: used by ${usedBy}>`;
    }
    return `<unnamed ref or enum>`;
  }
  buildFields(typeRef, fields) {
    Object.keys(fields).forEach((fieldName) => {
      const fieldRef = fields[fieldName];
      fieldRef.fieldName = fieldName;
      if (this.pendingFields.has(fieldRef)) {
        this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
          this.buildField(typeRef, fieldRef, fieldName);
        });
      } else {
        this.buildField(typeRef, fieldRef, fieldName);
      }
    });
  }
  buildField(typeRef, field, fieldName) {
    const typeConfig = this.getTypeConfig(typeRef);
    const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
    const existingFields = this.getFields(typeConfig.name);
    if (existingFields.has(fieldName)) {
      throw new PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
    }
    if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
      throw new PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
    }
    existingFields.set(fieldName, fieldConfig);
    if (!this.fieldRefsToConfigs.has(field)) {
      this.fieldRefsToConfigs.set(field, []);
    }
    this.fieldRefsToConfigs.get(field).push(fieldConfig);
    if (this.fieldRefCallbacks.has(field)) {
      this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
    }
  }
  constructor() {
    _defineProperty12(this, "typeConfigs", new Map);
    _defineProperty12(this, "fieldRefs", new WeakMap);
    _defineProperty12(this, "fields", new Map);
    _defineProperty12(this, "pendingActions", []);
    _defineProperty12(this, "refsToName", new Map);
    _defineProperty12(this, "scalarsToRefs", new Map);
    _defineProperty12(this, "fieldRefsToConfigs", new Map);
    _defineProperty12(this, "pendingFields", new Map);
    _defineProperty12(this, "pendingRefResolutions", new Map);
    _defineProperty12(this, "fieldRefCallbacks", new Map);
    _defineProperty12(this, "pending", true);
    const scalars6 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars6.forEach((scalar2) => {
      const ref = new BuiltinScalarRef(scalar2);
      this.scalarsToRefs.set(scalar2.name, ref);
      this.refsToName.set(ref, scalar2.name);
    });
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/input.js
var _defineProperty14 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/input-field.js
var _defineProperty13 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputFieldShapeKey = inputFieldShapeKey;

class InputFieldRef {
  toString() {
    var _this_argFor;
    if (this.kind !== "Arg") {
      if (this.fieldName) {
        return `${this.parentTypename}.${this.fieldName}`;
      }
      return this.parentTypename;
    }
    var _this_argFor_fieldName;
    const fieldName = (_this_argFor_fieldName = (_this_argFor = this.argFor) === null || _this_argFor === undefined ? undefined : _this_argFor.fieldName) !== null && _this_argFor_fieldName !== undefined ? _this_argFor_fieldName : "[unnamed field]";
    var _this_fieldName;
    const argName = (_this_fieldName = this.fieldName) !== null && _this_fieldName !== undefined ? _this_fieldName : "[unnamed argument]";
    return `${this.parentTypename}.${fieldName}(${argName})`;
  }
  constructor(kind, parentTypename) {
    _defineProperty13(this, "kind", undefined);
    _defineProperty13(this, "parentTypename", undefined);
    _defineProperty13(this, "fieldName", undefined);
    _defineProperty13(this, "argFor", undefined);
    _defineProperty13(this, _inputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/input.js
class InputFieldBuilder {
  argBuilder() {
    const builder = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === undefined);
    [
      ...Object.keys(this),
      ...protoKeys
    ].forEach((key) => {
      builder[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    });
    return builder;
  }
  field(options) {
    const ref = new InputFieldRef(this.kind, this.typename);
    var _options_required;
    this.builder.configStore.addFieldRef(ref, options.type, {}, (name, parentField, typeConfig) => ({
      name,
      parentField,
      kind: this.kind,
      graphqlKind: this.kind,
      parentType: typeConfig.name,
      type: inputTypeFromParam(options.type, this.builder.configStore, (_options_required = options.required) !== null && _options_required !== undefined ? _options_required : this.builder.defaultInputFieldRequiredness),
      pothosOptions: options,
      description: options.description,
      deprecationReason: options.deprecationReason,
      defaultValue: options.defaultValue,
      extensions: options.extensions
    }));
    return ref;
  }
  helper(type) {
    return (...args) => {
      const [options = {}] = args;
      return this.field({
        ...options,
        type
      });
    };
  }
  constructor(builder, kind, typename) {
    _defineProperty14(this, "builder", undefined);
    _defineProperty14(this, "kind", undefined);
    _defineProperty14(this, "typename", undefined);
    _defineProperty14(this, "boolean", this.helper("Boolean"));
    _defineProperty14(this, "float", this.helper("Float"));
    _defineProperty14(this, "id", this.helper("ID"));
    _defineProperty14(this, "int", this.helper("Int"));
    _defineProperty14(this, "string", this.helper("String"));
    _defineProperty14(this, "booleanList", this.helper([
      "Boolean"
    ]));
    _defineProperty14(this, "floatList", this.helper([
      "Float"
    ]));
    _defineProperty14(this, "idList", this.helper([
      "ID"
    ]));
    _defineProperty14(this, "intList", this.helper([
      "Int"
    ]));
    _defineProperty14(this, "stringList", this.helper([
      "String"
    ]));
    var _options_required;
    _defineProperty14(this, "listRef", (type, options) => {
      return new InputObjectRef2(type, (_options_required = options === null || options === undefined ? undefined : options.required) !== null && _options_required !== undefined ? _options_required : true);
    });
    this.builder = builder;
    this.kind = kind;
    this.typename = typename;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/root.js
var _defineProperty17 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/base.js
var _defineProperty16 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/field.js
var _defineProperty15 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputFieldShapeKey = outputFieldShapeKey;

class FieldRef {
  toString() {
    if (this.fieldName) {
      return `${this.parentTypename}.${this.fieldName}`;
    }
    return this.parentTypename;
  }
  constructor(kind, parentTypename) {
    _defineProperty15(this, "kind", undefined);
    _defineProperty15(this, "parentTypename", undefined);
    _defineProperty15(this, "fieldName", undefined);
    _defineProperty15(this, _outputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/base.js
class BaseFieldUtil {
  createField(options) {
    const ref = new FieldRef(this.kind, this.typename);
    var _options_args;
    this.builder.configStore.addFieldRef(ref, options.type, (_options_args = options.args) !== null && _options_args !== undefined ? _options_args : {}, (name, parentField, typeConfig) => {
      var _options_extensions;
      const args = {};
      if (options.args) {
        Object.keys(options.args).forEach((argName) => {
          const argRef = options.args[argName];
          args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
        });
      }
      var _options_resolve;
      let resolve = (_options_resolve = options.resolve) !== null && _options_resolve !== undefined ? _options_resolve : () => {
        throw new PothosSchemaError(`Not implemented: No resolver found for ${this.typename}.${name}`);
      };
      if (((_options_extensions = options.extensions) === null || _options_extensions === undefined ? undefined : _options_extensions.pothosExposedField) === name) {
        resolve = defaultFieldResolver;
      }
      const { subscribe: subscribe3 } = options;
      var _options_nullable;
      return {
        kind: this.kind,
        graphqlKind: this.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : this.builder.defaultFieldNullability),
        pothosOptions: options,
        extensions: {
          pothosOriginalResolve: resolve,
          pothosOriginalSubscribe: subscribe3,
          ...options.extensions
        },
        description: options.description,
        deprecationReason: options.deprecationReason,
        resolve,
        subscribe: subscribe3
      };
    });
    return ref;
  }
  exposeField(name, { extensions, ...options }) {
    return this.createField({
      ...options,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(name, builder, kind, graphqlKind) {
    _defineProperty16(this, "typename", undefined);
    _defineProperty16(this, "builder", undefined);
    _defineProperty16(this, "kind", undefined);
    _defineProperty16(this, "graphqlKind", undefined);
    this.typename = name;
    this.builder = builder;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/root.js
class RootFieldBuilder extends BaseFieldUtil {
  boolean(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Boolean"
    });
  }
  float(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Float"
    });
  }
  id(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "ID"
    });
  }
  int(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Int"
    });
  }
  string(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "String"
    });
  }
  booleanList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  floatList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Float"
      ]
    });
  }
  idList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "ID"
      ]
    });
  }
  intList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Int"
      ]
    });
  }
  stringList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "String"
      ]
    });
  }
  field(options) {
    return this.createField(options);
  }
  listRef(type, options) {
    var _options_nullable;
    return new ListRef(type, (_options_nullable = options === null || options === undefined ? undefined : options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : false);
  }
  constructor(...args) {
    super(...args);
    _defineProperty17(this, "arg", new InputFieldBuilder(this.builder, "Arg", this.typename).argBuilder());
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/builder.js
class FieldBuilder extends RootFieldBuilder {
  exposeBoolean(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Boolean"
    });
  }
  exposeFloat(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Float"
    });
  }
  exposeID(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "ID"
    });
  }
  exposeInt(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Int"
    });
  }
  exposeString(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "String"
    });
  }
  exposeBooleanList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  exposeFloatList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Float"
      ]
    });
  }
  exposeIDList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "ID"
      ]
    });
  }
  exposeIntList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Int"
      ]
    });
  }
  exposeStringList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "String"
      ]
    });
  }
  expose(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, options);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/interface.js
class InterfaceFieldBuilder extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Interface", "Interface");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/mutation.js
class MutationFieldBuilder extends RootFieldBuilder {
  constructor(builder2) {
    super("Mutation", builder2, "Mutation", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/object.js
class ObjectFieldBuilder extends FieldBuilder {
  constructor(name, builder3) {
    super(name, builder3, "Object", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/query.js
class QueryFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Query", builder3, "Query", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/fieldUtils/subscription.js
class SubscriptionFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Subscription", builder3, "Subscription", "Object");
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/enum.js
var _defineProperty18 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey4 = outputShapeKey;
var _inputShapeKey5 = inputShapeKey;

class EnumRef extends BaseTypeRef {
  constructor(name) {
    super("Enum", name);
    _defineProperty18(this, "kind", "Enum");
    _defineProperty18(this, _outputShapeKey4, undefined);
    _defineProperty18(this, _inputShapeKey5, undefined);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/interface.js
var _defineProperty19 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey5 = outputShapeKey;
var _parentShapeKey4 = parentShapeKey;

class InterfaceRef extends BaseTypeRef {
  constructor(name) {
    super("Interface", name);
    _defineProperty19(this, "kind", "Interface");
    _defineProperty19(this, _outputShapeKey5, undefined);
    _defineProperty19(this, _parentShapeKey4, undefined);
  }
}
class ImplementableInterfaceRef extends InterfaceRef {
  implement(options) {
    return this.builder.interfaceType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty19(this, "builder", undefined);
    this.builder = builder3;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/object.js
var _defineProperty20 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey6 = outputShapeKey;
var _parentShapeKey5 = parentShapeKey;

class ObjectRef extends BaseTypeRef {
  constructor(name) {
    super("Object", name);
    _defineProperty20(this, "kind", "Object");
    _defineProperty20(this, _outputShapeKey6, undefined);
    _defineProperty20(this, _parentShapeKey5, undefined);
  }
}
class ImplementableObjectRef extends ObjectRef {
  implement(options) {
    return this.builder.objectType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty20(this, "builder", undefined);
    this.builder = builder3;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/refs/union.js
var _defineProperty21 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey7 = outputShapeKey;
var _parentShapeKey6 = parentShapeKey;

class UnionRef extends BaseTypeRef {
  constructor(name) {
    super("Union", name);
    _defineProperty21(this, "kind", "Union");
    _defineProperty21(this, _outputShapeKey7, undefined);
    _defineProperty21(this, _parentShapeKey6, undefined);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/builder.js
class SchemaBuilder {
  static registerPlugin(name, plugin3) {
    if (!this.allowPluginReRegistration && this.plugins[name]) {
      throw new PothosError(`Received multiple implementations for plugin ${name}`);
    }
    this.plugins[name] = plugin3;
  }
  objectType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    if (name === "Query" || name === "Mutation" || name === "Subscription") {
      throw new PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
    }
    const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
    const config = {
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options.description,
      extensions: options.extensions,
      isTypeOf: options.isTypeOf,
      pothosOptions: options
    };
    this.configStore.addTypeConfig(config, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(name, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => {
        const t = new ObjectFieldBuilder(name, this);
        return options.fields(t);
      });
    }
    return ref;
  }
  objectFields(ref, fields) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
    });
  }
  objectField(ref, fieldName, field2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field2(new ObjectFieldBuilder(name, this))
      }));
    });
  }
  queryType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Query",
      graphqlKind: "Object",
      name: "Query",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    const ref = new ObjectRef("Query");
    this.configStore.addTypeConfig(config, ref);
    if (fields) {
      this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
    }
    return ref;
  }
  queryFields(fields) {
    this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
  }
  queryField(name, field2) {
    this.configStore.addFields("Query", () => ({
      [name]: field2(new QueryFieldBuilder(this))
    }));
  }
  mutationType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Mutation",
      graphqlKind: "Object",
      name: "Mutation",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields) {
      this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
    }
  }
  mutationFields(fields) {
    this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
  }
  mutationField(name, field2) {
    this.configStore.addFields("Mutation", () => ({
      [name]: field2(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Subscription",
      graphqlKind: "Object",
      name: "Subscription",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields) {
      this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
    }
  }
  subscriptionFields(fields) {
    this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field2) {
    this.configStore.addFields("Subscription", () => ({
      [name]: field2(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields) {
    return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
  }
  interfaceType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
    const typename = ref.name;
    const config = {
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions,
      resolveType: options.resolveType
    };
    this.configStore.addTypeConfig(config, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(typename, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(typename, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(typename, this)));
    }
    return ref;
  }
  interfaceFields(ref, fields) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(name, this)));
    });
  }
  interfaceField(ref, fieldName, field2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field2(new InterfaceFieldBuilder(name, this))
      }));
    });
  }
  unionType(name, options) {
    const ref = new UnionRef(name);
    if (Array.isArray(options.types)) {
      options.types.forEach((type) => {
        verifyRef(type);
      });
    }
    const config = {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: [],
      description: options.description,
      resolveType: options.resolveType,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    this.configStore.addUnionTypes(name, options.types);
    return ref;
  }
  enumType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options.name;
    const ref = new EnumRef(name);
    const values3 = typeof param === "object" ? valuesFromEnum(param, options === null || options === undefined ? undefined : options.values) : normalizeEnumValues(options.values);
    const config = {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values: values3,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    if (typeof param !== "string") {
      this.configStore.associateRefWithName(param, name);
    }
    return ref;
  }
  scalarType(name, options) {
    const ref = new ScalarRef(name);
    const config = {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options.description,
      parseLiteral: options.parseLiteral,
      parseValue: options.parseValue,
      serialize: options.serialize,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    return ref;
  }
  addScalarType(name, scalar3, options) {
    const config = scalar3.toConfig();
    return this.scalarType(name, {
      ...config,
      ...options,
      extensions: {
        ...config.extensions,
        ...options.extensions
      }
    });
  }
  inputType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref = typeof param === "string" ? new InputObjectRef(name) : param;
    const config = {
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    this.configStore.addFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
    return ref;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(...args) {
    const [options = {}] = args;
    const { directives: directives11, extensions } = options;
    const scalars6 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars6.forEach((scalar3) => {
      if (!this.configStore.hasConfig(scalar3.name)) {
        this.addScalarType(scalar3.name, scalar3, {});
      }
    });
    const buildCache = new BuildCache(this, options);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const schema3 = new GraphQLSchema({
      query: buildCache.types.get("Query"),
      mutation: buildCache.types.get("Mutation"),
      subscription: buildCache.types.get("Subscription"),
      extensions: extensions !== null && extensions !== undefined ? extensions : {},
      directives: directives11,
      types: builtTypes
    });
    const processedSchema = buildCache.plugin.afterBuild(schema3);
    return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
  }
  constructor(options) {
    _defineProperty22(this, "configStore", undefined);
    _defineProperty22(this, "options", undefined);
    _defineProperty22(this, "defaultFieldNullability", undefined);
    _defineProperty22(this, "defaultInputFieldRequiredness", undefined);
    this.options = options;
    this.configStore = new ConfigStore;
    var _options_defaultFieldNullability;
    this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== undefined ? _options_defaultFieldNullability : false;
    var _options_defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== undefined ? _options_defaultInputFieldRequiredness : false;
  }
}
_defineProperty22(SchemaBuilder, "plugins", {});
_defineProperty22(SchemaBuilder, "allowPluginReRegistration", false);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;
var RootFieldBuilder2 = RootFieldBuilder;
var QueryFieldBuilder2 = QueryFieldBuilder;
var MutationFieldBuilder2 = MutationFieldBuilder;
var SubscriptionFieldBuilder2 = SubscriptionFieldBuilder;
var ObjectFieldBuilder2 = ObjectFieldBuilder;
var InterfaceFieldBuilder2 = InterfaceFieldBuilder;
var InputFieldBuilder2 = InputFieldBuilder;
var BaseTypeRef2 = BaseTypeRef;
var InputObjectRef3 = InputObjectRef;
var InterfaceRef2 = InterfaceRef;
var ObjectRef2 = ObjectRef;

// src/utils/prisma.ts
var client = __toESM(require_client2(), 1);

// src/env.ts
var envsToCheck = {
  NODE_ENV: [false, false],
  PORT: [false, false],
  DATABASE_URL: [true, true],
  ORIGIN: [true, false],
  PATH_TO_PLUGINS: [false, true]
};
var env = {};
console.log("\x1B[2mEnvironment variables:\x1B[0m");
for (const [envKey, [required, sensitive]] of Object.entries(envsToCheck)) {
  const envValue = process.env[envKey];
  if (required && !envValue) {
    throw `\x1B[31mEnvironment variable ${envKey} is required but not set.\x1B[0m`;
  }
  if (sensitive) {
    console.log(`\x1B[2m  ${envKey}: ${envValue ? `***${envValue.slice(-15)}` : undefined}\x1B[0m`);
  } else {
    console.log(`\x1B[2m  ${envKey}: ${envValue}\x1B[0m`);
  }
  env[envKey] = envValue;
  delete process.env[envKey];
}

// src/pubsub.ts
var pubsub = createPubSub();

// src/utils/dayjs.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var customParseFormat = __toESM(require_customParseFormat(), 1);
var utc = __toESM(require_utc(), 1);
var timezone = __toESM(require_timezone(), 1);
import_dayjs.default.extend(customParseFormat.default);
import_dayjs.default.extend(utc.default);
import_dayjs.default.extend(timezone.default);
var dayjs = import_dayjs.default;

// src/utils/prisma.ts
var $prisma = new client.PrismaClient({
  datasources: {
    db: {
      url: env.DATABASE_URL
    }
  }
});
var withPubsub = (delegate, pub) => ({
  ...delegate,
  async create(args) {
    const res = await delegate.create(args);
    pub("Created", [res]);
    return res;
  },
  async createMany(args) {
    const now = dayjs().subtract(1, "second").toDate();
    const res = await delegate.createMany(args);
    const created = await delegate.findMany({ where: { createdAt: { gte: now } } });
    pub("Created", created);
    return res;
  },
  async update(args) {
    const res = await delegate.update(args);
    pub("Updated", [res]);
    return res;
  },
  async updateMany(args) {
    const now = dayjs().subtract(1, "second").toDate();
    const res = await delegate.updateMany(args);
    const updated = await delegate.findMany({ where: { updatedAt: { gte: now } } });
    pub("Updated", updated);
    return res;
  },
  async upsert(args) {
    const res = await delegate.upsert(args);
    if (dayjs(res.updatedAt).isSame(dayjs(res.createdAt))) {
      pub("Created", [res]);
    } else {
      pub("Updated", [res]);
    }
    return res;
  },
  async delete(args) {
    const res = await delegate.delete(args);
    pub("Deleted", [res]);
    return res;
  },
  async deleteMany(args) {
    const toBeDeleted = await delegate.findMany(args);
    const res = await delegate.deleteMany(args);
    pub("Deleted", toBeDeleted);
    return res;
  }
});
var prisma = {
  ...$prisma,
  task: withPubsub($prisma.task, (action, rows) => pubsub.publish(`tasks${action}`, rows)),
  item: withPubsub($prisma.item, (action, rows) => pubsub.publish(`items${action}`, rows)),
  async $transaction(fn, options) {
    const tasksCreated = [];
    const tasksUpdated = [];
    const tasksDeleted = [];
    const itemsCreated = [];
    const itemsUpdated = [];
    const itemsDeleted = [];
    if (typeof fn !== "function") {
      return $prisma.$transaction(fn, options);
    }
    const res = await $prisma.$transaction((tx) => {
      return fn({
        ...tx,
        task: withPubsub(tx.task, (action, rowsRaw) => {
          const rows = rowsRaw;
          switch (action) {
            case "Created":
              tasksCreated.push(...rows);
              break;
            case "Updated":
              tasksUpdated.push(...rows);
              break;
            case "Deleted":
              tasksDeleted.push(...rows);
              break;
          }
        }),
        item: withPubsub(tx.item, (action, rowsRaw) => {
          const rows = rowsRaw;
          switch (action) {
            case "Created":
              itemsCreated.push(...rows);
              break;
            case "Updated":
              itemsUpdated.push(...rows);
              break;
            case "Deleted":
              itemsDeleted.push(...rows);
              break;
          }
        })
      });
    }, options);
    if (tasksCreated.length)
      pubsub.publish("tasksCreated", tasksCreated);
    if (tasksUpdated.length)
      pubsub.publish("tasksUpdated", tasksUpdated);
    if (tasksDeleted.length)
      pubsub.publish("tasksDeleted", tasksDeleted);
    if (itemsCreated.length)
      pubsub.publish("itemsCreated", itemsCreated);
    if (itemsUpdated.length)
      pubsub.publish("itemsUpdated", itemsUpdated);
    if (itemsDeleted.length)
      pubsub.publish("itemsDeleted", itemsDeleted);
    return res;
  },
  $executeRaw: $prisma.$executeRaw,
  $executeRawUnsafe: (...args) => $prisma.$executeRawUnsafe(...args),
  $on: $prisma.$on,
  $use: $prisma.$use,
  $connect: $prisma.$connect,
  $disconnect: $prisma.$disconnect,
  $queryRaw: $prisma.$queryRaw,
  $queryRawUnsafe: $prisma.$queryRawUnsafe
};
// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/global-ids.js
function encodeGlobalID(typename, id) {
  return encodeBase64(`${typename}:${id}`);
}
function decodeGlobalID(globalID) {
  const [typename, id] = decodeBase64(globalID).split(":");
  if (!typename || !id) {
    throw new TypeError(`Invalid global ID: ${globalID}`);
  }
  return {
    typename,
    id
  };
}
// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/internal.js
function internalEncodeGlobalID(builder5, typename, id, ctx) {
  if (builder5.options.relayOptions.encodeGlobalID) {
    return builder5.options.relayOptions.encodeGlobalID(typename, id, ctx);
  }
  return encodeGlobalID(typename, id);
}
function internalDecodeGlobalID(builder5, globalID, ctx) {
  if (builder5.options.relayOptions.decodeGlobalID) {
    return builder5.options.relayOptions.decodeGlobalID(globalID, ctx);
  }
  return decodeGlobalID(globalID);
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/resolve-nodes.js
async function resolveNodes(builder5, context, info, globalIDs) {
  const requestCache = getRequestCache(context);
  const idsByType = {};
  const results = {};
  globalIDs.forEach((globalID, i) => {
    if (globalID == null) {
      return;
    }
    if (requestCache.has(globalID)) {
      results[globalID] = requestCache.get(globalID);
      return;
    }
    const { id, typename } = internalDecodeGlobalID(builder5, globalID, context);
    idsByType[typename] = idsByType[typename] || new Map;
    idsByType[typename].set(id, globalID);
  });
  await Promise.all(Object.keys(idsByType).map(async (typename) => {
    const ids = [
      ...idsByType[typename].keys()
    ];
    const globalIds = [
      ...idsByType[typename].values()
    ];
    const config = builder5.configStore.getTypeConfig(typename, "Object");
    const options = config.pothosOptions;
    var _brandLoadedObjects, ref;
    const shouldBrandObjects = (ref = (_brandLoadedObjects = options.brandLoadedObjects) !== null && _brandLoadedObjects !== undefined ? _brandLoadedObjects : builder5.options.relayOptions.brandLoadedObjects) !== null && ref !== undefined ? ref : false;
    const resultsForType = await resolveUncachedNodesForType(builder5, context, info, ids, typename);
    resultsForType.forEach((val, i) => {
      if (shouldBrandObjects) {
        brandWithType(val, typename);
      }
      results[globalIds[i]] = val;
    });
  }));
  var _globalID;
  return globalIDs.map((globalID) => globalID == null ? null : (_globalID = results[globalID]) !== null && _globalID !== undefined ? _globalID : null);
}
async function resolveUncachedNodesForType(builder5, context, info, ids, type) {
  const requestCache = getRequestCache(context);
  const config = builder5.configStore.getTypeConfig(type, "Object");
  const options = config.pothosOptions;
  if (options.loadMany) {
    const loadManyPromise = Promise.resolve(options.loadMany(ids, context));
    return Promise.all(ids.map((id, i) => {
      const globalID = internalEncodeGlobalID(builder5, config.name, id, context);
      const entryPromise = loadManyPromise.then((results) => results[i]).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadOne) {
    return Promise.all(ids.map((id) => {
      const globalID = internalEncodeGlobalID(builder5, config.name, id, context);
      const entryPromise = Promise.resolve(options.loadOne(id, context)).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadManyWithoutCache) {
    return options.loadManyWithoutCache(ids, context);
  }
  if (options.loadWithoutCache) {
    return Promise.all(ids.map((id) => Promise.resolve(options.loadWithoutCache(id, context, info))));
  }
  throw new Error(`${config.name} does not support loading by id`);
}
var getRequestCache = createContextCache(() => new Map);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/utils/index.js
function capitalize(s) {
  return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/field-builder.js
var fieldBuilderProto = RootFieldBuilder2.prototype;
fieldBuilderProto.globalIDList = function globalIDList({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result) {
      return result;
    }
    assertArray(result);
    if (Array.isArray(result)) {
      return (await Promise.all(result)).map((item) => item == null || typeof item === "string" ? item : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context));
    }
    return null;
  };
  return this.field({
    ...options,
    type: [
      "ID"
    ],
    resolve: wrappedResolve
  });
};
fieldBuilderProto.globalID = function globalID({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result || typeof result === "string") {
      return result;
    }
    const item = result;
    return internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context);
  };
  return this.field({
    ...options,
    type: "ID",
    resolve: wrappedResolve
  });
};
fieldBuilderProto.node = function node({ id, ...options }) {
  return this.field({
    ...options,
    type: this.builder.nodeInterfaceRef(),
    nullable: true,
    resolve: async (parent, args, context, info) => {
      const rawID = await id(parent, args, context, info);
      if (rawID == null) {
        return null;
      }
      const globalID2 = typeof rawID === "string" ? rawID : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(rawID.type).name, String(rawID.id), context);
      return (await resolveNodes(this.builder, context, info, [
        globalID2
      ]))[0];
    }
  });
};
fieldBuilderProto.nodeList = function nodeList({ ids, ...options }) {
  return this.field({
    ...options,
    nullable: {
      list: false,
      items: true
    },
    type: [
      this.builder.nodeInterfaceRef()
    ],
    resolve: async (parent, args, context, info) => {
      const rawIDList = await ids(parent, args, context, info);
      assertArray(rawIDList);
      if (!Array.isArray(rawIDList)) {
        return [];
      }
      const rawIds = await Promise.all(rawIDList);
      const globalIds = rawIds.map((id) => !id || typeof id === "string" ? id : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(id.type).name, String(id.id), context));
      return resolveNodes(this.builder, context, info, globalIds);
    }
  });
};
fieldBuilderProto.connection = function connection({ type, edgesNullable, nodeNullable, ...fieldOptions }, connectionOptionsOrRef = {}, edgeOptionsOrRef = {}) {
  var ref;
  const connectionRef = connectionOptionsOrRef instanceof ObjectRef2 ? connectionOptionsOrRef : this.builder.objectRef("Unnamed connection");
  const fieldRef = this.field({
    ...(ref = this.builder.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultConnectionFieldOptions,
    ...fieldOptions,
    type: connectionRef,
    args: {
      ...fieldOptions.args,
      ...this.arg.connectionArgs()
    },
    resolve: fieldOptions.resolve
  });
  if (!(connectionOptionsOrRef instanceof ObjectRef2)) {
    this.builder.configStore.onFieldUse(fieldRef, (fieldConfig) => {
      var _name;
      const connectionName = (_name = connectionOptionsOrRef.name) !== null && _name !== undefined ? _name : `${this.typename}${capitalize(fieldConfig.name)}${fieldConfig.name.toLowerCase().endsWith("connection") ? "" : "Connection"}`;
      this.builder.connectionObject({
        type,
        edgesNullable,
        nodeNullable,
        ...connectionOptionsOrRef,
        name: connectionName
      }, edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : {
        name: `${connectionName}Edge`,
        ...edgeOptionsOrRef
      });
      this.builder.configStore.associateRefWithName(connectionRef, connectionName);
    });
  }
  return fieldRef;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/input-field-builder.js
var inputFieldBuilder = InputFieldBuilder2.prototype;
inputFieldBuilder.globalIDList = function globalIDList2(options = {}) {
  return this.idList({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.globalID = function globalID2(options = {}) {
  return this.id({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.connectionArgs = function connectionArgs() {
  const {
    cursorType = "ID",
    beforeArgOptions = {},
    afterArgOptions = {},
    firstArgOptions = {},
    lastArgOptions = {}
  } = this.builder.options.relayOptions;
  return {
    before: this.field({
      ...beforeArgOptions,
      type: cursorType,
      required: false
    }),
    after: this.field({
      ...afterArgOptions,
      type: cursorType,
      required: false
    }),
    first: this.int({
      ...firstArgOptions,
      required: false
    }),
    last: this.int({
      ...lastArgOptions,
      required: false
    })
  };
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/schema-builder.js
var schemaBuilderProto = esm_default.prototype;
var pageInfoRefMap = new WeakMap;
var nodeInterfaceRefMap = new WeakMap;
var connectionRefs = new WeakMap;
var globalConnectionFieldsMap = new WeakMap;
schemaBuilderProto.pageInfoRef = function pageInfoRef() {
  if (pageInfoRefMap.has(this)) {
    return pageInfoRefMap.get(this);
  }
  const ref = this.objectRef("PageInfo");
  pageInfoRefMap.set(this, ref);
  const { cursorType = "String", hasNextPageFieldOptions = {}, hasPreviousPageFieldOptions = {}, startCursorFieldOptions = {}, endCursorFieldOptions = {} } = this.options.relayOptions;
  ref.implement({
    ...this.options.relayOptions.pageInfoTypeOptions,
    fields: (t) => ({
      hasNextPage: t.exposeBoolean("hasNextPage", {
        nullable: false,
        ...hasNextPageFieldOptions
      }),
      hasPreviousPage: t.exposeBoolean("hasPreviousPage", {
        nullable: false,
        ...hasPreviousPageFieldOptions
      }),
      startCursor: t.expose("startCursor", {
        nullable: true,
        ...startCursorFieldOptions,
        type: cursorType
      }),
      endCursor: t.expose("endCursor", {
        nullable: true,
        ...endCursorFieldOptions,
        type: cursorType
      })
    })
  });
  return ref;
};
schemaBuilderProto.nodeInterfaceRef = function nodeInterfaceRef() {
  if (nodeInterfaceRefMap.has(this)) {
    return nodeInterfaceRefMap.get(this);
  }
  const ref = this.interfaceRef("Node");
  nodeInterfaceRefMap.set(this, ref);
  var ref1;
  ref.implement({
    resolveType: (value, context, info, graphQLType) => {
      if (!value) {
        return defaultTypeResolver(value, context, info, graphQLType);
      }
      const typeBrand = getTypeBrand(value);
      if (typeBrand) {
        const type = this.configStore.getTypeConfig(typeBrand);
        return type.name;
      }
      try {
        if (typeof value === "object") {
          const typename = value.__typename;
          if (typename) {
            return typename;
          }
          const nodeRef = value.__type;
          if (nodeRef) {
            const config = this.configStore.getTypeConfig(nodeRef);
            if (config) {
              return config.name;
            }
          }
        }
      } catch {
      }
      return defaultTypeResolver(value, context, info, graphQLType);
    },
    ...this.options.relayOptions.nodeTypeOptions,
    fields: (t) => {
      var ref2;
      return {
        [(ref1 = (ref2 = this.options.relayOptions) === null || ref2 === undefined ? undefined : ref2.idFieldName) !== null && ref1 !== undefined ? ref1 : "id"]: t.globalID({
          nullable: false,
          resolve: (parent) => {
            throw new Error("id field not implemented");
          }
        })
      };
    }
  });
  this.queryField("node", (t) => t.field({
    nullable: true,
    ...this.options.relayOptions.nodeQueryOptions,
    type: ref,
    args: {
      id: t.arg.id({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => (await resolveNodes(this, context, info, [
      String(args.id)
    ]))[0]
  }));
  this.queryField("nodes", (t) => t.field({
    nullable: {
      list: false,
      items: true
    },
    ...this.options.relayOptions.nodesQueryOptions,
    type: [
      ref
    ],
    args: {
      ids: t.arg.idList({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => await resolveNodes(this, context, info, args.ids)
  }));
  return ref;
};
schemaBuilderProto.node = function node2(param, { interfaces, ...options }, fields) {
  verifyRef(param);
  const interfacesWithNode = [
    this.nodeInterfaceRef(),
    ...interfaces !== null && interfaces !== undefined ? interfaces : []
  ];
  let nodeName;
  var _isTypeOf;
  const ref = this.objectType(param, {
    ...options,
    isTypeOf: (_isTypeOf = options.isTypeOf) !== null && _isTypeOf !== undefined ? _isTypeOf : typeof param === "function" ? (maybeNode, context, info) => {
      if (!maybeNode) {
        return false;
      }
      if (maybeNode instanceof param) {
        return true;
      }
      const proto = Object.getPrototypeOf(maybeNode);
      try {
        if (proto === null || proto === undefined ? undefined : proto.constructor) {
          const config = this.configStore.getTypeConfig(proto.constructor);
          return config.name === nodeName;
        }
      } catch {
      }
      return false;
    } : undefined,
    interfaces: interfacesWithNode
  }, fields);
  this.configStore.onTypeConfig(ref, (nodeConfig) => {
    nodeName = nodeConfig.name;
    var _idFieldName;
    this.objectField(ref, (_idFieldName = this.options.relayOptions.idFieldName) !== null && _idFieldName !== undefined ? _idFieldName : "id", (t) => t.globalID({
      nullable: false,
      ...this.options.relayOptions.idFieldOptions,
      ...options.id,
      args: {},
      resolve: async (parent, args, context, info) => ({
        type: nodeConfig.name,
        id: await options.id.resolve(parent, args, context, info)
      })
    }));
  });
  return ref;
};
schemaBuilderProto.globalConnectionField = function globalConnectionField(name, field2) {
  var ref;
  const onRef = (ref2) => {
    this.objectField(ref2, name, field2);
  };
  (ref = connectionRefs.get(this)) === null || ref === undefined || ref.forEach((ref2) => void onRef(ref2));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
schemaBuilderProto.globalConnectionFields = function globalConnectionFields(fields) {
  var ref;
  const onRef = (ref2) => {
    this.objectFields(ref2, fields);
  };
  (ref = connectionRefs.get(this)) === null || ref === undefined || ref.forEach((ref2) => void onRef(ref2));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
var mutationIdCache = createContextCache(() => new Map);
schemaBuilderProto.relayMutationField = function relayMutationField(fieldName, inputOptionsOrRef, { resolve, ...fieldOptions }, { name: payloadName = `${capitalize(fieldName)}Payload`, outputFields, interfaces, ...paylaodOptions }) {
  var ref;
  const { relayOptions: { clientMutationIdInputOptions = {}, clientMutationIdFieldOptions = {}, mutationInputArgOptions = {} } } = this.options;
  const includeClientMutationId = this.options.relayOptions.clientMutationId !== "omit";
  let inputRef;
  let argName = "input";
  if (inputOptionsOrRef instanceof InputObjectRef3) {
    inputRef = inputOptionsOrRef;
  } else {
    var ref1;
    const { name: inputName = `${capitalize(fieldName)}Input`, argName: argNameFromOptions = "input", inputFields, ...inputOptions } = inputOptionsOrRef;
    argName = argNameFromOptions;
    inputRef = this.inputType(inputName, {
      ...(ref1 = this.options.relayOptions) === null || ref1 === undefined ? undefined : ref1.defaultMutationInputTypeOptions,
      ...inputOptions,
      fields: (t) => ({
        ...inputFields(t),
        ...includeClientMutationId ? {
          clientMutationId: t.id({
            ...clientMutationIdInputOptions,
            required: this.options.relayOptions.clientMutationId !== "optional"
          })
        } : {}
      })
    });
  }
  const payloadRef = this.objectRef(payloadName).implement({
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultPayloadTypeOptions,
    ...paylaodOptions,
    interfaces,
    fields: (t) => ({
      ...outputFields(t),
      ...includeClientMutationId ? {
        clientMutationId: t.id({
          nullable: this.options.relayOptions.clientMutationId === "optional",
          ...clientMutationIdFieldOptions,
          resolve: (parent, args, context, info) => mutationIdCache(context).get(String(info.path.prev.key))
        })
      } : {}
    })
  });
  this.mutationField(fieldName, (t) => t.field({
    ...fieldOptions,
    type: payloadRef,
    args: {
      [argName]: t.arg({
        ...mutationInputArgOptions,
        type: inputRef,
        required: true
      })
    },
    resolve: (root6, args, context, info) => {
      mutationIdCache(context).set(String(info.path.key), args[argName].clientMutationId);
      return resolve(root6, args, context, info);
    }
  }));
  return {
    inputType: inputRef,
    payloadType: payloadRef
  };
};
schemaBuilderProto.connectionObject = function connectionObject({ type, name: connectionName, edgesNullable: edgesNullableField, nodeNullable, ...connectionOptions }, edgeOptionsOrRef) {
  var ref, ref1;
  verifyRef(type);
  const { edgesFieldOptions: { nullable: edgesNullable = {
    items: true,
    list: false
  }, ...edgesFieldOptions } = {}, pageInfoFieldOptions = {} } = this.options.relayOptions;
  const connectionRef = this.objectRef(connectionName);
  const edgeRef = edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : this.edgeObject({
    name: `${connectionName.replace(/Connection$/, "")}Edge`,
    ...edgeOptionsOrRef,
    nodeNullable,
    type
  });
  const connectionFields = connectionOptions.fields;
  const { nodesOnConnection } = this.options.relayOptions;
  const edgesNullableOption = edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable;
  const edgeListNullable = typeof edgesNullableOption === "object" ? edgesNullableOption.list : !!edgesNullableOption;
  const edgeItemsNullable = typeof edgesNullableOption === "object" && ("items" in edgesNullableOption) ? edgesNullableOption.items : false;
  var ref2, ref3, ref4;
  this.objectType(connectionRef, {
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultConnectionTypeOptions,
    ...connectionOptions,
    fields: (t) => {
      var ref5, ref12;
      return {
        pageInfo: t.field({
          nullable: false,
          ...pageInfoFieldOptions,
          type: this.pageInfoRef(),
          resolve: (parent) => parent.pageInfo
        }),
        edges: t.field({
          nullable: edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable,
          ...edgesFieldOptions,
          type: [
            edgeRef
          ],
          resolve: (parent) => parent.edges
        }),
        ...nodesOnConnection ? {
          nodes: t.field({
            ...typeof nodesOnConnection === "object" ? nodesOnConnection : {},
            type: [
              type
            ],
            nullable: {
              list: edgeListNullable,
              items: (ref3 = (ref2 = edgeItemsNullable !== null && edgeItemsNullable !== undefined ? edgeItemsNullable : nodeNullable) !== null && ref2 !== undefined ? ref2 : (ref5 = this.options.relayOptions) === null || ref5 === undefined ? undefined : (ref12 = ref5.nodeFieldOptions) === null || ref12 === undefined ? undefined : ref12.nullable) !== null && ref3 !== undefined ? ref3 : false
            },
            resolve: (con) => {
              var ref6;
              return (ref4 = (ref6 = con.edges) === null || ref6 === undefined ? undefined : ref6.map((edge) => {
                return edge === null || edge === undefined ? undefined : edge.node;
              })) !== null && ref4 !== undefined ? ref4 : [];
            }
          })
        } : {},
        ...connectionFields === null || connectionFields === undefined ? undefined : connectionFields(t)
      };
    }
  });
  if (!connectionRefs.has(this)) {
    connectionRefs.set(this, []);
  }
  connectionRefs.get(this).push(connectionRef);
  (ref1 = globalConnectionFieldsMap.get(this)) === null || ref1 === undefined || ref1.forEach((fieldFn) => void fieldFn(connectionRef));
  return connectionRef;
};
schemaBuilderProto.edgeObject = function edgeObject({ type, name: edgeName, nodeNullable: nodeFieldNullable, ...edgeOptions }) {
  var ref;
  verifyRef(type);
  const { cursorType = "String", cursorFieldOptions = {}, nodeFieldOptions: { nullable: nodeNullable = false, ...nodeFieldOptions } = {} } = this.options.relayOptions;
  const edgeRef = this.objectRef(edgeName);
  const edgeFields = edgeOptions.fields;
  this.objectType(edgeRef, {
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultEdgeTypeOptions,
    ...edgeOptions,
    fields: (t) => {
      return {
        node: t.field({
          nullable: nodeFieldNullable !== null && nodeFieldNullable !== undefined ? nodeFieldNullable : nodeNullable,
          ...nodeFieldOptions,
          type,
          resolve: (parent) => parent.node
        }),
        cursor: t.expose("cursor", {
          nullable: false,
          type: cursorType,
          ...cursorFieldOptions
        }),
        ...edgeFields === null || edgeFields === undefined ? undefined : edgeFields(t)
      };
    }
  });
  return edgeRef;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-relay/esm/index.js
var pluginName = "relay";
var esm_default2 = pluginName;

class PothosRelayPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref;
      if ((ref = inputField.extensions) === null || ref === undefined ? undefined : ref.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => resolver(parent, argMapper(args, undefined, context), context, info);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref;
      if ((ref = inputField.extensions) === null || ref === undefined ? undefined : ref.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings || !subscribe3) {
      return subscribe3;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => subscribe3(parent, argMapper(args, undefined, context), context, info);
  }
}
esm_default.registerPlugin(pluginName, PothosRelayPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/interface-ref.js
var _define_property2 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/object-ref.js
var _define_property = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var prismaModelKey = Symbol.for("Pothos.prismaModelKey");
var _prismaModelKey = prismaModelKey;
var _abstractReturnShapeKey = abstractReturnShapeKey;

class PrismaObjectRef extends ObjectRef2 {
  addBrand(value) {
    if (Array.isArray(value)) {
      value.forEach((val) => void brandWithType(val, this.name));
      return value;
    }
    brandWithType(value, this.name);
    return value;
  }
  hasBrand(value) {
    return typeof value === "object" && value !== null && (typeBrandKey in value) && value[typeBrandKey] === this.name;
  }
  constructor(name, modelName) {
    super(name);
    _define_property(this, _prismaModelKey, undefined);
    _define_property(this, _abstractReturnShapeKey, undefined);
    _define_property(this, "modelName", undefined);
    this.modelName = modelName;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/interface-ref.js
var _prismaModelKey2 = prismaModelKey;

class PrismaInterfaceRef extends InterfaceRef2 {
  constructor(name, modelName) {
    super(name);
    _define_property2(this, _prismaModelKey2, undefined);
    _define_property2(this, "modelName", undefined);
    this.modelName = modelName;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/model-loader.js
var _define_property3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/get-client.js
function getClient(builder5, context) {
  if (typeof builder5.options.prisma.client === "function") {
    return prismaClientCache(builder5)(context);
  }
  return builder5.options.prisma.client;
}
function getDMMF(builder5) {
  var _client__baseDmmf;
  if (("dmmf" in builder5.options.prisma) && builder5.options.prisma.dmmf) {
    return builder5.options.prisma.dmmf.datamodel;
  }
  const client2 = builder5.options.prisma.client;
  var _client__runtimeDataModel, _ref;
  return (_ref = (_client__runtimeDataModel = client2._runtimeDataModel) !== null && _client__runtimeDataModel !== undefined ? _client__runtimeDataModel : (_client__baseDmmf = client2._baseDmmf) === null || _client__baseDmmf === undefined ? undefined : _client__baseDmmf.datamodel) !== null && _ref !== undefined ? _ref : client2._dmmf.datamodel;
}
var prismaClientCache = createContextCache((builder5) => createContextCache((context) => typeof builder5.options.prisma.client === "function" ? builder5.options.prisma.client(context) : builder5.options.prisma.client));

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/datamodel.js
function getRefFromModel(name, builder5, type = "object") {
  if (!refMap.has(builder5)) {
    refMap.set(builder5, new Map);
  }
  const cache = refMap.get(builder5);
  if (!cache.has(name)) {
    cache.set(name, type === "object" ? new PrismaObjectRef(name, name) : new PrismaInterfaceRef(name, name));
  }
  return cache.get(name);
}
function getRelation(name, builder5, relation) {
  const fieldData = getFieldData(name, builder5, relation);
  if (fieldData.kind !== "object") {
    throw new PothosSchemaError(`Field ${relation} of model '${name}' is not a relation (${fieldData.kind})`);
  }
  return fieldData;
}
function getFieldData(name, builder5, fieldName) {
  const modelData = getModel(name, builder5);
  const fieldData = modelData.fields.find((field2) => field2.name === fieldName);
  if (!fieldData) {
    throw new PothosSchemaError(`Field '${fieldName}' not found in model '${name}'`);
  }
  return fieldData;
}
function getModel(name, builder5) {
  const dmmf = getDMMF(builder5);
  const modelData = Array.isArray(dmmf.models) ? dmmf.models.find((model) => model.name === name) : dmmf.models[name];
  if (!modelData) {
    throw new PothosSchemaError(`Model '${name}' not found in DMMF`);
  }
  return modelData;
}
function getDelegateFromModel(client2, model) {
  const lowerCase = `${model.slice(0, 1).toLowerCase()}${model.slice(1)}`;
  const delegate = lowerCase in client2 ? client2[lowerCase] : null;
  if (!delegate) {
    throw new PothosSchemaError(`Unable to find delegate for model ${model}`);
  }
  return delegate;
}
var refMap = new WeakMap;
var findUniqueMap = new WeakMap;
var includeForRefMap = new WeakMap;

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/loader-map.js
function cacheKey(type, path, subPath = []) {
  let key = "";
  let current = path;
  while (current) {
    if (typeof current.key === "string") {
      key = key ? `${current.key}.${key}` : current.key;
    }
    current = current.prev;
  }
  for (const entry of subPath) {
    key = `${key}.${entry}`;
  }
  return `${type}@${key}`;
}
function setLoaderMappings(ctx, info, value) {
  Object.keys(value).forEach((field2) => {
    const map2 = cache(ctx);
    const mapping = value[field2];
    const subPath = [
      ...mapping.indirectPath,
      field2
    ];
    const key = cacheKey(mapping.type, info.path, subPath);
    map2.set(key, mapping.mappings);
  });
}
function getLoaderMapping(ctx, path, type) {
  const map2 = cache(ctx);
  const key = cacheKey(type, path, []);
  var _map_get;
  return (_map_get = map2.get(key)) !== null && _map_get !== undefined ? _map_get : null;
}
var cache = createContextCache((ctx) => new Map);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/deep-equal.js
function deepEqual(left, right, ignore) {
  if (left === right) {
    return true;
  }
  if (left && right && typeof left === "object" && typeof right === "object") {
    var _left_valueOf, _right_valueOf;
    if (Array.isArray(left)) {
      if (!Array.isArray(right)) {
        return false;
      }
      const { length } = left;
      if (right.length !== length) {
        return false;
      }
      for (let i = 0;i < length; i += 1) {
        if (!deepEqual(left[i], right[i])) {
          return false;
        }
      }
      return true;
    }
    const lValue = (_left_valueOf = left.valueOf) === null || _left_valueOf === undefined ? undefined : _left_valueOf.call(left);
    const rValue = (_right_valueOf = right.valueOf) === null || _right_valueOf === undefined ? undefined : _right_valueOf.call(right);
    if ((lValue != null || rValue != null) && typeof lValue !== "object") {
      return lValue === rValue;
    }
    const keys = Object.keys(left);
    const keyLength = keys.length;
    if (keyLength !== Object.keys(right).length) {
      return false;
    }
    for (const key of keys) {
      if (ignore === null || ignore === undefined ? undefined : ignore.has(key)) {
        continue;
      }
      if (!deepEqual(left[key], right[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/selections.js
function selectionCompatible(state, selectionMap, ignoreQuery = false) {
  if (typeof selectionMap === "boolean") {
    return ignoreQuery || !selectionMap || Object.keys(state.query).length === 0;
  }
  const { select, include, ...query3 } = selectionMap;
  if (select && Object.keys(select).some((key) => compare(key, select[key]))) {
    return false;
  }
  if (include && Object.keys(include).some((key) => compare(key, include[key]))) {
    return false;
  }
  return ignoreQuery || deepEqual(state.query, query3);
  function compare(key, value) {
    if (key === "_count") {
      const selections = value && value.select;
      const keys = selections && Object.keys(selections);
      if (!keys || keys.length === 0) {
        return false;
      }
      return keys.some((k) => state.counts.has(k) && !deepEqual(state.counts.get(k), selections[k]));
    }
    return value && state.fieldMap.relations.has(key) && state.relations.has(key) && !selectionCompatible(state.relations.get(key), value);
  }
}
function createState(fieldMap, mode, parent) {
  return {
    parent,
    mode,
    fieldMap,
    query: {},
    fields: new Set,
    counts: new Map,
    relations: new Map,
    mappings: {}
  };
}
function mergeSelection(state, { select, include, ...query3 }) {
  if (state.mode === "select" && !select) {
    state.mode = "include";
  }
  if (include) {
    Object.keys(include).forEach((key) => {
      merge2(key, include[key]);
    });
  }
  if (select) {
    Object.keys(select).forEach((key) => {
      merge2(key, select[key]);
    });
  }
  if (Object.keys(query3).length > 0) {
    state.query = query3;
  }
  function merge2(key, value) {
    if (!value) {
      return;
    }
    if (key === "_count") {
      var _value_select;
      const counts = (_value_select = value.select) !== null && _value_select !== undefined ? _value_select : {};
      Object.keys(counts).forEach((count) => {
        state.counts.set(count, counts[count]);
      });
      return;
    }
    const selection = value === true ? {
      include: {}
    } : value;
    const childMap = state.fieldMap.relations.get(key);
    if (childMap) {
      if (state.relations.has(key)) {
        mergeSelection(state.relations.get(key), selection);
      } else {
        const relatedState = createState(childMap, "select");
        mergeSelection(relatedState, selection);
        state.relations.set(key, relatedState);
      }
    } else {
      state.fields.add(key);
    }
  }
}
function selectionToQuery(state) {
  const nestedIncludes = {};
  const counts = {};
  let hasSelection = false;
  state.relations.forEach((sel, relation) => {
    hasSelection = true;
    const nested = selectionToQuery(sel);
    nestedIncludes[relation] = Object.keys(nested).length > 0 ? nested : true;
  });
  if (state.counts.size > 0) {
    hasSelection = true;
    for (const [count, selection] of state.counts) {
      counts[count] = selection;
    }
    nestedIncludes._count = {
      select: counts
    };
  }
  if (state.mode === "select") {
    state.fields.forEach((field2) => {
      hasSelection = true;
      nestedIncludes[field2] = true;
    });
    return {
      ...state.query,
      select: nestedIncludes
    };
  }
  return hasSelection ? {
    ...state.query,
    include: nestedIncludes
  } : state.query;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/usage.js
function wrapWithUsageCheck(obj) {
  const result = {};
  let used = true;
  Object.defineProperty(result, usageSymbol, {
    get() {
      return used;
    },
    set(value) {
      used = value;
    },
    enumerable: false
  });
  for (const key of Object.keys(obj)) {
    used = false;
    Object.defineProperty(result, key, {
      enumerable: true,
      configurable: true,
      get() {
        used = true;
        return obj[key];
      }
    });
  }
  return result;
}
function isUsed(obj) {
  return !(usageSymbol in obj) || obj[usageSymbol];
}
function extendWithUsage(original, extension) {
  if (!(usageSymbol in original)) {
    return {
      ...original,
      ...extension
    };
  }
  const result = {
    ...extension
  };
  for (const key of [
    usageSymbol,
    ...Object.keys(original)
  ]) {
    if (key in result) {
      continue;
    }
    Object.defineProperty(result, key, {
      enumerable: key !== usageSymbol,
      configurable: key !== usageSymbol,
      get() {
        return original[key];
      }
    });
  }
  return result;
}
var usageSymbol = Symbol.for("Pothos.isUsed");

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/map-query.js
var addTypeSelectionsForField = function(type, context, info, state, selection, indirectPath) {
  if (selection.name.value.startsWith("__")) {
    return;
  }
  var _type_extensions;
  const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_type_extensions = type.extensions) !== null && _type_extensions !== undefined ? _type_extensions : {};
  if (!!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.path) && pothosPrismaIndirectInclude.path.length > 0 || !!(pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.paths) && pothosPrismaIndirectInclude.paths.length === 0) {
    var _pothosPrismaIndirectInclude_paths;
    resolveIndirectIncludePaths(type, info, selection, [], (_pothosPrismaIndirectInclude_paths = pothosPrismaIndirectInclude.paths) !== null && _pothosPrismaIndirectInclude_paths !== undefined ? _pothosPrismaIndirectInclude_paths : [
      pothosPrismaIndirectInclude.path
    ], indirectPath, (resolvedType, field2, path) => {
      addTypeSelectionsForField(resolvedType, context, info, state, field2, path);
    });
  } else if (pothosPrismaIndirectInclude) {
    addTypeSelectionsForField(info.schema.getType(pothosPrismaIndirectInclude.getType()), context, info, state, selection, indirectPath);
    return;
  }
  if (!(isObjectType(type) || isInterfaceType(type))) {
    return;
  }
  if (pothosPrismaModel && !pothosPrismaSelect) {
    state.mode = "include";
  }
  if (pothosPrismaInclude !== null && pothosPrismaInclude !== undefined ? pothosPrismaInclude : pothosPrismaSelect) {
    mergeSelection(state, {
      select: pothosPrismaSelect ? {
        ...pothosPrismaSelect
      } : undefined,
      include: pothosPrismaInclude ? {
        ...pothosPrismaInclude
      } : undefined
    });
  }
  if (selection.selectionSet) {
    addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
  }
};
var resolveIndirectIncludePaths = function(type, info, selection, pathPrefix, includePaths, path, resolve) {
  for (const includePath of includePaths) {
    if (pathPrefix.length > 0) {
      resolveIndirectInclude(type, info, selection, [
        ...pathPrefix,
        ...includePath
      ], path, resolve);
    } else {
      resolveIndirectInclude(type, info, selection, includePath, path, resolve);
    }
  }
};
var resolveIndirectInclude = function(type, info, selection, includePath, path, resolve, expectedType = type) {
  if (includePath.length === 0) {
    resolve(type, selection, path);
    return;
  }
  const [include, ...rest] = includePath;
  if (!selection.selectionSet || !include) {
    return;
  }
  for (const sel of selection.selectionSet.selections) {
    switch (sel.kind) {
      case Kind.FIELD:
        if (expectedType.name === type.name && !fieldSkipped(info, sel) && sel.name.value === include.name && (isObjectType(type) || isInterfaceType(type))) {
          var _sel_alias;
          const returnType = getNamedType(type.getFields()[sel.name.value].type);
          var _sel_alias_value;
          resolveIndirectInclude(returnType, info, sel, rest, [
            ...path,
            (_sel_alias_value = (_sel_alias = sel.alias) === null || _sel_alias === undefined ? undefined : _sel_alias.value) !== null && _sel_alias_value !== undefined ? _sel_alias_value : sel.name.value
          ], resolve);
        }
        continue;
      case Kind.FRAGMENT_SPREAD:
        resolveIndirectInclude(info.schema.getType(info.fragments[sel.name.value].typeCondition.name.value), info, info.fragments[sel.name.value], includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
        continue;
      case Kind.INLINE_FRAGMENT:
        if (!sel.typeCondition || !include.type || sel.typeCondition.name.value === include.type) {
          resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve, include.type ? info.schema.getType(include.type) : expectedType);
        }
        continue;
      default:
        throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
    }
  }
};
var addNestedSelections = function(type, context, info, state, selections2, indirectPath, expectedType = type) {
  let parentType = type;
  for (const selection of selections2.selections) {
    switch (selection.kind) {
      case Kind.FIELD:
        if (expectedType.name !== type.name) {
          continue;
        }
        addFieldSelection(type, context, info, state, selection, indirectPath);
        continue;
      case Kind.FRAGMENT_SPREAD:
        var _parentType_extensions;
        parentType = info.schema.getType(info.fragments[selection.name.value].typeCondition.name.value);
        addNestedSelections(parentType, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath, ((_parentType_extensions = parentType.extensions) === null || _parentType_extensions === undefined ? undefined : _parentType_extensions.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
        continue;
      case Kind.INLINE_FRAGMENT:
        var _parentType_extensions1;
        parentType = selection.typeCondition ? info.schema.getType(selection.typeCondition.name.value) : type;
        addNestedSelections(parentType, context, info, state, selection.selectionSet, indirectPath, ((_parentType_extensions1 = parentType.extensions) === null || _parentType_extensions1 === undefined ? undefined : _parentType_extensions1.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
        continue;
      default:
        throw new PothosValidationError(`Unsupported selection kind ${selection.kind}`);
    }
  }
};
var addFieldSelection = function(type, context, info, state, selection, indirectPath) {
  var _field_extensions;
  if (selection.name.value.startsWith("__") || fieldSkipped(info, selection)) {
    return;
  }
  const field2 = type.getFields()[selection.name.value];
  if (!field2) {
    throw new PothosValidationError(`Unknown field ${selection.name.value} on ${type.name}`);
  }
  const fieldSelect = (_field_extensions = field2.extensions) === null || _field_extensions === undefined ? undefined : _field_extensions.pothosPrismaSelect;
  let fieldSelectionMap;
  let mappings = {};
  if (typeof fieldSelect === "function") {
    const args = getArgumentValues(field2, selection, info.variableValues);
    fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude) => {
      const returnType = getNamedType(field2.type);
      const query3 = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
      const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info)) : indirectInclude;
      const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
      if (typeof query3 === "object" && Object.keys(query3).length > 0) {
        mergeSelection(fieldState, {
          select: {},
          ...query3
        });
      }
      if (!!(normalizedIndirectInclude === null || normalizedIndirectInclude === undefined ? undefined : normalizedIndirectInclude.path) && normalizedIndirectInclude.path.length > 0 || !!(normalizedIndirectInclude === null || normalizedIndirectInclude === undefined ? undefined : normalizedIndirectInclude.paths) && normalizedIndirectInclude.paths.length > 0) {
        var _this, _returnType_extensions;
        var _path, _normalizedIndirectInclude_paths;
        resolveIndirectIncludePaths(returnType, info, selection, (_path = (_this = (_returnType_extensions = returnType.extensions) === null || _returnType_extensions === undefined ? undefined : _returnType_extensions.pothosPrismaIndirectInclude) === null || _this === undefined ? undefined : _this.path) !== null && _path !== undefined ? _path : [], (_normalizedIndirectInclude_paths = normalizedIndirectInclude.paths) !== null && _normalizedIndirectInclude_paths !== undefined ? _normalizedIndirectInclude_paths : [
          normalizedIndirectInclude.path
        ], [], (resolvedType, resolvedField, path) => {
          addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
        });
      }
      addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
      mappings = fieldState.mappings;
      return selectionToQuery(fieldState);
    }, (path) => {
      if (path.length === 0) {
        return selection;
      }
      const returnType = getNamedType(field2.type);
      let node3 = null;
      resolveIndirectInclude(returnType, info, selection, path.map((name) => ({
        name
      })), [], (_, resolvedField) => {
        node3 = resolvedField;
      });
      return node3;
    });
  } else {
    fieldSelectionMap = {
      select: fieldSelect
    };
  }
  if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
    var _selection_alias;
    mergeSelection(state, fieldSelectionMap);
    var _selection_alias_value;
    state.mappings[(_selection_alias_value = (_selection_alias = selection.alias) === null || _selection_alias === undefined ? undefined : _selection_alias.value) !== null && _selection_alias_value !== undefined ? _selection_alias_value : selection.name.value] = {
      field: selection.name.value,
      type: type.name,
      mappings,
      indirectPath
    };
  }
};
function queryFromInfo({ context, info, typeName, select, path = [], paths = [], withUsageCheck = false }) {
  const returnType = getNamedType(info.returnType);
  const type = typeName ? info.schema.getTypeMap()[typeName] : returnType;
  let state;
  const initialSelection = select ? {
    select
  } : undefined;
  if (path.length > 0 || paths.length > 0) {
    var _returnType_extensions;
    const { pothosPrismaIndirectInclude } = (_returnType_extensions = returnType.extensions) !== null && _returnType_extensions !== undefined ? _returnType_extensions : {};
    var _pothosPrismaIndirectInclude_path;
    resolveIndirectInclude(returnType, info, info.fieldNodes[0], (_pothosPrismaIndirectInclude_path = pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === undefined ? undefined : pothosPrismaIndirectInclude.path) !== null && _pothosPrismaIndirectInclude_path !== undefined ? _pothosPrismaIndirectInclude_path : [], [], (indirectType, indirectField, subPath) => {
      resolveIndirectIncludePaths(indirectType, info, indirectField, [], paths.length > 0 ? paths.map((p) => p.map((n) => typeof n === "string" ? {
        name: n
      } : n)) : [
        path.map((n) => typeof n === "string" ? {
          name: n
        } : n)
      ], subPath, (resolvedType, resolvedField, nested) => {
        state = createStateForType(typeName ? type : resolvedType, info, undefined, initialSelection);
        addTypeSelectionsForField(typeName ? type : resolvedType, context, info, state, resolvedField, nested);
      });
    });
  } else {
    state = createStateForType(type, info, undefined, initialSelection);
    addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
  }
  if (!state) {
    state = createStateForType(type, info, undefined, initialSelection);
  }
  setLoaderMappings(context, info, state.mappings);
  const query3 = selectionToQuery(state);
  return withUsageCheck ? wrapWithUsageCheck(query3) : query3;
}
function selectionStateFromInfo(context, info, typeName) {
  const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
  const state = createStateForType(type, info);
  if (!(isObjectType(type) || isInterfaceType(type))) {
    throw new PothosValidationError("Prisma plugin can only resolve includes for object and interface types");
  }
  addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
  return state;
}
var createStateForType = function(type, info, parent, initialSelections) {
  var _targetType_extensions, _targetType_extensions1;
  const targetType = getIndirectType(type, info);
  const fieldMap = (_targetType_extensions = targetType.extensions) === null || _targetType_extensions === undefined ? undefined : _targetType_extensions.pothosPrismaFieldMap;
  const state = createState(fieldMap, ((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === undefined ? undefined : _targetType_extensions1.pothosPrismaSelect) ? "select" : "include", parent);
  if (initialSelections) {
    mergeSelection(state, initialSelections);
  }
  return state;
};
function getIndirectType(type, info) {
  var _targetType_extensions;
  let targetType = type;
  while ((_targetType_extensions = targetType.extensions) === null || _targetType_extensions === undefined ? undefined : _targetType_extensions.pothosPrismaIndirectInclude) {
    var _targetType_extensions1;
    targetType = info.schema.getType(((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === undefined ? undefined : _targetType_extensions1.pothosPrismaIndirectInclude).getType());
  }
  return targetType;
}
var normalizeInclude = function(path, type) {
  let currentType = type;
  const normalized = [];
  if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
    throw new PothosValidationError(`Expected ${currentType} to be an Object type`);
  }
  for (const fieldName of path) {
    const field2 = currentType.getFields()[fieldName];
    if (!field2) {
      throw new PothosValidationError(`Expected ${currentType} to have a field ${fieldName}`);
    }
    currentType = getNamedType(field2.type);
    if (!(isObjectType(currentType) || isInterfaceType(currentType))) {
      throw new PothosValidationError(`Expected ${currentType} to be an Object or Interface type`);
    }
    normalized.push({
      name: fieldName,
      type: currentType.name
    });
  }
  return {
    getType: () => normalized.length > 0 ? normalized[normalized.length - 1].type : type.name,
    path: normalized
  };
};
var fieldSkipped = function(info, selection) {
  const skip = getDirectiveValues(GraphQLSkipDirective, selection, info.variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return true;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, selection, info.variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return true;
  }
  return false;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/model-loader.js
var createResolvablePromise = function() {
  let resolveFn;
  let rejectFn;
  const promise = new Promise((resolve, reject2) => {
    resolveFn = resolve;
    rejectFn = reject2;
  });
  return {
    promise,
    resolve: resolveFn,
    reject: rejectFn
  };
};

class ModelLoader {
  static forRef(ref, modelName, findUnique, builder5) {
    return createContextCache((model) => new ModelLoader(model, builder5, modelName, findUnique === null ? () => {
      throw new PothosSchemaError(`Missing findUnique for ${ref.name}`);
    } : findUnique !== null && findUnique !== undefined ? findUnique : this.getDefaultFindUnique(ref, modelName, builder5)));
  }
  static getFindUnique(findBy) {
    if (typeof findBy === "string") {
      return (parent) => ({
        [findBy]: parent[findBy]
      });
    }
    const { fields, name: primaryKeyName } = findBy;
    return (parent) => {
      const primaryKey = {};
      for (const key of fields) {
        primaryKey[key] = parent[key];
      }
      return {
        [primaryKeyName !== null && primaryKeyName !== undefined ? primaryKeyName : fields.join("_")]: primaryKey
      };
    };
  }
  static getDefaultFindBy(ref, modelName, builder5) {
    const model = getModel(modelName, builder5);
    const idField = model.fields.find((field2) => field2.isId);
    const uniqueField = model.fields.find((field2) => field2.isRequired && field2.isUnique);
    const uniqueIndex = model.uniqueIndexes.find((idx) => idx.fields.every((field2) => {
      var _model_fields_find;
      return (_model_fields_find = model.fields.find((f) => f.name === field2)) === null || _model_fields_find === undefined ? undefined : _model_fields_find.isRequired;
    }));
    let findBy;
    if (model.primaryKey) {
      findBy = model.primaryKey;
    } else if (idField) {
      findBy = idField.name;
    } else if (uniqueField) {
      findBy = uniqueField.name;
    } else if (uniqueIndex) {
      findBy = uniqueIndex;
    }
    if (!findBy) {
      throw new PothosSchemaError(`Missing findUnique for ${ref.name}`);
    }
    return findBy;
  }
  static getDefaultFindUnique(ref, modelName, builder5) {
    const findBy = this.getDefaultFindBy(ref, modelName, builder5);
    return this.getFindUnique(findBy);
  }
  static getDefaultIDSelection(ref, modelName, builder5) {
    const findBy = this.getDefaultFindBy(ref, modelName, builder5);
    if (typeof findBy === "string") {
      return {
        [findBy]: true
      };
    }
    const result = {};
    for (const field2 of findBy.fields) {
      result[field2] = true;
    }
    return result;
  }
  static getCursorSelection(ref, modelName, cursor, builder5) {
    const model = getModel(modelName, builder5);
    const field2 = model.fields.find((field3) => field3.name === cursor);
    if (field2) {
      return {
        [field2.name]: true
      };
    }
    const index = [
      model.primaryKey,
      ...model.uniqueIndexes
    ].filter(Boolean).find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
    });
    if (!index) {
      throw new PothosSchemaError(`Can't find "${cursor}" field or index for ${ref.name}`);
    }
    const selection = {};
    for (const column of index.fields) {
      selection[column] = true;
    }
    return selection;
  }
  static getFindUniqueForField(ref, modelName, fieldName, builder5) {
    var _model_primaryKey, _model_primaryKey1;
    const model = getModel(modelName, builder5);
    const uniqueIndex = model.uniqueIndexes.find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
    });
    let findBy;
    var _model_primaryKey_name;
    if (model.fields.some((field2) => field2.name === fieldName)) {
      findBy = fieldName;
    } else if (model.primaryKey && ((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
      findBy = model.primaryKey;
    } else if (uniqueIndex) {
      findBy = uniqueIndex;
    }
    if (!findBy) {
      throw new PothosSchemaError(`Unable to find field or index for ${fieldName} of ${ref.name}`);
    }
    return this.getFindUnique(findBy);
  }
  getSelection(info) {
    const key = cacheKey(info.parentType.name, info.path);
    if (!this.queryCache.has(key)) {
      const selection = selectionStateFromInfo(this.context, info);
      this.queryCache.set(key, {
        selection,
        query: selectionToQuery(selection)
      });
    }
    return this.queryCache.get(key);
  }
  async loadSelection(info, model) {
    const { selection, query: query3 } = this.getSelection(info);
    const result = await this.stageQuery(selection, query3, model);
    if (result) {
      const mappings = selection.mappings[info.path.key];
      if (mappings) {
        setLoaderMappings(this.context, info, mappings.mappings);
      }
    }
    return result;
  }
  async stageQuery(selection, query3, model) {
    for (const entry of this.staged) {
      if (selectionCompatible(entry.state, query3)) {
        mergeSelection(entry.state, query3);
        if (!entry.models.has(model)) {
          entry.models.set(model, createResolvablePromise());
        }
        return entry.models.get(model).promise;
      }
    }
    return this.initLoad(selection, model);
  }
  async initLoad(state, initialModel) {
    const models = new Map;
    const promise = createResolvablePromise();
    models.set(initialModel, promise);
    const entry = {
      models,
      state
    };
    this.staged.add(entry);
    const nextTick = createResolvablePromise();
    this.tick.then(() => {
      this.staged.delete(entry);
      for (const [model, { resolve, reject: reject2 }] of entry.models) {
        if (this.delegate.findUniqueOrThrow) {
          this.delegate.findUniqueOrThrow({
            ...selectionToQuery(state),
            where: {
              ...this.findUnique(model, this.context)
            }
          }).then(resolve, reject2);
        } else {
          this.delegate.findUnique({
            rejectOnNotFound: true,
            ...selectionToQuery(state),
            where: {
              ...this.findUnique(model, this.context)
            }
          }).then(resolve, reject2);
        }
      }
    });
    setTimeout(() => void nextTick.resolve(), 0);
    this.tick = nextTick.promise;
    return promise.promise;
  }
  constructor(context, builder5, modelName, findUnique) {
    _define_property3(this, "context", undefined);
    _define_property3(this, "builder", undefined);
    _define_property3(this, "findUnique", undefined);
    _define_property3(this, "modelName", undefined);
    _define_property3(this, "queryCache", new Map);
    _define_property3(this, "staged", new Set);
    _define_property3(this, "delegate", undefined);
    _define_property3(this, "tick", Promise.resolve());
    this.context = context;
    this.builder = builder5;
    this.findUnique = findUnique;
    this.modelName = modelName;
    this.delegate = getDelegateFromModel(getClient(this.builder, this.context), this.modelName);
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/node-ref.js
class PrismaNodeRef extends PrismaObjectRef {
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var _define_property4 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/cursors.js
function formatCursorChunk(value) {
  if (value instanceof Date) {
    return `D:${String(Number(value))}`;
  }
  switch (typeof value) {
    case "number":
      return `N:${value}`;
    case "string":
      return `S:${value}`;
    case "bigint":
      return `I:${value}`;
    default:
      throw new PothosValidationError(`Unsupported cursor type ${typeof value}`);
  }
}
function cursorFormatter(fields) {
  return (value) => {
    if (typeof fields === "string") {
      return encodeBase64(`GPC:${formatCursorChunk(value[fields])}`);
    }
    return encodeBase64(`GPC:J:${JSON.stringify(fields.map((name) => value[name]))}`);
  };
}
function parsePrismaCursor(cursor) {
  if (typeof cursor !== "string") {
    throw new PothosValidationError("Cursor must be a string");
  }
  try {
    const decoded = decodeBase64(cursor);
    const [, type, value] = decoded.match(/^GPC:(\w):(.*)/);
    switch (type) {
      case "S":
        return value;
      case "N":
        return Number.parseInt(value, 10);
      case "D":
        return new Date(Number.parseInt(value, 10));
      case "J":
        return JSON.parse(value);
      case "I":
        return BigInt(value);
      default:
        throw new PothosValidationError(`Invalid cursor type ${type}`);
    }
  } catch {
    throw new PothosValidationError(`Invalid cursor: ${cursor}`);
  }
}
function parseID(id, dataType) {
  if (!id) {
    return id;
  }
  switch (dataType) {
    case "String":
      return id;
    case "Int":
      return Number.parseInt(id, 10);
    case "BigInt":
      return BigInt(id);
    case "Boolean":
      return id !== "false";
    case "Float":
    case "Decimal":
      return Number.parseFloat(id);
    case "DateTime":
      return new Date(id);
    case "Json":
      return JSON.parse(id);
    case "Byte":
      return Buffer.from(id, "base64");
    default:
      return id;
  }
}
function getDefaultIDSerializer(modelName, fieldName, builder5) {
  var _model_primaryKey, _model_primaryKey1;
  const model = getModel(modelName, builder5);
  const field2 = model.fields.find((f) => f.name === fieldName);
  if (field2) {
    return (parent) => serializeID(parent[fieldName], field2.type);
  }
  var _model_primaryKey_name;
  if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
    const fields = model.primaryKey.fields.map((n) => model.fields.find((f) => f.name === n));
    return (parent) => JSON.stringify(fields.map((f) => serializeID(parent[f.name], f.kind)));
  }
  const index = model.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
  });
  if (index) {
    const fields = index.fields.map((n) => model.fields.find((f) => f.name === n));
    return (parent) => JSON.stringify(fields.map((f) => serializeID(parent[f.name], f.kind)));
  }
  throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
}
function getDefaultIDParser(modelName, fieldName, builder5) {
  var _model_primaryKey, _model_primaryKey1;
  if (!fieldName) {
    throw new PothosValidationError("Missing field name");
  }
  const model = getModel(modelName, builder5);
  const field2 = model.fields.find((f) => f.name === fieldName);
  if (field2) {
    return (id) => parseID(id, field2.type);
  }
  const index = model.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === fieldName;
  });
  let fields;
  var _model_primaryKey_name;
  if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === undefined ? undefined : _model_primaryKey.name) !== null && _model_primaryKey_name !== undefined ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === undefined ? undefined : _model_primaryKey1.fields.join("_")) === fieldName) {
    fields = model.primaryKey.fields.map((n) => model.fields.find((f) => f.name === n));
  } else if (index) {
    fields = index.fields.map((n) => model.fields.find((f) => f.name === n));
  }
  if (!fields) {
    throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
  }
  return (id) => {
    const parts = JSON.parse(id);
    if (!Array.isArray(parts)) {
      throw new PothosValidationError(`Invalid id received for ${fieldName} of ${modelName}`);
    }
    const result = {};
    for (let i = 0;i < fields.length; i += 1) {
      result[fields[i].name] = parseID(parts[i], fields[i].type);
    }
    return result;
  };
}
function serializeID(id, dataType) {
  switch (dataType) {
    case "Json":
      return JSON.stringify(id);
    case "Byte":
      return id.toString("base64");
    default:
      return String(id);
  }
}
function parseCompositeCursor(fields) {
  return (cursor) => {
    const parsed = parsePrismaCursor(cursor);
    if (!Array.isArray(parsed)) {
      throw new PothosValidationError(`Expected compound cursor to contain an array, but got ${parsed}`);
    }
    const record = {};
    fields.forEach((field2, i) => {
      record[field2] = parsed[i];
    });
    return record;
  };
}
function prismaCursorConnectionQuery({ args, ctx, maxSize = DEFAULT_MAX_SIZE, defaultSize = DEFAULT_SIZE, parseCursor }) {
  const { before, after, first, last } = args;
  if (first != null && first < 0) {
    throw new PothosValidationError("Argument \"first\" must be a non-negative integer");
  }
  if (last != null && last < 0) {
    throw new PothosValidationError("Argument \"last\" must be a non-negative integer");
  }
  if (before && after) {
    throw new PothosValidationError("Arguments \"before\" and \"after\" are not supported at the same time");
  }
  if (before != null && first != null) {
    throw new PothosValidationError("Arguments \"before\" and \"first\" are not supported at the same time");
  }
  if (after != null && last != null) {
    throw new PothosValidationError("Arguments \"after\" and \"last\" are not supported at the same time");
  }
  const cursor = before !== null && before !== undefined ? before : after;
  const maxSizeForConnection = typeof maxSize === "function" ? maxSize(args, ctx) : maxSize;
  const defaultSizeForConnection = typeof defaultSize === "function" ? defaultSize(args, ctx) : defaultSize;
  var _ref;
  let take = Math.min((_ref = first !== null && first !== undefined ? first : last) !== null && _ref !== undefined ? _ref : defaultSizeForConnection, maxSizeForConnection) + 1;
  if (before || last) {
    take = -take;
  }
  return cursor == null ? {
    take,
    skip: 0
  } : {
    cursor: parseCursor(cursor),
    take,
    skip: 1
  };
}
function wrapConnectionResult(parent, results, args, take, cursor, totalCount, resolveNode) {
  var _edges_, _edges_1;
  const gotFullResults = results.length === Math.abs(take);
  const hasNextPage = args.before ? true : args.last ? false : gotFullResults;
  const hasPreviousPage = args.after ? true : args.before || args.last ? gotFullResults : false;
  const nodes = gotFullResults ? results.slice(take < 0 ? 1 : 0, take < 0 ? results.length : -1) : results;
  const connection2 = {
    parent,
    args,
    totalCount,
    edges: [],
    pageInfo: {
      startCursor: null,
      endCursor: null,
      hasPreviousPage,
      hasNextPage
    }
  };
  const edges = nodes.map((value, index) => value == null ? null : resolveNode ? {
    connection: connection2,
    ...value,
    cursor: cursor(value),
    node: resolveNode(value)
  } : {
    connection: connection2,
    cursor: cursor(value),
    node: value
  });
  connection2.edges = edges;
  var _edges__cursor;
  connection2.pageInfo.startCursor = (_edges__cursor = (_edges_ = edges[0]) === null || _edges_ === undefined ? undefined : _edges_.cursor) !== null && _edges__cursor !== undefined ? _edges__cursor : null;
  var _edges__cursor1;
  connection2.pageInfo.endCursor = (_edges__cursor1 = (_edges_1 = edges[edges.length - 1]) === null || _edges_1 === undefined ? undefined : _edges_1.cursor) !== null && _edges__cursor1 !== undefined ? _edges__cursor1 : null;
  return connection2;
}
async function resolvePrismaCursorConnection(options, cursor, resolve) {
  const query3 = prismaCursorConnectionQuery(options);
  const results = await resolve(extendWithUsage(options.query, query3));
  if (!results) {
    return results;
  }
  return wrapConnectionResult(options.parent, results, options.args, query3.take, cursor, options.totalCount);
}
function getCursorFormatter(name, builder5, cursor) {
  var _modelData_primaryKey, _modelData_primaryKey1;
  const modelData = getModel(name, builder5);
  var _modelData_primaryKey_name;
  const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === undefined ? undefined : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== undefined ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === undefined ? undefined : _modelData_primaryKey1.fields.join("_");
  if (primaryKey === cursor) {
    return cursorFormatter(modelData.primaryKey.fields);
  }
  const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
    var _idx_name;
    return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
  });
  var _uniqueIndex_fields;
  return cursorFormatter((_uniqueIndex_fields = uniqueIndex === null || uniqueIndex === undefined ? undefined : uniqueIndex.fields) !== null && _uniqueIndex_fields !== undefined ? _uniqueIndex_fields : cursor);
}
function getCursorParser(name, builder5, cursor) {
  var _modelData_primaryKey, _modelData_primaryKey1;
  const modelData = getModel(name, builder5);
  var _modelData_primaryKey_name;
  const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === undefined ? undefined : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== undefined ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === undefined ? undefined : _modelData_primaryKey1.fields.join("_");
  let parser = parsePrismaCursor;
  if (primaryKey === cursor) {
    parser = parseCompositeCursor(modelData.primaryKey.fields);
  } else {
    const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
      var _idx_name;
      return ((_idx_name = idx.name) !== null && _idx_name !== undefined ? _idx_name : idx.fields.join("_")) === cursor;
    });
    if (uniqueIndex) {
      parser = parseCompositeCursor(uniqueIndex.fields);
    }
  }
  return (rawCursor) => ({
    [cursor]: parser(rawCursor)
  });
}
var DEFAULT_MAX_SIZE = 100;
var DEFAULT_SIZE = 20;

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/description.js
function getFieldDescription(model, builder5, fieldName, description) {
  const { exposeDescriptions } = builder5.options.prisma;
  const usePrismaDescription = exposeDescriptions === true || typeof exposeDescriptions === "object" && (exposeDescriptions === null || exposeDescriptions === undefined ? undefined : exposeDescriptions.fields) === true;
  return (usePrismaDescription ? description !== null && description !== undefined ? description : getFieldData(model, builder5, fieldName).documentation : description) || undefined;
}
function getModelDescription(model, builder5, description) {
  const { exposeDescriptions } = builder5.options.prisma;
  const usePrismaDescription = exposeDescriptions === true || typeof exposeDescriptions === "object" && (exposeDescriptions === null || exposeDescriptions === undefined ? undefined : exposeDescriptions.models) === true;
  return (usePrismaDescription ? description !== null && description !== undefined ? description : getModel(model, builder5).documentation : description) || undefined;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var addScopes = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var withAuth = function(scopes) {
  return addScopes(scopes, new PrismaObjectFieldBuilder(this.typename, this.builder, this.model, this.prismaFieldMap));
};
var RootBuilder = RootFieldBuilder2;

class PrismaObjectFieldBuilder extends RootBuilder {
  relation(name, ...allArgs) {
    const [{ description: description2, ...options } = {}] = allArgs;
    const relationField = getRelation(this.model, this.builder, name);
    var _options_type;
    const ref = (_options_type = options.type) !== null && _options_type !== undefined ? _options_type : getRefFromModel(relationField.type, this.builder);
    const { query: query3 = {}, resolve, extensions, ...rest } = options;
    const relationSelect = (args, context, nestedQuery) => ({
      select: {
        [name]: nestedQuery(query3)
      }
    });
    return this.field({
      ...rest,
      type: relationField.isList ? [
        ref
      ] : ref,
      description: getFieldDescription(this.model, this.builder, name, description2),
      extensions: {
        ...extensions,
        pothosPrismaSelect: relationSelect,
        pothosPrismaLoaded: (value) => value[name] !== undefined,
        pothosPrismaFallback: resolve && ((q, parent, args, context, info) => resolve({
          ...q,
          ...typeof query3 === "function" ? query3(args, context) : query3
        }, parent, args, context, info))
      },
      resolve: (parent) => parent[name]
    });
  }
  relationCount(name, ...allArgs) {
    const [{ where, ...options } = {}] = allArgs;
    const { resolve, ...rest } = options;
    const countSelect = typeof where === "function" ? (args, context) => ({
      _count: {
        select: {
          [name]: {
            where: where(args, context)
          }
        }
      }
    }) : {
      _count: {
        select: {
          [name]: where ? {
            where
          } : true
        }
      }
    };
    return this.field({
      ...rest,
      type: "Int",
      nullable: false,
      select: countSelect,
      resolve: (parent, args, context, info) => {
        var _parent__count;
        return (_parent__count = parent._count) === null || _parent__count === undefined ? undefined : _parent__count[name];
      }
    });
  }
  variant(variant, ...allArgs) {
    const [{ isNull, nullable, ...options } = {}] = allArgs;
    const ref = typeof variant === "string" ? getRefFromModel(variant, this.builder) : variant;
    const selfSelect = (args, context, nestedQuery) => nestedQuery({});
    return this.field({
      ...options,
      type: ref,
      extensions: {
        ...options === null || options === undefined ? undefined : options.extensions,
        pothosPrismaSelect: selfSelect
      },
      nullable: nullable !== null && nullable !== undefined ? nullable : !!isNull,
      resolve: isNull ? (parent, args, context, info) => {
        const parentIsNull = isNull(parent, args, context, info);
        if (parentIsNull) {
          if (isThenable(parentIsNull)) {
            return parentIsNull.then((resolved) => resolved ? null : parent);
          }
          return null;
        }
        return parent;
      } : (parent) => parent
    });
  }
  expose(name, ...args) {
    var _typeConfig_extensions;
    const [options = {}] = args;
    const typeConfig = this.builder.configStore.getTypeConfig(this.typename);
    const usingSelect = !!((_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === undefined ? undefined : _typeConfig_extensions.pothosPrismaSelect);
    return this.exposeField(name, {
      ...options,
      description: getFieldDescription(this.model, this.builder, name, options.description),
      extensions: {
        ...options.extensions,
        pothosPrismaVariant: name,
        pothosPrismaSelect: usingSelect && {
          [name]: true
        }
      }
    });
  }
  createExpose(type) {
    return (name, ...args) => {
      const [options = {}] = args;
      return this.expose(name, {
        ...options,
        type
      });
    };
  }
  constructor(name, builder5, model, fieldMap, graphqlKind = "Object") {
    super(name, builder5, "PrismaObject", graphqlKind);
    _define_property4(this, "model", undefined);
    _define_property4(this, "prismaFieldMap", undefined);
    _define_property4(this, "exposeBoolean", this.createExpose("Boolean"));
    _define_property4(this, "exposeFloat", this.createExpose("Float"));
    _define_property4(this, "exposeInt", this.createExpose("Int"));
    _define_property4(this, "exposeID", this.createExpose("ID"));
    _define_property4(this, "exposeString", this.createExpose("String"));
    _define_property4(this, "exposeBooleanList", this.createExpose([
      "Boolean"
    ]));
    _define_property4(this, "exposeFloatList", this.createExpose([
      "Float"
    ]));
    _define_property4(this, "exposeIntList", this.createExpose([
      "Int"
    ]));
    _define_property4(this, "exposeIDList", this.createExpose([
      "ID"
    ]));
    _define_property4(this, "exposeStringList", this.createExpose([
      "String"
    ]));
    _define_property4(this, "withAuth", withAuth);
    _define_property4(this, "relatedConnection", function relatedConnection(name2, { maxSize, defaultSize, cursor: cursorValue, query: query3, resolve, extensions, totalCount, description: description2, ...options }, connectionOptions = {}, edgeOptions = {}) {
      const relationField = getRelation(this.model, this.builder, name2);
      var _options_type;
      const ref = (_options_type = options.type) !== null && _options_type !== undefined ? _options_type : getRefFromModel(relationField.type, this.builder);
      let typeName;
      const formatCursor = getCursorFormatter(relationField.type, this.builder, cursorValue);
      const parseCursor = getCursorParser(relationField.type, this.builder, cursorValue);
      const getQuery = (args, ctx) => {
        const connectionQuery = prismaCursorConnectionQuery({
          parseCursor,
          ctx,
          maxSize,
          defaultSize,
          args
        });
        var _ref;
        const { take = connectionQuery.take, skip = connectionQuery.skip, cursor = connectionQuery.cursor, ...fieldQuery } = (_ref = typeof query3 === "function" ? query3(args, ctx) : query3) !== null && _ref !== undefined ? _ref : {};
        return {
          ...fieldQuery,
          ...connectionQuery,
          take,
          skip,
          ...cursor ? {
            cursor
          } : {}
        };
      };
      const cursorSelection = ModelLoader.getCursorSelection(ref, relationField.type, cursorValue, this.builder);
      const relationSelect = (args, context, nestedQuery, getSelection) => {
        var _selection_selectionSet;
        typeName !== null && typeName !== undefined || (typeName = this.builder.configStore.getTypeConfig(ref).name);
        const nested = nestedQuery(getQuery(args, context), {
          getType: () => typeName,
          paths: [
            [
              {
                name: "nodes"
              }
            ],
            [
              {
                name: "edges"
              },
              {
                name: "node"
              }
            ]
          ]
        });
        const selection = getSelection([]);
        const hasTotalCount = totalCount && !!getSelection([
          "totalCount"
        ]);
        const totalCountOnly = ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && hasTotalCount;
        const countSelect = this.builder.options.prisma.filterConnectionTotalCount ? nested.where ? {
          where: nested.where
        } : true : true;
        return {
          select: {
            ...hasTotalCount ? {
              _count: {
                select: {
                  [name2]: countSelect
                }
              }
            } : {},
            [name2]: totalCountOnly ? undefined : (nested === null || nested === undefined ? undefined : nested.select) ? {
              ...nested,
              select: {
                ...cursorSelection,
                ...nested.select
              }
            } : nested
          }
        };
      };
      const fieldRef = this.connection({
        ...options,
        description: getFieldDescription(this.model, this.builder, name2, description2),
        extensions: {
          ...extensions,
          pothosPrismaSelect: relationSelect,
          pothosPrismaLoaded: (value, info) => {
            const returnType = getNamedType(info.returnType);
            const fields = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
            const selections3 = info.fieldNodes;
            const totalCountOnly = selections3.every((selection) => {
              var _selection_selectionSet;
              return ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && selection.selectionSet.selections.every((s) => {
                var _fields_s_name_value_extensions, _fields_s_name_value;
                return s.kind === Kind.FIELD && ((_fields_s_name_value = fields[s.name.value]) === null || _fields_s_name_value === undefined ? undefined : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === undefined ? undefined : _fields_s_name_value_extensions.pothosPrismaTotalCount);
              });
            });
            return totalCountOnly || value[name2] !== undefined;
          },
          pothosPrismaFallback: resolve && ((q, parent, args, context, info) => Promise.resolve(resolve({
            ...q,
            ...getQuery(args, context)
          }, parent, args, context, info)).then((result) => wrapConnectionResult(parent, result, args, q.take, formatCursor)))
        },
        type: ref,
        resolve: (parent, args, context) => {
          var _parent__count;
          const connectionQuery = getQuery(args, context);
          var _parent_name;
          return wrapConnectionResult(parent, (_parent_name = parent[name2]) !== null && _parent_name !== undefined ? _parent_name : [], args, connectionQuery.take, formatCursor, (_parent__count = parent._count) === null || _parent__count === undefined ? undefined : _parent__count[name2]);
        }
      }, connectionOptions instanceof ObjectRef2 ? connectionOptions : {
        ...connectionOptions,
        fields: totalCount ? (t) => {
          var _connectionOptions_fields;
          return {
            totalCount: t.int({
              nullable: false,
              extensions: {
                pothosPrismaTotalCount: true
              },
              resolve: (parent, args, context) => parent.totalCount
            }),
            ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === undefined ? undefined : _connectionOptions_fields.call(connectionOptions, t)
          };
        } : connectionOptions.fields
      }, edgeOptions);
      return fieldRef;
    });
    this.model = model;
    this.prismaFieldMap = fieldMap;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/util/relation-map.js
function createRelationMap({ models }) {
  const relationMap = new Map;
  if (Array.isArray(models)) {
    models.forEach((model) => {
      relationMap.set(model.name, {
        model: model.name,
        relations: new Map
      });
    });
    models.forEach((model) => {
      const map2 = relationMap.get(model.name).relations;
      model.fields.forEach((field2) => {
        if (field2.kind === "object" && relationMap.has(field2.type)) {
          map2.set(field2.name, relationMap.get(field2.type));
        }
      });
    });
  } else {
    Object.keys(models).forEach((name) => {
      relationMap.set(name, {
        model: name,
        relations: new Map
      });
    });
    Object.entries(models).forEach(([name, model]) => {
      const map2 = relationMap.get(name).relations;
      model.fields.forEach((field2) => {
        if (field2.kind === "object" && relationMap.has(field2.type)) {
          map2.set(field2.name, relationMap.get(field2.type));
        }
      });
    });
  }
  return relationMap;
}
var getRelationMap = createContextCache((datamodel5) => createRelationMap(datamodel5));

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/schema-builder.js
var schemaBuilderProto2 = esm_default.prototype;
schemaBuilderProto2.prismaObject = function prismaObject(type, { fields, findUnique, select, include, description: description3, ...options }) {
  const ref = options.variant ? new PrismaObjectRef(options.variant, type) : getRefFromModel(type, this);
  var _options_variant, _ref;
  const name = (_ref = (_options_variant = options.variant) !== null && _options_variant !== undefined ? _options_variant : options.name) !== null && _ref !== undefined ? _ref : type;
  const fieldMap = getRelationMap(getDMMF(this)).get(type);
  const idSelection = ModelLoader.getDefaultIDSelection(ref, type, this);
  ref.name = name;
  this.objectType(ref, {
    ...options,
    description: getModelDescription(type, this, description3),
    extensions: {
      ...options.extensions,
      pothosPrismaInclude: include,
      pothosPrismaModel: type,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: select && {
        ...idSelection,
        ...select
      },
      pothosPrismaLoader: ModelLoader.forRef(ref, type, findUnique, this)
    },
    name,
    fields: fields ? () => fields(new PrismaObjectFieldBuilder(name, this, type, getRelationMap(getDMMF(this)).get(type))) : undefined
  });
  return ref;
};
schemaBuilderProto2.prismaInterface = function prismaInterface(type, { fields, findUnique, select, include, description: description3, ...options }) {
  const ref = options.variant ? new PrismaInterfaceRef(options.variant, type) : getRefFromModel(type, this, "interface");
  var _options_variant, _ref;
  const name = (_ref = (_options_variant = options.variant) !== null && _options_variant !== undefined ? _options_variant : options.name) !== null && _ref !== undefined ? _ref : type;
  const fieldMap = getRelationMap(getDMMF(this)).get(type);
  const idSelection = ModelLoader.getDefaultIDSelection(ref, type, this);
  ref.name = name;
  this.interfaceType(ref, {
    ...options,
    description: getModelDescription(type, this, description3),
    extensions: {
      ...options.extensions,
      pothosPrismaInclude: include,
      pothosPrismaModel: type,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: select && {
        ...idSelection,
        ...select
      },
      pothosPrismaLoader: ModelLoader.forRef(ref, type, findUnique, this)
    },
    name,
    fields: fields ? () => fields(new PrismaObjectFieldBuilder(name, this, type, getRelationMap(getDMMF(this)).get(type), "Interface")) : undefined
  });
  return ref;
};
schemaBuilderProto2.prismaNode = function prismaNode(type, { id: { field: field2, resolve: rawResolve, ...idOptions }, findUnique: rawFindUnique, name, variant, nullable, ...options }) {
  var _this_nodeInterfaceRef, _this;
  const fieldName = field2;
  const interfaceRef = (_this_nodeInterfaceRef = (_this = this).nodeInterfaceRef) === null || _this_nodeInterfaceRef === undefined ? undefined : _this_nodeInterfaceRef.call(_this);
  const resolve = rawResolve !== null && rawResolve !== undefined ? rawResolve : getDefaultIDSerializer(type, fieldName, this);
  const idParser = fieldName ? getDefaultIDParser(type, fieldName, this) : undefined;
  var _ref;
  const typeName = (_ref = variant !== null && variant !== undefined ? variant : name) !== null && _ref !== undefined ? _ref : type;
  const nodeRef = new PrismaNodeRef(typeName, type);
  const findUnique = rawFindUnique ? (parent, context) => rawFindUnique(resolve(parent, context), context) : ModelLoader.getFindUniqueForField(nodeRef, type, fieldName, this);
  if (!interfaceRef) {
    throw new PothosError("builder.prismaNode requires @pothos/plugin-relay to be installed");
  }
  const extendedOptions = {
    ...options,
    name,
    variant,
    interfaces: [
      interfaceRef
    ],
    findUnique,
    loadWithoutCache: async (id, context, info) => {
      const query3 = queryFromInfo({
        context,
        info,
        typeName
      });
      const delegate = getDelegateFromModel(getClient(this, context), type);
      const record = await (delegate.findUniqueOrThrow && !nullable ? delegate.findUniqueOrThrow({
        ...query3,
        where: rawFindUnique ? rawFindUnique(id, context) : {
          [fieldName]: idParser(id)
        }
      }) : delegate.findUnique({
        ...query3,
        ...nullable ? {} : {
          rejectOnNotFound: true
        },
        where: rawFindUnique ? rawFindUnique(id, context) : {
          [fieldName]: idParser(id)
        }
      }));
      brandWithType(record, typeName);
      return record;
    }
  };
  const ref = this.prismaObject(type, extendedOptions);
  if (options.interfaces) {
    this.configStore.addInterfaces(typeName, options.interfaces);
  }
  this.configStore.onTypeConfig(ref, (nodeConfig) => {
    var _this_options_relayOptions;
    var _this_options_relayOptions_idFieldName;
    this.objectField(ref, (_this_options_relayOptions_idFieldName = (_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === undefined ? undefined : _this_options_relayOptions.idFieldName) !== null && _this_options_relayOptions_idFieldName !== undefined ? _this_options_relayOptions_idFieldName : "id", (t) => {
      var _this_options_relayOptions2;
      return t.globalID({
        ...(_this_options_relayOptions2 = this.options.relayOptions) === null || _this_options_relayOptions2 === undefined ? undefined : _this_options_relayOptions2.idFieldOptions,
        ...idOptions,
        nullable: false,
        args: {},
        resolve: (parent, args, context, info) => completeValue2(resolve(parent, context), (id) => ({
          type: nodeConfig.name,
          id
        }))
      });
    });
  });
  this.configStore.associateRefWithName(nodeRef, typeName);
  return nodeRef;
};
schemaBuilderProto2.prismaObjectField = function prismaObjectField(type, fieldName, field2) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => ({
      [fieldName]: field2(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName)))
    }));
  });
};
schemaBuilderProto2.prismaInterfaceField = function prismaInterfaceField(type, fieldName, field2) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => ({
      [fieldName]: field2(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName), "Interface"))
    }));
  });
};
schemaBuilderProto2.prismaObjectFields = function prismaObjectFields(type, fields) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => fields(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName))));
  });
};
schemaBuilderProto2.prismaInterfaceFields = function prismaInterfaceFields(type, fields) {
  const ref = typeof type === "string" ? getRefFromModel(type, this) : type;
  this.configStore.onTypeConfig(ref, ({ name }) => {
    this.configStore.addFields(ref, () => fields(new PrismaObjectFieldBuilder(name, this, ref.modelName, getRelationMap(getDMMF(this)).get(ref.modelName), "Interface")));
  });
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/field-builder.js
var checkIfQueryIsUsed = function(builder5, query3, info, result) {
  const { onUnusedQuery } = builder5.options.prisma || {};
  if (!onUnusedQuery) {
    return result;
  }
  if (isThenable(result)) {
    return result.then((resolved) => {
      if (!isUsed(query3)) {
        onUnused();
      }
      return resolved;
    });
  }
  if (!isUsed(query3)) {
    onUnused();
  }
  return result;
  function onUnused() {
    if (typeof onUnusedQuery === "function") {
      onUnusedQuery(info);
      return;
    }
    const message = `Prisma query was unused in resolver for ${info.parentType.name}.${info.fieldName}`;
    if (onUnusedQuery === "error") {
      throw new PothosError(message);
    } else if (onUnusedQuery === "warn") {
      console.warn(message);
    }
  }
};
var fieldBuilderProto2 = RootFieldBuilder2.prototype;
fieldBuilderProto2.prismaField = function prismaField({ type, resolve, ...options }) {
  const modelOrRef = Array.isArray(type) ? type[0] : type;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type) ? [
    typeRef
  ] : typeRef;
  return this.field({
    ...options,
    type: typeParam,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      return checkIfQueryIsUsed(this.builder, query3, info, resolve(query3, parent, args, context, info));
    }
  });
};
fieldBuilderProto2.prismaFieldWithInput = function prismaFieldWithInput({ type, resolve, ...options }) {
  const modelOrRef = Array.isArray(type) ? type[0] : type;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type) ? [
    typeRef
  ] : typeRef;
  return this.fieldWithInput({
    ...options,
    type: typeParam,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      return checkIfQueryIsUsed(this.builder, query3, info, resolve(query3, parent, args, context, info));
    }
  });
};
fieldBuilderProto2.prismaConnection = function prismaConnection({ type, cursor, maxSize, defaultSize, resolve, totalCount, ...options }, connectionOptions = {}, edgeOptions = {}) {
  var _this_builder_configStore_getTypeConfig_extensions;
  const ref = typeof type === "string" ? getRefFromModel(type, this.builder) : type;
  const typeName = this.builder.configStore.getTypeConfig(ref).name;
  const model = (_this_builder_configStore_getTypeConfig_extensions = this.builder.configStore.getTypeConfig(ref).extensions) === null || _this_builder_configStore_getTypeConfig_extensions === undefined ? undefined : _this_builder_configStore_getTypeConfig_extensions.pothosPrismaModel;
  const formatCursor = getCursorFormatter(model, this.builder, cursor);
  const parseCursor = getCursorParser(model, this.builder, cursor);
  const cursorSelection = ModelLoader.getCursorSelection(ref, model, cursor, this.builder);
  const fieldRef = this.connection({
    ...options,
    type: ref,
    resolve: (parent, args, context, info) => {
      var _this_builder_options_prisma;
      const query3 = queryFromInfo({
        context,
        info,
        select: cursorSelection,
        paths: [
          [
            "nodes"
          ],
          [
            "edges",
            "node"
          ]
        ],
        typeName,
        withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === undefined ? undefined : _this_builder_options_prisma.onUnusedQuery)
      });
      const returnType = getNamedType(info.returnType);
      const fields = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
      const selections3 = info.fieldNodes;
      const totalCountOnly = selections3.every((selection) => {
        var _selection_selectionSet;
        return ((_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === undefined ? undefined : _selection_selectionSet.selections.length) === 1 && selection.selectionSet.selections.every((s) => {
          var _fields_s_name_value_extensions, _fields_s_name_value;
          return s.kind === Kind.FIELD && ((_fields_s_name_value = fields[s.name.value]) === null || _fields_s_name_value === undefined ? undefined : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === undefined ? undefined : _fields_s_name_value_extensions.pothosPrismaTotalCount);
        });
      });
      return resolvePrismaCursorConnection({
        parent,
        query: query3,
        ctx: context,
        parseCursor,
        maxSize,
        defaultSize,
        args,
        totalCount: totalCount && (() => totalCount(parent, args, context, info))
      }, formatCursor, (q) => {
        if (totalCountOnly)
          return [];
        return checkIfQueryIsUsed(this.builder, query3, info, resolve(q, parent, args, context, info));
      });
    }
  }, connectionOptions instanceof ObjectRef2 ? connectionOptions : {
    ...connectionOptions,
    fields: totalCount ? (t) => {
      var _connectionOptions_fields;
      return {
        totalCount: t.int({
          nullable: false,
          extensions: {
            pothosPrismaTotalCount: true
          },
          resolve: (parent, args, context) => {
            var _parent_totalCount;
            return (_parent_totalCount = parent.totalCount) === null || _parent_totalCount === undefined ? undefined : _parent_totalCount.call(parent);
          }
        }),
        ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === undefined ? undefined : _connectionOptions_fields.call(connectionOptions, t)
      };
    } : connectionOptions.fields,
    extensions: {
      ...connectionOptions === null || connectionOptions === undefined ? undefined : connectionOptions.extensions
    }
  }, edgeOptions);
  return fieldRef;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/connection-helpers.js
var prismaModelKey2 = Symbol.for("Pothos.prismaModelKey");
// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/types.js
var prismaModelName = Symbol.for("Pothos.prismaModelName");

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma/esm/index.js
var pluginName2 = "prisma";
var esm_default3 = pluginName2;
class PrismaPlugin extends BasePlugin {
  onTypeConfig(typeConfig) {
    var _typeConfig_extensions;
    if (typeConfig.kind !== "Object" && typeConfig.kind !== "Interface") {
      return typeConfig;
    }
    let model = (_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === undefined ? undefined : _typeConfig_extensions.pothosPrismaModel;
    typeConfig.interfaces.forEach((iface) => {
      var _this_buildCache_getTypeConfig_extensions;
      const interfaceModel = (_this_buildCache_getTypeConfig_extensions = this.buildCache.getTypeConfig(iface, "Interface").extensions) === null || _this_buildCache_getTypeConfig_extensions === undefined ? undefined : _this_buildCache_getTypeConfig_extensions.pothosPrismaModel;
      if (interfaceModel) {
        if (model && model !== interfaceModel) {
          throw new PothosSchemaError(`PrismaObjects must be based on the same prisma model as any PrismaInterfaces they extend. ${typeConfig.name} uses ${model} and ${iface.name} uses ${interfaceModel}`);
        }
        model = interfaceModel;
      }
    });
    return {
      ...typeConfig,
      extensions: {
        ...typeConfig.extensions,
        pothosPrismaModel: model
      }
    };
  }
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "PrismaObject" && fieldConfig.pothosOptions.select) {
      const { select } = fieldConfig.pothosOptions;
      return {
        ...fieldConfig,
        extensions: {
          ...fieldConfig.extensions,
          pothosPrismaSelect: typeof select === "function" ? (args, ctx, nestedQuery) => ({
            select: select(args, ctx, nestedQuery)
          }) : select
        }
      };
    }
    return fieldConfig;
  }
  wrapResolve(resolver, fieldConfig) {
    var _fieldConfig_extensions, _fieldConfig_extensions1, _parentConfig_extensions, _fieldConfig_extensions2;
    if (fieldConfig.kind !== "PrismaObject" || !((_fieldConfig_extensions = fieldConfig.extensions) === null || _fieldConfig_extensions === undefined ? undefined : _fieldConfig_extensions.pothosPrismaSelect)) {
      return resolver;
    }
    const parentConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    const loadedCheck = (_fieldConfig_extensions1 = fieldConfig.extensions) === null || _fieldConfig_extensions1 === undefined ? undefined : _fieldConfig_extensions1.pothosPrismaLoaded;
    const loaderCache = (_parentConfig_extensions = parentConfig.extensions) === null || _parentConfig_extensions === undefined ? undefined : _parentConfig_extensions.pothosPrismaLoader;
    const fallback = (_fieldConfig_extensions2 = fieldConfig.extensions) === null || _fieldConfig_extensions2 === undefined ? undefined : _fieldConfig_extensions2.pothosPrismaFallback;
    const parentTypes = new Set([
      fieldConfig.parentType
    ]);
    if (parentConfig.kind === "Interface" || parentConfig.kind === "Object") {
      parentConfig.interfaces.forEach((iface) => {
        var _interfaceConfig_extensions;
        const interfaceConfig = this.buildCache.getTypeConfig(iface, "Interface");
        if ((_interfaceConfig_extensions = interfaceConfig.extensions) === null || _interfaceConfig_extensions === undefined ? undefined : _interfaceConfig_extensions.pothosPrismaModel) {
          parentTypes.add(interfaceConfig.name);
        }
      });
    }
    return (parent, args, context, info) => {
      let mapping = getLoaderMapping(context, info.path, info.parentType.name);
      if (!mapping) {
        for (const parentType of parentTypes) {
          mapping = getLoaderMapping(context, info.path, parentType);
          if (mapping) {
            break;
          }
        }
      }
      if ((!loadedCheck || loadedCheck(parent, info)) && mapping) {
        setLoaderMappings(context, info, mapping);
        return resolver(parent, args, context, info);
      }
      if (fallback) {
        return fallback(queryFromInfo({
          context,
          info
        }), parent, args, context, info);
      }
      return loaderCache(context).loadSelection(info, parent).then((result) => resolver(result, args, context, info));
    };
  }
  constructor(cache2) {
    super(cache2, pluginName2);
  }
}
esm_default.registerPlugin(pluginName2, PrismaPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma-utils/esm/schema-builder.js
var nameFromType = function(type, builder5) {
  if (typeof type === "string") {
    return type;
  }
  if (builder5.configStore.hasConfig(type)) {
    return builder5.configStore.getTypeConfig(type).name;
  }
  if (typeof type === "function" && ("name" in type)) {
    return type.name;
  }
  if (type instanceof BaseTypeRef2) {
    return type.name;
  }
  throw new PothosSchemaError(`Unable to determine name for type ${String(type)}`);
};
var capitalize2 = function(str) {
  return str[0].toUpperCase() + str.slice(1);
};
var schemaBuilder = esm_default.prototype;
var OrderByRefMap = new WeakMap;
var PrismaStringFilterModeRefMap = new WeakMap;
schemaBuilder.prismaFilter = function prismaFilter(type, { ops, name, ...options }) {
  const filterName = name !== null && name !== undefined ? name : `${nameFromType(type, this)}Filter`;
  const ref = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map2, op) => {
    map2[op] = {};
    return map2;
  }, {}) : ops;
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fields = {};
      for (const op of Object.keys(opsOptions)) {
        const isList = op === "in" || op === "notIn";
        let fieldType;
        switch (op) {
          case "not":
            fieldType = ref;
            break;
          case "in":
          case "notIn":
            fieldType = [
              type
            ];
            break;
          case "mode":
            fieldType = this.prismaStringFilterModeEnum();
            break;
          default:
            fieldType = type;
        }
        fields[op] = t.field({
          required: isList ? {
            list: false,
            items: true
          } : false,
          type: fieldType,
          ...opsOptions[op]
        });
      }
      return fields;
    }
  });
  return ref;
};
schemaBuilder.prismaStringFilterModeEnum = function prismaStringFilterModeEnum() {
  if (PrismaStringFilterModeRefMap.has(this)) {
    return PrismaStringFilterModeRefMap.get(this);
  }
  const ref = this.enumType("StringFilterMode", {
    values: {
      Default: {
        value: "default"
      },
      Insensitive: {
        value: "insensitive"
      }
    }
  });
  PrismaStringFilterModeRefMap.set(this, ref);
  return ref;
};
schemaBuilder.prismaListFilter = function prismaListFilter(type, { name, ops, ...options }) {
  let filterName = name;
  if (!filterName) {
    const typeName = nameFromType(type, this);
    filterName = typeName.endsWith("Filter") ? typeName.replace(/Filter$/, "ListFilter") : `List${typeName}`;
  }
  const ref = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map2, op) => {
    map2[op] = {};
    return map2;
  }, {}) : ops;
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fields = {};
      for (const op of Object.keys(opsOptions)) {
        fields[op] = t.field({
          required: false,
          type,
          ...opsOptions[op]
        });
      }
      return fields;
    }
  });
  return ref;
};
schemaBuilder.prismaScalarListFilter = function prismaScalarListFilter(type, { name, ops, ...options }) {
  let filterName = name;
  if (!filterName) {
    const typeName = nameFromType(type, this);
    filterName = `${typeName}ListFilter`;
  }
  const ref = this.inputRef(filterName);
  const opsOptions = Array.isArray(ops) ? ops.reduce((map2, op) => {
    map2[op] = {};
    return map2;
  }, {}) : ops;
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fields = {};
      for (const op of Object.keys(opsOptions)) {
        let fieldType = type;
        switch (op) {
          case "has":
            fieldType = type;
            break;
          case "equals":
          case "hasSome":
          case "hasEvery":
            fieldType = [
              type
            ];
            break;
          case "isEmpty":
            fieldType = "Boolean";
            break;
          default:
            throw new Error(`Invalid op ${op} for scalar list filter`);
        }
        fields[op] = t.field({
          required: false,
          type: fieldType,
          ...opsOptions[op]
        });
      }
      return fields;
    }
  });
  return ref;
};
schemaBuilder.orderByEnum = function orderByEnum() {
  if (OrderByRefMap.has(this)) {
    return OrderByRefMap.get(this);
  }
  const ref = this.enumType("OrderBy", {
    values: {
      Asc: {
        value: "asc"
      },
      Desc: {
        value: "desc"
      }
    }
  });
  OrderByRefMap.set(this, ref);
  return ref;
};
schemaBuilder.prismaOrderBy = function prismaOrderBy(type, { name, fields, ...options }) {
  const filterName = name !== null && name !== undefined ? name : `${nameFromType(type, this)}OrderBy`;
  const ref = this.inputRef(filterName);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields() : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (typeof fieldOption === "function") {
          const { type: fieldType, ...fieldOptions } = fieldOption();
          fieldDefs[field2] = t.field({
            required: false,
            ...fieldOptions,
            type: fieldType
          });
        } else if (typeof fieldOption === "boolean") {
          fieldDefs[field2] = t.field({
            required: false,
            type: this.orderByEnum()
          });
        } else {
          fieldDefs[field2] = t.field({
            required: false,
            type: fieldOption
          });
        }
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaWhere = function prismaWhere(type, { name, fields, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}Filter`);
  const model = getModel(type, this);
  const nullableFields = new Set(model.fields.filter((field2) => !field2.isRequired).map((field2) => field2.name));
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: {
        nullableFields
      }
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        if (field2 === "AND" || field2 === "OR" || field2 === "NOT") {
          fieldDefs[field2] = t.field({
            required: false,
            type: field2 === "NOT" ? ref : [
              ref
            ],
            ...typeof fieldOption === "object" ? fieldOption : {}
          });
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaWhereUnique = function prismaWhereUnique(type, { name, fields, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}UniqueFilter`);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaCreate = function prismaCreate(type, { name, fields, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}CreateInput`);
  const model = getModel(type, this);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldModel = model.fields.find(({ name: fieldName }) => fieldName === field2);
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: fieldModel.isRequired && !fieldModel.isList && !fieldModel.hasDefaultValue && !fieldModel.isUpdatedAt,
          type: fieldModel.isList && fieldModel.kind !== "object" ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaUpdate = function prismaUpdate(type, { name, fields, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}UpdateInput`);
  const model = getModel(type, this);
  const nullableFields = new Set(model.fields.filter((field2) => !field2.isRequired).map((field2) => field2.name));
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: {
        nullableFields
      }
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldModel = model.fields.find(({ name: fieldName }) => fieldName === field2);
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldModel.isList && fieldModel.kind !== "object" ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaCreateRelation = function prismaCreateRelation(type, relation, { name, fields, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}Create${capitalize2(relation)}RelationInput`);
  const model = getModel(type, this);
  const fieldModel = model.fields.find((field2) => field2.name === relation);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t) : fields;
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        fieldDefs[field2] = fieldOption instanceof InputFieldRef ? fieldOption : t.field({
          required: false,
          type: fieldModel.isList ? [
            fieldOption
          ] : fieldOption
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaUpdateRelation = function prismaUpdateRelation(type, relation, { name, fields, ...options }) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : `${nameFromType(type, this)}Update${capitalize2(relation)}RelationInput`);
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      const fieldMap = typeof fields === "function" ? fields(t) : fields;
      const model = getModel(type, this);
      const fieldModel = model.fields.find((field2) => field2.name === relation);
      Object.keys(fieldMap).forEach((field2) => {
        const fieldOption = fieldMap[field2];
        if (!fieldOption) {
          return;
        }
        if (fieldOption instanceof InputFieldRef) {
          fieldDefs[field2] = fieldOption;
        } else if (fieldModel.isList && (field2 === "update" || field2 === "updateMany")) {
          const { name: nestedName = `${ref.name}U${field2.slice(1)}`, where: whereType, data: dataType } = fieldOption;
          const nestedRef = this.inputType(nestedName, {
            fields: (t2) => ({
              where: whereType instanceof InputFieldRef ? whereType : t2.field({
                type: whereType
              }),
              data: dataType instanceof InputFieldRef ? dataType : t2.field({
                type: dataType
              })
            })
          });
          fieldDefs[field2] = t.field({
            required: false,
            type: [
              nestedRef
            ]
          });
        } else {
          fieldDefs[field2] = t.field({
            required: false,
            type: fieldModel.isList ? [
              fieldOption
            ] : fieldOption
          });
        }
      });
      return fieldDefs;
    }
  });
  return ref;
};
schemaBuilder.prismaIntAtomicUpdate = function prismaIntUpdateOperations({ name, ops = [
  "set",
  "increment",
  "decrement",
  "multiply",
  "divide"
], ...options } = {}) {
  const ref = this.inputRef(name !== null && name !== undefined ? name : "IntAtomicUpdate");
  ref.implement({
    ...options,
    extensions: {
      ...options.extensions,
      pothosPrismaInput: true
    },
    fields: (t) => {
      const fieldDefs = {};
      ops.forEach((op) => {
        fieldDefs[op] = t.field({
          required: false,
          type: "Int"
        });
      });
      return fieldDefs;
    }
  });
  return ref;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-prisma-utils/esm/index.js
var normalizeInputObject = function(object5, nullableFields) {
  if (!object5) {
    return object5;
  }
  if (typeof object5 !== "object") {
    return object5;
  }
  if (Array.isArray(object5)) {
    return object5.map((o) => normalizeInputObject(o, nullableFields));
  }
  const mapped = {};
  Object.keys(object5).forEach((key) => {
    mapped[key] = !nullableFields.has(key) && object5[key] === null ? undefined : object5[key];
  });
  return mapped;
};
var pluginName3 = "prismaUtils";
var esm_default4 = pluginName3;

class PrismaUtilsPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var _inputType_extensions;
      const inputType = this.buildCache.getTypeConfig(unwrapInputFieldType(inputField.type));
      if ((_inputType_extensions = inputType.extensions) === null || _inputType_extensions === undefined ? undefined : _inputType_extensions.pothosPrismaInput) {
        var _inputType_extensions1, _inputType_extensions2;
        return typeof ((_inputType_extensions1 = inputType.extensions) === null || _inputType_extensions1 === undefined ? undefined : _inputType_extensions1.pothosPrismaInput) === "object" ? (_inputType_extensions2 = inputType.extensions) === null || _inputType_extensions2 === undefined ? undefined : _inputType_extensions2.pothosPrismaInput : {
          nullableFields: new Set
        };
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    var _mapping_value_nullableFields;
    const argMapper = createInputValueMapper(argMappings, (inputObject, mapping) => {
      var _mapping_value;
      return normalizeInputObject(inputObject, (_mapping_value_nullableFields = (_mapping_value = mapping.value) === null || _mapping_value === undefined ? undefined : _mapping_value.nullableFields) !== null && _mapping_value_nullableFields !== undefined ? _mapping_value_nullableFields : new Set);
    });
    return (parent, args, context, info) => resolver(parent, argMapper(args), context, info);
  }
  constructor(cache2) {
    super(cache2, pluginName3);
  }
}
esm_default.registerPlugin(pluginName3, PrismaUtilsPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-with-input/esm/schema-builder.js
var capitalize3 = function(s) {
  return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
};
var rootBuilderProto = RootFieldBuilder2.prototype;
rootBuilderProto.fieldWithInput = function fieldWithInput({ typeOptions: { name: typeName, ...typeOptions } = {}, argOptions: { name: argName = "input", ...argOptions } = {}, args, input: input6, ...fieldOptions }) {
  var ref;
  const inputRef = this.builder.inputRef(typeName !== null && typeName !== undefined ? typeName : `UnnamedWithInputOn${this.typename}`);
  const fieldRef = this.field({
    args: {
      ...args,
      [argName]: this.arg({
        required: true,
        ...(ref = this.builder.options.withInput) === null || ref === undefined ? undefined : ref.argOptions,
        ...argOptions,
        type: inputRef
      })
    },
    ...fieldOptions
  });
  this.builder.configStore.onFieldUse(fieldRef, (config) => {
    var ref2;
    const name = typeName !== null && typeName !== undefined ? typeName : `${this.typename}${capitalize3(config.name)}Input`;
    this.builder.inputType(name, {
      fields: () => input6,
      ...(ref2 = this.builder.options.withInput) === null || ref2 === undefined ? undefined : ref2.typeOptions,
      ...typeOptions
    });
    this.builder.configStore.associateRefWithName(inputRef, name);
  });
  return fieldRef;
};
Object.defineProperty(rootBuilderProto, "input", {
  get: function getInputBuilder() {
    return new InputFieldBuilder2(this.builder, "InputObject", `UnnamedWithInputOn${this.typename}`);
  }
});

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-with-input/esm/index.js
var pluginName4 = "withInput";
var esm_default5 = pluginName4;

class PothosWithInputPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName4, PothosWithInputPlugin);

// /Users/richardguerre/Projects/flow/node_modules/graphql-scalars/index.mjs
var _validateInt = function(value) {
  if (!Number.isFinite(value)) {
    throw new TypeError(`Value is not a finite number: ${value}`);
  }
  if (!Number.isInteger(value)) {
    throw new TypeError(`Value is not an integer: ${value}`);
  }
  if (!Number.isSafeInteger(value)) {
    throw new TypeError(`Value is not a safe integer: ${value}`);
  }
};
var _validateFloat = function(value) {
  if (!Number.isFinite(value)) {
    throw new TypeError(`Value is not a finite number: ${value}`);
  }
};
var processValue = function(value, scalarName) {
  const VALIDATIONS = {
    NonPositiveInt: {
      range: VALUE_RANGES.NON_POSITIVE,
      type: VALUE_TYPES.INT
    },
    PositiveInt: {
      range: VALUE_RANGES.POSITIVE,
      type: VALUE_TYPES.INT
    },
    NonNegativeInt: {
      range: VALUE_RANGES.NON_NEGATIVE,
      type: VALUE_TYPES.INT
    },
    NegativeInt: {
      range: VALUE_RANGES.NEGATIVE,
      type: VALUE_TYPES.INT
    },
    NonPositiveFloat: {
      range: VALUE_RANGES.NON_POSITIVE,
      type: VALUE_TYPES.FLOAT
    },
    PositiveFloat: {
      range: VALUE_RANGES.POSITIVE,
      type: VALUE_TYPES.FLOAT
    },
    NonNegativeFloat: {
      range: VALUE_RANGES.NON_NEGATIVE,
      type: VALUE_TYPES.FLOAT
    },
    NegativeFloat: {
      range: VALUE_RANGES.NEGATIVE,
      type: VALUE_TYPES.FLOAT
    }
  };
  const { range, type } = VALIDATIONS[scalarName];
  if (value === null || typeof value === "undefined" || isNaN(value) || Number.isNaN(value) || value === Number.NaN) {
    throw new TypeError(`Value is not a number: ${value}`);
  }
  let parsedValue;
  switch (type) {
    case VALUE_TYPES.FLOAT:
      parsedValue = parseFloat(value);
      _validateFloat(parsedValue);
      break;
    case VALUE_TYPES.INT:
      parsedValue = parseInt(value, 10);
      _validateInt(parsedValue);
      break;
  }
  if (range === VALUE_RANGES.NEGATIVE && !(parsedValue < 0) || range === VALUE_RANGES.NON_NEGATIVE && !(parsedValue >= 0) || range === VALUE_RANGES.POSITIVE && !(parsedValue > 0) || range === VALUE_RANGES.NON_POSITIVE && !(parsedValue <= 0)) {
    throw new TypeError(`Value is not a ${VALUE_RANGES[range].toLowerCase().replace("_", "-")} number: ${value}`);
  }
  return parsedValue;
};
var identity = function(value) {
  return value;
};
var parseObject$1 = function(ast8, variables) {
  const value = Object.create(null);
  ast8.fields.forEach((field2) => {
    value[field2.name.value] = parseLiteral(field2.value, variables);
  });
  return value;
};
var parseLiteral = function(ast8, variables) {
  switch (ast8.kind) {
    case Kind.STRING:
    case Kind.BOOLEAN:
      return ast8.value;
    case Kind.INT:
    case Kind.FLOAT:
      return parseFloat(ast8.value);
    case Kind.OBJECT:
      return parseObject$1(ast8, variables);
    case Kind.LIST:
      return ast8.values.map((n) => parseLiteral(n, variables));
    case Kind.NULL:
      return null;
    case Kind.VARIABLE: {
      const name = ast8.name.value;
      return variables ? variables[name] : undefined;
    }
  }
};
var leapYear = (year) => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var validateTime = (time) => {
  time = time === null || time === undefined ? undefined : time.toUpperCase();
  const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  return TIME_REGEX.test(time);
};
var validateDate = (datestring) => {
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;
  if (!RFC_3339_REGEX.test(datestring)) {
    return false;
  }
  const year = Number(datestring.substr(0, 4));
  const month = Number(datestring.substr(5, 2));
  const day2 = Number(datestring.substr(8, 2));
  switch (month) {
    case 2:
      if (leapYear(year) && day2 > 29) {
        return false;
      } else if (!leapYear(year) && day2 > 28) {
        return false;
      }
      return true;
    case 4:
    case 6:
    case 9:
    case 11:
      if (day2 > 30) {
        return false;
      }
      break;
  }
  return true;
};
var validateDateTime = (dateTimeString) => {
  dateTimeString = dateTimeString === null || dateTimeString === undefined ? undefined : dateTimeString.toUpperCase();
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  if (!RFC_3339_REGEX.test(dateTimeString)) {
    return false;
  }
  const time = Date.parse(dateTimeString);
  if (time !== time) {
    return false;
  }
  const index = dateTimeString.indexOf("T");
  const dateString = dateTimeString.substr(0, index);
  const timeString = dateTimeString.substr(index + 1);
  return validateDate(dateString) && validateTime(timeString);
};
var validateJSDate = (date) => {
  const time = date.getTime();
  return time === time;
};
var parseDate = (date) => {
  return new Date(date);
};
var serializeDate = (date) => {
  return date.toISOString().split("T")[0];
};
var parseDateTime = (dateTime) => {
  return new Date(dateTime);
};
var GraphQLDateConfig = {
  name: "Date",
  description: "A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return serializeDate(value);
      }
      throw new TypeError("Date cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDate(value)) {
        return value;
      }
      throw new TypeError(`Date cannot represent an invalid date-string ${value}.`);
    } else {
      throw new TypeError("Date cannot represent a non string, or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (!(typeof value === "string")) {
      throw new TypeError(`Date cannot represent non string type ${JSON.stringify(value)}`);
    }
    if (validateDate(value)) {
      return parseDate(value);
    }
    throw new TypeError(`Date cannot represent an invalid date-string ${value}.`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw new TypeError(`Date cannot represent non string type ${("value" in ast8) && ast8.value}`);
    }
    const { value } = ast8;
    if (validateDate(value)) {
      return parseDate(value);
    }
    throw new TypeError(`Date cannot represent an invalid date-string ${String(value)}.`);
  },
  extensions: {
    codegenScalarType: "Date | string"
  }
};
var GraphQLDate = new GraphQLScalarType(GraphQLDateConfig);
var GraphQLDateTimeConfig = {
  name: "DateTime",
  description: "A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw new TypeError("DateTime cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw new TypeError(`DateTime cannot represent an invalid date-time-string ${value}.`);
    } else if (typeof value === "number") {
      try {
        return new Date(value);
      } catch (e) {
        throw new TypeError("DateTime cannot represent an invalid Unix timestamp " + value);
      }
    } else {
      throw new TypeError("DateTime cannot be serialized from a non string, non numeric or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw new TypeError("DateTime cannot represent an invalid Date instance");
    }
    if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw new TypeError(`DateTime cannot represent an invalid date-time-string ${value}.`);
    }
    throw new TypeError(`DateTime cannot represent non string or Date type ${JSON.stringify(value)}`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw new TypeError(`DateTime cannot represent non string or Date type ${("value" in ast8) && ast8.value}`);
    }
    const { value } = ast8;
    if (validateDateTime(value)) {
      return parseDateTime(value);
    }
    throw new TypeError(`DateTime cannot represent an invalid date-time-string ${String(value)}.`);
  },
  extensions: {
    codegenScalarType: "Date | string"
  }
};
var GraphQLDateTime = new GraphQLScalarType(GraphQLDateTimeConfig);
var ISO_DURATION = /^(-|\+)?P(?!$)((-|\+)?\d+(?:(\.|,)\d+)?Y)?((-|\+)?\d+(?:(\.|,)\d+)?M)?((-|\+)?\d+(?:(\.|,)\d+)?W)?((-|\+)?\d+(?:(\.|,)\d+)?D)?(T(?=(-|\+)?\d)((-|\+)?\d+(?:(\.|,)\d+)?H)?((-|\+)?\d+(?:(\.|,)\d+)?M)?((-|\+)?\d+(?:(\.|,)\d+)?S)?)?$/;
var GraphQLDurationConfig = {
  name: "Duration",
  description: `
    A string representing a duration conforming to the ISO8601 standard,
    such as: P1W1DT13H23M34S
    P is the duration designator (for period) placed at the start of the duration representation.
    Y is the year designator that follows the value for the number of years.
    M is the month designator that follows the value for the number of months.
    W is the week designator that follows the value for the number of weeks.
    D is the day designator that follows the value for the number of days.
    T is the time designator that precedes the time components of the representation.
    H is the hour designator that follows the value for the number of hours.
    M is the minute designator that follows the value for the number of minutes.
    S is the second designator that follows the value for the number of seconds.

    Note the time designator, T, that precedes the time value.

    Matches moment.js, Luxon and DateFns implementations
    ,/. is valid for decimal places and +/- is a valid prefix
  `,
  serialize(value) {
    if (typeof value !== "string") {
      throw new TypeError(`Value is not string: ${value}`);
    }
    if (!ISO_DURATION.test(value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${value}`);
    }
    return value;
  },
  parseValue(value) {
    if (typeof value !== "string") {
      throw new TypeError(`Value is not string: ${value}`);
    }
    if (!ISO_DURATION.test(value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${value}`);
    }
    return value;
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw new GraphQLError(`Can only validate strings as ISO Durations but got a: ${ast8.kind}`);
    }
    if (!ISO_DURATION.test(ast8.value)) {
      throw new TypeError(`Value is not a valid ISO Duration: ${ast8.value}`);
    }
    return ast8.value;
  },
  extensions: {
    codegenScalarType: "string"
  }
};
var GraphQLISO8601Duration = new GraphQLScalarType({
  ...GraphQLDurationConfig,
  name: "ISO8601Duration"
});
var GraphQLDuration = new GraphQLScalarType({
  ...GraphQLDurationConfig,
  name: "Duration"
});
var VALUE_RANGES;
(function(VALUE_RANGES2) {
  VALUE_RANGES2[VALUE_RANGES2["NEGATIVE"] = 0] = "NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_NEGATIVE"] = 1] = "NON_NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["POSITIVE"] = 2] = "POSITIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_POSITIVE"] = 3] = "NON_POSITIVE";
})(VALUE_RANGES || (VALUE_RANGES = {}));
var VALUE_TYPES;
(function(VALUE_TYPES2) {
  VALUE_TYPES2[VALUE_TYPES2["INT"] = 0] = "INT";
  VALUE_TYPES2[VALUE_TYPES2["FLOAT"] = 1] = "FLOAT";
})(VALUE_TYPES || (VALUE_TYPES = {}));
var GraphQLPositiveInt = new GraphQLScalarType({
  name: "PositiveInt",
  description: "Integers that will have a value greater than 0.",
  serialize(value) {
    return processValue(value, "PositiveInt");
  },
  parseValue(value) {
    return processValue(value, "PositiveInt");
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.INT) {
      throw new GraphQLError(`Can only validate integers as positive integers but got a: ${ast8.kind}`);
    }
    return processValue(ast8.value, "PositiveInt");
  },
  extensions: {
    codegenScalarType: "number"
  }
});
var specifiedByURL$5 = "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf";
var GraphQLJSONConfig = {
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: identity,
  parseValue: identity,
  parseLiteral,
  specifiedByURL: specifiedByURL$5,
  specifiedByUrl: specifiedByURL$5,
  extensions: {
    codegenScalarType: "any"
  }
};
var GraphQLJSON = new GraphQLScalarType(GraphQLJSONConfig);
var A = "A".charCodeAt(0);
var Z = "Z".charCodeAt(0);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/errors.js
var _define_property5 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/types.js
var AuthScopeFailureType;
(function(AuthScopeFailureType2) {
  AuthScopeFailureType2["AuthScope"] = "AuthScope";
  AuthScopeFailureType2["AuthScopeFunction"] = "AuthScopeFunction";
  AuthScopeFailureType2["GrantedScope"] = "GrantedScope";
  AuthScopeFailureType2["AnyAuthScopes"] = "AnyAuthScopes";
  AuthScopeFailureType2["AllAuthScopes"] = "AllAuthScopes";
  AuthScopeFailureType2["Unknown"] = "Unknown";
})(AuthScopeFailureType || (AuthScopeFailureType = {}));

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/errors.js
class ForbiddenError extends PothosValidationError {
  constructor(message, result) {
    super(message);
    _define_property5(this, "code", "FORBIDDEN");
    _define_property5(this, "result", undefined);
    this.name = "ForbiddenError";
    this.result = result !== null && result !== undefined ? result : {
      kind: AuthScopeFailureType.Unknown
    };
    Object.defineProperty(this, "name", {
      value: "ForbiddenError"
    });
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var _define_property6 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/util.js
function canCache(map2) {
  if (map2.$granted) {
    return false;
  }
  return (map2.$all ? canCache(map2.$all) : true) && (map2.$any ? canCache(map2.$any) : true);
}
function cacheKey2(path) {
  if (!path) {
    return "*";
  }
  let key = String(path.key);
  let current = path.prev;
  while (current) {
    key = `${current.key}.${key}`;
    current = current.prev;
  }
  return key;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var requestCache = new WeakMap;

class RequestCache {
  static fromContext(context, builder5) {
    if (!requestCache.has(context)) {
      requestCache.set(context, new RequestCache(builder5, context));
    }
    return requestCache.get(context);
  }
  getScopes() {
    if (!this.scopes) {
      const scopes = this.builder.options.authScopes(this.context);
      this.scopes = isThenable(scopes) ? scopes.then((resolved) => {
        this.scopes = resolved;
        return resolved;
      }) : scopes;
    }
    return this.scopes;
  }
  withScopes(cb) {
    const scopes = this.getScopes();
    if (isThenable(scopes)) {
      return scopes.then((resolvedScopes) => cb(resolvedScopes));
    }
    return cb(scopes);
  }
  saveGrantedScopes(scopes, path) {
    const key = cacheKey2(path);
    if (this.grantCache.has(key)) {
      const set = this.grantCache.get(key);
      scopes.forEach((scope) => set.add(scope));
    } else {
      this.grantCache.set(key, new Set(scopes));
    }
    return null;
  }
  testGrantedScopes(scope, path) {
    var _this_grantCache_get, _path_prev, _this_grantCache_get1;
    if ((_this_grantCache_get = this.grantCache.get(cacheKey2(path.prev))) === null || _this_grantCache_get === undefined ? undefined : _this_grantCache_get.has(scope)) {
      return true;
    }
    if (typeof ((_path_prev = path.prev) === null || _path_prev === undefined ? undefined : _path_prev.key) === "number" && ((_this_grantCache_get1 = this.grantCache.get(cacheKey2(path.prev.prev))) === null || _this_grantCache_get1 === undefined ? undefined : _this_grantCache_get1.has(scope))) {
      return true;
    }
    return false;
  }
  grantTypeScopes(type, parent, path, cb) {
    if (!this.typeGrants.has(type)) {
      this.typeGrants.set(type, new Map);
    }
    const cache2 = this.typeGrants.get(type);
    if (!cache2.has(parent)) {
      const result = cb();
      if (isThenable(result)) {
        cache2.set(parent, result.then((resolved) => this.saveGrantedScopes(resolved, path)));
      } else {
        cache2.set(parent, this.saveGrantedScopes(result, path));
      }
    }
    return cache2.get(parent);
  }
  evaluateScopeLoader(scopes, name, arg) {
    if (!this.scopeCache.has(name)) {
      this.scopeCache.set(name, new Map);
    }
    const cache2 = this.scopeCache.get(name);
    const key = this.cacheKey ? this.cacheKey(arg) : arg;
    if (!cache2.has(key)) {
      const loader = scopes[name];
      if (typeof loader !== "function") {
        throw new PothosValidationError(`Attempted to evaluate scope ${String(name)} as scope loader, but it is not a function`);
      }
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = loader(arg);
        } catch (error8) {
          cache2.set(key, {
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error8
          });
          return cache2.get(key);
        }
      } else {
        result = loader(arg);
      }
      if (isThenable(result)) {
        let promise = result.then((r) => r ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
        if (this.treatErrorsAsUnauthorized) {
          promise = promise.catch((error8) => ({
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error8
          }));
        }
        cache2.set(key, promise);
      } else {
        cache2.set(key, result ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
      }
    }
    return cache2.get(key);
  }
  evaluateScopeMapWithScopes({ $all, $any, $granted, ...map2 }, scopes, info, forAll) {
    const scopeNames = Object.keys(map2);
    const problems = [];
    const failure = {
      kind: forAll ? AuthScopeFailureType.AllAuthScopes : AuthScopeFailureType.AnyAuthScopes,
      failures: problems
    };
    const loaderList = [];
    for (const scopeName of scopeNames) {
      if (scopes[scopeName] == null || scopes[scopeName] === false) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map2[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
        continue;
      }
      const scope = scopes[scopeName];
      if (typeof scope === "function") {
        loaderList.push([
          scopeName,
          map2[scopeName]
        ]);
      } else if (scope && !forAll) {
        return null;
      } else if (!scope) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map2[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
      }
    }
    const promises = [];
    if ($granted) {
      const result = !!info && this.testGrantedScopes($granted, info.path);
      if (result && !forAll) {
        return null;
      }
      if (!result) {
        problems.push({
          kind: AuthScopeFailureType.GrantedScope,
          scope: $granted
        });
        if (forAll) {
          return failure;
        }
      }
    }
    if ($any) {
      const anyResult = this.evaluateScopeMap($any, info, false);
      if (isThenable(anyResult)) {
        promises.push(anyResult);
      } else if (anyResult === null && !forAll) {
        return null;
      } else if (anyResult) {
        problems.push(anyResult);
        if (forAll) {
          return failure;
        }
      }
    }
    if ($all) {
      const allResult = this.evaluateScopeMap($all, info, true);
      if (isThenable(allResult)) {
        promises.push(allResult);
      } else if (allResult === null && !forAll) {
        return resolveAndReturn(null);
      } else if (allResult) {
        problems.push(allResult);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    for (const [loaderName, arg] of loaderList) {
      const result = this.evaluateScopeLoader(scopes, loaderName, arg);
      if (isThenable(result)) {
        promises.push(result);
      } else if (result === null && !forAll) {
        return resolveAndReturn(null);
      } else if (result) {
        problems.push(result);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    if (promises.length === 0) {
      return forAll && problems.length === 0 ? null : failure;
    }
    return Promise.all(promises).then((results) => {
      let hasSuccess = false;
      results.forEach((result) => {
        if (result) {
          problems.push(result);
        } else {
          hasSuccess = true;
        }
      });
      if (forAll) {
        return problems.length > 0 ? failure : null;
      }
      return hasSuccess ? null : failure;
    });
    function resolveAndReturn(val) {
      if (promises.length > 0) {
        return Promise.all(promises).then(() => val);
      }
      return val;
    }
  }
  evaluateScopeMap(map2, info, forAll = this.defaultStrategy === "all") {
    if (typeof map2 === "boolean") {
      return map2 ? null : {
        kind: AuthScopeFailureType.AuthScopeFunction,
        error: null
      };
    }
    if (!this.mapCache.has(map2)) {
      const result = this.withScopes((scopes) => this.evaluateScopeMapWithScopes(map2, scopes, info, forAll));
      if (canCache(map2)) {
        this.mapCache.set(map2, result);
      }
      return result;
    }
    return this.mapCache.get(map2);
  }
  evaluateTypeScopeFunction(authScopes, type, parent, info) {
    const { typeCache } = this;
    if (!typeCache.has(type)) {
      typeCache.set(type, new Map);
    }
    const cache2 = typeCache.get(type);
    if (!cache2.has(parent)) {
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = authScopes(parent, this.context);
        } catch (error8) {
          cache2.set(parent, {
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error8
          });
          return cache2.get(parent);
        }
      } else {
        result = authScopes(parent, this.context);
      }
      if (isThenable(result)) {
        let promise = result.then((resolved) => this.evaluateScopeMap(resolved, info));
        if (this.treatErrorsAsUnauthorized) {
          promise = promise.catch((error8) => ({
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error8
          }));
        }
        cache2.set(parent, promise);
      } else {
        cache2.set(parent, this.evaluateScopeMap(result, info));
      }
    }
    return cache2.get(parent);
  }
  constructor(builder5, context) {
    var _builder_options_scopeAuthOptions, _builder_options_scopeAuthOptions1, _builder_options_scopeAuthOptions2;
    _define_property6(this, "builder", undefined);
    _define_property6(this, "context", undefined);
    _define_property6(this, "mapCache", new Map);
    _define_property6(this, "scopeCache", new Map);
    _define_property6(this, "typeCache", new Map);
    _define_property6(this, "typeGrants", new Map);
    _define_property6(this, "grantCache", new Map);
    _define_property6(this, "scopes", undefined);
    _define_property6(this, "cacheKey", undefined);
    _define_property6(this, "treatErrorsAsUnauthorized", undefined);
    _define_property6(this, "defaultStrategy", undefined);
    this.builder = builder5;
    this.context = context;
    this.cacheKey = (_builder_options_scopeAuthOptions = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions === undefined ? undefined : _builder_options_scopeAuthOptions.cacheKey;
    var _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized;
    this.treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions_treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions1 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions1 === undefined ? undefined : _builder_options_scopeAuthOptions1.treatErrorsAsUnauthorized) !== null && _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized !== undefined ? _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized : false;
    var _builder_options_scopeAuthOptions_defaultStrategy;
    this.defaultStrategy = (_builder_options_scopeAuthOptions_defaultStrategy = (_builder_options_scopeAuthOptions2 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions2 === undefined ? undefined : _builder_options_scopeAuthOptions2.defaultStrategy) !== null && _builder_options_scopeAuthOptions_defaultStrategy !== undefined ? _builder_options_scopeAuthOptions_defaultStrategy : "any";
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/schema-builder.js
var schemaBuilderProto3 = esm_default.prototype;
schemaBuilderProto3.runAuthScopes = function runAuthScopes(context, scopes, unauthorizedError = (result) => new ForbiddenError(result.message, result.failure)) {
  const cache2 = RequestCache.fromContext(context, this);
  const resultOrPromise = cache2.evaluateScopeMap(scopes);
  if (isThenable(resultOrPromise)) {
    return resultOrPromise.then(handleScopeResult);
  }
  handleScopeResult(resultOrPromise);
  function handleScopeResult(result) {
    if (result) {
      const error8 = unauthorizedError({
        message: "Unauthorized",
        failure: result
      });
      if (typeof error8 === "string") {
        throw new ForbiddenError(error8, result);
      }
      throw error8;
    }
  }
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/field-builders.js
var addScopes2 = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var objectFieldBuilder = ObjectFieldBuilder2.prototype;
objectFieldBuilder.withAuth = function withAuth2(scopes) {
  return addScopes2(scopes, new ObjectFieldBuilder2(this.typename, this.builder));
};
var interfaceFieldBuilder = InterfaceFieldBuilder2.prototype;
interfaceFieldBuilder.withAuth = function withAuth3(scopes) {
  return addScopes2(scopes, new InterfaceFieldBuilder2(this.typename, this.builder));
};
var queryFieldBuilder = QueryFieldBuilder2.prototype;
queryFieldBuilder.withAuth = function withAuth4(scopes) {
  return addScopes2(scopes, new QueryFieldBuilder2(this.builder));
};
var mutationFieldBuilder = MutationFieldBuilder2.prototype;
mutationFieldBuilder.withAuth = function withAuth5(scopes) {
  return addScopes2(scopes, new MutationFieldBuilder2(this.builder));
};
var subscriptionFieldBuilder = SubscriptionFieldBuilder2.prototype;
subscriptionFieldBuilder.withAuth = function withAuth6(scopes) {
  return addScopes2(scopes, new SubscriptionFieldBuilder2(this.builder));
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/is-type-of-helper.js
function isTypeOfHelper(steps, plugin3, isTypeOf) {
  var _plugin_builder_options_scopeAuthOptions;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin3.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const createError = (parent, context, info, result) => globalUnauthorizedError ? globalUnauthorizedError(parent, context, info, result) : result.message;
  return (parent, context, info) => {
    const cache2 = RequestCache.fromContext(context, plugin3.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache2, parent, {}, context, info, () => {
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error8 = createError(parent, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
                failure: result
              });
              throw typeof error8 === "string" ? new ForbiddenError(error8, result) : error8;
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error8 = createError(parent, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
            failure: stepResult
          });
          throw typeof error8 === "string" ? new ForbiddenError(error8, stepResult) : error8;
        }
      }
      return isTypeOf ? isTypeOf(parent, context, info) : true;
    }
    return runSteps(0);
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/resolve-helper.js
function resolveHelper(steps, plugin3, fieldConfig) {
  var _plugin_builder_options_scopeAuthOptions;
  var _fieldConfig_pothosOptions_unauthorizedResolver;
  const unauthorizedResolver = (_fieldConfig_pothosOptions_unauthorizedResolver = fieldConfig.pothosOptions.unauthorizedResolver) !== null && _fieldConfig_pothosOptions_unauthorizedResolver !== undefined ? _fieldConfig_pothosOptions_unauthorizedResolver : defaultUnauthorizedResolver;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin3.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const defaultUnauthorizedError = (parent, args, context, info, result) => {
    if (globalUnauthorizedError) {
      return globalUnauthorizedError(parent, context, info, result);
    }
    if ((result.failure.kind === AuthScopeFailureType.AuthScope || result.failure.kind === AuthScopeFailureType.AuthScopeFunction) && result.failure.error) {
      return result.failure.error;
    }
    return result.message;
  };
  var _fieldConfig_pothosOptions_unauthorizedError;
  const createError = (_fieldConfig_pothosOptions_unauthorizedError = fieldConfig.pothosOptions.unauthorizedError) !== null && _fieldConfig_pothosOptions_unauthorizedError !== undefined ? _fieldConfig_pothosOptions_unauthorizedError : defaultUnauthorizedError;
  return (parent, args, context, info) => {
    let resolvedValue;
    const cache2 = RequestCache.fromContext(context, plugin3.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache2, parent, args, context, info, (val) => {
          resolvedValue = val;
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error8 = createError(parent, args, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
                failure: result
              });
              return unauthorizedResolver(parent, args, context, info, typeof error8 === "string" ? new ForbiddenError(error8, result) : error8);
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error8 = createError(parent, args, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
            failure: stepResult
          });
          return unauthorizedResolver(parent, args, context, info, typeof error8 === "string" ? new ForbiddenError(error8, stepResult) : error8);
        }
      }
      return resolvedValue;
    }
    return runSteps(0);
  };
}
var defaultUnauthorizedResolver = (_root, _args, _context, _info, error8) => {
  throw error8;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/steps.js
function createTypeAuthScopesStep(authScopes, type) {
  if (typeof authScopes === "function") {
    return {
      run: (state, parent, args, context, info) => state.evaluateTypeScopeFunction(authScopes, type, parent, info),
      errorMessage: `Not authorized to read fields for ${type}`
    };
  }
  return {
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info),
    errorMessage: `Not authorized to read fields for ${type}`
  };
}
function createTypeGrantScopesStep(grantScopes, type, forField) {
  return {
    run: (state, parent, args, context, info) => state.grantTypeScopes(type, parent, forField ? info.path.prev : info.path, () => grantScopes(parent, context)),
    errorMessage: `Unknown error creating grants for ${type}`
  };
}
function createFieldAuthScopesStep(authScopes) {
  if (typeof authScopes === "function") {
    return {
      errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
      run: (state, parent, args, context, info) => {
        const scopeMap = authScopes(parent, args, context, info);
        if (isThenable(scopeMap)) {
          return scopeMap.then((resolved) => state.evaluateScopeMap(resolved, info));
        }
        return state.evaluateScopeMap(scopeMap, info);
      }
    };
  }
  return {
    errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info)
  };
}
function createFieldGrantScopesStep(grantScopes) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue generating grants for ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => {
      if (typeof grantScopes !== "function") {
        state.saveGrantedScopes(grantScopes, info.path);
        return null;
      }
      const result = grantScopes(parent, args, context, info);
      if (isThenable(result)) {
        return result.then((resolved) => {
          state.saveGrantedScopes(resolved, info.path);
          return null;
        });
      }
      state.saveGrantedScopes(result, info.path);
      return null;
    }
  };
}
function createResolveStep(resolver) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue resolving ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info, setResolved) => {
      const result = resolver(parent, args, context, info);
      if (isThenable(result)) {
        return Promise.resolve(result).then((resolved) => {
          setResolved(resolved);
          return null;
        });
      }
      setResolved(result);
      return null;
    }
  };
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-scope-auth/esm/index.js
var pluginName5 = "scopeAuth";
var esm_default6 = pluginName5;
var inResolveType = false;

class PothosScopeAuthPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    var _this_builder_options_scopeAuthOptions, _this_builder_options_scopeAuthOptions1;
    if (this.options.disableScopeAuth) {
      return resolver;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    const authorizedOnSubscribe = !!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) && typeConfig.kind === "Subscription";
    const nonRoot = (typeConfig.graphqlKind === "Interface" || typeConfig.graphqlKind === "Object") && typeConfig.kind !== "Query" && typeConfig.kind !== "Mutation" && typeConfig.kind !== "Subscription";
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const runTypeScopesOnField = !nonRoot || !((_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions1 = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions1 === undefined ? undefined : _this_builder_options_scopeAuthOptions1.runScopesOnType) !== null && _ref !== undefined ? _ref : false);
    const steps2 = this.createResolveSteps(fieldConfig, typeConfig, resolver, runTypeScopesOnField, authorizedOnSubscribe);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return resolver;
  }
  wrapSubscribe(subscriber, fieldConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return subscriber;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    if (!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) || typeConfig.kind !== "Subscription") {
      return subscriber;
    }
    const steps2 = this.createSubscribeSteps(fieldConfig, typeConfig, subscriber);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return subscriber;
  }
  wrapResolveType(resolveType, typeConfig) {
    return (...args) => {
      inResolveType = true;
      try {
        return resolveType(...args);
      } finally {
        inResolveType = false;
      }
    };
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return isTypeOf;
    }
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const shouldRunTypeScopes = (_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.runScopesOnType) !== null && _ref !== undefined ? _ref : false;
    if (!shouldRunTypeScopes) {
      return isTypeOf;
    }
    const steps2 = this.createStepsForType(typeConfig, {
      forField: false
    });
    if (steps2.length === 0) {
      return isTypeOf;
    }
    const runSteps = isTypeOfHelper(steps2, this, isTypeOf);
    return (source2, context, info) => {
      if (inResolveType) {
        var _isTypeOf;
        var _isTypeOf1;
        return (_isTypeOf1 = (_isTypeOf = isTypeOf) === null || _isTypeOf === undefined ? undefined : _isTypeOf(source2, context, info)) !== null && _isTypeOf1 !== undefined ? _isTypeOf1 : false;
      }
      return runSteps(source2, context, info);
    };
  }
  createStepsForType(typeConfig, { skipTypeScopes, skipInterfaceScopes, forField }) {
    const parentAuthScope = typeConfig.pothosOptions.authScopes;
    const parentGrantScopes = typeConfig.pothosOptions.grantScopes;
    const interfaceConfigs = typeConfig.kind === "Object" || typeConfig.kind === "Interface" ? typeConfig.interfaces.map((iface) => this.buildCache.getTypeConfig(iface, "Interface")) : [];
    const steps2 = [];
    if (parentAuthScope && !skipTypeScopes) {
      steps2.push(createTypeAuthScopesStep(parentAuthScope, typeConfig.name));
    }
    if (!skipInterfaceScopes && !(typeConfig.kind === "Object" && typeConfig.pothosOptions.skipInterfaceScopes)) {
      interfaceConfigs.forEach((interfaceConfig) => {
        if (interfaceConfig.pothosOptions.authScopes) {
          steps2.push(createTypeAuthScopesStep(interfaceConfig.pothosOptions.authScopes, interfaceConfig.name));
        }
      });
    }
    if (parentGrantScopes) {
      steps2.push(createTypeGrantScopesStep(parentGrantScopes, typeConfig.name, forField));
    }
    return steps2;
  }
  createResolveSteps(fieldConfig, typeConfig, resolver, shouldRunTypeScopes, authorizedOnSubscribe) {
    var _ref, _ref1;
    const stepsForType = shouldRunTypeScopes && !authorizedOnSubscribe ? this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    }) : [];
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const fieldGrantScopes = fieldConfig.pothosOptions.grantScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes && !authorizedOnSubscribe) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(resolver));
    if (fieldGrantScopes) {
      steps2.push(createFieldGrantScopesStep(fieldGrantScopes));
    }
    return steps2;
  }
  createSubscribeSteps(fieldConfig, typeConfig, subscriber) {
    var _ref, _ref1;
    const stepsForType = this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    });
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(subscriber));
    return steps2;
  }
}
var fieldBuilderProto3 = RootFieldBuilder2.prototype;
fieldBuilderProto3.authField = function authField(options) {
  return this.field(options);
};
esm_default.registerPlugin(pluginName5, PothosScopeAuthPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/index.js
var _defineProperty29 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache.js
var _defineProperty27 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache-node.js
var _defineProperty26 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/field.js
var _defineProperty24 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/base.js
var _defineProperty23 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

class BaseSubscriptionManager {
  addRegistration(options) {
    this.registrations.push(options);
    this.manager.register(options);
  }
  reRegister() {
    this.registrations.forEach((options) => void this.manager.register(options));
  }
  constructor(manager) {
    _defineProperty23(this, "manager", undefined);
    _defineProperty23(this, "registrations", []);
    this.manager = manager;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/field.js
class FieldSubscriptionManager extends BaseSubscriptionManager {
  register(name, { filter: filter2, invalidateCache } = {}) {
    this.addRegistration({
      name,
      filter: filter2,
      onValue: (value) => {
        if (invalidateCache) {
          invalidateCache(value);
        }
        return this.cacheNode.refetch();
      }
    });
  }
  constructor(manager, cacheNode) {
    super(manager);
    _defineProperty24(this, "cacheNode", undefined);
    this.cacheNode = cacheNode;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/type.js
var _defineProperty25 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
class TypeSubscriptionManager extends BaseSubscriptionManager {
  register(name, { filter: filter2, invalidateCache, refetch } = {}) {
    this.addRegistration({
      name,
      filter: filter2,
      onValue: (value) => {
        if (invalidateCache) {
          invalidateCache(value);
        }
        if (refetch) {
          let resultOrPromise;
          try {
            resultOrPromise = refetch(value);
          } catch (error8) {
            this.manager.handleError(error8);
          }
          this.replace(resultOrPromise);
          return resultOrPromise;
        }
        return this.refetchParent();
      }
    });
  }
  constructor(manager, replace, refetchParent) {
    super(manager);
    _defineProperty25(this, "replace", undefined);
    _defineProperty25(this, "refetchParent", undefined);
    this.replace = replace;
    this.refetchParent = refetchParent;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache-node.js
class CacheNode {
  reRegister() {
    if (this.fieldManager) {
      this.fieldManager.reRegister();
    }
    this.typeManagers.forEach((manager) => void manager.reRegister());
  }
  managerForField() {
    this.fieldManager = new FieldSubscriptionManager(this.cache.manager, this);
    return this.fieldManager;
  }
  managerForType(key) {
    if (this.typeManagers.has(key)) {
      return null;
    }
    const typeManager = new TypeSubscriptionManager(this.cache.manager, (value) => {
      this.replaceValue(value, key);
    }, this.refetch);
    this.typeManagers.set(key, typeManager);
    return typeManager;
  }
  replaceValue(value, key) {
    if (typeof key === "number") {
      if (!Array.isArray(this.value)) {
        throw new PothosValidationError("Expected value of CacheNode for list path to be an array");
      }
      this.cache.invalidPaths.push(`${this.path}.${key}`);
      this.value[key] = value;
    } else {
      this.cache.invalidPaths.push(`${this.path}.`);
      this.value = value;
    }
    this.typeManagers.delete(key);
  }
  constructor(cache2, path, value, refetch) {
    _defineProperty26(this, "path", undefined);
    _defineProperty26(this, "value", undefined);
    _defineProperty26(this, "fieldManager", null);
    _defineProperty26(this, "typeManagers", new Map);
    _defineProperty26(this, "cache", undefined);
    _defineProperty26(this, "refetch", undefined);
    this.cache = cache2;
    this.path = path;
    this.value = value;
    this.refetch = refetch;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/cache.js
class SubscriptionCache {
  get(path, reRegister) {
    const node3 = this.currentCache.get(path);
    if (!node3) {
      return null;
    }
    for (const invalid of this.prevInvalidPaths) {
      if (path.startsWith(invalid)) {
        return null;
      }
    }
    if (reRegister) {
      this.nextCache.set(path, node3);
      node3.reRegister();
    }
    return node3;
  }
  getTypeSubscriber(type2) {
    const config = this.buildCache.getTypeConfig(type2, "Object");
    if (config.graphqlKind === "Object") {
      var _config_pothosOptions_subscribe;
      return (_config_pothosOptions_subscribe = config.pothosOptions.subscribe) !== null && _config_pothosOptions_subscribe !== undefined ? _config_pothosOptions_subscribe : null;
    }
    return null;
  }
  getParent(info) {
    let parentPath = info.path.prev;
    if (!parentPath) {
      return null;
    }
    if (typeof parentPath.key === "number") {
      parentPath = parentPath.prev;
    }
    const parentKey = this.cacheKey(parentPath);
    if (this.nextCache.has(parentKey)) {
      return this.nextCache.get(parentKey);
    }
    return null;
  }
  managerForParentType(info) {
    const parentPath = info.path.prev;
    if (!parentPath) {
      return null;
    }
    const isListItem = typeof parentPath.key === "number";
    const parentKey = this.cacheKey(isListItem ? parentPath.prev : parentPath);
    const parentCacheNode = this.nextCache.get(parentKey);
    var _parentCacheNode_managerForType;
    return (_parentCacheNode_managerForType = parentCacheNode === null || parentCacheNode === undefined ? undefined : parentCacheNode.managerForType(parentPath.key)) !== null && _parentCacheNode_managerForType !== undefined ? _parentCacheNode_managerForType : null;
  }
  add(info, path, canRefetch, value) {
    const parent = this.getParent(info);
    const node3 = new CacheNode(this, path, value, canRefetch || !parent ? () => void this.invalidPaths.push(path) : parent.refetch);
    this.nextCache.set(path, node3);
    return node3;
  }
  next() {
    this.prevInvalidPaths = this.invalidPaths;
    this.invalidPaths = [];
    this.currentCache = this.nextCache;
    this.nextCache = new Map;
  }
  cacheKey(path) {
    let { key, prev } = path;
    while (prev) {
      key = `${prev.key}.${key}`;
      prev = prev.prev;
    }
    return key.toString();
  }
  constructor(manager, buildCache) {
    _defineProperty27(this, "manager", undefined);
    _defineProperty27(this, "buildCache", undefined);
    _defineProperty27(this, "currentCache", new Map);
    _defineProperty27(this, "nextCache", new Map);
    _defineProperty27(this, "invalidPaths", []);
    _defineProperty27(this, "prevInvalidPaths", []);
    this.manager = manager;
    this.buildCache = buildCache;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/create-field-data.js
function getFieldSubscribe(field3, plugin3) {
  if (field3.graphqlKind === "Object" && field3.kind !== "Mutation" && field3.kind !== "Subscription") {
    return field3.pothosOptions.subscribe;
  }
  if (field3.kind === "Subscription" && plugin3.smartSubscriptionsToQueryField.has(field3.name)) {
    return plugin3.smartSubscriptionsToQueryField.get(field3.name).subscribe;
  }
  return null;
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/manager/index.js
var _defineProperty28 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _Symbol_asyncIterator = Symbol.asyncIterator;

class SubscriptionManager {
  register({ name, ...options }) {
    if (this.stopped) {
      return;
    }
    this.addOptions(name, options);
    if (this.nextSubscriptions.has(name)) {
      return;
    }
    this.nextSubscriptions.add(name);
    if (this.activeSubscriptions.has(name)) {
      return;
    }
    const maybePromise = this.subscribeToName(name, (err, value) => {
      if (err) {
        this.handleError(err);
      } else {
        this.handleValue(name, value);
      }
    });
    if (maybePromise) {
      maybePromise.catch((error8) => void this.handleError(error8));
    }
  }
  [_Symbol_asyncIterator]() {
    return this;
  }
  async return() {
    if (this.pendingError) {
      throw this.pendingError;
    }
    await this.stop();
    return {
      done: true,
      value: this.value
    };
  }
  async throw(error8) {
    this.handleError(error8);
    return Promise.reject(error8);
  }
  async next() {
    if (this.pendingError) {
      throw this.pendingError;
    }
    if (this.stopped) {
      return {
        done: true,
        value: this.value
      };
    }
    for (const name of this.activeSubscriptions) {
      if (!this.nextSubscriptions.has(name)) {
        await this.unsubscribeFromName(name);
      }
    }
    this.activeSubscriptions = this.nextSubscriptions;
    this.nextSubscriptions = new Set;
    this.activeOptions = this.nextOptions;
    this.nextOptions = new Map;
    if (this.pendingEvent) {
      this.pendingEvent = false;
      return {
        done: false,
        value: this.value
      };
    }
    return new Promise((resolve, reject2) => {
      this.resolveNext = (done = false) => {
        this.resolveNext = null;
        this.rejectNext = null;
        resolve({
          done,
          value: this.value
        });
      };
      this.rejectNext = (err) => {
        this.resolveNext = null;
        this.rejectNext = null;
        reject2(err);
      };
      const pending = this.pendingEvents;
      if (pending.length > 0) {
        this.pendingEvents = [];
        for (const [name, value] of pending) {
          this.handleValue(name, value);
        }
      }
    });
  }
  handleError(err) {
    this.pendingError = err;
    if (this.rejectNext) {
      this.rejectNext(err);
    }
    this.stop().catch((error8) => void this.handleError(error8));
  }
  async stop() {
    if (this.stopped) {
      return;
    }
    if (this.debounceRef) {
      clearTimeout(this.debounceRef);
      this.debounceRef = null;
    }
    this.stopped = true;
    const names = new Set([
      ...this.activeSubscriptions,
      ...this.nextSubscriptions
    ]);
    this.activeSubscriptions = new Set;
    this.nextSubscriptions = new Set;
    this.activeOptions = new Map;
    this.nextOptions = new Map;
    if (this.pendingError && this.rejectNext) {
      this.rejectNext(this.pendingError);
    } else if (this.resolveNext) {
      this.resolveNext(true);
    }
    for (const name of names) {
      await this.unsubscribeFromName(name);
    }
  }
  addOptions(name, options) {
    if (!this.nextOptions.has(name)) {
      this.nextOptions.set(name, []);
    }
    this.nextOptions.get(name).push(options);
  }
  filterValue(name, value) {
    const optionsList = this.activeOptions.get(name);
    if (!optionsList) {
      return {
        allowed: true
      };
    }
    let allowed = false;
    const promises = [];
    for (const options of optionsList) {
      const currentAllowed = !options.filter || options.filter(value);
      allowed = allowed || currentAllowed;
      if (currentAllowed && options.onValue) {
        const promise = options.onValue(value);
        if (promise) {
          promises.push(promise);
        }
      }
    }
    return {
      allowed,
      promises: Promise.all(promises)
    };
  }
  handleValue(name, value) {
    if (this.stopped) {
      return;
    }
    if (!this.resolveNext) {
      this.pendingEvents.push([
        name,
        value
      ]);
      return;
    }
    const { allowed, promises } = this.filterValue(name, value);
    if (promises) {
      promises.catch((error8) => void this.handleError(error8));
    }
    if (!allowed) {
      return;
    }
    if (this.debounceRef) {
      return;
    }
    if (this.debounceDelay === null) {
      this.pushValue();
    } else {
      this.debounceRef = setTimeout(() => {
        this.debounceRef = null;
        this.pushValue();
      }, this.debounceDelay);
      if (typeof this.debounceRef === "object" && ("unref" in this.debounceRef)) {
        this.debounceRef.unref();
      }
    }
  }
  pushValue() {
    if (this.stopped) {
      return;
    }
    if (this.resolveNext) {
      this.resolveNext();
    } else {
      this.pendingEvent = true;
    }
  }
  constructor({ value, debounceDelay, subscribe: subscribe3, unsubscribe }) {
    _defineProperty28(this, "activeSubscriptions", new Set);
    _defineProperty28(this, "nextSubscriptions", new Set);
    _defineProperty28(this, "activeOptions", new Map);
    _defineProperty28(this, "nextOptions", new Map);
    _defineProperty28(this, "subscribeToName", undefined);
    _defineProperty28(this, "unsubscribeFromName", undefined);
    _defineProperty28(this, "pendingEvent", true);
    _defineProperty28(this, "pendingError", undefined);
    _defineProperty28(this, "pendingEvents", []);
    _defineProperty28(this, "value", undefined);
    _defineProperty28(this, "resolveNext", null);
    _defineProperty28(this, "rejectNext", null);
    _defineProperty28(this, "stopped", false);
    _defineProperty28(this, "debounceDelay", null);
    _defineProperty28(this, "debounceRef", null);
    this.subscribeToName = subscribe3;
    this.unsubscribeFromName = unsubscribe;
    this.value = value;
    this.debounceDelay = debounceDelay !== null && debounceDelay !== undefined ? debounceDelay : null;
  }
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/resolve-with-cache.js
function resolveWithCache(cache2, subscribe3, resolve, canRefetch, parent, args, context, info) {
  const key = cache2.cacheKey(info.path);
  const existingCacheNode = cache2.get(key, true);
  if (existingCacheNode) {
    return existingCacheNode.value;
  }
  const parentSubscriber = cache2.getTypeSubscriber(info.parentType.name);
  if (parentSubscriber) {
    const parentManager = cache2.managerForParentType(info);
    if (parentManager) {
      parentSubscriber(parentManager, parent, context, info);
    }
  }
  const resultOrPromise = resolve(parent, args, context, info);
  function cacheResult(result) {
    const cacheNode = cache2.add(info, key, canRefetch, result);
    subscribe3 === null || subscribe3 === undefined || subscribe3(cacheNode.managerForField(), parent, args, context, info);
    return result;
  }
  return isThenable(resultOrPromise) ? resultOrPromise.then(cacheResult) : cacheResult(resultOrPromise);
}

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-smart-subscriptions/esm/index.js
var DEFAULT_DEBOUNCE_DELAY = 10;
var pluginName6 = "smartSubscriptions";
var esm_default7 = pluginName6;

class PothosSmartSubscriptionsPlugin extends BasePlugin {
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "Query" && fieldConfig.pothosOptions.smartSubscription) {
      this.smartSubscriptionsToQueryField.set(fieldConfig.name, fieldConfig);
      var _fieldConfig_resolve;
      this.builder.subscriptionField(fieldConfig.name, (t) => t.field({
        ...fieldConfig.pothosOptions,
        resolve: (parent, args, context, info) => ((_fieldConfig_resolve = fieldConfig.resolve) !== null && _fieldConfig_resolve !== undefined ? _fieldConfig_resolve : defaultFieldResolver)(parent, args, context, info),
        subscribe: (parent, args, context, info) => {
          const manager2 = new SubscriptionManager({
            value: parent,
            debounceDelay: this.debounceDelay,
            subscribe: (subName, cb) => this.subscribe(subName, context, cb),
            unsubscribe: (subName) => this.unsubscribe(subName, context)
          });
          const cache3 = new SubscriptionCache(manager2, this.buildCache);
          this.requestData(context).cache = cache3;
          return {
            [Symbol.asyncIterator]() {
              return {
                async next() {
                  return manager2.next().then((next) => {
                    cache3.next();
                    return next;
                  });
                },
                async return() {
                  return manager2.return();
                },
                async throw(error8) {
                  return manager2.throw(error8);
                }
              };
            }
          };
        }
      }));
    }
    return fieldConfig;
  }
  createRequestData(context) {
    return {};
  }
  wrapResolve(resolve, field3) {
    let canRefetch = false;
    if (field3.graphqlKind === "Object" && field3.kind !== "Query" && field3.kind !== "Subscription" && field3.kind !== "Mutation") {
      var _field_pothosOptions_canRefetch;
      canRefetch = (_field_pothosOptions_canRefetch = field3.pothosOptions.canRefetch) !== null && _field_pothosOptions_canRefetch !== undefined ? _field_pothosOptions_canRefetch : false;
    }
    const subscribe3 = getFieldSubscribe(field3, this);
    return (parent, args, context, info) => {
      const { cache: cache3 } = this.requestData(context);
      if (!cache3) {
        return resolve(parent, args, context, info);
      }
      return resolveWithCache(cache3, subscribe3, resolve, canRefetch, parent, args, context, info);
    };
  }
  wrapResolveType(resolveType) {
    return resolveType;
  }
  constructor(buildCache) {
    super(buildCache, pluginName6);
    _defineProperty29(this, "debounceDelay", undefined);
    _defineProperty29(this, "smartSubscriptionsToQueryField", new Map);
    _defineProperty29(this, "subscribe", undefined);
    _defineProperty29(this, "unsubscribe", undefined);
    this.subscribe = this.builder.options.smartSubscriptions.subscribe;
    this.unsubscribe = this.builder.options.smartSubscriptions.unsubscribe;
    var _this_builder_options_smartSubscriptions_debounceDelay;
    this.debounceDelay = (_this_builder_options_smartSubscriptions_debounceDelay = this.builder.options.smartSubscriptions.debounceDelay) !== null && _this_builder_options_smartSubscriptions_debounceDelay !== undefined ? _this_builder_options_smartSubscriptions_debounceDelay : DEFAULT_DEBOUNCE_DELAY;
  }
}
esm_default.registerPlugin(pluginName6, PothosSmartSubscriptionsPlugin);

// /Users/richardguerre/Projects/flow/node_modules/@pothos/plugin-simple-objects/esm/index.js
var pluginName7 = "simpleObjects";
var esm_default8 = pluginName7;

class PothosSimpleObjectsPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName7, PothosSimpleObjectsPlugin);
var proto = esm_default.prototype;
proto.simpleObject = function simpleObject(name, options, extraFields) {
  const ref = new ObjectRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t) => {
      const fields = originalFields(t);
      Object.keys(fields).forEach((key) => {
        this.configStore.onFieldUse(fields[key], (config) => {
          if (config.kind === "Object") {
            config.resolve = (parent) => parent[key];
          }
        });
      });
      return fields;
    };
  }
  this.objectType(ref, options);
  if (extraFields) {
    this.objectFields(ref, extraFields);
  }
  return ref;
};
proto.simpleInterface = function simpleInterface(name, options, extraFields) {
  const ref = new InterfaceRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t) => {
      const fields = originalFields(t);
      Object.keys(fields).forEach((key) => {
        this.configStore.onFieldUse(fields[key], (config) => {
          if (config.kind === "Interface") {
            config.resolve = (parent) => parent[key];
          }
        });
      });
      return fields;
    };
  }
  this.interfaceType(ref, options);
  if (extraFields) {
    this.interfaceFields(ref, extraFields);
  }
  return ref;
};

// src/graphql/builder.ts
function u(input6) {
  return input6 ?? undefined;
}
function uParseInt(input6) {
  return input6 ? parseInt(input6) : undefined;
}
var encodeGlobalID2 = (typename, id) => {
  return `${typename}_${id}`;
};
var decodeGlobalID2 = (globalId) => {
  const [typename, ...idElements] = globalId.split("_");
  const id = idElements.join("_");
  if (!typename || !id)
    throw new Error("Invalid Relay ID");
  return { typename, id };
};
var builder5 = new esm_default({
  plugins: [
    esm_default2,
    esm_default6,
    esm_default3,
    esm_default4,
    esm_default5,
    esm_default7,
    esm_default8
  ],
  relayOptions: {
    clientMutationId: "omit",
    cursorType: "ID",
    edgesFieldOptions: {
      nullable: false
    },
    nodeFieldOptions: {
      nullable: false
    },
    encodeGlobalID: encodeGlobalID2,
    decodeGlobalID: decodeGlobalID2
  },
  prisma: {
    client: prisma,
    exposeDescriptions: true,
    filterConnectionTotalCount: true
  },
  authScopes: async (context) => {
    return {
      public: true,
      authenticated: () => context.isSessionValid()
    };
  },
  scopeAuthOptions: {
    unauthorizedError: (_, __, info) => {
      const errors16 = {
        query: "You need to be logged in to see this.",
        mutation: "You need to be logged in to do this.",
        subscription: "You need to be logged in to see this.",
        _default: "You need to be logged in to do this."
      };
      return new GraphQLError(errors16[info.operation.operation] ?? errors16._default, {
        extensions: {
          code: "UNAUTHENTICATED",
          userFriendlyMessage: errors16[info.operation.operation] ?? errors16._default
        }
      });
    }
  },
  smartSubscriptions: {
    subscribe: async ($name, context, callback) => {
      const name = $name;
      if (!context.subscriptions[name])
        context.subscriptions[name] = pubsub.subscribe(name);
      for await (const data of context.subscriptions[name]) {
        callback(undefined, data);
      }
    },
    unsubscribe: ($name, context) => {
      const name = $name;
      context.subscriptions[name]?.return?.();
      delete context.subscriptions[name];
    }
  }
});
builder5.queryType({ authScopes: { authenticated: true } });
builder5.mutationType({ authScopes: { authenticated: true } });
builder5.subscriptionType({ authScopes: { authenticated: true } });
builder5.addScalarType("Date", GraphQLDate, {});
builder5.addScalarType("DateTime", GraphQLDateTime, {});
builder5.addScalarType("PositiveInt", GraphQLPositiveInt, {});
builder5.addScalarType("JSON", GraphQLJSON, {});
builder5.scalarType("Time", {
  description: "A time of day, represented as a string in the format `HH:mm`. For example, `16:20`.",
  serialize: (value) => dayjs(value).utc(false).format("HH:mm"),
  parseValue: (value) => {
    const dayjsObj = dayjs(`1970-01-01 ${value}`, "YYYY-MM-DD HH:mm", true).utc(true);
    if (!dayjsObj.isValid()) {
      throw new GraphQLError(`Invalid time "${value}". Should be in the format \`HH:mm\`. For example, \`16:20\`.`);
    }
    return dayjsObj.toDate();
  }
});

// src/graphql/Color.ts
var values3 = {
  slate: { value: "slate" },
  gray: { value: "gray" },
  zinc: { value: "zinc" },
  neutral: { value: "neutral" },
  stone: { value: "stone" },
  red: { value: "red" },
  orange: { value: "orange" },
  amber: { value: "amber" },
  yellow: { value: "yellow" },
  lime: { value: "lime" },
  green: { value: "green" },
  emerald: { value: "emerald" },
  teal: { value: "teal" },
  cyan: { value: "cyan" },
  sky: { value: "sky" },
  blue: { value: "blue" },
  indigo: { value: "indigo" },
  violet: { value: "violet" },
  purple: { value: "purple" },
  fuchsia: { value: "fuchsia" },
  pink: { value: "pink" },
  rose: { value: "rose" }
};
var ColorEnum = builder5.enumType("Color", { values: values3 });

// src/utils/getDays.ts
var getStartFromConnectionArgs = ({ after, before, last }) => {
  let start = new Date;
  if (after) {
    const afterDate = new Date(after);
    start = addDays(afterDate, 1);
  } else if (last) {
    const beforeDate = new Date(before ?? start);
    start = addDays(beforeDate, (before ? 0 : 1) - last);
  }
  return startOfDay(start);
};
var startOfDay = (day2 = new Date) => {
  return new Date(day2.setUTCHours(0, 0, 0, 0));
};
var endOfDay = (day2 = new Date) => {
  return new Date(day2.setUTCHours(23, 59, 59, 999));
};
var addDays = (day2 = new Date, days) => {
  return new Date(day2.setDate(day2.getDate() + days));
};
var getDayOfWeek = (date) => {
  return dayOfWeekArr[date.getDay()];
};
var dayOfWeekArr = [
  "SUNDAY",
  "MONDAY",
  "TUESDAY",
  "WEDNESDAY",
  "THURSDAY",
  "FRIDAY",
  "SATURDAY"
];
var toDateOnly = (date) => {
  const dateString = date.toJSON();
  return dateString.split("T")[0] ?? dateString;
};

// src/graphql/Day.ts
var DayType = builder5.prismaNode("Day", {
  id: { resolve: (day2) => toDateOnly(day2.date) },
  findUnique: (date) => ({ date: new Date(date) }),
  nullable: true,
  extensions: {
    resolveWhenNull: (findUniqueRes) => createEmptyNode(findUniqueRes)
  },
  fields: (t) => ({
    date: t.expose("date", { type: "Date", description: "The date of the day." }),
    notes: t.relation("notes"),
    tasks: t.prismaField({
      type: ["Task"],
      resolve: async (query3, day2) => {
        const dayInfo = await prisma.day.findUnique({
          where: { date: day2.date },
          select: { tasksOrder: true }
        });
        const order = dayInfo?.tasksOrder ?? day2.tasksOrder;
        const tasks = await prisma.task.findMany({
          ...query3,
          where: { date: day2.date }
        });
        const tasksOrdered = tasks.sort((a, b) => {
          return order.indexOf(a.id) - order.indexOf(b.id);
        });
        return tasksOrdered;
      }
    }),
    routines: t.prismaField({
      type: ["Routine"],
      description: "The routines for the day in chronological order.",
      select: { date: true, routinesCompleted: { select: { id: true } } },
      resolve: async (query3, day2) => {
        const completedRoutineIds = new Set(day2.routinesCompleted.map((routine) => routine.id));
        const routines = await prisma.routine.findMany({
          ...query3,
          orderBy: { time: "asc" },
          where: {
            isActive: true,
            repeats: { has: getDayOfWeek(day2.date) },
            firstDay: { lte: day2.date },
            OR: [{ lastDay: null }, { lastDay: { gte: day2.date } }]
          }
        });
        return routines.map((routine) => ({
          ...routine,
          _done: completedRoutineIds.has(routine.id)
        }));
      }
    })
  })
});
builder5.queryField("days", (t) => t.connection({
  type: DayType,
  extensions: {
    pothosPrismaFallback: () => console.log("fallback")
  },
  description: `Get days using a Relay connection.

If no arguments are provided, it will return the current day.

If \`first\` (Int) is provided, it will return the current day and the following days.

If \`after\` (Date*) is provided, it will return the days after the given date.

If \`last\` (Int) is provided, it will return the current day and the previous days.

If \`before\` (Date*) is provided, it will return the days before the given date.

*Ignore that the GraphQL type is ID as Pothos doesn't support overriding the type of the connection fields.
Please input a Date in the format: YYYY-MM-DD`,
  resolve: async (_, args, context, info) => {
    const start = getStartFromConnectionArgs(args);
    const totalDays = args.first ?? args.last ?? 1;
    const end = endOfDay(new Date(start));
    end.setDate(end.getDate() + totalDays - 1);
    const days = await prisma.day.findMany({
      ...queryFromInfo({ context, info, typeName: "Day", path: ["edges", "node"] }),
      where: { date: { gte: start, lte: end } }
    });
    const dayMap = new Map(days.map((day2) => [toDateOnly(day2.date), day2]));
    const dayEdges = [];
    const dateCursor = new Date(start);
    for (const _2 of Array.from({ length: totalDays })) {
      const day2 = toDateOnly(dateCursor);
      dayEdges.push({
        cursor: day2,
        node: dayMap.get(day2) ?? createEmptyNode({ date: new Date(dateCursor) })
      });
      dateCursor.setDate(dateCursor.getDate() + 1);
    }
    return {
      edges: dayEdges,
      pageInfo: {
        hasNextPage: true,
        hasPreviousPage: true,
        startCursor: toDateOnly(start),
        endCursor: toDateOnly(end)
      }
    };
  }
}));
var createEmptyNode = ({ date }) => ({
  __typename: "Day",
  id: `Day_${toDateOnly(date)}`,
  date,
  tasksOrder: [],
  notes: [],
  routines: [],
  routinesCompleted: [],
  tasks: []
});

// src/graphql/ItemPluginData.ts
var ItemPluginDataType = builder5.prismaNode("ItemPluginData", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    min: t.expose("min", { type: "JSON" }),
    full: t.expose("full", { type: "JSON" }),
    pluginSlug: t.exposeString("pluginSlug")
  })
});
var ItemPluginDataInput = builder5.inputType(builder5.inputRef("ItemPluginDataInput"), {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    originalId: t.string({ required: false }),
    min: t.field({ type: "JSON", required: true }),
    full: t.field({ type: "JSON", required: true })
  })
});

// src/graphql/PrismaFilters.ts
var DateFilter = builder5.prismaFilter("Date", {
  name: "PrismaDateFilter",
  description: "Filter input of Date",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var DateTimeFilter = builder5.prismaFilter("DateTime", {
  name: "PrismaDateTimeFilter",
  description: "Filter input of DateTime",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});
var IntFilter = builder5.prismaFilter("Int", {
  name: "PrismaIntFilter",
  description: "Filter input of Int",
  ops: ["equals", "lt", "lte", "gt", "gte", "in", "not", "notIn"]
});

// src/utils/getPlugins.ts
import fs from "fs/promises";
import path from "path";

// src/utils/pgBoss.ts
var import_pg_boss = __toESM(require_src(), 1);
var pgBoss = new import_pg_boss.default(env.DATABASE_URL ?? "postgresql://postgres@localhost:5432/flow");
pgBoss.on("error", (error8) => {
  console.error(error8);
});

// /Users/richardguerre/Projects/flow/node_modules/@flowdev/nearest-color/src/index.ts
var hexToRgb = function(hex) {
  if (hex.length === 4) {
    hex = hex.replace(/#([a-f0-9])/i, "$1$1");
  }
  const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return {
    r: parseInt(res[1], 16),
    g: parseInt(res[2], 16),
    b: parseInt(res[3], 16)
  };
};
var nearestColor = (colorPallette, color) => {
  if (typeof color === "string") {
    color = hexToRgb(color);
  }
  const rgbColor = color;
  const colorKeys = Object.keys(colorPallette);
  const colorValues = colorKeys.map((key) => hexToRgb(colorPallette[key]));
  const colorDistances = colorValues.map((value) => {
    return Math.sqrt(Math.pow(value.r - rgbColor.r, 2) + Math.pow(value.g - rgbColor.g, 2) + Math.pow(value.b - rgbColor.b, 2));
  });
  const minDistance = Math.min(...colorDistances);
  const minDistanceIndex = colorDistances.indexOf(minDistance);
  return colorKeys[minDistanceIndex];
};

// src/utils/nearestTailwindColor.ts
var colorPalette = {
  slate: "#cbd5e1",
  gray: "#d1d5db",
  zinc: "#d4d4d8",
  neutral: "#d4d4d4",
  stone: "#d6d3d1",
  red: "#fca5a5",
  orange: "#fdba74",
  amber: "#fcd34d",
  yellow: "#fde047",
  lime: "#bef264",
  green: "#86efac",
  emerald: "#6ee7b7",
  teal: "#5eead4",
  cyan: "#67e8f9",
  sky: "#7dd3fc",
  blue: "#93c5fd",
  indigo: "#a5b4fc",
  violet: "#c4b5fd",
  purple: "#d8b4fe",
  fuchsia: "#f0abfc",
  pink: "#f9a8d4",
  rose: "#fda4af"
};
var nearestTailwindColor = (color) => nearestColor(colorPalette, color);

// src/utils/index.ts
var ROLLOVER_TASKS_JOB_NAME = "rollover-tasks-to-today";
var ROLLOVER_TASKS_CRON = "0 4 * * *";
var syncTasks = async () => {
  console.log("-- Syncing tasks...");
  const usersTimezone = await getTimezone();
  const usersToday = dayjs().tz(usersTimezone).utc(true).startOf("day").toDate();
  await prisma.day.upsert({
    where: { date: usersToday },
    create: { date: usersToday },
    update: {}
  });
  const res = await prisma.task.updateMany({
    where: {
      status: { notIn: ["DONE", "CANCELED"] },
      date: { lt: usersToday },
      OR: [{ item: null }, { item: { scheduledAt: null } }]
    },
    data: { date: usersToday }
  });
  console.log(`\u2705 Synced ${res.count} tasks.`);
};
var scheduleRolloverTasks = async (timezone3 = "Etc/GMT-11") => {
  await pgBoss.schedule(ROLLOVER_TASKS_JOB_NAME, ROLLOVER_TASKS_CRON, undefined, {
    tz: timezone3,
    singletonKey: ROLLOVER_TASKS_JOB_NAME
  });
  console.log(`\u2705 Scheduled "${ROLLOVER_TASKS_JOB_NAME}" job.`);
};
var isSessionTokenValid = async (sessionToken) => {
  if (!sessionToken) {
    return false;
  } else {
    const sessionItem = await prisma.store.findFirst({
      where: {
        pluginSlug: FlowPluginSlug,
        key: { startsWith: StoreKeys.AUTH_SESSION_PREFIX },
        AND: [
          { value: { path: ["token"], equals: sessionToken } },
          { value: { path: ["expiresAt"], gt: new Date().toISOString() } }
        ]
      }
    });
    if (!sessionItem) {
      return false;
    }
  }
  return true;
};
var getTimezone = async () => {
  const timezoneItem = await prisma.store.findFirst({
    where: {
      pluginSlug: FlowPluginSlug,
      key: StoreKeys.TIMEZONE
    }
  });
  const timezone3 = timezoneItem?.value;
  try {
    dayjs().tz(timezone3);
    return timezone3;
  } catch {
    return;
  }
};

// src/graphql/Store.ts
var FlowPluginSlug = "flow";
var StoreKeys = {
  INSTALLED_PLUGINS: "installed-plugins",
  PASSWORD_HASH: "password-hash",
  AUTH_SESSION_PREFIX: "session-",
  TIMEZONE: "timezone"
};
var StoreType = builder5.prismaNode("Store", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    key: t.exposeString("key"),
    pluginSlug: t.exposeString("pluginSlug"),
    isSecret: t.exposeBoolean("isSecret"),
    isServerOnly: t.exposeBoolean("isServerOnly"),
    value: t.field({
      type: "JSON",
      nullable: true,
      description: "The value of the store item.",
      resolve: (store) => store.isSecret || store.isServerOnly ? null : store.value
    })
  })
});
builder5.queryField("storeItems", (t) => t.prismaFieldWithInput({
  type: ["Store"],
  description: `Get store items.

Pass the \`pluginSlug\` if you want to get items created by a specific plugin. Not passing the \`pluginSlug\` will return items created by flow.`,
  input: {
    pluginSlug: t.input.string({ required: false }),
    keys: t.input.stringList({ required: false })
  },
  argOptions: {
    required: false,
    name: "where"
  },
  resolve: (query3, _, args) => {
    return prisma.store.findMany({
      ...query3,
      where: {
        ...args.where?.pluginSlug ? { pluginSlug: args.where?.pluginSlug } : {},
        ...args.where?.keys?.length ? { key: { in: args.where.keys } } : {}
      }
    });
  }
}));
builder5.queryField("isPasswordSet", (t) => t.field({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "Boolean",
  description: "Whether the password is set.",
  resolve: async () => {
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    }).catch(() => null);
    return !!passwordSetting;
  }
}));
builder5.queryField("timezoneSet", (t) => t.field({
  type: "String",
  description: "The timezone set for the Flow instance. `null` if no timezone is set.",
  nullable: true,
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: async () => {
    const timezoneSetting = await prisma.store.findUnique({
      where: { pluginSlug_key_unique: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug } }
    }).catch(() => null);
    return timezoneSetting?.value ?? null;
  }
}));
builder5.queryField("isFullySetup", (t) => t.field({
  type: "Boolean",
  description: "Whether the Flow instance is fully setup.",
  nullable: false,
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: async () => {
    const storeItems = await prisma.store.findMany({
      where: {
        key: { in: [StoreKeys.PASSWORD_HASH, StoreKeys.TIMEZONE] },
        pluginSlug: FlowPluginSlug
      }
    });
    return storeItems.length === 2;
  }
}));
builder5.queryField("isSessionValid", (t) => t.field({
  type: "Boolean",
  description: "Whether the session is valid.",
  authScopes: { public: true },
  skipTypeScopes: true,
  resolve: (_, __, context) => context.isSessionValid()
}));
builder5.queryField("installedPlugins", (t) => t.field({
  type: [PluginInstallationType],
  description: "Get all installed plugins.",
  resolve: getPluginsInStore
}));
var PluginInstallationType = builder5.objectType(builder5.objectRef("PluginInstallation"), {
  fields: (t) => ({
    slug: t.exposeString("slug"),
    url: t.exposeString("url"),
    hasWebRuntime: t.exposeBoolean("web"),
    hasServerRuntime: t.exposeBoolean("server")
  })
});
builder5.mutationField("upsertStoreItem", (t) => t.prismaFieldWithInput({
  type: "Store",
  description: `Creates a store item. If a store item with the same key exists, only its value will be updated (\`isSecret\` and \`isServerOnly\` will not be updated).

If the \`pluginSlug\` is passed, it will create/update a store item for that plugin. Otherwise, it will create/update a store item for flow.

If \`isSecret\` is set to true, \`isServerOnly\` will also be set to true and will not be returned in the \`storeItems\` query (it will be \`null\`). The item will only be accessible by plugin with the same \`pluginSlug\` in the server.

If \`isServerOnly\` is set to true, the store item will not be returned in the \`storeItems\` query (it will be \`null\`). The item will be accessible by all plugins in the server.`,
  input: {
    key: t.input.string({ required: true }),
    value: t.input.field({ type: "JSON", required: true }),
    pluginSlug: t.input.string({ required: true }),
    isSecret: t.input.boolean({ required: false }),
    isServerOnly: t.input.boolean({ required: false })
  },
  resolve: async (query3, _, args) => {
    if (args.input.pluginSlug === "flow") {
      throw new GraphQLError("The slug 'flow' is reserved for internal use. Please use your plugin's slug.", {
        extensions: {
          code: "KEY_RESERVED",
          userFriendlyMessage: "The item couldn't be saved. Please ask the plugin author for more information."
        }
      });
    }
    const res = await prisma.store.upsert({
      ...query3,
      where: {
        pluginSlug_key_unique: { key: args.input.key, pluginSlug: args.input.pluginSlug }
      },
      update: { value: args.input.value },
      create: {
        key: args.input.key,
        value: args.input.value,
        pluginSlug: args.input.pluginSlug,
        isSecret: args.input.isSecret ?? false,
        isServerOnly: args.input.isServerOnly ?? args.input.isSecret ?? false
      }
    });
    const plugins4 = await getPlugins2();
    const plugin3 = plugins4[args.input.pluginSlug];
    await plugin3?.onStoreItemUpsert?.(args.input.key).catch((e) => console.log(`Error plugin.onStoreItemUpsert for ${args.input.pluginSlug}`, e));
    return res;
  }
}));
builder5.mutationField("installPlugin", (t) => t.fieldWithInput({
  type: [PluginInstallationType],
  description: "Install a plugin. If a plugin with the same slug exists, it will throw an error, unless `override` is set to true.",
  input: {
    url: t.input.string({ required: true }),
    override: t.input.boolean({ required: false })
  },
  resolve: async (_, args) => {
    let installedPlugins = await getPluginsInStore();
    const newPluginJson = await getPluginJson({ url: args.input.url });
    if (!args.input.override && installedPlugins.find((p) => p.slug === newPluginJson.slug)) {
      throw new GraphQLError(`A plugin with the slug "${newPluginJson.slug}" is already installed. Use the \`override\` option to override the existing plugin.`, {
        extensions: {
          code: "PLUGIN_WITH_SAME_SLUG",
          userFriendlyMessage: "There is a problem with the plugin you are trying to install (Error: PLUGIN_WITH_SAME_SLUG). Please contact the plugin author for more information."
        }
      });
    }
    if (newPluginJson.slug.includes("_")) {
      throw new GraphQLError(`The plugin slug "${newPluginJson.slug}" is invalid. Plugin slugs cannot contain underscores.`, {
        extensions: {
          code: "PLUGIN_SLUG_INVALID",
          userFriendlyMessage: "There is a problem with the plugin you are trying to install (Err: PLUGIN_SLUG_INVALID). Please contact the plugin author for more information."
        }
      });
    }
    if (newPluginJson.server) {
      await installServerPlugin({
        url: args.input.url,
        slug: newPluginJson.slug,
        override: args.input.override ?? false
      });
    }
    installedPlugins = installedPlugins.filter((p) => p.slug !== newPluginJson.slug);
    installedPlugins.push({
      url: args.input.url,
      slug: newPluginJson.slug,
      web: newPluginJson.web ?? false,
      server: newPluginJson.server ?? false
    });
    const newSetting = await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.INSTALLED_PLUGINS, pluginSlug: FlowPluginSlug }
      },
      update: { value: installedPlugins },
      create: {
        key: StoreKeys.INSTALLED_PLUGINS,
        pluginSlug: FlowPluginSlug,
        value: installedPlugins,
        isSecret: false,
        isServerOnly: false
      }
    });
    return newSetting.value;
  }
}));
builder5.mutationField("uninstallPlugin", (t) => t.fieldWithInput({
  type: [PluginInstallationType],
  description: "Uninstall a plugin.",
  input: {
    slug: t.input.string({ required: true })
  },
  resolve: async (_, args) => {
    let installedPlugins = await getPluginsInStore();
    await uninstallServerPlugin(args.input.slug);
    installedPlugins = installedPlugins.filter((p) => p.slug !== args.input.slug);
    const newSetting = await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.INSTALLED_PLUGINS, pluginSlug: FlowPluginSlug }
      },
      update: { value: installedPlugins },
      create: {
        key: StoreKeys.INSTALLED_PLUGINS,
        pluginSlug: FlowPluginSlug,
        value: installedPlugins,
        isSecret: false,
        isServerOnly: false
      }
    });
    return newSetting.value;
  }
}));
var generatePasswordHash = async (password) => {
  return Bun.password.hash(password, "bcrypt");
};
var generateSessionToken = () => {
  return new Bun.CryptoHasher("sha256").digest("base64");
};
builder5.mutationField("setPassword", (t) => t.fieldWithInput({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "String",
  description: "Set password for the Flow instance and get a session token to make authenticated requests.",
  input: {
    password: t.input.string({ required: true, description: "The password to set (unhashed)." })
  },
  resolve: async (_, args, context) => {
    if (args.input.password.length < 8) {
      throw new GraphQLError("The password must be at least 8 characters long.", {
        extensions: { code: "PASSWORD_TOO_SHORT" }
      });
    }
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (passwordSetting) {
      throw new GraphQLError("The password can only be set once. Use the `changePassword` mutation to change the password.", { extensions: { code: "PASSWORD_ALREADY_SET" } });
    }
    const passwordHash = await generatePasswordHash(args.input.password);
    await prisma.store.create({
      data: {
        key: StoreKeys.PASSWORD_HASH,
        pluginSlug: FlowPluginSlug,
        value: passwordHash,
        isSecret: true,
        isServerOnly: true
      }
    }).catch((e) => {
      console.error(e);
      throw new GraphQLError(e.message ?? "Something went wrong while setting the password.", {
        extensions: {
          code: "PASSWORD_SET_ERROR",
          userFriendlyMessage: "Something went wrong while setting the password."
        }
      });
    });
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    return sessionToken;
  }
}));
builder5.mutationField("changePassword", (t) => t.fieldWithInput({
  type: "String",
  description: "Change password for the Flow instance and get a new session token to make authenticated requests.",
  input: {
    oldPassword: t.input.string({ required: true, description: "The old password (unhashed)." }),
    newPassword: t.input.string({ required: true, description: "The new password (unhashed)." })
  },
  resolve: async (_, args, context) => {
    if (args.input.newPassword.length < 8) {
      throw new GraphQLError("The new password must be at least 8 characters.", {
        extensions: { code: "PASSWORD_TOO_SHORT" }
      });
    }
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (!passwordSetting) {
      throw new GraphQLError("The password is not set. Use the `setPassword` mutation to set the password.", {
        extensions: {
          code: "PASSWORD_NOT_SET",
          userFriendlyMessage: "No password was set for your Flow yet. Please refresh the page to set the password."
        }
      });
    }
    const isOldPasswordCorrect = await Bun.password.verify(args.input.oldPassword, passwordSetting.value);
    if (!isOldPasswordCorrect) {
      throw new GraphQLError("The old password is incorrect.", {
        extensions: { code: "PASSWORD_INCORRECT" }
      });
    }
    const newPasswordHash = await generatePasswordHash(args.input.newPassword);
    await prisma.store.update({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      },
      data: { value: newPasswordHash }
    }).catch((e) => {
      console.error(e);
      throw new GraphQLError(e.message ?? "Something went wrong while changing the password.", {
        extensions: {
          code: "PASSWORD_CHANGE_ERROR",
          userFriendlyMessage: "Something went wrong while changing the password."
        }
      });
    });
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    await prisma.store.deleteMany({
      where: { pluginSlug: FlowPluginSlug, key: { not: authSessionKey } }
    });
    return sessionToken;
  }
}));
builder5.mutationField("login", (t) => t.fieldWithInput({
  authScopes: { public: true },
  skipTypeScopes: true,
  type: "String",
  description: "Login to the Flow instance and get a session token to make authenticated requests.",
  input: {
    password: t.input.string({ required: true, description: "The password (unhashed)." })
  },
  resolve: async (_, args, context) => {
    const passwordSetting = await prisma.store.findUnique({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.PASSWORD_HASH, pluginSlug: FlowPluginSlug }
      }
    });
    if (!passwordSetting) {
      throw new GraphQLError("The password is not set. Use the `setPassword` mutation to set the password.", {
        extensions: {
          code: "PASSWORD_NOT_SET",
          userFriendlyMessage: "No password was set for your Flow yet. Please refresh the page to set the password."
        }
      });
    }
    const isPasswordCorrect = await Bun.password.verify(args.input.password, passwordSetting.value);
    if (!isPasswordCorrect) {
      throw new GraphQLError("The password is incorrect.", {
        extensions: { code: "PASSWORD_INCORRECT" }
      });
    }
    const sessionToken = generateSessionToken();
    const authSession = {
      ...context.userAgent ? { userAgent: context.userAgent } : { name: "No user-agent" },
      createdAt: dayjs().toISOString(),
      expiresAt: dayjs().add(1, "year").toISOString(),
      token: sessionToken
    };
    const authSessionKey = StoreKeys.AUTH_SESSION_PREFIX + dayjs().toISOString();
    await prisma.store.upsert({
      where: { pluginSlug_key_unique: { key: authSessionKey, pluginSlug: FlowPluginSlug } },
      update: { value: authSession },
      create: {
        key: authSessionKey,
        pluginSlug: FlowPluginSlug,
        value: authSession,
        isSecret: true,
        isServerOnly: true
      }
    });
    return sessionToken;
  }
}));
builder5.mutationField("logout", (t) => t.field({
  authScopes: { authenticated: true },
  skipTypeScopes: true,
  type: "Boolean",
  description: "Logout from the Flow instance using the session token set in the Authorization header.",
  resolve: async (_, __, { sessionToken }) => {
    await prisma.store.deleteMany({
      where: {
        pluginSlug: FlowPluginSlug,
        key: { startsWith: StoreKeys.AUTH_SESSION_PREFIX },
        value: { path: ["token"], equals: sessionToken }
      }
    });
    return true;
  }
}));
builder5.mutationField("setTimezone", (t) => t.fieldWithInput({
  type: "String",
  description: 'Set the timezone using a [dayjs timezone string](https://day.js.org/docs/en/plugin/timezone) (e.g. "America/New_York") for the Flow instance. This will affect the time the tasks are synced (default is 04:00 in the timezone set)',
  input: {
    timezone: t.input.string({
      required: true,
      description: 'The timezone to set as a [dayjs timezone string](https://day.js.org/docs/en/plugin/timezone) (e.g. "America/New_York").'
    })
  },
  resolve: async (_, args) => {
    try {
      dayjs().tz(args.input.timezone);
    } catch {
      throw new GraphQLError('The timezone is invalid. Please use a correct timezone identifier (e.g. "America/New_York") from this list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.', { extensions: { code: "TIMEZONE_INVALID" } });
    }
    await prisma.store.upsert({
      where: {
        pluginSlug_key_unique: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug }
      },
      update: { value: args.input.timezone },
      create: {
        key: StoreKeys.TIMEZONE,
        pluginSlug: FlowPluginSlug,
        value: args.input.timezone,
        isSecret: false,
        isServerOnly: false
      }
    });
    await scheduleRolloverTasks(args.input.timezone);
    return args.input.timezone;
  }
}));

// src/utils/getPluginOptions.ts
var getPluginOptions = (pluginSlug) => ({
  pluginSlug,
  serverOrigin: env.ORIGIN,
  dayjs,
  pgBoss: {
    send: pgBoss.send,
    sendAfter: pgBoss.sendAfter,
    sendOnce: pgBoss.sendOnce,
    sendSingleton: pgBoss.sendSingleton,
    sendThrottled: pgBoss.sendThrottled,
    sendDebounced: pgBoss.sendDebounced,
    schedule: pgBoss.schedule
  },
  prisma: {
    day: {
      findUnique: prisma.day.findUnique,
      findUniqueOrThrow: prisma.day.findUniqueOrThrow,
      findFirst: prisma.day.findFirst,
      findFirstOrThrow: prisma.day.findFirstOrThrow,
      findMany: prisma.day.findMany,
      count: prisma.day.count,
      aggregate: prisma.day.aggregate,
      groupBy: prisma.day.groupBy
    },
    note: prisma.note,
    noteTag: prisma.noteTag,
    task: prisma.task,
    taskPluginData: prisma.taskPluginData,
    taskTag: prisma.taskTag,
    item: prisma.item,
    itemPluginData: prisma.itemPluginData,
    list: prisma.list,
    routine: prisma.routine
  },
  store: {
    setItem: async (key, value) => {
      if (typeof value === "symbol" || typeof value === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value },
        create: { pluginSlug, key, value }
      });
      return result;
    },
    setSecretItem: async (key, value) => {
      if (typeof value === "symbol" || typeof value === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value },
        create: { pluginSlug, key, value, isSecret: true, isServerOnly: true }
      });
      return result;
    },
    setServerOnlyItem: async (key, value) => {
      if (typeof value === "symbol" || typeof value === "function") {
        throw new Error("Cannot store symbols or functions in the store.");
      }
      const result = await prisma.store.upsert({
        where: { pluginSlug_key_unique: { pluginSlug, key } },
        update: { value },
        create: { pluginSlug, key, value, isServerOnly: true }
      });
      return result;
    },
    deleteItem: async (key) => {
      const result = await prisma.store.delete({
        where: { pluginSlug_key_unique: { pluginSlug, key } }
      });
      return result;
    },
    getPluginItem: async (key) => {
      const result = await prisma.store.findFirst({
        where: { key, pluginSlug }
      });
      return result;
    },
    getItem: async (key, opts) => {
      const result = await prisma.store.findFirst({
        where: { key, pluginSlug: opts?.pluginSlug, isSecret: false }
      });
      return result;
    }
  },
  getUsersTimezone: async () => {
    const timezoneItem = await prisma.store.findFirst({
      where: { key: StoreKeys.TIMEZONE, pluginSlug: FlowPluginSlug }
    });
    return timezoneItem?.value ?? null;
  },
  getNearestItemColor: (hex) => nearestTailwindColor(hex),
  GraphQLError
});

// src/utils/getPlugins.ts
async function installServerPlugin(opts) {
  const res = await fetch(`${opts.url}/server.js`).catch((err) => {
    if (err.message === "fetch failed") {
      throw new GraphQLError(`Got no response. Make sure the URL is correct: "${opts.url}/server.js"`);
    }
    throw new GraphQLError(err.message);
  });
  if (!res.ok) {
    throw new GraphQLError(`Got status code ${res.status} from "${opts.url}/server.js"`);
  }
  const text = await res.text();
  if (text.startsWith("Couldn't find the requested file")) {
    throw new GraphQLError(`Couldn't find the plugin at "${opts.url}/server.js"`);
  }
  try {
    await fs.readdir(pathToPlugins);
  } catch (err) {
    if (err.code !== "ENOENT") {
      throw err;
    }
    await fs.mkdir(pathToPlugins, { recursive: true });
  }
  if (/Bun|require|eval|setTimeout|setInterval|setImmidiate|process\.|__dirname|__filename|spawn|spawnSync|write|import\.meta|ffi|transpile|transform/.test(text)) {
    throw new GraphQLError(`The plugin is unsafe to install as it can gain access to sensitive data. Contact the plugin author or install a different plugin.`);
  }
  await Bun.write(pathToTemp, text);
  delete import.meta.require.cache[pathToTemp];
  let exported;
  try {
    exported = import.meta.require(pathToTemp);
  } catch (e) {
    console.log(e);
    throw new GraphQLError(`Couldn't install the server part of the plugin. Contact the plugin author to fix this.`);
  }
  if (typeof exported !== "object") {
    throw new GraphQLError(`Couldn't find any exports at "${opts.url}/server.js"`);
  }
  if ("default" in exported) {
    exported = exported.default;
  }
  if (typeof exported.plugin !== "function") {
    throw new GraphQLError(`The exports of "${opts.url}/server.js" must have a \`plugin\` property which is a function. Please use \`definePlugin\` from \`@flowdev/plugin/server\`.`);
  }
  if (!opts.override && cache3.has(opts.slug)) {
    throw new GraphQLError(`PLUGIN_WITH_SAME_SLUG: A plugin with the slug "${opts.slug}" is already installed. Use the \`override\` option to override the existing plugin.`);
  }
  await fs.rename(pathToTemp, path.join(pathToPlugins, `${opts.slug}.js`));
  const plugin3 = exported.plugin(getPluginOptions(opts.slug));
  cache3.set(opts.slug, plugin3);
  await plugin3.onInstall?.();
}
async function uninstallServerPlugin(slug) {
  await cache3.get(slug)?.onUninstall?.();
  await fs.unlink(path.join(pathToPlugins, `${slug}.js`));
  cache3.delete(slug);
}
var cache3 = new Map;
var pathToPlugins = path.join(import.meta.dir, env.PATH_TO_PLUGINS ?? "../../plugins");
var pathToTemp = path.join(pathToPlugins, "__temp.js");
var getPlugins2 = async () => {
  const plugins4 = (await fs.readdir(pathToPlugins).catch(() => [])).filter((p) => p.endsWith(".js") && p !== "__temp.js").map((p) => p.replace(".js", ""));
  const unCachedPlugins = plugins4.filter((plugin3) => !cache3.has(plugin3));
  if (unCachedPlugins.length === 0) {
    return Object.fromEntries(cache3);
  }
  for (const pluginSlug of unCachedPlugins) {
    let exported = import.meta.require(path.join(pathToPlugins, pluginSlug));
    if ("default" in exported) {
      exported = exported.default;
    }
    cache3.set(pluginSlug, exported.plugin(getPluginOptions(pluginSlug)));
  }
  return Object.fromEntries(cache3);
};
var getPluginsInStore = async () => {
  const storeItem = await prisma.store.findFirst({
    where: {
      key: StoreKeys.INSTALLED_PLUGINS,
      isSecret: false,
      isServerOnly: false,
      pluginSlug: FlowPluginSlug
    }
  });
  return storeItem?.value ?? [];
};
var getPluginJson = async (opts) => {
  const res = await fetch(`${opts.url}/plugin.json`).catch((err) => {
    if (err.message === "fetch failed") {
      throw new GraphQLError(`Got no response. Make sure the URL is correct: "${opts.url}/plugin.json"`);
    }
    throw new GraphQLError(err.message);
  });
  if (!res.ok) {
    throw new GraphQLError(`Got status code ${res.status} from "${opts.url}/plugin.json"`);
  }
  const text = await res.text();
  if (text.startsWith("Couldn't find the requested file")) {
    throw new GraphQLError(`Couldn't find the plugin at "${opts.url}/server.js"`);
  }
  try {
    return JSON.parse(text);
  } catch (err) {
    throw new GraphQLError(`Couldn't parse JSON of "${opts.url}/plugin.json"`);
  }
};

// src/graphql/Task.ts
var TaskType = builder5.prismaNode("Task", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    title: t.exposeString("title"),
    status: t.expose("status", { type: TaskStatusEnum }),
    completedAt: t.expose("completedAt", { type: "DateTime", nullable: true }),
    date: t.expose("date", { type: "Date" }),
    item: t.relation("item", { nullable: true }),
    durationInMinutes: t.int({
      nullable: true,
      description: "The length of time the task is expected to take.",
      select: { item: { select: { durationInMinutes: true } } },
      resolve: (task) => {
        return task.durationInMinutes ?? task.item?.durationInMinutes;
      }
    }),
    tags: t.relation("tags"),
    pluginDatas: t.relation("pluginDatas")
  })
});
var TaskStatusEnum = builder5.enumType("TaskStatus", {
  values: {
    TODO: {
      description: "When the task is planned or in progress.",
      value: "TODO"
    },
    CANCELED: {
      description: "When the task was decided not to be done anymore.",
      value: "CANCELED"
    },
    DONE: {
      description: "When the task is done.",
      value: "DONE"
    }
  }
});
var TaskStatusFilter = builder5.prismaFilter(TaskStatusEnum, {
  ops: ["equals", "not", "in", "notIn"]
});
var TaskWhereInputType = builder5.prismaWhere("Task", {
  fields: {
    status: TaskStatusFilter,
    date: DateFilter,
    completedAt: DateTimeFilter
  }
});
var TaskListWhereInputType = builder5.prismaListFilter(TaskWhereInputType, {
  ops: ["every", "some", "none"]
});
builder5.mutationField("createTask", (t) => t.prismaFieldWithInput({
  type: "Task",
  description: `Create a new task.`,
  input: {
    title: t.input.string({ required: true, description: "The title of the task." }),
    status: t.input.field({
      type: TaskStatusEnum,
      defaultValue: "TODO",
      description: "The initial status of the task. Defaults to `TODO`."
    }),
    durationInMinutes: t.input.field({
      type: "PositiveInt",
      description: "The length of time (in minutes) the task is expected to take."
    }),
    date: t.input.field({
      type: "Date",
      description: "The day (no time required) the task is planned for."
    }),
    itemId: t.input.globalID({
      description: "The Relay ID of the Item that should be linked to the task."
    }),
    atIndex: t.input.int({
      description: "The position in the day the task should be placed at. If not specified, it will be placed at the beginning."
    }),
    pluginDatas: t.input.field({
      description: "The plugin data to be linked to the task.",
      type: [TaskPluginDataInput]
    }),
    actionDatas: t.input.field({
      description: "The actions to be executed after the task is created.",
      type: [TaskActionDataInput]
    })
  },
  resolve: async (query3, _, args) => {
    const date = args.input.date ?? startOfDay(new Date);
    const index = args.input.atIndex ?? 0;
    const plugins4 = await getPlugins2();
    const pluginDatas = [];
    let item;
    if (args.input.itemId) {
      item = await prisma.item.findUnique({
        where: { id: parseInt(args.input.itemId?.id) },
        include: { pluginDatas: true }
      });
    }
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      const actionData = args.input.actionDatas?.find((actionData2) => actionData2.pluginSlug === pluginSlug)?.data;
      const webPluginData = args.input.pluginDatas?.find((pluginData) => pluginData.pluginSlug === pluginSlug);
      const result = await plugin3.onCreateTask?.({
        actionData,
        task: {
          title: args.input.title,
          status: args.input.status,
          durationInMinutes: args.input.durationInMinutes,
          date,
          item,
          pluginData: {
            originalId: webPluginData?.originalId,
            min: webPluginData?.min,
            full: webPluginData?.full
          }
        }
      }).catch((e) => {
        console.log(`Error plugin.onCreateTask for ${pluginSlug}`, e);
        return null;
      });
      if (result?.pluginData) {
        pluginDatas.push({
          pluginSlug,
          originalId: result.pluginData.originalId,
          min: result.pluginData.min,
          full: result.pluginData.full
        });
      }
    }
    return prisma.$transaction(async (tx) => {
      const task = await tx.task.create({
        ...query3,
        data: {
          title: args.input.title,
          status: u(args.input.status),
          durationInMinutes: args.input.durationInMinutes,
          day: { connectOrCreate: { where: { date }, create: { date } } },
          ...args.input.itemId ? { item: { connect: { id: parseInt(args.input.itemId.id) } } } : {},
          pluginDatas: { createMany: { data: pluginDatas } }
        }
      });
      const day2 = await tx.day.findUnique({ where: { date }, select: { tasksOrder: true } });
      const newTasksOrder = [
        ...day2.tasksOrder.slice(0, index),
        task.id,
        ...day2.tasksOrder.slice(index)
      ];
      await tx.day.update({ where: { date }, data: { tasksOrder: { set: newTasksOrder } } });
      return task;
    });
  }
}));
var TaskPluginDataInput = builder5.inputType("TaskPluginDataInput", {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    originalId: t.string({ required: false }),
    min: t.field({ type: "JSON" }),
    full: t.field({ type: "JSON" })
  })
});
var TaskActionDataInput = builder5.inputType("TaskActionDataInput", {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    data: t.field({ type: "JSON" })
  })
});
builder5.mutationField("updateTask", (t) => t.prismaFieldWithInput({
  type: "Task",
  description: `Update a task.`,
  input: {
    id: t.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    title: t.input.string({ description: "The title of the task." }),
    durationInMinutes: t.input.field({
      type: "PositiveInt",
      description: "The length of time (in minutes) the task is expected to take."
    })
  },
  resolve: (query3, _, args) => {
    return prisma.task.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: {
        title: u(args.input.title),
        durationInMinutes: args.input.durationInMinutes
      }
    });
  }
}));
builder5.mutationField("deleteTask", (t) => t.prismaField({
  type: "Task",
  description: `Delete a task.`,
  args: {
    id: t.arg.globalID({ required: true, description: "The Relay ID of the task to delete." })
  },
  resolve: (query3, _, args) => {
    return prisma.task.delete({ ...query3, where: { id: parseInt(args.id.id) } });
  }
}));
builder5.mutationField("updateTaskStatus", (t) => t.prismaFieldWithInput({
  type: ["Day"],
  description: `Update the status of a task and get the updated days (as a list in chronological order).

When the task is:
- already in the desired status, it does nothing and returns an empty list.
- for today, it updates the status and returns the day.
- for a previous day and changing to \`TODO\`, it updates the status and
  returns the original day and today.
- for a future day and changing to \`DONE\` or \`CANCELED\`, it updates the status and
  returns the original day and today.

Any other scenario is not possible by nature of the app, where tasks:
- in the past can only be \`DONE\` or \`CANCELED\` 
- in the future can only be in \`TODO\`
    `,
  input: {
    id: t.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    status: t.input.field({
      type: TaskStatusEnum,
      required: true,
      description: "The new status of the task."
    }),
    actionData: t.input.field({
      type: [TaskActionDataInput],
      description: "The action data to be passed to the plugin."
    })
  },
  resolve: async (query3, _, args) => {
    const days = [];
    const plugins4 = await getPlugins2();
    await prisma.$transaction(async (tx) => {
      const newStatus = args.input.status;
      const task = await tx.task.findUniqueOrThrow({
        where: { id: parseInt(args.input.id.id) },
        include: { day: { select: { date: true, tasksOrder: true } }, pluginDatas: true }
      });
      for (const pluginSlug in plugins4) {
        const plugin3 = plugins4[pluginSlug];
        await plugin3.onUpdateTaskStatus?.({
          actionData: args.input.actionData,
          newStatus,
          task
        });
      }
      const originalDay = task.day;
      const startOfToday = startOfDay();
      const endOfToday = endOfDay();
      if (task.status === newStatus) {
      } else if (task.date >= startOfToday && task.date <= endOfToday) {
        await tx.task.update({
          where: { id: task.id },
          data: { status: newStatus, completedAt: newStatus === "DONE" ? new Date : null }
        });
        const newTasksOrder = originalDay.tasksOrder.filter((id) => id !== task.id);
        if (newStatus === "TODO") {
          newTasksOrder.splice(0, 0, task.id);
        } else {
          newTasksOrder.push(task.id);
        }
        await tx.day.update({
          where: { date: startOfToday },
          data: {
            tasksOrder: { set: newTasksOrder }
          }
        });
        days.push(task.date);
      } else if (task.date > endOfToday && (newStatus === "DONE" || newStatus === "CANCELED")) {
        await tx.task.update({
          where: { id: task.id },
          data: {
            status: newStatus,
            completedAt: newStatus === "DONE" ? new Date : null,
            day: {
              connectOrCreate: {
                where: { date: startOfToday },
                create: { date: startOfToday }
              }
            }
          }
        });
        await tx.day.update({
          where: { date: startOfToday },
          data: { tasksOrder: { push: task.id } }
        });
        days.push(startOfToday);
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
        });
        days.push(originalDay.date);
      } else if (task.date < startOfToday) {
        if (newStatus === "TODO") {
          const updatedTask = await tx.task.update({
            where: { id: task.id },
            data: {
              status: newStatus,
              completedAt: null,
              day: {
                connectOrCreate: {
                  where: { date: startOfToday },
                  create: { date: startOfToday }
                }
              }
            },
            select: {
              day: {
                select: { tasks: { select: { id: true, status: true } }, tasksOrder: true }
              }
            }
          });
          await tx.day.update({
            where: { date: originalDay.date },
            data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
          });
          days.push(task.date);
          const tasksOrdered = updatedTask.day.tasks.sort((a, b) => updatedTask.day.tasksOrder.indexOf(a.id) - updatedTask.day.tasksOrder.indexOf(b.id));
          const lastTodoIndex = tasksOrdered.findIndex((t2) => t2.status === "TODO");
          const newTasksOrder = updatedTask.day.tasksOrder.splice(lastTodoIndex + 1, 0, task.id);
          await tx.day.update({
            where: { date: startOfToday },
            data: { tasksOrder: { set: newTasksOrder } }
          });
          days.push(startOfToday);
        } else {
          await tx.task.update({
            where: { id: task.id },
            data: {
              status: newStatus,
              completedAt: newStatus === "DONE" ? dayjs(task.date).endOf("day").toDate() : null
            }
          });
          days.push(task.date);
        }
      }
    });
    return prisma.day.findMany({
      ...query3,
      where: { date: { in: days } },
      orderBy: { date: "asc" }
    });
  }
}));
builder5.mutationField("updateTaskDate", (t) => t.fieldWithInput({
  type: [DayType],
  description: `Update the date of a task and/or position of the task in the day, and get the updated days (as a list in chronological order).

Input:
- \`id\`: The ID of the task to update.
- \`date\`: The new date of the task.
- \`after\`: The ID of the task to place the task after. If \`null\`, the task will be placed at the beginning of the day.

When the task is:
- already in the desired date, it updates the order and returns the day.
- moved to today, it updates the date and order but not the status, and returns the original day and today.
- moved into the past, it updates the date and order, updates the status to \`DONE\` (if not already),
  and returns the original day and the new day.
- moved into the future, it updates the date and order, updates the status to \`TODO\` (if not already),
  and returns the original day and the new day.`,
  input: {
    id: t.input.globalID({ required: true, description: "The Relay ID of the task to update." }),
    date: t.input.field({
      type: "Date",
      required: true,
      description: "The new date of the task."
    }),
    newTasksOrder: t.input.globalIDList({
      required: true,
      description: "The new order of the tasks in the day the task is moved into."
    })
  },
  resolve: async (_, args) => {
    const plugins4 = await getPlugins2();
    return prisma.$transaction(async (tx) => {
      const days = [];
      const newDate = args.input.date;
      const task = await tx.task.findUniqueOrThrow({
        where: { id: parseInt(args.input.id.id) },
        include: { day: { select: { date: true, tasksOrder: true } }, pluginDatas: true }
      });
      const originalDay = task.day;
      const isSameDay = dayjs(task.date).isSame(newDate, "day");
      const newDayTasksOrder = args.input.newTasksOrder.filter((id) => id.typename === "Task").map((id) => parseInt(id.id));
      const startOfToday = startOfDay();
      const endOfToday = endOfDay();
      let newStatus = null;
      if (isSameDay) {
        newStatus = null;
        days.push(task.date);
      } else if (newDate >= startOfToday && newDate <= endOfToday) {
        newStatus = null;
        days.push(task.date, newDate);
      } else if (newDate < startOfToday) {
        if (task.status !== "CANCELED") {
          newStatus = "DONE";
        }
        days.push(task.date, newDate);
      } else if (newDate > endOfToday) {
        newStatus = "TODO";
        days.push(task.date, newDate);
      }
      if (newStatus === task.status) {
        newStatus = null;
      }
      if (newStatus) {
        for (const pluginSlug in plugins4) {
          const plugin3 = plugins4[pluginSlug];
          await plugin3.onUpdateTaskStatus?.({ newStatus, task });
        }
      }
      await tx.task.update({
        where: { id: task.id },
        data: {
          day: { connectOrCreate: { where: { date: newDate }, create: { date: newDate } } },
          ...newStatus ? {
            status: newStatus,
            completedAt: newStatus === "DONE" ? dayjs(newDate).endOf("day").toDate() : null
          } : {}
        }
      });
      if (isSameDay) {
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: newDayTasksOrder } }
        });
      } else {
        await tx.day.update({
          where: { date: originalDay.date },
          data: { tasksOrder: { set: originalDay.tasksOrder.filter((id) => id !== task.id) } }
        });
        await tx.day.update({
          where: { date: newDate },
          data: { tasksOrder: { set: newDayTasksOrder } }
        });
      }
      return prisma.day.findMany({
        where: { date: { in: days } },
        orderBy: { date: "asc" }
      });
    });
  }
}));

// src/graphql/Item.ts
var ItemType = builder5.prismaNode("Item", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    title: t.exposeString("title"),
    isRelevant: t.exposeBoolean("isRelevant"),
    inboxPoints: t.exposeInt("inboxPoints", { nullable: true }),
    scheduledAt: t.expose("scheduledAt", { type: "DateTime", nullable: true }),
    durationInMinutes: t.exposeInt("durationInMinutes", { nullable: true }),
    isAllDay: t.exposeBoolean("isAllDay", { nullable: true }),
    color: t.expose("color", { type: ColorEnum, nullable: true }),
    pluginDatas: t.relation("pluginDatas"),
    tasks: t.relation("tasks"),
    list: t.relation("list", { nullable: true })
  })
});
var ItemWhereInputType = builder5.prismaWhere("Item", {
  fields: {
    isRelevant: "Boolean",
    scheduledAt: DateTimeFilter,
    inboxPoints: IntFilter,
    tasks: TaskListWhereInputType
  }
});
var ItemOrderByType = builder5.prismaOrderBy("Item", {
  fields: {
    inboxPoints: true,
    scheduledAt: true,
    createdAt: true,
    updatedAt: true
  }
});
builder5.queryField("items", (t) => t.prismaConnection({
  type: "Item",
  cursor: "id",
  description: `Get all external items. Useuful to get list of items for a specific day to show in a calendar, or get items with inboxPoints to show in the inbox.
By default, only items where \`isRelevant\` is true.
Pass the \`where\` argument to override these defaults.`,
  args: {
    where: t.arg({ type: ItemWhereInputType, required: false }),
    orderBy: t.arg({ type: ItemOrderByType, required: false })
  },
  smartSubscription: true,
  subscribe: (subs) => {
    subs.register("itemsCreated");
    subs.register("itemsUpdated");
    subs.register("itemsDeleted");
  },
  resolve: (query3, _, args) => {
    return prisma.item.findMany({
      ...query3,
      take: undefined,
      where: args.where ?? undefined,
      orderBy: args.orderBy ?? undefined
    });
  }
}));
builder5.mutationField("createItem", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Create an item.`,
  input: {
    title: t.input.string({ required: true, description: `The title of the item.` }),
    isRelevant: t.input.boolean({
      required: false,
      description: `If set to true, it will return items where \`isRelevant\` is true. 

\`isRelevant\` is used in the List component to only show relevant items. If the item becomes irrelevant (e.g. because the trello task was already completed), you can update the item to make this \`isRelevant = false\``
    }),
    scheduledAt: t.input.field({ type: "DateTime", required: false }),
    durationInMinutes: t.input.int({ required: false }),
    isAllDay: t.input.boolean({ required: false }),
    color: t.input.field({ type: ColorEnum, required: false }),
    inboxPoints: t.input.int({ required: false }),
    listId: t.input.globalID({ required: false }),
    pluginDatas: t.input.field({ type: [ItemPluginDataInput], required: false })
  },
  resolve: (query3, _, { input: input6 }) => {
    return prisma.item.create({
      ...query3,
      data: {
        title: input6.title,
        isRelevant: u(input6.isRelevant),
        scheduledAt: u(input6.scheduledAt),
        durationInMinutes: u(input6.durationInMinutes),
        isAllDay: u(input6.isAllDay),
        color: u(input6.color),
        inboxPoints: u(input6.inboxPoints),
        list: input6.listId && input6.listId.typename === "List" ? { connect: { id: parseInt(input6.listId.id) } } : undefined,
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {}
      }
    });
  }
}));
builder5.mutationField("updateItem", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Update an item.`,
  input: {
    id: t.input.globalID({ required: true }),
    title: t.input.string({ required: false }),
    isRelevant: t.input.boolean({
      required: false,
      description: `If set to true, it will return items where \`isRelevant\` is true.

\`isRelevant\` is used in the List component to only show relevant items. If the item becomes irrelevant (e.g. because the trello task was already completed), you can update the item to make this \`isRelevant = false\``
    }),
    scheduledAt: t.input.field({ type: "DateTime", required: false }),
    durationInMinutes: t.input.int({ required: false }),
    isAllDay: t.input.boolean({ required: false }),
    color: t.input.field({ type: ColorEnum, required: false }),
    inboxPoints: t.input.int({ required: false }),
    listId: t.input.globalID({ required: false }),
    pluginDatas: t.input.field({ type: [ItemPluginDataInput], required: false })
  },
  resolve: (query3, _, { input: input6 }) => {
    return prisma.item.update({
      ...query3,
      where: { id: parseInt(input6.id.id) },
      data: {
        title: u(input6.title),
        isRelevant: u(input6.isRelevant),
        scheduledAt: u(input6.scheduledAt),
        durationInMinutes: u(input6.durationInMinutes),
        isAllDay: u(input6.isAllDay),
        color: u(input6.color),
        inboxPoints: u(input6.inboxPoints),
        list: input6.listId && input6.listId.typename === "List" ? { connect: { id: parseInt(input6.listId.id) } } : undefined,
        ...input6.pluginDatas ? {
          pluginDatas: {
            createMany: {
              data: input6.pluginDatas
            }
          }
        } : {}
      }
    });
  }
}));
builder5.mutationField("updateItemStatus", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Mark an item as done or not done. Plugins can use this to mark the item as done or not done in the external system. For example, if the item is a trello task and is marked as done in Flow, it will be marked as done in trello (by the Trello plugin).`,
  input: {
    id: t.input.globalID({ required: true, description: "The ID of the item." }),
    done: t.input.boolean({ required: true, description: "Whether the item is done or not." })
  },
  resolve: async (query3, _, args) => {
    const plugins4 = await getPlugins2();
    const item = await prisma.item.findUnique({
      where: { id: parseInt(args.input.id.id) },
      include: { pluginDatas: true }
    });
    if (!item)
      throw new Error(`Item with id ${args.input.id} not found.`);
    for (const pluginSlug in plugins4) {
      const plugin3 = plugins4[pluginSlug];
      if (plugin3.onUpdateItemStatus) {
        await plugin3.onUpdateItemStatus({
          settingToDone: args.input.done,
          item
        });
      }
    }
    return await prisma.item.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: { isRelevant: !args.input.done }
    });
  }
}));
builder5.mutationField("deleteItem", (t) => t.prismaField({
  type: "Item",
  description: `Delete an item.`,
  args: {
    id: t.arg.globalID({ required: true })
  },
  resolve: (query3, _, args) => {
    return prisma.item.delete({ ...query3, where: { id: parseInt(args.id.id) } });
  }
}));
builder5.mutationField("dismissItemFromInbox", (t) => t.prismaFieldWithInput({
  type: "Item",
  description: `Dismiss an item from the inbox. This effectively sets \`inboxPoints = null\` for the item.`,
  input: {
    id: t.input.globalID({ required: true })
  },
  resolve: (query3, _, args) => {
    return prisma.item.update({
      ...query3,
      where: { id: parseInt(args.input.id.id) },
      data: { inboxPoints: null }
    });
  }
}));

// src/graphql/List.ts
var ListType = builder5.prismaNode("List", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    slug: t.exposeString("slug"),
    description: t.exposeString("description", { nullable: true }),
    items: t.relatedConnection("items", {
      cursor: "id",
      args: { where: t.arg({ type: ItemWhereInputType, required: false }) },
      query: (args) => ({
        where: args.where ?? undefined,
        orderBy: { updatedAt: "desc" }
      })
    })
  })
});
builder5.queryField("lists", (t) => t.prismaField({
  type: ["List"],
  description: "Get all lists.",
  args: {
    first: t.arg({
      type: "PositiveInt",
      required: false,
      description: "The number of lists to return. If not provided, all lists will be returned."
    })
  },
  resolve: (query3, _, args) => {
    return prisma.list.findMany({
      ...query3,
      take: u(args.first),
      orderBy: { createdAt: "asc" }
    });
  }
}));
builder5.queryField("list", (t) => t.prismaField({
  type: "List",
  description: "Get a list by its id or slug.",
  nullable: true,
  smartSubscription: true,
  subscribe: (subs) => {
    subs.register("itemsCreated");
    subs.register("itemsUpdated");
    subs.register("itemsDeleted");
  },
  args: {
    id: t.arg.globalID({ required: false }),
    slug: t.arg.string({ required: false })
  },
  resolve: (query3, _, args) => {
    return prisma.list.findFirst({
      ...query3,
      where: { id: uParseInt(args.id?.id), slug: args.slug ?? undefined }
    });
  }
}));

// src/graphql/NoteTag.ts
var NoteTagType = builder5.prismaNode("NoteTag", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    slug: t.exposeString("slug"),
    color: t.expose("color", { type: ColorEnum }),
    notes: t.relatedConnection("notes", { cursor: "id" }),
    isPrivate: t.exposeBoolean("isPrivate")
  })
});
builder5.queryField("noteTags", (t) => t.prismaConnection({
  type: "NoteTag",
  cursor: "id",
  description: "Get all note tags ordered by usage in descending order. `before` and `after` cursors are ignored, and `first` and `last` act the same and are limited to 100.",
  args: {
    where: t.arg({
      type: NoteTagWhereInput,
      required: false,
      description: "Filters to use when querying note tags."
    })
  },
  resolve: (query3, _, args) => {
    const where = args.where;
    return prisma.noteTag.findMany({
      ...query3,
      where: {
        ...where?.nameIsLike ? { name: { contains: where.nameIsLike, mode: "insensitive" } } : {},
        ...where?.isPrivate ? { isPrivate: { equals: where.isPrivate } } : {}
      },
      orderBy: { notes: { _count: "desc" } },
      take: Math.min(args.first ?? args.last ?? 100, 100)
    });
  }
}));
var NoteTagWhereInput = builder5.inputType("NoteTagWhereInput", {
  fields: (t) => ({
    nameIsLike: t.string({
      required: false,
      description: "Filter by name. Case insensitive."
    }),
    isPrivate: t.boolean({
      required: false,
      description: "Filter by whether the tag is for private use."
    })
  })
});
var CreateNoteTagInputType = builder5.inputType("CreateNoteTagInput", {
  fields: (t) => ({
    name: t.string({ required: true, description: "The name of the tag." }),
    slug: t.string({
      required: false,
      description: "The slug of the tag. Defaults to dashcase version of the name."
    }),
    color: t.string({ required: true, description: "The color of the tag." })
  })
});

// src/graphql/Note.ts
var NoteType = builder5.prismaNode("Note", {
  id: { field: "slug" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    date: t.expose("date", { type: "Date" }),
    slug: t.exposeString("slug"),
    title: t.exposeString("title"),
    content: t.exposeString("content"),
    tags: t.relation("tags")
  })
});
builder5.queryField("note", (t) => t.prismaField({
  type: "Note",
  description: "Get a note by its `slug`.",
  nullable: true,
  args: {
    slug: t.arg.string({ required: true, description: "The slug of the note." })
  },
  resolve: (query3, _, { slug }) => {
    return prisma.note.findUnique({ ...query3, where: { slug } });
  }
}));
builder5.mutationField("createOrUpdateNote", (t) => t.prismaFieldWithInput({
  type: "Note",
  description: "Updates a note if one exists with the passed in `slug`, otherwise creates a new note.",
  input: {
    date: t.input.field({ type: "Date", required: true, description: "The date of the note." }),
    slug: t.input.string({
      required: true,
      description: "The slug of the note. Used for retrieving the note back."
    }),
    title: t.input.string({ required: true, description: "The title of the note." }),
    content: t.input.string({ required: true, description: "The content of the note." }),
    tags: t.input.globalIDList({
      required: false,
      description: "The IDs of exsiting tags to be linked to the note. If you want to create a new tag, use the `newTags` input."
    }),
    newTags: t.input.field({
      type: [CreateNoteTagInputType],
      required: false,
      description: "Create new tags and link them to the note."
    }),
    removedTags: t.input.globalIDList({
      required: false,
      description: "The IDs of tags to be unlinked from the note."
    })
  },
  resolve: (query3, _, args) => {
    const date = args.input.date;
    const tags = {
      connect: args.input.tags?.map((globalId) => ({ id: parseInt(globalId.id) })) ?? [],
      create: args.input.newTags?.map((tag) => ({
        name: tag.name,
        slug: tag.slug ?? tag.name.toLowerCase().replace(/ /g, "-"),
        color: tag.color
      })) ?? []
    };
    return prisma.note.upsert({
      ...query3,
      where: { slug: args.input.slug },
      update: {
        day: { connectOrCreate: { where: { date }, create: { date } } },
        title: args.input.title,
        content: args.input.content,
        tags: {
          ...tags,
          disconnect: args.input.removedTags?.map((globalId) => ({
            id: parseInt(globalId.id)
          })) ?? []
        }
      },
      create: {
        day: { connectOrCreate: { where: { date }, create: { date } } },
        slug: args.input.slug,
        title: args.input.title,
        content: args.input.content,
        tags
      }
    });
  }
}));

// src/graphql/Notifications.ts
var NotificationsType = builder5.simpleObject("Notifications", {
  fields: (t) => ({
    itemsCreated: t.field({ type: [ItemType] }),
    itemsUpdated: t.field({ type: [ItemType] }),
    itemsDeleted: t.field({ type: [ItemType] }),
    tasksCreated: t.field({ type: [TaskType] }),
    tasksUpdated: t.field({ type: [TaskType] }),
    tasksDeleted: t.field({ type: [TaskType] })
  })
});
var getArrayInObj = (payload, type2) => {
  if (!payload)
    return [];
  if (type2 in payload) {
    return payload[type2];
  }
  return [];
};
builder5.subscriptionField("notifications", (t) => t.field({
  type: NotificationsType,
  subscribe(_parent, _args, _context, _info) {
    return Repeater.merge([
      undefined,
      pipe(pubsub.subscribe("itemsCreated"), map((items) => ({ itemsCreated: items }))),
      pipe(pubsub.subscribe("itemsUpdated"), map((items) => ({ itemsUpdated: items }))),
      pipe(pubsub.subscribe("itemsDeleted"), map((items) => ({ itemsDeleted: items }))),
      pipe(pubsub.subscribe("tasksCreated"), map((tasks) => ({ tasksCreated: tasks }))),
      pipe(pubsub.subscribe("tasksUpdated"), map((tasks) => ({ tasksUpdated: tasks }))),
      pipe(pubsub.subscribe("tasksDeleted"), map((tasks) => ({ tasksDeleted: tasks })))
    ]);
  },
  resolve: (payload) => {
    return {
      itemsCreated: getArrayInObj(payload, "itemsCreated"),
      itemsUpdated: getArrayInObj(payload, "itemsUpdated"),
      itemsDeleted: getArrayInObj(payload, "itemsDeleted"),
      tasksCreated: getArrayInObj(payload, "tasksCreated"),
      tasksUpdated: getArrayInObj(payload, "tasksUpdated"),
      tasksDeleted: getArrayInObj(payload, "tasksDeleted")
    };
  }
}));

// src/graphql/PluginOperation.ts
var PluginOperationType = builder5.node(builder5.objectRef("PluginOperation"), {
  id: { resolve: (op) => op.id },
  loadOne: async (id) => {
    const [pluginSlug, operationName] = id.split("_");
    if (!pluginSlug || !operationName) {
      throw new GraphQLError(`Invalid plugin operation id: PluginOperation_${id}. It should be in the format of PluginOperation_pluginSlug_operationName.`);
    }
    return await loadOneWithInput(pluginSlug, operationName, {});
  },
  fields: (t) => ({
    data: t.field({ type: "JSON", resolve: (op) => op.data, nullable: true })
  }),
  description: `A plugin operation similar to making a request to /api/plugin/:pluginSlug/:operation, but it can be cached by Relay.

This is the recommended way to interact with the plugin's from the web app.

If you want to do a GET-like request, you can do it through \`node\` field if there are no parameters to pass. For example:
\`\`\`graphql
query {
  node(id: "PluginOperation_pluginSlug_operationName") {
    ... on PluginOperation {
      id
      data
    }
  }
}
\`\`\`
Or you can do it through \`pluginOperation\` field if there are parameters to pass. For example:
\`\`\`graphql
query {
  pluginOperation(
    input: {
      pluginSlug: "pluginSlug",
      operationName: "operationName",
      data: { param1: "value1"}
    }
  ) {
    id
    data
  }
}
\`\`\`

If you want to do a POST-like request, you can do it through \`pluginOperation\` field in the Mutation type. For example:
\`\`\`graphql
mutation {
  pluginOperation(
    input: {
      pluginSlug: "pluginSlug",
      operationName: "operationName",
      data: { param1: "value1"}
    }
  ) {
    id
    data
  }
}

What's the difference between \`pluginOperation\` field in the Query type and the Mutation type?
- \`pluginOperation\` field in the Query type is used for GET-like requests and will get cached by Relay in the web app.
- \`pluginOperation\` field in the Mutation type is used for POST-like requests and will invalidate any cached data from the \`pluginOperation\` field in the Query type and Relay will automatically update it's store.
`
});
var loadOneWithInput = async (pluginSlug, operationName, input6) => {
  const plugins4 = await getPlugins2();
  const plugin3 = plugins4[pluginSlug];
  if (!plugin3) {
    throw new GraphQLError(`Plugin ${pluginSlug} not found.`);
  }
  const operation = plugin3.operations?.[operationName];
  if (!operation) {
    throw new GraphQLError(`Operation ${operationName} not found in plugin ${pluginSlug}.`);
  }
  try {
    const result = await operation(input6);
    if (!result)
      return null;
    return {
      id: `${pluginSlug}_${result.operationName ?? operationName}`,
      data: result.data ?? null
    };
  } catch (e) {
    if (e instanceof GraphQLError)
      throw e;
    if (e instanceof Error) {
      throw new GraphQLError(e.message);
    }
    throw new GraphQLError(JSON.stringify(e));
  }
};
builder5.queryField("pluginOperation", (t) => t.fieldWithInput({
  type: PluginOperationType,
  nullable: true,
  input: {
    pluginSlug: t.input.string({ required: true }),
    operationName: t.input.string({ required: true }),
    data: t.input.field({ type: "JSON", required: false })
  },
  resolve: async (_, args) => {
    return await loadOneWithInput(args.input.pluginSlug, args.input.operationName, args.input.data ?? {});
  }
}));
builder5.mutationField("pluginOperation", (t) => t.fieldWithInput({
  type: PluginOperationType,
  nullable: true,
  input: {
    pluginSlug: t.input.string({ required: true }),
    operationName: t.input.string({ required: true }),
    data: t.input.field({ type: "JSON", required: false })
  },
  resolve: async (_, args) => {
    return await loadOneWithInput(args.input.pluginSlug, args.input.operationName, args.input.data ?? {});
  }
}));

// src/graphql/RepetitionPattern.ts
var values4 = {
  MONDAY: { value: "MONDAY" },
  TUESDAY: { value: "TUESDAY" },
  WEDNESDAY: { value: "WEDNESDAY" },
  THURSDAY: { value: "THURSDAY" },
  FRIDAY: { value: "FRIDAY" },
  SATURDAY: { value: "SATURDAY" },
  SUNDAY: { value: "SUNDAY" }
};
var RepetitionPatternEnum = builder5.enumType("RepetitionPattern", { values: values4 });

// src/graphql/Routine.ts
var RoutineType = builder5.prismaNode("Routine", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    actionName: t.exposeString("actionName"),
    time: t.expose("time", { type: "Time" }),
    repeats: t.expose("repeats", { type: [RepetitionPatternEnum] }),
    steps: t.field({
      type: [RoutineStepType],
      resolve: (routine) => routine.steps.map((step) => {
        const [pluginSlug, stepSlug, shouldSkip] = step.split("_");
        return {
          pluginSlug,
          stepSlug,
          shouldSkip: shouldSkip === "true"
        };
      })
    }),
    isActive: t.exposeBoolean("isActive"),
    firstStep: t.string({
      resolve: (routine) => routine.steps[0] ?? null,
      nullable: true,
      description: "Returns the first step in the routine. If there are no steps in the routine, it returns `null`."
    }),
    done: t.boolean({
      description: "Whether the routine was done for the day. This can be null if the routine is queried outside of a day.",
      nullable: true,
      resolve: async (routine) => {
        if (!("_done" in routine) || typeof routine._done !== "boolean")
          return null;
        return routine._done;
      }
    })
  })
});
var RoutineStepType = builder5.simpleObject("RoutineStep", {
  description: "A step in a routine. To know which plugin the step belongs to, see `pluginSlug`.",
  fields: (t) => ({
    pluginSlug: t.string({ description: "The slug of the plugin that the step belongs to." }),
    stepSlug: t.string({ description: "The slug of the step." }),
    shouldSkip: t.boolean({
      description: "Whether the step should be skipped if the previous routine was done (i.e. routine.done = true)."
    })
  })
});
var RoutineStepInput = builder5.inputType(builder5.inputRef("RoutineStepInput"), {
  fields: (t) => ({
    pluginSlug: t.string({ required: true }),
    stepSlug: t.string({ required: true }),
    shouldSkip: t.boolean({ required: true })
  })
});
builder5.queryField("routines", (t) => t.prismaField({
  type: ["Routine"],
  description: "Get all routines.",
  resolve: prisma.routine.findMany
}));
builder5.mutationField("createRoutine", (t) => t.prismaFieldWithInput({
  type: "Routine",
  input: {
    name: t.input.string({ required: true }),
    actionName: t.input.string({ required: true }),
    time: t.input.field({ type: "Time", required: true }),
    repeats: t.input.field({ type: [RepetitionPatternEnum], required: true }),
    steps: t.input.field({ type: [RoutineStepInput], required: true })
  },
  resolve: async (query3, _, args) => {
    return prisma.routine.create({
      ...query3,
      data: {
        name: args.input.name,
        actionName: args.input.actionName,
        time: args.input.time,
        repeats: args.input.repeats,
        firstDay: new Date,
        isActive: true,
        steps: args.input.steps.map((step) => `${step.pluginSlug}_${step.stepSlug}_${step.shouldSkip}`)
      }
    });
  }
}));
builder5.mutationField("updateRoutine", (t) => t.prismaFieldWithInput({
  type: "Routine",
  input: {
    routineId: t.input.globalID({
      description: "The ID of the routine to update.",
      required: true
    }),
    isActive: t.input.boolean({
      description: "Whether the routine is active.",
      required: false
    }),
    name: t.input.string({
      description: "The name to update the routine with.",
      required: false
    }),
    actionName: t.input.string({
      description: "The action name to update the routine with.",
      required: false
    }),
    time: t.input.field({
      type: "Time",
      description: "The time to update the routine with.",
      required: false
    }),
    steps: t.input.field({
      type: [RoutineStepInput],
      description: "The steps to update the routine with.",
      required: false
    }),
    repeats: t.input.field({
      type: [RepetitionPatternEnum],
      description: "The repetition patterns to update the routine with.",
      required: false
    })
  },
  resolve: async (query3, _, args) => {
    return prisma.routine.update({
      ...query3,
      where: { id: parseInt(args.input.routineId.id) },
      data: {
        isActive: u(args.input.isActive),
        name: u(args.input.name),
        actionName: u(args.input.actionName),
        time: u(args.input.time),
        repeats: u(args.input.repeats),
        steps: args.input.steps?.map((step) => `${step.pluginSlug}_${step.stepSlug}_${step.shouldSkip}`) ?? undefined
      }
    });
  }
}));
builder5.mutationField("completeRoutine", (t) => t.fieldWithInput({
  type: "Boolean",
  input: {
    routineId: t.input.globalID({
      description: "The ID of the routine that was completed.",
      required: true
    }),
    date: t.input.field({
      type: "Date",
      description: "The date the routine was completed.",
      required: true
    })
  },
  resolve: async (_, args) => {
    try {
      await prisma.day.update({
        where: { date: args.input.date },
        data: { routinesCompleted: { connect: { id: parseInt(args.input.routineId.id) } } }
      });
    } catch (e) {
      new GraphQLError(e.message);
    }
    return true;
  }
}));

// src/graphql/TaskPluginData.ts
var TaskPluginDataType = builder5.prismaNode("TaskPluginData", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    updatedAt: t.expose("updatedAt", { type: "DateTime" }),
    min: t.expose("min", { type: "JSON" }),
    full: t.expose("full", { type: "JSON" }),
    pluginSlug: t.exposeString("pluginSlug")
  })
});

// src/graphql/TaskTag.ts
var TaskTagType = builder5.prismaNode("TaskTag", {
  id: { field: "id" },
  fields: (t) => ({
    createdAt: t.expose("createdAt", { type: "DateTime" }),
    name: t.exposeString("name"),
    slug: t.exposeString("slug"),
    color: t.expose("color", { type: ColorEnum }),
    tasks: t.relatedConnection("tasks", { cursor: "id" }),
    isPrivate: t.exposeBoolean("isPrivate")
  })
});
builder5.queryField("taskTags", (t) => t.prismaConnection({
  type: "TaskTag",
  cursor: "id",
  description: "Get all task tags ordered by usage in descending order. `before` and `after` cursors are ignored, and `first` and `last` act the same and are limited to 100.",
  args: {
    where: t.arg({
      type: TaskTagWhereInput,
      required: false,
      description: "Filters to use when querying task tags."
    })
  },
  resolve: (query3, _, args) => {
    const where = args.where;
    return prisma.taskTag.findMany({
      ...query3,
      where: {
        ...where?.nameIsLike ? { name: { contains: where.nameIsLike, mode: "insensitive" } } : {},
        ...where?.isPrivate ? { isPrivate: { equals: where.isPrivate } } : {}
      },
      orderBy: { tasks: { _count: "desc" } },
      take: Math.min(args.first ?? args.last ?? 100, 100)
    });
  }
}));
var TaskTagWhereInput = builder5.inputType("TaskTagWhereInput", {
  fields: (t) => ({
    nameIsLike: t.string({
      required: false,
      description: "Filter by name. Case insensitive."
    }),
    isPrivate: t.boolean({
      required: false,
      description: "Filter by whether the tag is for private use."
    })
  })
});

// src/graphql/index.ts
var schema3 = builder5.toSchema();
if (env.NODE_ENV === "development") {
  const schemaAsString = printSchema(schema3);
  const path2 = Bun.resolveSync("../../../web/src/relay/schema.graphql", import.meta.dir);
  await Bun.write(path2, schemaAsString);
  console.log(`
\u2705 GraphQL schema generated into apps/web/src/relay/schema.graphql`);
}

// src/index.ts
var PORT = env.PORT ?? 4000;
var yogaHandler = async (request) => {
  const res = await createYoga({
    schema: schema3,
    cors: {
      origin: undefined
    },
    context: async (req) => {
      const sessionToken = req.request.headers.get("authorization")?.replace("Bearer ", "");
      return {
        userAgent: req.request.headers.get("user-agent") ?? undefined,
        sessionToken,
        isSessionValid: () => isSessionTokenValid(sessionToken),
        subscriptions: {}
      };
    },
    graphiql: {
      title: "Flow GraphQL API",
      headers: JSON.stringify({
        Authorization: `Bearer COPY_TOKEN_FROM_BROWSER_CONSOLE_OR_LOGIN_MUTATION`
      })
    }
  }).handle(request);
  res.headers.delete("Access-Control-Allow-Origin");
  return res;
};
var app = new c$().use(cors()).get("/graphql", async ({ request }) => yogaHandler(request)).post("/graphql", async ({ request }) => yogaHandler(request), {
  type: "none"
}).all("/api/plugin/:pluginSlug/*", async (req) => {
  const pluginSlug = req.params.pluginSlug;
  const installedPlugins = await getPlugins2();
  const plugin3 = installedPlugins[pluginSlug];
  if (!plugin3) {
    return new Response(`Plugin ${pluginSlug} not found. It may be in the process of being installed. Please try again later.`, { status: 404 });
  }
  if (!plugin3.onRequest) {
    return new Response(`Plugin ${pluginSlug} has no \`onRequest\` function to handle the request.`, { status: 404 });
  }
  req.path = req.path.replace(`/api/plugin/${pluginSlug}`, "");
  const maybePromise = plugin3.onRequest(req);
  if (maybePromise instanceof Response)
    return maybePromise;
  const res = await maybePromise?.catch(() => null);
  if (res)
    return res;
  return new Response(`Plugin ${pluginSlug} has no endpoint for ${req.path}.`, { status: 404 });
});
app.all("*", async (req) => {
  if (env.NODE_ENV === "development") {
    const developmentPath = `http://localhost:3000${req.path}`;
    try {
      const result = await fetch(developmentPath);
      if (result.ok) {
        return Response.redirect(developmentPath);
      }
    } catch {
      return new Response("Local frontend is not running on port 3000.", { status: 404 });
    }
  }
  const webDir = "./web";
  try {
    const path2 = await Bun.resolve(`${webDir}${req.path}`, import.meta.dir);
    return new Response(Bun.file(path2));
  } catch {
    try {
      const path2 = await Bun.resolve(`${webDir}/index.html`, import.meta.dir);
      return new Response(Bun.file(path2));
    } catch {
      return new Response("Not sure how you got here. Contact Richard Guerre (through Slack or @richardguerre_ on Twitter) with a screenshot of this screen with the URL.", { status: 404 });
    }
  }
});
if (env.NODE_ENV !== "test") {
  const plugins4 = await getPlugins2();
  if (env.NODE_ENV !== "development") {
    try {
      const installedPlugins = await getPluginsInStore().catch(() => {
        console.log("Failed to get plugins from DB.");
        return [];
      });
      for (const pluginInfo of installedPlugins) {
        const pluginJson = await getPluginJson(pluginInfo).catch(() => null);
        if (!pluginJson) {
          console.log(`Invalid plugin.json for "${pluginInfo.slug}".`);
          continue;
        }
        if (Object.keys(plugins4).find((p) => p === pluginJson.slug)) {
          console.log(`Plugin "${pluginJson.slug}" already installed on server.`);
          continue;
        }
        if (!pluginJson.server) {
          console.log(`Plugin "${pluginJson.slug}" has no server entrypoint.`);
          continue;
        }
        await installServerPlugin(pluginInfo).catch((e) => {
          if (e.message.includes("PLUGIN_WITH_SAME_SLUG")) {
            console.log(`Plugin "${pluginInfo.slug}" already installed on server.`);
            return;
          }
          console.log(`Failed to install "${pluginInfo.slug}": ${e}`);
        });
      }
    } catch (e) {
      console.log("Failed to install plugins from DB.");
      console.error(e);
    }
  }
  app.listen(PORT, () => {
    console.log(`\u2705 Server started at: http://localhost:${PORT}`);
    console.log(`\uD83D\uDFE3 GraphQL API: http://localhost:${PORT}/graphql`);
  });
  await pgBoss.start();
  console.log("\u2705 PgBoss started.");
  for (const plugin3 of Object.values(plugins4)) {
    const handlers = plugin3.handlePgBossWork?.(pgBoss.work) ?? [];
    await Promise.all(handlers);
  }
  if (env.NODE_ENV !== "development") {
    await pgBoss.work(ROLLOVER_TASKS_JOB_NAME, syncTasks);
    const timezone3 = await getTimezone();
    await scheduleRolloverTasks(timezone3);
    await syncTasks();
  }
} else {
  app.listen(0);
}
process.on("SIGINT", () => {
  Promise.allSettled([
    prisma.$disconnect().then(() => console.log("\u2705 Prisma disconnected.")),
    pgBoss.stop().then(() => console.log("\u2705 PgBoss stopped."))
  ]).then(() => {
    process.exit(0);
  }).catch((e) => {
    console.error(e);
    process.exit(1);
  });
});
export {
  app
};
